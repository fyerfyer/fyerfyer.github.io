<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>fyerfyer&#39;s Web Intro</title>
    <url>/2024/07/26/Introduction/</url>
    <content><![CDATA[<h1 id="fyerfyers-web-intro">fyerfyer's Web Intro</h1>
<p>  这是fyerfyer用来放自己写的学习笔记的网站（以后也可能会放别的东西）。</p>
<p>  笔记的分类如下：</p>
<ul>
<li><p><a href="https://fyerfyer.github.io/categories/CSAPP/">CSAPP的笔记（English
ver）</a></p></li>
<li><p><a href="https://fyerfyer.github.io/categories/SICP-in-python/">SICP in
Python的笔记</a></p></li>
<li><p><a href="https://fyerfyer.github.io/categories/CS61B-DataStructure/">CS61B的笔记</a></p></li>
<li><p><a href="https://fyerfyer.github.io/categories/The-Elements-of-Computer-System/">《计算机系统要素》笔记（English
ver）</a></p></li>
<li><p><a href="https://fyerfyer.github.io/categories/CS61C-Great-Ideas-in-Computer-Architecture/">CS61C的笔记（English
ver））</a></p></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>3.1.管道</title>
    <url>/2024/11/21/3-1-%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<h1 id="31管道"><span class="math inline">\(3.1.\)</span>管道</h1>
<h3 id="1系统命令创建">1.系统命令创建</h3>
<ul>
<li>创建命令：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd0 := exec.Command(<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;-n&quot;</span>, <span class="string">&quot;My first command comes from golang. &quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>启动命令：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := cmd0.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2读取数据">2.读取数据</h3>
<p>  
<code>StdoutPipe()</code>方法返回的对象类型为<code>io.ReadCloser</code>，这是拓展了<code>io.Reader</code>接口的接口类型。我们可以调用它的<code>Read</code>方法获取命令输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于存放数据的字节切片</span></span><br><span class="line">output0 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">30</span>)</span><br><span class="line">n, err := stdout0.Read(output0)</span><br><span class="line"><span class="keyword">if</span> err := <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, output0[:n])</span><br></pre></td></tr></table></figure>
<p>  如果输出管道没有可以读取的数据，<code>Read</code>方法返回的<code>err</code>就会是<code>io.EOF</code>。</p>
<p>  如果切片的长度过小，可以通过<code>for</code>循环迭代读取：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outputBuf0 bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    tempOutput := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>)</span><br><span class="line">    n, err := stdout0.Read(tempOutput)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        outputBuf0.Write(tempOutput[:n])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  还可以使用<strong>带缓冲的读取器</strong>来读取输出管道中的数据，这样更加简便：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">outputBuf0 := bufio.NewReader(stdout0)</span><br><span class="line">output0, _, err := outputBuf0.ReadLine()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="type">string</span>(output0))</span><br></pre></td></tr></table></figure>
<p>  由于<code>stdout0</code>也具有<code>io.Reader</code>接口类型，它可以作为<code>bufio.NewReader</code>的参数。</p>
<h3 id="3创建管道">3.创建管道</h3>
<h4 id="a匿名管道"><span class="math inline">\(a.\)</span>匿名管道</h4>
<ul>
<li>创建获取此命令的管道：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stdout0, err := cmd0.StdoutPipe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>  管道可以把一个命令的输出作为另一个命令的输入，在go中的例子如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd1 := exec.Command(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>)</span><br><span class="line">cmd2 := exec.Command(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;apipe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> outputBuf1 bytes.Buffer</span><br><span class="line"></span><br><span class="line">cmd1.Stdout = &amp;outputBuf1</span><br><span class="line"><span class="keyword">if</span> err := cmd1.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cmd1.wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd2.Stdin = &amp;outputBuf1</span><br><span class="line"><span class="keyword">var</span> outputBuf2 bytes.Buffer</span><br><span class="line">cmd2.Stdout = &amp;outputBuf2</span><br><span class="line"><span class="keyword">if</span> err := cmd2.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于<code>bytes.Buffer</code>实现了<code>io.Writer</code>和<code>io.Reader</code>接口，因此可以将它赋值给<code>.Stdout</code>和<code>.Stdin</code>。</p>
</blockquote>
<blockquote>
<p><code>cmd1.wait</code>会一直阻塞，直到<code>cmd1</code>完全运行结束。</p>
</blockquote>
<ul>
<li>匿名管道会在管道缓冲区被写满之后使写数据的进程阻塞</li>
</ul>
<h4 id="b命名管道"><span class="math inline">\(b.\)</span>命名管道</h4>
<p>  与匿名管道不同，<strong>任何进程都可以通过命名管道交换数据</strong>。</p>
<blockquote>
<p>实际上，命名管道<strong>以文件的形式存在于文件系统中</strong>，使用它的方法与使用文件很类似。</p>
</blockquote>
<p>  go中创建这样的管道的API如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reader, writer, err := os.Pipe()</span><br></pre></td></tr></table></figure>
<p>  这里返回的<code>reader</code>、<code>writer</code>分别为管道输入端、输出端的<code>*os.File</code>类型值。并发运行下面的代码，就可以让<code>reader</code>读取<code>writer</code>写入的数据了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n, err := writer.Write(input)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    output := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">100</span>)</span><br><span class="line">    n, err := reader.Read(output)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>  为什么要并发运行呢？因为<strong>管道的两端（读取端和写入端）在某一端未准备就绪时会阻塞</strong>：</p>
<ul>
<li><p>如果写入端试图写入管道，但管道的缓冲区已满，则写入操作会阻塞，直到读取端读取了足够的数据。</p></li>
<li><p>如果读取端试图从管道读取，但管道中没有数据，则读取操作会阻塞，直到写入端写入了数据。</p></li>
</ul>
<p>  如果顺序执行的话，程序就会一直被阻塞了。</p>
<p>  命名管道可以被多路复用，这使得我们需要考虑操作原子性。go的<code>io</code>包里提供了一个保证原子性的管道：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reader, writer := io.Pipe()</span><br></pre></td></tr></table></figure>
<p>  <code>reader</code>、<code>writer</code>分别为<code>*io.PipeReader</code>和<code>*io.PipeWriter</code>类型变量。</p>
]]></content>
      <categories>
        <category>go并发编程</category>
        <category>Chapter 3:并发编程综述</category>
      </categories>
  </entry>
  <entry>
    <title>11.2.Networks</title>
    <url>/2024/08/28/11-2-Networks/</url>
    <content><![CDATA[<h1 id="112networks"><span class="math inline">\(11.2.\)</span>Networks</h1>
<h3 id="1the-physical-interface">1.The Physical Interface</h3>
<p><img src="/2024/08/28/11-2-Networks/image.png"></p>
<ul>
<li><p>The <em>adapter</em> provides <strong>the physical
interface</strong> to the network.</p></li>
<li><p>Data received from the network are copied from the adapter
typically by a <em>DMA transfer</em>.</p></li>
</ul>
<h3 id="2ethernet-segment">2.Ethernet Segment</h3>
<p><img src="/2024/08/28/11-2-Networks/image-1.png"></p>
<ul>
<li><p>One end is attached to <strong>an adapter on a host</strong>, and
the other end is attached to <strong>a port on the
hub</strong>.</p></li>
<li><p>A host can send <strong>a chunk of bits</strong> called a
<em>frame</em> to any other <strong>host on the
segment</strong>.</p></li>
<li><p><strong>Every host adapter sees the frame</strong>, but
<strong>only the destination host actually reads it</strong>.</p></li>
</ul>
<h3 id="3lan">3.LAN</h3>
<p><img src="/2024/08/28/11-2-Networks/image-2.png"></p>
<ul>
<li><p>Multiple Ethernet segments can be connected into larger
LANs(Local Area Network), called <em>bridged Ethernets</em>, using a set
of wires and small boxes called <em>bridges</em>.</p></li>
<li><p>Bridges automatically learn over time which hosts are reachable
from which ports and only copy frames from one port to another
<strong>when necessary</strong>.</p></li>
</ul>
<h3 id="4internet">4.Internet</h3>
<p><img src="/2024/08/28/11-2-Networks/image-3.png"></p>
<ul>
<li><p>Multiple incompatible LANs can be connected by specialized
computers called <em>routers</em> to form an internet.</p></li>
<li><p>Each router has an <em>adapter</em>(port) for each network it
connected to.</p></li>
</ul>
<h3 id="5protocol-software-layer">5.Protocol Software Layer</h3>
<p>  A layer of protocol software smoothes out the differences between
the different networks. This software implements a protocol that
<strong>governs how hosts and routers cooperate in order to transfer
data</strong>.</p>
<p>  The following figure shows an example of using protocol software
layer for data transferring:</p>
<p><img src="/2024/08/28/11-2-Networks/image-4.png"></p>
<ol type="1">
<li>The client on host A <strong>invokes a system call</strong> that
copies the data from the client's virtual address space <strong>into a
kernel buffer</strong>.</li>
</ol>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 11.Network Programming</category>
      </categories>
  </entry>
  <entry>
    <title>11.1.The Client-Server Programming Model</title>
    <url>/2024/08/28/11-1-The-Client-Server-Programming-Model/</url>
    <content><![CDATA[<h1 id="111the-client-server-programmingmodel"><span class="math inline">\(11.1.\)</span>The Client-Server Programming
Model</h1>
<p>  A client-server transaction consists of four steps:</p>
<ol type="1">
<li><p>When a client needs service, it initiates a transaction by
<strong>sending a request to the server</strong>.</p></li>
<li><p>The server receives the request, <strong>interprets it, and
manipulates its resources</strong> in the appropriate way.</p></li>
<li><p>The server <strong>sends a response to the client</strong> and
then waits for the next request.</p></li>
<li><p>Theclient receives the response and manipulates it.</p></li>
</ol>
<p><img src="/2024/08/28/11-1-The-Client-Server-Programming-Model/image.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 11.Network Programming</category>
      </categories>
  </entry>
  <entry>
    <title>9.10.Simple Allocator Implementation</title>
    <url>/2024/08/23/9-10-Simple-Allocator-Implementation/</url>
    <content><![CDATA[<h1 id="910simple-allocator-implementation"><span class="math inline">\(9.10.\)</span>Simple Allocator Implementation</h1>
<h3 id="1general-allocator-design">1.General Allocator Design</h3>
<p>  The allocator exports three functions to application programs:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">mm_malloc</span> <span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">mm_free</span> <span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>  The allocator uses the block format as below:</p>
<p><img src="/2024/08/23/9-10-Simple-Allocator-Implementation/image.png"></p>
<p>  The minimum block size is 16 bytes. The free list is organized as
an implicit free list, with the invariant form shown as below:</p>
<p><img src="/2024/08/23/9-10-Simple-Allocator-Implementation/image-1.png"></p>
<ul>
<li><p>The first word is an unused padding word aligned to a double-word
boundary.</p></li>
<li><p>The padding is followed by a special prologue block, which is an
8-byte allocated block <strong>consisting of only a header and a
footer</strong>. The prologue block <strong>is created during
initialization and is never freed</strong>.</p></li>
<li><p>The heap always ends with a special epilogue block, which is a
zero-size allocated block that <strong>consists of only a
header</strong>.</p></li>
<li><p>The allocator uses a single private(<code>static</code>) global
variable(<code>heap_listp</code>) that <strong>always points to the
prologue block</strong>.</p></li>
</ul>
<h3 id="2basicconstants-and-macros-for-manipulating-the-free-list">2.Basic
Constants and Macros for Manipulating the Free List</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4 <span class="comment">/* Word and header/footer size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8 <span class="comment">/* Double word size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1&lt;&lt;12) <span class="comment">/* Extend heap by this amount (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p)) <span class="comment">// The pointer points to p is dereferenced</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) <span class="comment">// Why DSIZE? Because both header and footer need to decline WSIZE, and 2*WSIZE=DSIZE</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br></pre></td></tr></table></figure>
<h3 id="3creating-the-initial-freelist">3.Creating the Initial Free
List</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Create the initial empty heap */</span></span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>); <span class="comment">/* Alignment padding */</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>)); <span class="comment">/* Prologue header */</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>)); <span class="comment">/* Prologue footer */</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">/* Epilogue header */</span></span><br><span class="line">    heap_listp += (<span class="number">2</span> * WSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span></span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  The extend_heap function is invoked in two different
circumstances:</p>
<ol type="1">
<li><p>When the heap is initialized and</p></li>
<li><p>When <code>mm_malloc</code> is unable to find a suitable
fit.</p></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize free block header/footer and the epilogue header */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>)); <span class="comment">/* Free block header */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>)); <span class="comment">/* Free block footer */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">/* New epilogue header */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Coalesce if the previous block was free */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>Place enough space by invoking <code>mem_sbrk</code>.</p></li>
<li><p>Set the new space free by setting the allocate bit
<code>0</code>.</p></li>
<li><p>Set the block next to <code>bp</code> as the new epilogue
header.</p></li>
<li><p>Finally, in the likely case that <strong>the previous heap was
terminated by a free block</strong>, we call the <code>coalesce</code>
function to <strong>merge the two free blocks and return the block
pointer of the merged blocks</strong>.</p></li>
</ol>
<ul>
<li>To maintain alignment, extend_heap <strong>rounds up the requested
size to the nearest multiple of 2 words</strong>(8 bytes).</li>
</ul>
<h3 id="4freeing-and-coalescingblocks">4.Freeing and Coalescing
Blocks</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>The <code>mm_free</code> set the allocate bit of the current block
to <code>0</code>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">/* Case 1 */</span></span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123; <span class="comment">/* Case 2 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">/* Case 3 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* Case 4 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + </span><br><span class="line">        GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5allocating-blocks">5.Allocating Blocks</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize; <span class="comment">/* Adjusted block size */</span></span><br><span class="line">    <span class="type">size_t</span> extendsize; <span class="comment">/* Amount to extend heap if no fit */</span></span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ignore spurious requests */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Adjust block size to include overhead and alignment reqs. */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">        asize = <span class="number">2</span>*DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = DSIZE * ((size + (DSIZE) + (DSIZE<span class="number">-1</span>)) / DSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search the free list for a fit */</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No fit found. Get more memory and place the block */</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize/WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>The <code>DSIZE * ((size + (DSIZE) + (DSIZE-1)) / DSIZE);</code>
assures that the result is rounded <strong>up to the nearest multiple of
<code>DSIZE</code></strong>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* First-fit search */</span></span><br><span class="line">    <span class="type">void</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp)))) &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* No fit */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= (<span class="number">2</span>*DSIZE)) &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp), PACK(csize-asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize-asize, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Since the allocated space may not take up the whole block, we may
need to <strong>split the block</strong> by <strong>setting the
allocated space to <code>1</code> and the other
<code>0</code></strong>.</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 9.Virtual Memory</category>
      </categories>
  </entry>
  <entry>
    <title>9.9.Dynamic Memory Allocation</title>
    <url>/2024/08/23/9-9-Dynamic-Memory-Allocation/</url>
    <content><![CDATA[<h1 id="99dynamic-memory-allocation"><span class="math inline">\(9.9.\)</span>Dynamic Memory Allocation</h1>
<h3 id="1heap-struction">1.Heap Struction</h3>
<p><img src="/2024/08/23/9-9-Dynamic-Memory-Allocation/image.png"></p>
<h3 id="2the-malloc-andfree-functions">2.The <code>malloc</code> and
<code>free</code> Functions</h3>
<p>  Programs allocate blocks from the heap by calling the malloc
function:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">/* Returns: pointer to allocated block if OK, NULL on error */</span></span><br></pre></td></tr></table></figure>
<p>  The <code>malloc</code> function returns a pointer to a block of
memory of at least size bytes.</p>
<ul>
<li>If <code>malloc</code> encounters a problem (e.g., the program
requests a block of memory that is larger than the available virtual
memory), then it returns <code>NULL</code> and <strong>sets
<code>errno</code></strong>.</li>
</ul>
<p>  We can use <code>sbrk</code> function to manage the heap size:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: old brk pointer on success, −1 on error */</span></span><br></pre></td></tr></table></figure>
<p>  The <code>sbrk</code> function grows or shrinks the heap by
<strong>adding incr to the kernel's <code>brk</code> pointer</strong>.
If successful, it <strong>returns the old value of
<code>brk</code></strong>, otherwise it returns −1 and sets
<code>errno</code> to <code>ENOMEM</code>.</p>
<p>  We can use the <code>free</code> function to free allocated heap
blocks:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: nothing */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>The <code>ptr</code> argument must point to <strong>the beginning of
an allocated block</strong> that was obtained from <code>malloc</code>,
<code>calloc</code>, or <code>realloc</code>.</li>
</ul>
<h3 id="3fragementation">3.Fragementation</h3>
<ul>
<li><p><em>Internal fragmentation</em>: It occurs when an allocated
block is larger than the payload.</p></li>
<li><p><em>External fragmentation</em>: It occurs when there is enough
aggregate free memory to satisfy an allocate request, but no single free
block is large enough to handle the request.</p></li>
</ul>
<h3 id="4basic-implementation-model">4.Basic Implementation Model</h3>
<p>  The simplest imaginable allocator would organize the heap as
<strong>a large array of bytes</strong> and a pointer <code>p</code>
that <strong>initially points to the first byte of the
array</strong>.</p>
<ul>
<li>To allocate <code>size</code> bytes, <code>malloc</code> would
<strong>save the current value of <code>p</code> on the stack</strong>,
<strong>increment <code>p</code> by <code>size</code></strong>, and
return the old value of <code>p</code> to the caller.</li>
</ul>
<h3 id="5implicit-free-lists">5.Implicit Free Lists</h3>
<p>  Any practical allocator needs some data structure that allows it to
<strong>distinguish block boundaries</strong> and to <strong>distinguish
between allocated and free blocks</strong>:</p>
<p><img src="/2024/08/23/9-9-Dynamic-Memory-Allocation/image-1.png"></p>
<ul>
<li><p>A block consists of a one-word header, the payload, and possibly
some additional padding.</p></li>
<li><p>The header encodes the block size(including the header and any
padding) as well as whether the block is allocated or free.</p></li>
<li><p>When <code>malloc</code> is called, the application request the
payload. The payload is followed by a chunk of unused padding that can
be any size.</p></li>
<li><p>The <strong>free blocks</strong> are linked implicitly by the
size fields in the headers. The allocator can indirectly traverse the
entire set of free blocks by <strong>traversing all of the blocks in the
heap</strong>.</p></li>
</ul>
<hr>
<ul>
<li>The system's alignment requirement imposes <strong>a minimum block
size</strong> on the allocator. For example, if we assume a double-word
alignment requirement, then <strong>the size of each block must be a
multiple of two words(8 bytes)</strong>.</li>
</ul>
<h3 id="6placing-allocated-blocks">6.Placing Allocated Blocks</h3>
<ul>
<li><p><em>Next fit</em> starts each search <strong>where the previous
search left off</strong> for a suitable free list.</p></li>
<li><p>It's motivated by the idea that <strong>if we found a fit in some
free block the last time, there is a good chance that we will find a fit
the next time in the remainder of the block</strong>.</p></li>
</ul>
<h3 id="7-getting-additional-heapmemory">7. Getting Additional Heap
Memory</h3>
<ul>
<li>The allocator asks the kernel for additional heap memory by calling
the <code>sbrk</code> function</li>
</ul>
<h3 id="7coalescing-with-boundarytags">7.Coalescing with Boundary
Tags</h3>
<ul>
<li><p>The header of the current block points to the header of the next
block, which can be checked to determine if the next block is
free.</p></li>
<li><p>Similarly, we can add a <em>footer (the boundary tag)</em> at the
end of each block to check the previous block:</p></li>
</ul>
<p><img src="/2024/08/23/9-9-Dynamic-Memory-Allocation/image-2.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 9.Virtual Memory</category>
      </categories>
  </entry>
  <entry>
    <title>9.8.Memory Mapping</title>
    <url>/2024/08/21/9-8-Memory-Mapping/</url>
    <content><![CDATA[<h1 id="98memorymapping"><span class="math inline">\(9.8.\)</span>Memory
Mapping</h1>
<p>  Linux initializes the contents of a virtual memory area by
<strong>associating it with an object on disk</strong>. Areas can be
mapped to one of two types of objects:</p>
<ol type="1">
<li><p>Regular file in the Linux file system: The file section
<strong>is divided into page-size pieces</strong>, with each piece
containing the initial contents of a virtual page.</p></li>
<li><p>Anonymous file: The first time the CPU touches a virtual page in
such an area, the kernel：</p>
<ul>
<li><p>finds an appropriate victim page in physical memory，</p></li>
<li><p>swaps out the victim page if it is dirty, overwrites the victim
page with binary zeros,</p></li>
<li><p>updates the page table to mark the page as resident.</p></li>
</ul></li>
</ol>
<ul>
<li>Once a virtual page is initialized, it is swapped back and forth
between <strong>a special swap file</strong> maintained by the kernel.
It's known as the <em>swap space</em>.</li>
</ul>
<h3 id="1sharred-objects-revisited">1.Sharred Objects Revisited</h3>
<ul>
<li><p>An object can be mapped into an area of virtual memory as either
a <em>shared object</em> or a <em>private object</em>.</p></li>
<li><p>If a process maps a shared object into an area of its virtual
address space, then any writes that the process makes to that area
<strong>are visible to any other processes</strong> that <strong>have
also mapped the shared object into their virtual memory</strong>.
Further, the changes <strong>are also reflected in the original object
on disk</strong>.</p></li>
<li><p>Changes made to an area mapped to a <em>private object</em> are
not visible to other processes, and any writes that the process makes to
the area <strong>are not reflected back to the object on
disk</strong>.</p></li>
</ul>
<p><img src="/2024/08/21/9-8-Memory-Mapping/image.png"></p>
<ul>
<li><p>The kernel can quickly determine that process 1 has already
mapped this object and can <strong>point the page table entries in
process 2 to the appropriate physical pages</strong>.</p></li>
<li><p>The key point is that <strong>only a single copy of the shared
object</strong> needs to be stored in physical memory.</p></li>
</ul>
<p>  Private objects are mapped into virtual memory using a technique
known as <em>copy-on-write</em>:</p>
<p><img src="/2024/08/21/9-8-Memory-Mapping/image-1.png"></p>
<ul>
<li><p>Two processes have mapped a private object into different areas
of their virtual memories but <strong>share the same physical copy of
the object</strong>.</p></li>
<li><p>For each process that maps the private object, the page table
entries for the corresponding private area <strong>are flagged as
read-only</strong>, and the area struct is flagged as <strong>private
copy-on-write</strong>.</p></li>
<li><p>As soon as a process attempts to write to some page in the
private area, the write <strong>triggers a protection
fault</strong>:</p>
<ul>
<li><p>The fault handler <strong>creates a new copy of the page in
physical memory</strong>, <strong>updates the page table entry to point
to the new copy</strong>, and then <strong>restores write permissions to
the page</strong>.</p></li>
<li><p>When the fault handler returns, the CPU re-executes the write,
which now proceeds normally on the newly created page.</p></li>
</ul></li>
</ul>
<h3 id="2the-execvefunction-revisited">2.The <code>execve</code>
Function Revisited</h3>
<p>  Suppose that we make the following call:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execve(<span class="string">&quot;a.out&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>Delete existing user areas</p></li>
<li><p>Map private areas: Create new area structs for the code, data,
bss, and stack areas of the new program:</p></li>
</ol>
<p><img src="/2024/08/21/9-8-Memory-Mapping/image-2.png"></p>
<ol start="3" type="1">
<li><p>Map shared areas: If the <code>a.out</code> program was linked
with shared objects, then these objects <strong>are dynamically linked
into the program</strong>, and then mapped into the shared region of the
user’s virtual address space.</p></li>
<li><p>Set the PC. The last thing is to set the program counter in the
current process's context to <strong>point to the entry point in the
code area</strong>.</p></li>
</ol>
<h3 id="3user-levelmemory-mapping-with-the-mmap-function">3.User-Level
Memory Mapping with the <code>mmap</code> Function</h3>
<p>  <code>mmap</code> function is used to create new areas of virtual
memory and to map objects into these areas:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: pointer to mapped area if OK, MAP_FAILED (−1) on error */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/21/9-8-Memory-Mapping/image-3.png"></p>
<p>  The <code>munmap</code> function is used to delete regions of
virtual memory:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: 0 if OK, −1 on error */</span></span><br></pre></td></tr></table></figure>
<p>  The munmap function deletes the area starting at virtual address
<code>start</code> and consisting of the next <code>length</code>
bytes.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 9.Virtual Memory</category>
      </categories>
  </entry>
  <entry>
    <title>9.6.Address Translation</title>
    <url>/2024/08/20/9-6-Address-Translation/</url>
    <content><![CDATA[<h1 id="96address-translation"><span class="math inline">\(9.6.\)</span>Address Translation</h1>
<h3 id="1summary-of-translationsymbols">1.Summary of Translation
Symbols</h3>
<p><img src="/2024/08/20/9-6-Address-Translation/image.png"></p>
<h3 id="2basic-struction">2.Basic Struction</h3>
<p>  TThe following figure shows how the MMU uses the page table to
perform the mapping <span class="math inline">\(MAP:VAS \rightarrow PAS
\cup \emptyset\)</span>:</p>
<p><img src="/2024/08/20/9-6-Address-Translation/image-1.png"></p>
<ul>
<li><p>The page table base register(PTBR) points to the current page
table.</p></li>
<li><p>The n-bit virtual address has two components: a <span class="math inline">\(p\)</span>-bit virtual page offset(VPO) and an
<span class="math inline">\((n−p)\)</span>-bit virtual page
number(VPN).</p>
<ul>
<li><p>The MMU uses the VPN to <strong>select the appropriate
PTE</strong>. For example, VPN 0 selects PTE 0, VPN 1 selects PTE
1.</p></li>
<li><p>The corresponding physical address is the concatenation of the
<strong>physical page number(PPN) from the page table entry</strong> and
the <strong>VPO from the virtual address</strong>.</p></li>
</ul></li>
<li><p>Since the physical and virtual pages are both <span class="math inline">\(P\)</span> bytes, the physical page offset(PPO) is
identical to the VPO.</p></li>
</ul>
<h3 id="3cpu-hardwareperformance-for-page-hit-amp-page-fault">3.CPU Hardware
Performance for Page Hit &amp; Page Fault</h3>
<p>  The CPU performs the following steps when there's a page hit:</p>
<p><img src="/2024/08/20/9-6-Address-Translation/image-2.png"></p>
<ol type="1">
<li><p>The processor <strong>generates a virtual address</strong> and
sends it to the MMU.</p></li>
<li><p>The MMU <strong>generates the PTE address</strong> and requests
it <strong>from the cache/ main memory</strong>.</p></li>
<li><p>The cache/main memory <strong>returns the PTE to the
MMU</strong>.</p></li>
<li><p>The MMU <strong>constructs the physical address</strong> and
sends it to the cache/main memory.</p></li>
<li><p>The cache/main memory returns the requested data word to the
processor.</p></li>
</ol>
<p><img src="/2024/08/20/9-6-Address-Translation/image-3.png"></p>
<p>  When there's a page fault, step 1~3 are the same:</p>
<ol start="4" type="1">
<li><p>The valid bit in the PTE is zero, so the MMU <strong>triggers an
exception</strong>, which <strong>transfers control in the CPU to a page
fault exception handler</strong> in the operating system
kernel.</p></li>
<li><p>The fault handler <strong>identifies a victim page in physical
memory</strong>, and if that page has been modified, pages it out to
disk.</p></li>
<li><p>The fault handler pages in the new page and updates the PTE in
memory.</p></li>
<li><p>The fault handler <strong>returns to the original process,
causing the faulting instruction to be restarted</strong>. The CPU
resends the offending virtual address to the MMU. Because the virtual
page is now cached in physical memory, there is a hit.</p></li>
</ol>
<h3 id="4-integrating-caches-and-vm">4. Integrating Caches and VM</h3>
<p><img src="/2024/08/20/9-6-Address-Translation/image-4.png"></p>
<ul>
<li>The main idea is that the address translation occurs <strong>before
the cache lookup</strong>.</li>
</ul>
<h3 id="5translation-lookasidebuffer">5.Translation Lookaside
Buffer</h3>
<p>  When we meet a page fault, we will need to do an additional fetch
from memory. Many systems try to eliminate this cost by including
<strong>a small cache of PTEs in the MMU</strong> called a
<em>translation lookaside buffer(TLB)</em>.</p>
<ul>
<li>A TLB is a small, virtually addressed cache where <strong>each line
holds a block consisting of a single PTE</strong>:</li>
</ul>
<p><img src="/2024/08/20/9-6-Address-Translation/image-5.png"></p>
<ul>
<li><p>The index and tag fields that are used for set selection and line
matching <strong>are extracted from the virtual page number</strong> in
the virtual address.</p>
<ul>
<li>If the TLB has <span class="math inline">\(T = 2^t\)</span> sets,
then the TLB index(TLBI) consists of <strong>the <span class="math inline">\(t\)</span> least significant bits of the
VPN</strong>, and the TLB tag(TLBT) consists of <strong>the remaining
bits in the VPN</strong>.</li>
</ul></li>
</ul>
<p>  For a TLB hit, the mMU fetches the appropriate PTE from the
TLB:</p>
<p><img src="/2024/08/20/9-6-Address-Translation/image-6.png"></p>
<h3 id="6multi-level-page-tables">6.Multi-Level Page Tables</h3>
<h4 id="aanexample">  <span class="math inline">\(a.\)</span>An
example</h4>
<p>  The common approach for compacting the page table is to use a
hierarchy of page tables. The following is an example of a page table,
which has a 32-bit address space, 4 KB pages, and a 4-byte PTE:</p>
<p><img src="/2024/08/20/9-6-Address-Translation/image-7.png"></p>
<p>  For the page table:</p>
<ul>
<li><p>Each PTE in the level 1 table is responsible for mapping a 4 MB
chunk of the virtual address space.</p></li>
<li><p>Each chunk consists of 1,024 contiguous pages.</p></li>
</ul>
<p>  This scheme reduces memory requirements in two ways:</p>
<ol type="1">
<li><p>If a PTE in the level 1 table is null, then <strong>the
corresponding level 2 page table does not even have to
exist</strong>.</p></li>
<li><p>Only the level 1 table needs to be in main memory at all times.
The level 2 page tables can be created and paged in and out <strong>by
the VM system as they are needed</strong>.</p></li>
</ol>
<h4 id="baddress-translation-for-k-level-pagetable-hierarchy">  <span class="math inline">\(b.\)</span>Address translation for k-level page
table hierarchy</h4>
<p><img src="/2024/08/20/9-6-Address-Translation/image-8.png"></p>
<ul>
<li><p>The virtual address is partitioned into <span class="math inline">\(k\)</span> VPNs and a VPO.</p></li>
<li><p>Each VPN <span class="math inline">\(i\)</span>(<span class="math inline">\(1 \leq i \leq k\)</span>) is an index into a page
table at level <span class="math inline">\(i\)</span>.</p></li>
<li><p>Each PTE in a level <span class="math inline">\(j\)</span>
table(<span class="math inline">\(1 \leq j \leq k - 1\)</span>)
<strong>points to the base of some page table at level <span class="math inline">\(j + 1\)</span></strong>.</p></li>
<li><p>Each PTE in a level <span class="math inline">\(k\)</span> table
contains <strong>either the PPN of some physical page or the address of
a disk block</strong>.</p></li>
<li><p>As with a single-level hierarchy, the PPO is identical to the
VPO.</p></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 9.Virtual Memory</category>
      </categories>
  </entry>
  <entry>
    <title>9.5.Memory Protection</title>
    <url>/2024/08/20/9-5-Memory-Protection/</url>
    <content><![CDATA[<h1 id="95memory-protection"><span class="math inline">\(9.5.\)</span>Memory Protection</h1>
<ul>
<li><p>A user process shouldn't be allowed to modify any virtual pages
that are shared with other processes, <strong>unless all parties
explicitly allow it</strong>(via <strong>calls to explicit interprocess
communication system calls</strong>).</p></li>
<li><p>It is straightforward to control access to the contents of a
virtual page by <strong>adding some additional permission bits to the
PTE</strong>.</p></li>
</ul>
<p><img src="/2024/08/20/9-5-Memory-Protection/image.png"></p>
<ul>
<li><p>The <code>SUP</code> bit indicates <strong>whether processes must
be running in kernel(supervisor) mode</strong> to access the
page.</p></li>
<li><p>The <code>READ</code> and <code>WRITE</code> bits control read
and write access to the page.</p></li>
<li><p>If an instruction violates these permissions, then the CPU
<strong>triggers a general protection fault</strong> that transfers
control to an exception handler in the kernel, which sends a
<code>SIGSEGV</code> signal to the offending process. Linux shells
typically report this exception as a <strong>"segmentation
fault"</strong>.</p></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 9.Virtual Memory</category>
      </categories>
  </entry>
  <entry>
    <title>9.4.Memory Management</title>
    <url>/2024/08/20/9-4-Memory-Management/</url>
    <content><![CDATA[<h1 id="94memory-management"><span class="math inline">\(9.4.\)</span>Memory Management</h1>
<p><img src="/2024/08/20/9-4-Memory-Management/image.png"></p>
<ul>
<li><p>Operating systems provide <strong>a separate page table</strong>,
and thus <strong>a separate virtual address space</strong>, for each
process.</p></li>
<li><p><strong>Multiple virtual pages can be mapped to the same shared
physical page</strong>.</p></li>
</ul>
<p>   In particular, VM simplifies memory management in the following
aspects:</p>
<ul>
<li><p>Simplifying linking: A separate address space allows each process
to <strong>use the same basic format for its memory image</strong>,
regardless of where the code and data actually reside in physical
memory.</p></li>
<li><p>Simplifying loading: When loading the object file into a newly
created process, the Linux loader:</p>
<ol type="1">
<li><p>allocates virtual pages for the code and data segments</p></li>
<li><p><strong>marks them as invalid</strong>(i.e., not cached)</p></li>
<li><p><strong>points their page table entries to the appropriate
locations in the object file</strong>.</p></li>
</ol></li>
</ul>
<blockquote>
<p>The loader never actually copies any data from disk into memory.</p>
</blockquote>
<p>  This notion of mapping a set of contiguous virtual pages to an
arbitrary location in an arbitrary file is known as <em>memory
mapping</em>.</p>
<ul>
<li><p>Simplifying sharing: Rather than including separate copies of the
kernel and standard C library in each process, the operating system can
arrange for multiple processes to share a single copy of this code by
<strong>mapping the appropriate virtual pages in different processes to
the same physical pages</strong>.</p></li>
<li><p>Simplifying memory allocation: When a program running in a user
process requests additional heap space(e.g., <code>malloc</code>), the
operating system <strong>allocates <span class="math inline">\(k\)</span> of contiguous virtual memory
pages</strong>, and <strong>maps them to <span class="math inline">\(k\)</span> arbitrary physical pages located
anywhere in physical memory</strong>.</p></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 9.Virtual Memory</category>
      </categories>
  </entry>
  <entry>
    <title>9.1~9.3.VM Address Space</title>
    <url>/2024/08/20/9-1-9-3-VM-Address-Space/</url>
    <content><![CDATA[<h1 id="91-sim93vm-address-spaces"><span class="math inline">\(9.1 \sim
9.3\)</span>VM Address Spaces</h1>
<h3 id="1terminologies">1.Terminologies</h3>
<ul>
<li><p>Each byte has a unique <em>physical address(PA)</em>.</p></li>
<li><p><em>VA</em>: Virtual Address.</p></li>
<li><p>The activity of <strong>transferring a page between disk and
memory</strong> is known as <em>swapping</em> or
<em>paging</em>.</p></li>
<li><p>Pages are <em>swapped in(paged in)</em> from disk to DRAM, and
<em>swapped out(paged out)</em> from DRAM to disk.</p></li>
<li><p>The strategy of <strong>waiting until the last moment to swap in
a page</strong>, when a miss occurs, is known as <em>demand
paging</em>.</p></li>
</ul>
<p><img src="/2024/08/20/9-1-9-3-VM-Address-Space/image.png"></p>
<ul>
<li><p>An <em>address space</em> is an ordered set of nonnegative
integer addresses:</p>
<ul>
<li>If the integers in the address space are
<strong>consecutive</strong>, then we say that it is a <em>linear
address space</em>.</li>
</ul></li>
</ul>
<p><span class="math display">\[
\lbrace 0,1,2, \cdots \rbrace
\]</span></p>
<ul>
<li><p>A virtual address space with <span class="math inline">\(N =
2^n\)</span> addresses is called an <strong>n-bit address
space</strong>.</p></li>
<li><p>At any point in time, the set of virtual pages is partitioned
into three disjoint subsets:</p>
<ul>
<li><p><em>Unallocated</em></p></li>
<li><p><em>Cached</em></p></li>
<li><p><em>Uncached</em></p></li>
</ul></li>
</ul>
<h3 id="2dram-cache-organization">2.DRAM Cache Organization</h3>
<h4 id="apagetables">  <span class="math inline">\(a.\)</span>Page
tables</h4>
<p><img src="/2024/08/20/9-1-9-3-VM-Address-Space/image-1.png"></p>
<ul>
<li><p>A page table is an array of <em>page table entries(PTEs)</em>.
Each page in the virtual address space has a PTE at a fixed offset in
the page table.</p></li>
<li><p>The valid bit indicates <strong>whether the virtual page is
currently cached in DRAM</strong>.</p>
<ul>
<li>If the valid bit is set, the address field indicates the start of
the corresponding physical page in DRAM where the virtual page is
cached.</li>
</ul></li>
</ul>
<h4 id="bpagehits">  <span class="math inline">\(b.\)</span>Page
hits</h4>
<p><img src="/2024/08/20/9-1-9-3-VM-Address-Space/image-2.png"></p>
<ul>
<li>The address translation hardware <strong>uses the virtual address as
an index</strong> to locate PTE 2.</li>
</ul>
<h4 id="cpagefaults">  <span class="math inline">\(c.\)</span>Page
faults</h4>
<p><img src="/2024/08/20/9-1-9-3-VM-Address-Space/image-3.png"></p>
<ul>
<li><p>The page fault exception invokes a page fault exception handler
in the kernel, and it <strong>selects a victim page</strong>. In this
case, it's VP4 in PP3.</p></li>
<li><p>If VP 4 has been modified, then the kernel copies it back to
disk.</p></li>
<li><p>The kernel <strong>modifies the page table entry for VP
4</strong> to reflect the fact that VP 4 is no longer cached in main
memory.</p></li>
<li><p>Next, the kernel copies VP 3 from disk to PP 3 in memory, updates
PTE 3, and then returns.</p></li>
</ul>
<p><img src="/2024/08/20/9-1-9-3-VM-Address-Space/image-4.png"></p>
<ul>
<li>When the handler returns, it <strong>restarts the faulting
instruction</strong>, which resends the faulting virtual address to the
address translation hardware. But now, VP 3 is cached in main memory,
and <strong>the page hit is handled normally</strong> by the address
translation hardware.</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 9.Virtual Memory</category>
      </categories>
  </entry>
  <entry>
    <title>8.6.Nonlocal Jumps</title>
    <url>/2024/08/19/8-6-Nonlocal-Jumps/</url>
    <content><![CDATA[<h1 id="86nonlocal-jumps"><span class="math inline">\(8.6.\)</span>Nonlocal Jumps</h1>
<h3 id="1basic-concepts">1.Basic Concepts</h3>
<ul>
<li><em>Nonlocal jumps</em> <strong>transfers control directly from one
function to another currently executing function</strong> without having
to go through the normal call-and-return sequence.</li>
</ul>
<p>  Nonlocal jumps are provided by the following functions:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: 0 from setjmp, nonzero from longjmps */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>The <code>setjmp</code> function <strong>saves the current
calling environment</strong> in the <code>env</code> buffer for later
use by <code>longjmp</code>.</p>
<ul>
<li>The calling environment includes the program counter, stack pointer,
and general-purpose registers.</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Never returns */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>The <code>longjmp</code> function <strong>restores the calling
environment from the <code>env</code> buffer</strong> and then
<strong>triggers a return from the most recent <code>setjmp</code>
call</strong> that initialized <code>env</code>.</p></li>
<li><p>The <code>setjmp</code> then returns with the nonzero return
value <code>retval</code>.</p>
<ul>
<li>The <code>setjmp</code> function is <strong>called once but returns
multiple times</strong>: once when the setjmp is first called and the
calling environment is stored in the env buffer, and once for each
corresponding longjmp call.</li>
</ul></li>
</ul>
<p>  An important application of nonlocal jumps is to <strong>branch out
of a signal handler to a specific code location</strong>, rather than
returning to the instruction that was interrupted by the signal:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sigjmp_buf buf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    siglongjmp(buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sigsetjmp(buf, <span class="number">1</span>)) &#123;</span><br><span class="line">        Signal(SIGINT, handler);</span><br><span class="line">        Sio_puts(<span class="string">&quot;starting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Sio_puts(<span class="string">&quot;restarting\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        Sleep(<span class="number">1</span>);</span><br><span class="line">        Sio_puts(<span class="string">&quot;processing...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* Control never reaches here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>The initial call to the <code>sigsetjmp</code> function
<strong>saves the calling environment and signal
context</strong>.</p></li>
<li><p>When the user types Ctrl+C, the kernel sends a
<code>SIGINT</code> signal to the process.</p></li>
<li><p>Instead of returning from the signal handler, which would pass
control back to the interrupted processing loop, the handler performs a
nonlocal jump <strong>back to the beginning of the main
program</strong>.</p></li>
</ol>
<p>  The output of the program is as below:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linux&gt; ./restart</span><br><span class="line">starting</span><br><span class="line">processing...</span><br><span class="line">processing...</span><br><span class="line">Ctrl+C</span><br><span class="line">restarting</span><br><span class="line">processing...</span><br><span class="line">Ctrl+C</span><br><span class="line">restarting</span><br><span class="line">processing...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 8.Exceptional Control Flow</category>
      </categories>
  </entry>
  <entry>
    <title>8.5.Signal</title>
    <url>/2024/08/18/8-5-Signal/</url>
    <content><![CDATA[<h1 id="85signal"><span class="math inline">\(8.5.\)</span>Signal</h1>
<h3 id="1signal-terminology">1.Signal Terminology</h3>
<p>  A signal is a small message that <strong>notifies a
process</strong> that <strong>an event of some type has occurred in the
system</strong>.</p>
<p>  The transfer of a signal to a destination process contains two
distinct steps:</p>
<ul>
<li><em>Sending a signal</em>: The kernel <em>sends</em> a signal to a
destination process by <strong>updating some state in the
context</strong> of the destination process.</li>
</ul>
<p>  The signal is delivered for one of two reasons:</p>
<ul>
<li><p>The kernel has <strong>detected a system event</strong> such as a
divide-by-zero error or <strong>the termination of a child
process</strong>.</p></li>
<li><p>A process has <strong>invoked the <code>kill</code>
function</strong>.</p></li>
<li><p><em>Receiving a signal</em>: A destination process
<em>receives</em> a signal when it <strong>is forced by the kernel to
react in some way</strong> to the delivery of the signal.</p>
<ul>
<li>The process can either <strong>ignore the signal, terminate, or
catch the signal</strong> by executing a user-level function called a
<em>signal handler</em>.</li>
</ul></li>
</ul>
<p><img src="/2024/08/18/8-5-Signal/image.png"></p>
<ul>
<li><p>A signal that has been sent but not yet received is called a
<strong>pending signal</strong>.</p></li>
<li><p>At any point in time, there can be <strong>at most one pending
signal of a particular type</strong>. If a process has a pending signal
of type <span class="math inline">\(k\)</span>, then any subsequent
signals of type <span class="math inline">\(k\)</span> sent to that
process <strong>will be ignored and simply discarded</strong>.</p></li>
<li><p>A process can selectively <em>block</em> the receipt of certain
signals. When a signal is blocked, it <strong>can be delivered</strong>,
but <strong>the resulting pending signal will not be received until the
process unblocks the signal</strong>.</p></li>
<li><p>For each process, the kernel maintains the set of pending signals
in the <strong>pending bit vector</strong>, and the set of blocked
signals in the <strong>blocked bit vector</strong>.</p>
<ul>
<li>The kernel <strong>sets bit <span class="math inline">\(k\)</span></strong> in pending whenever a signal
of type <span class="math inline">\(k\)</span> is delivered and
<strong>clears bit <span class="math inline">\(k\)</span></strong> in
pending whenever a signal of type <span class="math inline">\(k\)</span>
is received.</li>
</ul></li>
</ul>
<h3 id="2sending-signals">2.Sending Signals</h3>
<h4 id="aprocess-groups">  <span class="math inline">\(a.\)</span>Process groups</h4>
<p>  Every process belongs to <strong>exactly one <em>process
group</em></strong>, which is identified by a <strong>positive integer
process group ID</strong>.</p>
<p>  The getpgrp function returns <strong>the process group ID</strong>
of the current process.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: process group ID of calling process */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>By default, a child process belongs to <strong>the same process
group as its parent</strong>.</li>
</ul>
<p>  We can change the process group of a process buyt using the
<code>setpgid</code> function:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: 0 on success, −1 on error */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>If <code>pid</code> is zero, the PID of the current process is
used.</p></li>
<li><p>If <code>pgid</code> is zero, the PID of the process
<strong>specified by <code>pid</code> is used for the process group
ID</strong>.</p></li>
</ul>
<h4 id="bsending-signals-from-the-keyboard">  <span class="math inline">\(b.\)</span>Sending signals from the keyboard</h4>
<ul>
<li><p>Unix shells use the abstraction of a <strong>job</strong> to
represent the <strong>processes</strong> that are created <strong>as a
result of evaluating a single command line</strong>.</p></li>
<li><p>At any point in time, there is at most <strong>one foreground
job</strong> and zero or more background jobs.</p></li>
</ul>
<p><img src="/2024/08/18/8-5-Signal/image-1.png"></p>
<h4 id="csending-signals-with-thekill-function">  <span class="math inline">\(c.\)</span>Sending signals with the
<code>kill</code> function</h4>
<p>  Processes <strong>send signals to other processes(including
themselves)</strong> by calling the <code>kill</code> function:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: 0 if OK, −1 on error */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>If <code>pid</code> is greater than zero, then the
<code>kill</code> function sends signal number <code>sig</code> to
process <code>pid</code>.</p></li>
<li><p>If <code>pid</code> is equal to zero, then <code>kill</code>
sends signal <code>sig</code> to <strong>every process in the process
group of the calling process</strong>, including the calling process
itself.</p></li>
<li><p>If <code>pid</code> is less than zero, then <code>kill</code>
sends signal <code>sig</code> to <strong>every process in process group
<code>|pid|</code>(the absolute value of
<code>pid</code>)</strong>.</p></li>
</ul>
<h4 id="dsending-signals-with-thealarm-function">  <span class="math inline">\(d.\)</span>Sending signals with the
<code>alarm</code> function</h4>
<p>  A process can <strong>send <code>SIGALRM</code> signals to
itself</strong> by calling the <code>alarm</code> function:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: remaining seconds of previous alarm, or 0 if no previous alarm */</span></span><br></pre></td></tr></table></figure>
<h3 id="3receiving-signals">3.Receiving Signals</h3>
<p>  When the kernel <strong>switches a process <span class="math inline">\(p\)</span> from kernel mode to user mode</strong>,
it checks <strong>the set of unblocked pending
signals</strong>(<code>pending &amp; ~blocked</code>) for <span class="math inline">\(p\)</span>.</p>
<ul>
<li><p>If this set is empty, the kernel <strong>passes control to the
next instruction</strong> in the logical control flow of <span class="math inline">\(p\)</span>.</p></li>
<li><p>If the set is nonempty, the kernel <strong>chooses some signal
<span class="math inline">\(k\)</span> in the set(typically the smallest
<span class="math inline">\(k\)</span>) and forces <span class="math inline">\(p\)</span> to receive signal <span class="math inline">\(k\)</span></strong>.</p>
<ul>
<li>Once the process completes the action, control passes back to the
next instruction.</li>
</ul></li>
</ul>
<p>  A process can modify <strong>the default action associated with a
signal</strong> by using the <code>signal</code> function:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: pointer to previous handler if OK, SIG_ERR on error (does not set errno)*/</span></span><br></pre></td></tr></table></figure>
<p>  The <code>signal</code> function can change the action associated
with a signal <code>signum</code> in one of three ways:</p>
<ul>
<li><p>If <code>handler</code> is <code>SIG_IGN</code>, then signals of
type <code>signum</code> <strong>are ignored</strong>.</p></li>
<li><p>If <code>handler</code> is <code>SIG_DFL</code>, then the action
for signals of type signum <strong>reverts to the default
action</strong>.</p></li>
<li><p>Otherwise, <code>handler</code> is <strong>the address of a
user-defined function</strong>, called a <em>signal handler</em>, that
will be called whenever the process receives a signal of type
<code>signum</code>.</p></li>
</ul>
<p>  Signal handlers can be interrupted by other handlers:</p>
<p><img src="/2024/08/18/8-5-Signal/image-2.png"></p>
<h3 id="4blocking-and-unblockingsignals">4.Blocking and Unblocking
Signals</h3>
<ul>
<li><p><em>Implicit blocking mechanism</em>: By default, the kernel
blocks any pending signals of the type <strong>currently being processed
by a handler</strong>.</p></li>
<li><p><em>Explicit blocking mechanism</em>: It can be done by
<strong>using the <code>sigprocmask</code> function and its
helpers</strong>:</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: 0 if OK, −1 on error */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: 1 if member, 0 if not, −1 on error */</span></span><br></pre></td></tr></table></figure>
<p>  The <code>sigprocmask</code> function changes <strong>the set of
currently blocked signals</strong>. The specific behavior depends on the
value of <code>how</code>:</p>
<ul>
<li><p><code>SIG_BLOCK</code>: Add the signals in set to blocked
(<code>blocked = blocked | set</code>).</p></li>
<li><p><code>SIG_UNBLOCK</code>: Remove the signals in set from blocked
(<code>blocked = blocked &amp; ~set</code>).</p></li>
<li><p><code>SIG_SETMASK</code>: <code>blocked = set</code>.</p></li>
</ul>
<h4 id="acorrect-signal-handling">  <span class="math inline">\(a.\)</span>Correct signal handling</h4>
<p>  Because the pending bit vector contains exactly one bit for each
type of signal, <strong>there can be at most one pending signal of any
particular type</strong>. Thus, if two signals of type <span class="math inline">\(k\)</span> are sent to a destination process while
signal <span class="math inline">\(k\)</span> is blocked because the
destination process is currently executing a handler for signal <span class="math inline">\(k\)</span>, then <strong>the second signal is
simply discarded</strong>.</p>
<p>  This characteristic of signal handling may lead to some mistakes.
Consider the following program, for example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* WARNING: This code is buggy! */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler1</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    Sio_puts(<span class="string">&quot;Handler reaped child\n&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGCHLD, handler1) == SIG_ERR)</span><br><span class="line">        unix_error(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent creates children */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello from child %d\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent waits for terminal input and then processes it */</span></span><br><span class="line">    <span class="keyword">if</span> ((n = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent processing input\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  When executing, we get the following result:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linux&gt; ./signal1</span><br><span class="line">Hello from child 14073</span><br><span class="line">Hello from child 14074</span><br><span class="line">Hello from child 14075</span><br><span class="line">Handler reaped child</span><br><span class="line">Handler reaped child</span><br><span class="line">CR</span><br><span class="line">Parent processing input</span><br></pre></td></tr></table></figure>
<p>  We first do some analysis for the program:</p>
<ol type="1">
<li><p>The parent process first create three child processes through
invoking <code>Fork()</code>.</p></li>
<li><p>For each child, they will do the conditional
<code>exit(0)</code>, terminate and send the signal.</p></li>
<li><p>The handler fetch the signal, reap the corresponding child
process, and send the message.</p></li>
</ol>
<p>  The result, however, shows that only two child processes are
reaped. The reason is that:</p>
<ol type="1">
<li><p>Our handler handle one signal per time.</p></li>
<li><p>While the handler is <strong>still processing the first
signal</strong>, <strong>the second signal is delivered and added to the
set of pending signals</strong>.</p></li>
<li><p>Since the first <code>SIGCHLD</code> signals are blocked by the
handler, the second signals are not received.</p></li>
<li><p>While the handler is still processing the first signal, the third
signal arrives. <strong>Since there is already a pending
<code>SIGCHLD</code>, this third <code>SIGCHLD</code> signal is
discarded</strong>, and the information of the third signal has been
lost.</p></li>
</ol>
<p>  To fix the problem, we must modify the <code>SIGCHLD</code> handler
to reap as many zombie children as possible each time it is invoked. We
do this by using the <code>while</code> loop:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler2</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Sio_puts(<span class="string">&quot;Handler reaped child\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">        Sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bportable-signal-handling">  <span class="math inline">\(b.\)</span>Portable signal handling</h4>
<p>  The standard <code>sigaction</code> function for specifying the
signal-handling semantics they want when they install a handler is as
below:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="keyword">struct</span> sigaction *act,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: 0 if OK, −1 on error */</span></span><br></pre></td></tr></table></figure>
<p>  The <code>Signal</code> wrapper is as below:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* Block sigs of type being handled */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* Restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5blocking-signalsto-avoid-concurrency-bugs">5.Blocking Signals
to Avoid Concurrency Bugs</h3>
<p>  Take the following program as an example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* WARNING: This code is buggy! */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123; <span class="comment">/* Reap a zombie child */</span></span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">        deletejob(pid); <span class="comment">/* Delete the child from the job list */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">        Sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* Initialize the job list */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child process */</span></span><br><span class="line">            Execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); <span class="comment">/* Parent process */</span></span><br><span class="line">        addjob(pid); <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  There consists two concurrent procedure:</p>
<ol type="1">
<li><p>The <code>addjob</code> and <code>deletejob</code> of the Unix
shell job list.</p></li>
<li><p>The reaping of the child process.</p></li>
</ol>
<p>  and we may meet the situation that the child process has been
reaped, and the <code>deletejob</code> function tries to delete it,
which is nonexisted.</p>
<p>  To prevent this, we <strong>blocking <code>SIGCHLD</code> signals
before the call to <code>fork</code></strong> and then unblocking them
<strong>only after we have called <code>addjob</code></strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child process */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">        Execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>); <span class="comment">/* Parent process */</span></span><br><span class="line">    addjob(pid); <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">    Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Notice that <strong>children inherit the blocked set of their
parents</strong>, so we must be careful to unblock the SIGCHLD signal in
the child.</p>
</blockquote>
<h3 id="6explicitly-waiting-forsignals">6.Explicitly Waiting for
Signals</h3>
<p>  In the previous code, we use <code>while(1)</code> loop to stall
the process. This is wasteful of processor resourses. We can use
<code>sigsuspend</code> instead:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: −1 */</span></span><br></pre></td></tr></table></figure>
<p>  The sigsuspend function temporarily <strong>replaces the current
blocked set with mask</strong> and then suspends the process
<strong>until the receipt of a signal</strong> whose action is either to
run a handler or to terminate the process.</p>
<p>  This code is equal to the <em>atomic</em> version of the
following:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 8.Exceptional Control Flow</category>
      </categories>
  </entry>
  <entry>
    <title>8.4.Process Control</title>
    <url>/2024/08/16/8-4-Process-Control/</url>
    <content><![CDATA[<h1 id="84process-control"><span class="math inline">\(8.4.\)</span>Process Control</h1>
<h3 id="1obtaining-process-ids">1.Obtaining Process IDs</h3>
<ul>
<li><p>Each process has a unique positive <em>process
ID(PID)</em>.</p></li>
<li><p>The <code>getpid</code> function returns the PID of the calling
process.</p></li>
<li><p>The <code>getppid</code> function returns the PID of its
parent(i.e., the process that created the calling process).</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: PID of either the caller or the parent */</span></span><br></pre></td></tr></table></figure>
<h3 id="2terminating-processes">2.Terminating Processes</h3>
<p>  We can think of a process as being in one of three states:</p>
<ul>
<li><p><em>Running</em>: The process is either executing on the CPU or
waiting to be executed and will eventually be scheduled by the
kernel.</p></li>
<li><p><em>Stopped</em>: The execution of the process is suspended and
<strong>will not be scheduled</strong>.</p></li>
<li><p><em>Terminated</em>: The process is stopped
<strong>permanently</strong>. This is due to the following reasons:</p>
<ol type="1">
<li><p>Receiving a signal whose default action is to terminate the
process.</p></li>
<li><p>Returning from the main routine.</p></li>
<li><p>Calling the <code>exit</code> function.</p></li>
</ol></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function does not return */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>The <code>exit</code> function terminates the process with an
<em>exit status</em> of status.</li>
</ul>
<blockquote>
<p>The other way to set the exit status is to <strong>return an integer
value from the main routine</strong>.</p>
</blockquote>
<h3 id="3creating-processes">3.Creating Processes</h3>
<p>  A parent process <strong>creates a new running child
process</strong> by calling the <code>fork</code> function.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: 0 to child, PID of child to parent, −1 on error */</span></span><br></pre></td></tr></table></figure>
<p>  The newly created child process is almost, identical to the
parent:</p>
<ul>
<li><p>The child gets an identical(but <strong>separate</strong>) copy
of the parent’s user-level virtual address space.</p></li>
<li><p>The child also gets identical copies of any of the parent’s open
file descriptors, which means the child <strong>can read and write any
files that were open in the parent when it called
fork</strong>.</p></li>
<li><p>However, they share different PIDs.</p></li>
</ul>
<p>  The <code>fork</code> function <strong>is called once but it
returns twice</strong>.</p>
<blockquote>
<p>Since the PID of the child is always nonzero, the return value
provides an unambiguous way to <strong>tell whether the program is
executing in the parent or the child</strong>.</p>
</blockquote>
<p>  Take the following program as an example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : x=%d\n&quot;</span>, ++x);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: x=%d\n&quot;</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  When we run the program on the Unix system, we get the following
result:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linux&gt; ./fork</span><br><span class="line">parent: x=0</span><br><span class="line">child : x=2</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The parent and the child are separate processes that run
<strong>concurrently</strong>, and whether we get the
<code>parent: x=0</code> first or <code>child: x=2</code>first depends
on <strong>whether the parent process completes faster than the child
process</strong>.</p></li>
<li><p>Since the parent and the child are separate processes, they each
have their own private address spaces, so that any subsequent changes
that a parent or child makes to <code>x</code> <strong>are private and
are not reflected in the memory of the other process</strong>.</p></li>
</ul>
<hr>
<p>  We can use a <em>process graph</em> to describe the process:</p>
<p><img src="/2024/08/16/8-4-Process-Control/image.png"></p>
<p>  Let's take a look at a more complicate example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Fork();</span><br><span class="line">    Fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  The process graph of the process is as below:</p>
<p><img src="/2024/08/16/8-4-Process-Control/image-1.png"></p>
<ul>
<li>For a program running on a single processor, any <strong>topological
sort of the vertices</strong> in the corresponding process graph
represents <strong>a feasible total ordering of the statements in the
program</strong>.</li>
</ul>
<h3 id="4reaping-child-processes">4.Reaping Child Processes</h3>
<h4 id="abasicconcept">  <span class="math inline">\(a.\)</span>Basic
concept</h4>
<p>  When a process terminates for any reason, the kernel does not
remove it from the system immediately. Instead, the process <strong>is
kept around in a terminated state</strong> until <strong>it is reaped by
its parent</strong>.</p>
<p>  When the parent reaps the terminated child, the kernel
<strong>passes the child's exit status to the parent</strong> and then
<strong>discards the terminated process</strong>.</p>
<ul>
<li><p>A terminated process that has not yet been reaped is called a
<em>zombie</em>.</p></li>
<li><p>Even though zombies are not running, they still consume system
memory resources.</p></li>
</ul>
<hr>
<p>  When a parent process terminates, the kernel <strong>arranges for
the <code>init</code> process to become the adopted parent of any
orphaned children</strong>. The <code>init</code> process:</p>
<ul>
<li><p>has a PID of 1,</p></li>
<li><p>is created by the kernel <strong>during system
start-up</strong>,</p></li>
<li><p>never terminates</p></li>
<li><p>is <strong>the ancestor of every process</strong>.</p></li>
</ul>
<h4 id="breaping-operations">  <span class="math inline">\(b.\)</span>Reaping operations</h4>
<h5 id="ithe-waitpid-function">  <span class="math inline">\(i.\)</span>The <code>waitpid</code> function</h5>
<p>  A process waits for its children to terminate or stop by calling
the <code>waitpid</code> function:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: PID of child if OK, 0 (if WNOHANG), or −1 on error */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>By default(when options = 0), <code>waitpid</code>
<strong>suspends execution of the calling process</strong> until
<strong>a child process in its wait set terminates</strong>.</p></li>
<li><p>If a process in the wait set has already terminated at the time
of the call, then <code>waitpid</code> returns immediately.</p></li>
<li><p>Else, <code>waitpid</code> returns the PID of the terminated
child that caused <code>waitpid</code> to return.</p></li>
</ul>
<hr>
<ul>
<li><p>If <code>pid &gt; 0</code>, then the wait set is <strong>the
singleton child process</strong> whose process ID is equal to
<code>pid</code>.</p></li>
<li><p>If <code>pid = -1</code>, then the wait set consists of
<strong>all of the parent's child processes</strong>.</p></li>
</ul>
<h5 id="iimodifying-the-default-behavior">  <span class="math inline">\(ii.\)</span>Modifying the default behavior</h5>
<p>  The default behavior can be modified by <strong>setting
<code>options</code> to</strong> various combinations of the
<code>WNOHANG</code>, <code>WUNTRACED</code>, and
<code>WCONTINUED</code> constants:</p>
<ul>
<li><p><code>WNOHANG</code>: <strong>Return immediately</strong>(with a
return value of 0) if <strong>none of the child processes in the wait
set has terminated yet</strong>.</p>
<ul>
<li>The default behavior suspends the calling process until a child
terminates, this option, however, allows us to <strong>do useful work
while waiting for a child to terminate</strong>.</li>
</ul></li>
<li><p><code>WUNTRACED</code>: Suspend execution of the calling process
until a process in the wait set becomes either terminated or stopped.
<strong>Return the PID of the terminated or stopped child</strong> that
caused the return.</p>
<ul>
<li>The default behavior returns only for terminated children; this
option is useful when you want to <strong>check for both terminated and
stopped children</strong>.</li>
</ul></li>
</ul>
<p>  The options can be combined by <code>ORING</code>, for example:</p>
<ul>
<li><code>WNOHANG | WUNTRACED</code>: Return immediately, with a return
value of 0, if none of the children in the wait set has stopped or
terminated, or with a return value equal to the PID of one of the
stopped or terminated children.</li>
</ul>
<h5 id="iiichecking-the-exit-status-of-a-reapedchild">  <span class="math inline">\(iii.\)</span>Checking the exit status of a reaped
child</h5>
<p>  If the <code>statusp</code> argument is non-NULL, then
<code>waitpid</code> encodes status information about the child that
caused the return in <code>status</code>, which is the value
<strong>pointed to by <code>statusp</code></strong>.</p>
<p>  The <code>wait.h</code> include file defines several macros for
interpreting the status argument:</p>
<ul>
<li><p><code>WIFEXITED(status)</code>: Returns true if the child
<strong>terminated normally</strong>, via a call to <code>exit</code> or
a <code>return</code>.</p></li>
<li><p><code>WEXITSTATUS(status)</code>: Returns <strong>the exit
status</strong> of a normally terminated child. This status is only
defined if <code>WIFEXITED()</code> returned true.</p></li>
<li><p><code>WTERMSIG(status)</code>: Returns <strong>the number of the
signal</strong> that caused the child process to terminate. This status
is only defined if <code>WIFSIGNALED()</code> returned true.</p></li>
<li><p><code>WIFSTOPPED(status)</code>: Returns true if the child that
caused the return is currently stopped.</p></li>
<li><p><code>WSTOPSIG(status)</code>: Returns <strong>the number of the
signal</strong> that caused the child to stop. This status is only
defined if <code>WIFSTOPPED()</code> returned true.</p></li>
</ul>
<h5 id="iverror-conditions">  <span class="math inline">\(iv.\)</span>Error conditions</h5>
<ul>
<li><p>If the calling process has no children, then <code>waitpid</code>
returns −1 and sets <code>errno</code> to <code>ECHILD</code>.</p></li>
<li><p>If the <code>waitpid</code> function was interrupted by a signal,
then it returns −1 and sets errno to <code>EINTR</code>.</p></li>
</ul>
<h5 id="vthe-wait-function">  <span class="math inline">\(v.\)</span>The <code>wait</code> function</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: PID of child if OK or −1 on error */</span></span><br></pre></td></tr></table></figure>
<p>  Calling <code>wait(&amp;status)</code> is equivalent to calling
<code>waitpid(-1, &amp;status, 0)</code>.</p>
<h3 id="5putting-processes-to-sleep">5.Putting Processes to Sleep</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: seconds left to sleep */</span></span><br></pre></td></tr></table></figure>
<p>  Another function that we will find useful is the <code>pause</code>
function, which <strong>puts the calling function to sleep</strong>
until <strong>a signal is received by the process</strong>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Always returns −1 */</span></span><br></pre></td></tr></table></figure>
<h3 id="6loading-and-runningprograms">6.Loading and Running
Programs</h3>
<h4 id="athe-execve-function-ampexecuting-process">  <span class="math inline">\(a.\)</span>The <code>execve</code> function &amp;
executing process</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Does not return if OK; returns −1 on error */</span></span><br></pre></td></tr></table></figure>
<p>  The data structure of argument list and the list of environment
variables are as below:</p>
<p><img src="/2024/08/16/8-4-Process-Control/image-2.png"></p>
<ul>
<li>By convention, <code>argv[0]</code> is the name of the executable
object file.</li>
</ul>
<p>  After <code>execve</code> loads <code>filename</code>, it
<strong>calls the start-up code</strong>. The start-up code <strong>sets
up the stack</strong> and <strong>passes control to the
<code>main</code> routine</strong> of the new program, which has a
prototype of the form:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span>;</span><br><span class="line"><span class="comment">/* int main(int argc, char *argv[], char *envp[]); */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>argc</code>:It gives <strong>the number of non-null
pointers</strong> in the <code>argv[]</code> array.</p></li>
<li><p><code>argv</code>:It <strong>points to the first entry</strong>
in the <code>argv[]</code> array.</p></li>
<li><p><code>envp</code>:It <strong>points to the first entry</strong>
in the <code>envp[]</code> array.</p></li>
</ul>
<p>  The stack has the organization as below:</p>
<p><img src="/2024/08/16/8-4-Process-Control/image-3.png"></p>
<h4 id="bmanipulating-the-environment-array">  <span class="math inline">\(b.\)</span>Manipulating the environment array</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: pointer to name if it exists, NULL if no match */</span></span><br></pre></td></tr></table></figure>
<p>  The getenv function searches the environment array for a string
<code>name=value</code>. If found, it returns a pointer to value;
otherwise, it returns <code>NULL</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *newvalue, <span class="type">int</span> overwrite)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: 0 on success, −1 on error */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: nothing */</span></span><br></pre></td></tr></table></figure>
<h3 id="7using-forkand-execve-to-run-programs">7.Using <code>fork</code>
and <code>execve</code> to Run Programs</h3>
<ul>
<li>A <em>shell</em> is an interactive application-level program that
<strong>runs other programs on behalf of the user</strong>. <strong>The
original shell was the <code>sh</code> program</strong>, which was
followed by variants such as <code>csh</code>, <code>tcsh</code>,
<code>ksh</code>, and <code>bash</code>.</li>
</ul>
<p>  A shell performs a sequence of <em>read/evaluate</em> steps and
then terminates.</p>
<ul>
<li><p>The read step reads a command line from the user.</p></li>
<li><p>The evaluate step <strong>parses the command line</strong> and
runs programs on behalf of the user.</p></li>
</ul>
<h4 id="athe-main-routine-of-asimple-shell">  <span class="math inline">\(a.\)</span>The <code>main</code> routine of a
simple shell</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE]; <span class="comment">/* Command line */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Read */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bthe-evaluating-routine">  <span class="math inline">\(b.\)</span>The evaluating routine</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* eval - Evaluate a command line */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS]; <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE]; <span class="comment">/* Holds modified command line */</span></span><br><span class="line">    <span class="type">int</span> bg; <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid; <span class="comment">/* Process id */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* Ignore empty lines */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If first arg is a builtin command, run it and return true */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>)) <span class="comment">/* quit command */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>)) <span class="comment">/* Ignore singleton &amp; */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Not a builtin command */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* parseline - Parse the command line and build the argv array */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *delim; <span class="comment">/* Points to first space delimiter */</span></span><br><span class="line">    <span class="type">int</span> argc; <span class="comment">/* Number of args */</span></span><br><span class="line">    <span class="type">int</span> bg; <span class="comment">/* Background job? */</span></span><br><span class="line"></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">&#x27; &#x27;</span>; <span class="comment">/* Replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* Ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>))) &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* Ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="comment">/* Ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The <code>phaseline</code> function parses the space-separated
command-line arguments and builds the <code>argv</code> vector that will
eventually be passed to <code>execve</code>.</p>
<ul>
<li><p>If the last argument is an '&amp;' character, then parseline
returns 1, indicating that the program should be executed in the
<em>background</em>(the shell <strong>does not wait for it to
complete</strong>).</p></li>
<li><p>Otherwise, it returns 0, indicating that the program should be
run in the <em>foreground</em>(the shell <strong>waits for it to
complete</strong>).</p></li>
</ul></li>
<li><p>After parsing the command line, the <code>eval</code> function
calls the <code>builtin_command</code> function, which <strong>checks
whether the first command-line argument is a built-in shell
command</strong>. If so, it interprets the command immediately and
returns 1. Otherwise, it returns 0.</p></li>
<li><p>If <code>builtin_command</code> returns 0, then the shell
<strong>creates a child process</strong> and <strong>executes the
requested program inside the child</strong>.</p>
<ul>
<li><p>If the user has asked for the program to run in the background,
then the shell <strong>returns to the top of the loop and waits for the
next command line</strong>.</p></li>
<li><p>Otherwise the shell uses the <code>waitpid</code> function to
<strong>wait for the job to terminate</strong>. When the job terminates,
the shell goes on to the next iteration.</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 8.Exceptional Control Flow</category>
      </categories>
  </entry>
  <entry>
    <title>8.3.System Call Error Handling</title>
    <url>/2024/08/16/8-3-System-Call-Error-Handling/</url>
    <content><![CDATA[<h1 id="83system-call-error-handling"><span class="math inline">\(8.3.\)</span>System Call Error Handling</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  We can simplify this code somewhat by defining the following
<em>error-reporting</em> function:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span> <span class="comment">/* Unix-style error */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  We can simplify our code even further by using <em>error-handling
wrappers</em>. For a given base function <code>foo</code>, we define a
wrapper function <code>Foo</code> with <strong>identical arguments but
with the first letter of the name capitalized</strong>. The wrapper
calls the base function, <strong>checks for errors, and terminates if
there are any problems</strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 8.Exceptional Control Flow</category>
      </categories>
  </entry>
  <entry>
    <title>8.2.Processes</title>
    <url>/2024/08/16/8-2-Processes/</url>
    <content><![CDATA[<h1 id="82processes"><span class="math inline">\(8.2.\)</span>Processes</h1>
<h3 id="1basic-concepts">1.Basic Concepts</h3>
<ul>
<li><p>The classic definition of a process is <strong>an instance of a
program in execution</strong>.</p></li>
<li><p>Each program in the system runs <strong>in the context
of</strong> some process. The context consists of <strong>the state that
the program needs to run correctly</strong>.</p></li>
</ul>
<h3 id="2logical-control-flow">2.Logical Control Flow</h3>
<p>   If we were to use a debugger to single-step the execution of our
program, we would observe <strong>a series of program counter(PC)
values</strong> that corresponded exclusively to instructions contained
in our program's executable object file or in shared objects linked into
our program dynamically at run time. This sequence of PC values is known
as a <strong>logical control flow</strong>, or simply <strong>logical
flow</strong>.</p>
<p><img src="/2024/08/16/8-2-Processes/image.png"></p>
<ul>
<li>Processes <strong>take turns using the processor</strong>. Each
process executes a portion of its flow and then <strong>is
<em>preempted</em></strong>(temporarily suspended) while other processes
take their turns.</li>
</ul>
<h3 id="3user-and-kernel-modes">3.User and Kernel Modes</h3>
<p>  In order for the operating system kernel to provide an airtight
process abstraction, the processor must provide a mechanism that
<strong>restricts the instructions that an application can execute, as
well as the portions of the address space that it can
access</strong>.</p>
<p>  Processors typically provide this capability with a <strong>mode
bit</strong> in some control register that characterizes the privileges
that the process currently enjoys.</p>
<ul>
<li><p>A process running in <em>kernel mode</em> can <strong>execute any
instruction in the instruction set and access any memory location in the
system</strong>.</p></li>
<li><p>A process running in <em>user mode</em> is <strong>not allowed to
execute privileged instructions</strong> that do things such as halt the
processor, change the mode bit, or initiate an I/O operation. Nor is it
allowed to <strong>directly reference code or data in the kernel area of
the address space</strong>.</p>
<ul>
<li><p>Any such attempt results in a <strong>fatal protection
fault</strong>.</p></li>
<li><p>To execute these instructions, user programs must instead access
kernel code and data indirectly <strong>via the system call
interface</strong>.</p></li>
</ul></li>
</ul>
<h3 id="4context-switches">4.Context Switches</h3>
<p>  The operating system kernel implements multitasking using a
higher-level form of exceptional control flow known as a <em>context
switch</em>.</p>
<ul>
<li><p>The kernel maintains a context for each process. The context is
the <strong>state</strong> that the kernel needs <strong>to restart a
preempted process</strong>.</p></li>
<li><p>At certain points during the execution of a process, the kernel
can decide to <strong>preempt the current process and restart a
previously preempted process</strong>. And we say that the kernel has
<em>scheduled</em> that process.</p></li>
</ul>
<p>  The context switch contains the following steps:</p>
<ol type="1">
<li><p><strong>Saves the context of the current
process</strong>.</p></li>
<li><p><strong>Restores the saved context</strong> of some previously
preempted process.</p></li>
<li><p><strong>Passes control</strong> to this newly restored
process.</p></li>
</ol>
<p>  If the system call blocks because it is waiting for some event to
occur, then the kernel can <strong>put the current process to
sleep</strong> and <strong>switch to another process</strong>.</p>
<blockquote>
<p>A context switch can also occur as a result of an interrupt. For
example, all systems have some mechanism for <strong>generating periodic
timer interrupts</strong>. Each time a timer interrupt occurs, the
kernel can decide that the current process has run long enough and
switch to a new process.</p>
</blockquote>
<p><img src="/2024/08/16/8-2-Processes/image-1.png"></p>
<ul>
<li><p>The disk will take a relatively long time to fetch the data, so
instead of waiting and doing nothing, the kernel <strong>performs a
context switch from process A to B</strong>.</p></li>
<li><p>Process B then runs for a while in user mode until <strong>the
disk sends an interrupt</strong> to signal that data have been
transferred from disk to memory.</p></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 8.Exceptional Control Flow</category>
      </categories>
  </entry>
  <entry>
    <title>8.1.Exceptions</title>
    <url>/2024/08/15/8-1-Exceptions/</url>
    <content><![CDATA[<h1 id="81exceptions"><span class="math inline">\(8.1.\)</span>Exceptions</h1>
<p>  An exception is <strong>an abrupt change in the control
flow</strong> in response to <strong>some change in the processor's
state</strong>：</p>
<p><img src="/2024/08/15/8-1-Exceptions/image.png"></p>
<h3 id="1exception-handling">1.Exception Handling</h3>
<ul>
<li>Each type of possible exception in a system <strong>is assigned a
unique nonnegative integer exception number</strong>.</li>
</ul>
<ol type="1">
<li>At <strong>system boot time</strong>(when the computer is reset or
powered on), the operating system allocates and initializes a jump table
called an <strong>exception table</strong>, so that entry <span class="math inline">\(k\)</span> <strong>contains the address of the
handler for exception <span class="math inline">\(k\)</span></strong>.</li>
</ol>
<p><img src="/2024/08/15/8-1-Exceptions/image-1.png"></p>
<ol start="2" type="1">
<li>At run time(when <strong>the system is executing some
program</strong>), the processor detects that an exception has occurred
and determines the corresponding exception number <span class="math inline">\(k\)</span>. The processor then triggers the
exception by making an indirect procedure call, <strong>through entry
<span class="math inline">\(k\)</span> of the exception table, to the
corresponding handler</strong>.</li>
</ol>
<p><img src="/2024/08/15/8-1-Exceptions/image-2.png"></p>
<ul>
<li>The starting address of the exception table is contained in a
special CPU register called the <em>exception table base
register</em>.</li>
</ul>
<h3 id="2differencesbetween-exceptions-and-procedure-call">2.Differences
between Exceptions and Procedure Call</h3>
<ul>
<li><p>As with a procedure call, the processor pushes a return address
on the stack before branching to the handler. However, depending on the
class of exception, the return address will have multiple
choices.</p></li>
<li><p>The processor also <strong>pushes some additional processor state
onto the stack</strong> that will be necessary to <strong>restart the
interrupted program when the handler returns</strong>.</p></li>
</ul>
<p>  Once the hardware triggers the exception, the rest of the work is
done in software by the exception handler. After the handler has
processed the event, it optionally returns to the interrupted program by
<strong>executing a special "return from interrupt"
instruction</strong>, which <strong>pops the appropriate state back into
the processor's control and data registers, restores the state to user
mode</strong> if the exception interrupted a user program, and then
returns control to the interrupted program.</p>
<h3 id="3classes-of-exceptions">3.Classes of Exceptions</h3>
<p><img src="/2024/08/15/8-1-Exceptions/image-3.png"></p>
<h4 id="ainterrupts">  <span class="math inline">\(a.\)</span>Interrupts</h4>
<p>  <em>Interrupts</em> occur asynchronously as a result of
<strong>signals from I/O devices that are external to the
processor</strong>.</p>
<p><img src="/2024/08/15/8-1-Exceptions/image-4.png"></p>
<ul>
<li><p>I/O devices interrupts by <strong>signaling a pin on the
processor chip</strong> and <strong>placing onto the system bus the
exception number</strong> that <strong>identifies the device that caused
the interrupt</strong>.</p></li>
<li><p>After the current instruction finishes executing, the processor
<strong>notices that the interrupt pin has gone high</strong>,
<strong>reads the exception number from the system bus</strong>, and
then <strong>calls the appropriate interrupt handler</strong>.</p></li>
<li><p>When the handler returns, it <strong>returns control to the next
instruction</strong>. The program continues executing as though the
interrupt had never happened.</p></li>
</ul>
<hr>
<p>  The remaining classes of exceptions(traps, faults, and aborts)
occur synchronously <strong>as a result of executing the current
instruction</strong>. We refer to this instruction as the <em>faulting
instruction</em>.</p>
<h4 id="btraps-and-system-calls">  <span class="math inline">\(b.\)</span>Traps and system calls</h4>
<p>  The most important use of traps is to <strong>provide a
procedure-like interface between user programs and the kernel</strong>,
known as a <em>system call</em>.</p>
<p>  User program often needs to request services from the kernel.
processors provide a special <code>syscall n</code> instruction that
user programs can execute <strong>when they want to request service
n</strong>.</p>
<ul>
<li>Executing the syscall instruction <strong>causes a trap to an
exception handler</strong> that <strong>decodes the argument and calls
the appropriate kernel routine</strong>.</li>
</ul>
<p><img src="/2024/08/15/8-1-Exceptions/image-5.png"></p>
<h4 id="cfaults">  <span class="math inline">\(c.\)</span>Faults</h4>
<p><img src="/2024/08/15/8-1-Exceptions/image-6.png"></p>
<h4 id="dabort">  <span class="math inline">\(d.\)</span>Abort</h4>
<p><img src="/2024/08/15/8-1-Exceptions/image-7.png"></p>
<h3 id="4linuxx86-64-system-calls">4.Linux/x86-64 System Calls</h3>
<p><img src="/2024/08/15/8-1-Exceptions/image-8.png"></p>
<ul>
<li>Each system call has a unique integer number that
<strong>corresponds to an offset in a jump table</strong> in the
kernel.(This jump table is not the same as the exception table.)</li>
</ul>
<p>  The C standard library provides a set of convenient wrapper
functions for most system calls. The wrapper functions <strong>package
up the arguments, trap to the kernel with the appropriate system call
instruction, and then pass the return status of the system call back to
the calling program</strong>.</p>
<ul>
<li>All arguments to Linux system calls are passed <strong>through
general-purpose registers</strong> rather than the stack.</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 8.Exceptional Control Flow</category>
      </categories>
  </entry>
  <entry>
    <title>6.6.The Impact of Caches on Program Performance</title>
    <url>/2024/08/12/6-6-The-Impact-of-Caches-on-Program-Performance/</url>
    <content><![CDATA[<h1 id="66the-impact-of-caches-on-programperformance"><span class="math inline">\(6.6.\)</span>The Impact of Caches on Program
Performance</h1>
<h3 id="1rearrangingloops-to-increase-spatial-locality">1.Rearranging
Loops to Increase Spatial Locality</h3>
<p>  Consider the problem of multiplying a pair of <span class="math inline">\(2 \times 2\)</span> matrices: <span class="math inline">\(C = AB\)</span>:</p>
<p><span class="math display">\[
\begin{bmatrix}
c_{11} &amp; c_{12} \\
c_{21} &amp; c_{22}
\end{bmatrix}
=
\begin{bmatrix}
a_{11} &amp; a_{12} \\
a_{21} &amp; a_{22}
\end{bmatrix}
\cdot
\begin{bmatrix}
b_{11} &amp; b_{12} \\
b_{21} &amp; b_{22}
\end{bmatrix}
\]</span></p>
<p>  and we make the following assumptions:</p>
<ul>
<li><p>Each array is an <span class="math inline">\(n \times n\)</span>
array of double, with <code>sizeof(double) = 8</code>.</p></li>
<li><p>There is a single cache with a 32-byte block size(B =
32).</p></li>
<li><p>The array size n is so large that a single matrix row does not
fit in the L1 cache.</p></li>
<li><p>The compiler stores local variables in registers, and thus
references to local variables inside loops do not require any load or
store instructions.</p></li>
</ul>
<p>  We can write three different versions:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            sum += A[i][k]*B[k][j];</span><br><span class="line">        C[i][j] += sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        r = B[k][j];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        C[i][j] += A[i][k]*r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        r = A[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            C[i][j] += r * B[k][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/12/6-6-The-Impact-of-Caches-on-Program-Performance/image.png"></p>
<p>  The third routine present an interesting trade-off: With two loads
and a store, they <strong>require one more memory operation than the
first routines</strong>. On the other hand, since the inner loop scans
both B and C row-wise with a stride-1 access pattern, the miss rate on
each array is only 0.25 misses per iteration, for a total of 0.50 misses
per iteration.</p>
<p>  The performance result is as below:</p>
<p><img src="/2024/08/12/6-6-The-Impact-of-Caches-on-Program-Performance/image-1.png"></p>
<p>  We can see that in this case, <strong>miss rate is a better
predictor of performance</strong> than the total number of memory
accesses.</p>
<h3 id="2exploiting-locality">2.Exploiting Locality</h3>
<ul>
<li><p>Focus your attention on the inner loops.</p></li>
<li><p>Try to maximize the spatial locality in your programs by reading
data objects sequentially, <strong>with stride 1</strong>, <strong>in
the order they are stored in memory</strong>.</p></li>
<li><p>Try to maximize the temporal locality in your programs by
<strong>using a data object as often as possible once it has been read
from memory</strong>.</p></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 6.The Memory Hierarchy</category>
      </categories>
  </entry>
  <entry>
    <title>6.3~6.5.Cache Key Point</title>
    <url>/2024/08/11/6-3-6-5-Cache-Key-Point/</url>
    <content><![CDATA[<h1 id="63-sim65cache-key-point"><span class="math inline">\(6.3 \sim
6.5\)</span>.Cache Key Point</h1>
<h3 id="1cache-read-process">1.Cache Read Process</h3>
<p>   Suppose we have a direct-mapped cache described by <span class="math inline">\((S, E, B, m) = (4, 1, 2, 4)\)</span>, and we only
read word(1 byte).</p>
<ul>
<li><p>If block <span class="math inline">\(x \mod setNum\)</span>
equals block <span class="math inline">\(y \mod setNum\)</span>, then
block x and y belong to the same set.</p></li>
<li><p>Since a block can contain two words, <strong>when reading the
address <span class="math inline">\(x\)</span>(suppose x is odd), both
information in <span class="math inline">\(x\)</span> and <span class="math inline">\(x+1\)</span> will be read into the
block</strong>.</p></li>
</ul>
<p><img src="/2024/08/11/6-3-6-5-Cache-Key-Point/image.png"></p>
<p>  Let us simulate the cache in action as the CPU performs a sequence
of reads:</p>
<ol type="1">
<li>Initially, the cache is empty(i.e., each valid bit is 0):</li>
</ol>
<p><img src="/2024/08/11/6-3-6-5-Cache-Key-Point/image-1.png"></p>
<ol start="2" type="1">
<li>Read word at address 0: Since the valid bit for set 0 is 0, this is
a cache miss. The cache <strong>fetches block 0 from memory</strong> and
stores the block in set 0. Then the cache returns <code>m[0]</code> (the
contents of memory location 0) from <code>block[0]</code> of the newly
fetched cache line.</li>
</ol>
<p><img src="/2024/08/11/6-3-6-5-Cache-Key-Point/image-2.png"></p>
<ol start="3" type="1">
<li>Read word at address 1: This is a cache hit, The cache immediately
returns <code>m[1]</code> from <code>block[1]</code> of the cache line.
The state of the cache does not change.</li>
</ol>
<hr>
<p>  <span class="math inline">\(e.g.\)</span>Consider the following
transpose routine:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">transpose1</span><span class="params">(<span class="built_in">array</span> dst, <span class="built_in">array</span> src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            dst[j][i] = src[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Assume this code runs on a machine with the following
properties:</p>
<ul>
<li><p><code>sizeof(int) = 4</code>.</p></li>
<li><p>The <code>src</code> array starts at address 0 and the
<code>dst</code> array starts at address 16 (decimal).</p></li>
<li><p>There is a single L1 data cache that is direct-mapped,
write-through, and write-allocate, <strong>with a block size of 8
bytes</strong>.</p></li>
<li><p>The cache has <strong>a total size of 16 data bytes</strong> and
the cache is initially empty.</p></li>
<li><p>Accesses to the <code>src</code> and <code>dst</code> arrays are
the only sources of read and write misses, respectively.</p></li>
</ul>
<p>  For each row and column, indicate whether the access to
<code>src[row][col]</code> and <code>dst[row][col]</code> is a hit(h) or
a miss(m). For example, reading <code>src[0][0]</code> is a miss and
writing <code>dst[0][0]</code> is also a miss:</p>
<p>  <span class="math inline">\(dst \; array\)</span> | | Col. 0 | Col.
1 | |--------|--------|--------| | <strong>Row 0</strong> | m | | |
<strong>Row 1</strong> | | |</p>
<p>  <span class="math inline">\(src \; array\)</span> | | Col. 0 | Col.
1 | |--------|--------|--------| | <strong>Row 0</strong> | m | | |
<strong>Row 1</strong> | | |</p>
<p>  <span class="math inline">\(solution:\)</span> Because the cache is
too small to hold both arrays, <strong>references to one array keep
evicting useful lines from the other array</strong>:</p>
<p>  <span class="math inline">\(dst \; array\)</span> | | Col. 0 | Col.
1 | |--------|--------|--------| | <strong>Row 0</strong> | m | m | |
<strong>Row 1</strong> | m | m |</p>
<p>  <span class="math inline">\(src \; array\)</span> | | Col. 0 | Col.
1 | |--------|--------|--------| | <strong>Row 0</strong> | m | m | |
<strong>Row 1</strong> | m | h |</p>
<h3 id="2conflict-misses-indirect-mapped-caches">2.Conflict Misses in
Direct-Mapped Caches</h3>
<p>  <strong>Periodically misses</strong> in direct-mapped caches
typically occur when programs access <strong>arrays whose sizes are a
power of 2</strong>.</p>
<p>  Take the following code as an example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">dotprod</span><span class="params">(<span class="type">float</span> x[<span class="number">8</span>], <span class="type">float</span> y[<span class="number">8</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        sum += x[i] * y[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Suppose that: * floats are 4 bytes.</p>
<ul>
<li><p><code>x</code> is loaded into the 32 bytes of contiguous memory
starting at address 0, and that <code>y</code> starts immediately after
<code>x</code> at address 32.</p></li>
<li><p>A block is 16 bytes (big enough to hold four floats)</p></li>
<li><p>the cache consists of two sets, for a total cache size of 32
bytes.</p></li>
</ul>
<p>  Given these assumptions, each <code>x[i]</code> and
<code>y[i]</code> will map to the identical cache set:</p>
<table>
<thead>
<tr class="header">
<th>Element</th>
<th>Address</th>
<th>Set index</th>
<th>Element</th>
<th>Address</th>
<th>Set index</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x[0]</td>
<td>0</td>
<td>0</td>
<td>y[0]</td>
<td>32</td>
<td>0</td>
</tr>
<tr class="even">
<td>x[1]</td>
<td>4</td>
<td>0</td>
<td>y[1]</td>
<td>36</td>
<td>0</td>
</tr>
<tr class="odd">
<td>x[2]</td>
<td>8</td>
<td>0</td>
<td>y[2]</td>
<td>40</td>
<td>0</td>
</tr>
<tr class="even">
<td>x[3]</td>
<td>12</td>
<td>0</td>
<td>y[3]</td>
<td>44</td>
<td>0</td>
</tr>
<tr class="odd">
<td>x[4]</td>
<td>16</td>
<td>1</td>
<td>y[4]</td>
<td>48</td>
<td>1</td>
</tr>
<tr class="even">
<td>x[5]</td>
<td>20</td>
<td>1</td>
<td>y[5]</td>
<td>52</td>
<td>1</td>
</tr>
<tr class="odd">
<td>x[6]</td>
<td>24</td>
<td>1</td>
<td>y[6]</td>
<td>56</td>
<td>1</td>
</tr>
<tr class="even">
<td>x[7]</td>
<td>28</td>
<td>1</td>
<td>y[7]</td>
<td>60</td>
<td>1</td>
</tr>
</tbody>
</table>
<ul>
<li><p>The first iteration of the loop references <code>x[0]</code>, the
block containing <code>x[0]–x[3]</code> is loaded into set 0.</p></li>
<li><p>The next reference is to <code>y[0]</code>, another miss that
causes the block containing <code>y[0]–y[3]</code> to be copied into set
0, <strong>overwriting the values of x that were copied in by the
previous reference</strong>.</p></li>
</ul>
<p>  The term <em>thrashing</em> describes any situation where a cache
is <strong>repeatedly loading and evicting the same sets of cache
blocks</strong>.</p>
<p>  One easy solution to this problem is to <strong>put B bytes of
padding at the end of each array</strong>. For example, instead of
defining <code>x</code> to be float <code>x[8]</code>, we <strong>define
it to be float <code>x[12]</code></strong>:</p>
<table>
<thead>
<tr class="header">
<th>Element</th>
<th>Address</th>
<th>Set index</th>
<th>Element</th>
<th>Address</th>
<th>Set index</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x[0]</td>
<td>0</td>
<td>0</td>
<td>y[0]</td>
<td>48</td>
<td>1</td>
</tr>
<tr class="even">
<td>x[1]</td>
<td>4</td>
<td>0</td>
<td>y[1]</td>
<td>52</td>
<td>1</td>
</tr>
<tr class="odd">
<td>x[2]</td>
<td>8</td>
<td>0</td>
<td>y[2]</td>
<td>56</td>
<td>1</td>
</tr>
<tr class="even">
<td>x[3]</td>
<td>12</td>
<td>0</td>
<td>y[3]</td>
<td>60</td>
<td>1</td>
</tr>
<tr class="odd">
<td>x[4]</td>
<td>16</td>
<td>1</td>
<td>y[4]</td>
<td>64</td>
<td>0</td>
</tr>
<tr class="even">
<td>x[5]</td>
<td>20</td>
<td>1</td>
<td>y[5]</td>
<td>68</td>
<td>0</td>
</tr>
<tr class="odd">
<td>x[6]</td>
<td>24</td>
<td>1</td>
<td>y[6]</td>
<td>72</td>
<td>0</td>
</tr>
<tr class="even">
<td>x[7]</td>
<td>28</td>
<td>1</td>
<td>y[7]</td>
<td>76</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>  <code>x[i]</code> and <code>y[i]</code> now map to different
sets</p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 6.The Memory Hierarchy</category>
      </categories>
  </entry>
  <entry>
    <title>6.2.Locality</title>
    <url>/2024/08/09/6-2-Locality/</url>
    <content><![CDATA[<h1 id="62locality"><span class="math inline">\(6.2.\)</span>Locality</h1>
<h3 id="1basic-idea-amp-example">1.Basic Idea &amp; Example</h3>
<p><img src="/2024/08/09/6-2-Locality/image.png"></p>
<p><img src="/2024/08/09/6-2-Locality/image-1.png"></p>
<p><img src="/2024/08/09/6-2-Locality/image-2.png"></p>
<h3 id="2locality-of-instructionfetch">2.Locality of Instruction
Fetch</h3>
<p>  In Figure 6.17 the instructions in the body of the <code>for</code>
loop are executed in sequential memory order, and thus the loop enjoys
good spatial locality. Since the loop body is executed multiple times,
it also enjoys good temporal locality.</p>
<blockquote>
<p>An important property of code that distinguishes it from program data
is that it is rarely modified at run time. While a program is executing,
the CPU reads its instructions from memory. The CPU <strong>rarely
overwrites or modifies these instructions</strong>.</p>
</blockquote>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 6.The Memory Hierarchy</category>
      </categories>
  </entry>
  <entry>
    <title>6.1.Storage Technologies</title>
    <url>/2024/08/07/6-1-Storage-Technologies/</url>
    <content><![CDATA[<h1 id="61storage-technologies"><span class="math inline">\(6.1.\)</span>Storage Technologies</h1>
<h3 id="1random-access-memory">1.Random Access Memory</h3>
<h4 id="astaticram">  <span class="math inline">\(a.\)</span>Static
RAM</h4>
<p>  SRAM stores each bit in a bistable memory cell. Each cell is
implemented with a six-transistor circuit. This circuit has the property
that it can stay indefinitely in <strong>either of two different voltage
configurations</strong>, or <em>states</em>:</p>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image.png"></p>
<h4 id="bdynamicram">  <span class="math inline">\(b.\)</span>Dynamic
RAM</h4>
<p>  DRAM stores each bit as charge on a capacitor. A DRAM memory cell
is very sensitive to any disturbance. <strong>When the capacitor voltage
is disturbed, it will never recover</strong>.</p>
<h4 id="cconventional-drams">  <span class="math inline">\(c.\)</span>Conventional DRAMs</h4>
<p>  The cells(bits) in a DRAM chip <strong>are partitioned into <span class="math inline">\(d\)</span> supercells</strong>, each consisting of
<span class="math inline">\(w\)</span> DRAM cells. A <span class="math inline">\(d \times w\)</span> DRAM stores a total of <span class="math inline">\(dw\)</span> bits of information. The supercells
are organized as <strong>a rectangular array with <span class="math inline">\(r\)</span> rows and <span class="math inline">\(c\)</span> columns</strong>, where <strong><span class="math inline">\(rc = d\)</span></strong>. Each supercell has an
address of the form <span class="math inline">\((i, j)\)</span>, where
<span class="math inline">\(i\)</span> denotes the row and <span class="math inline">\(j\)</span> denotes the column:</p>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-1.png"></p>
<ul>
<li><p>Information flows in and out of the chip via external connectors
called <em>pins</em>. Each pin carries a 1-bit signal:</p>
<ul>
<li><p>Eight data pins that can <strong>transfer 1 byte in or out of the
chip</strong>.</p></li>
<li><p>Two addr pins that carry <strong>two-bit row and column supercell
addresses</strong>.</p></li>
</ul></li>
<li><p>Each DRAM chip is connected to <em>memory
controller</em>.</p></li>
</ul>
<p>  To read the contents of supercell <span class="math inline">\((i,
j)\)</span>, the memory controller sends the row address <span class="math inline">\(i\)</span> to the DRAM first, and then send the
column address <span class="math inline">\(j\)</span>. The DRAM responds
by sending the contents of supercell <span class="math inline">\((i,
j)\)</span> back to the controller:</p>
<blockquote>
<p>The row address <span class="math inline">\(i\)</span> is called a
<em>RAS</em>(row access strobe) request. The column address <span class="math inline">\(j\)</span> is called a <em>CAS</em>(column access
strobe) request.</p>
</blockquote>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-2.png"></p>
<blockquote>
<p>One reason circuit designers organize DRAMs as two-dimensional arrays
instead of linear arrays is to <strong>reduce the number of address pins
on the chip</strong>. However, the address must be sent in two distinct
steps, which <strong>increases the access time</strong>.</p>
</blockquote>
<h4 id="dmemory-modules">  <span class="math inline">\(d.\)</span>Memory modules</h4>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-3.png"></p>
<ul>
<li><p>Each supercell stores 1 byte of main memory.</p></li>
<li><p>Each 64-bit word at byte address A in main memory is represented
by the eight supercells.</p></li>
</ul>
<p>  To retrieve the word at memory address A, the memory controller
converts A to a supercell address <span class="math inline">\((i,
j)\)</span> and sends it to the memory module, which then broadcasts
<span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> to each DRAM.</p>
<p>  Main memory can be aggregated by connecting multiple memory modules
to the memory controller.</p>
<h4 id="eenhanced-drams">  <span class="math inline">\(e.\)</span>Enhanced DRAMs</h4>
<ul>
<li><p>A conventional DRAM <strong>copies an entire row of supercells
into its internal row buffer</strong>, uses one, and then
<strong>discards the rest</strong>.</p></li>
<li><p>FPM DRAM(Fast Page mode) improves on this by <strong>allowing
consecutive accesses to the same row</strong> to be served directly from
the row buffer.</p>
<ul>
<li>The initial RAS/CAS request copies row <span class="math inline">\(i\)</span> into the row buffer and returns the
supercell addressed by the CAS. The next three requests then search
<strong>directly from the row buffer</strong>.</li>
</ul></li>
</ul>
<h4 id="eaccessing-main-memory">  <span class="math inline">\(e.\)</span>Accessing main memory</h4>
<h5 id="ibasic-structure">  <span class="math inline">\(i.\)</span>Basic structure</h5>
<ul>
<li><p>Data flows back and forth between the processor and the DRAM main
memory over shared electrical conduits called <em>buses</em>.</p></li>
<li><p>Each transfer is accomplished with a series of steps called a
<em>bus transaction</em>.</p></li>
<li><p>The control wires of the bus carry signals that
<strong>synchronize the transaction</strong> and <strong>identify what
kind of transaction is currently being performed</strong>. For example,
the operand of the transaction, and the type of the
transaction.</p></li>
</ul>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-4.png"></p>
<h5 id="iiaccessing-procedure">  <span class="math inline">\(ii.\)</span>Accessing procedure</h5>
<p>  Take the following instruction as an example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq A, %rax</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-5.png"></p>
<ol type="1">
<li><p>The <em>bus interface</em> <strong>initiates a read
transaction</strong> on the bus.</p></li>
<li><p>The CPU <strong>places the address A on the system bus</strong>.
The I/O bridge passes the signal along to the memory bus.</p></li>
<li><p>The main memory <strong>senses the address signal on the memory
bus</strong> and fetch the data from DRAM. It <strong>writes the data to
the memory bus</strong>. The I/O bridge <strong>translates the memory
bus signal into a system bus signal</strong> and passes it along to the
system bus</p></li>
<li><p>The CPU <strong>senses the data on the system bus</strong>, reads
the data from the bus, and <strong>copies the data to register
<code>%rax</code></strong>.</p></li>
</ol>
<p>  The converse instruction <code>movq %rax,A</code> is similar:</p>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-6.png"></p>
<h3 id="2disk-storage">2.Disk Storage</h3>
<h4 id="adiskgeometry">  <span class="math inline">\(a.\)</span>Disk
geometry</h4>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-7.png"></p>
<ul>
<li><p>Each surface consists of a collection of concentric rings called
<em>tracks</em>.</p></li>
<li><p>Each track is partitioned into a collection of
<em>sectors</em>.</p></li>
<li><p>Sectors are separated by <em>gaps</em>, gaps store formatting
bits that identify sectors.</p></li>
</ul>
<p>  Disk manufacturers describe the geometry of multiple-platter drives
in terms of <em>cylinders</em>, where a cylinder is <strong>the
collection of tracks</strong> on all the surfaces that <strong>are
equidistant from the center of the spindle</strong>. For example, if a
drive has three platters and six surfaces, and the tracks on each
surface are numbered consistently, then cylinder <span class="math inline">\(k\)</span> is <strong>the collection of the six
instances of track <span class="math inline">\(k\)</span></strong>.</p>
<h4 id="bdiskcapacity">  <span class="math inline">\(b.\)</span>Disk
capacity</h4>
<p>  Disk capacity is determined by the following technology
factors:</p>
<ul>
<li><p><em>Recording density</em>: The number of bits on a
track.</p></li>
<li><p><em>Track density</em>: The number of tracks on the radius
extending from the center of the platter.</p></li>
<li><p><em>Areal density</em>: The product of the recording density and
the track density.</p></li>
</ul>
<p>  Modern high-capacity disks use a technique known as <em>multiple
zone recording</em>, where the set of cylinders <strong>is partitioned
into disjoint subsets</strong> known as <em>recording zones</em>. Each
zone consists of a contiguous collection of cylinders. <strong>Each
track in each cylinder in a zone has the same number of
sectors</strong>.</p>
<p>  The capacity of a disk is given by the following formula:</p>
<p><span class="math display">\[
{Capacity} = \frac{\# {bytes} } {sector} \times \frac{ {average} \#
{sectors} } {track} \times \frac{\# {tracks} } {surface} \times
\frac{\#  {surfaces} } {platter} \times \frac{\# {platters} } {disk}
\]</span></p>
<p>  The number of cylinders is identical to <span class="math inline">\({track} \over {surface}\)</span>.</p>
<p>  <span class="math inline">\(e.g.\)</span>What is the capacity of a
disk with 3 platters, 15,000 cylinders, an average of 500 sectors per
track, and 1,024 bytes per sector?</p>
<p>  <span class="math inline">\(solution\)</span>:</p>
<p><span class="math display">\[
Disk\; Capacity = \frac{1,024 \, bytes}{sector} \times \frac{500 \,
sectors}{track} \times \frac{15,000 \, tracks}{surface} \times \frac{2
\, surfaces}{platter} \times \frac{3 \, platters}{disk}
\]</span></p>
<h4 id="cdiskoperations">  <span class="math inline">\(c.\)</span>Disk
operations</h4>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-8.png"></p>
<ul>
<li><p>Disks read and write bits stored on the magnetic surface using a
<em>read/write head</em> connected to the end of an <em>actuator
arm</em>.</p>
<ul>
<li>The head can either sense the value of the bit(read the bit) or
alter the value of the bit(write the bit).</li>
</ul></li>
</ul>
<p>  The disk <em>access time</em> for a sector has three main
<em>components: </em>seek time<em>, </em>rotational latency<em>, and
</em>transfer time*:</p>
<ul>
<li><p>Seek time: It depends on the previous position of the head and
the speed that the arm moves across the surface.</p></li>
<li><p>Rotational latency:</p></li>
</ul>
<p><span class="math display">\[
T_{max \; rotation}={1 \over RPM} \times { {60 \; secs} \over {1 \; min}
}
\]</span></p>
<ul>
<li>Transfer time:</li>
</ul>
<p><span class="math display">\[
T_{avg \; transfer} = {1 \over RPM} \times {1 \over {average \; \# \;
sector/track} \times { {60 \; secs} \over {1 \; min} }}
\]</span></p>
<blockquote>
<p>The <span class="math inline">\(1 \over {average \; \# \;
sector/track}\)</span> is to compute the time cost per sector.</p>
</blockquote>
<h4 id="dlogical-disk-blocks">  <span class="math inline">\(d.\)</span>Logical disk blocks</h4>
<p>  Modern disks present a simple view of their geometry as <strong>a
sequence of B sector-size logical blocks</strong>, numbered 0, 1, ...,
B−1.</p>
<ul>
<li>The disk controller maintains <strong>the mapping between</strong>
logical block numbers and actual(physical) disk sectors.</li>
</ul>
<p>  When the operating system wants to perform an I/O operation such as
reading a disk sector into main memory:</p>
<ul>
<li><p>The OS <strong>sends a command to the disk controller</strong>
asking it to read a particular logical block number.</p></li>
<li><p><em>Firmware</em> on the controller <strong>performs a fast table
lookup</strong> that <strong>translates the logical block number into a
(surface, track, sector) triple</strong> that uniquely identifies the
corresponding physical sector.</p></li>
<li><p><em>Hardware</em> on the controller <strong>interprets this
triple</strong> to move the heads to the appropriate cylinder.</p></li>
</ul>
<h4 id="eaccessing-disks">  <span class="math inline">\(e.\)</span>Accessing disks</h4>
<ul>
<li><p>Disks are connected to the CPU and main memory using <em>an I/O
bus</em>. They are designed to be independent of the underlying
CPU.</p></li>
<li><p>The CPU issues commands to I/O devices using a technique called
<em>memory-mapped I/O</em>.</p>
<ul>
<li>In this system, <strong>a block of addresses</strong> in the address
space is reserved for communicating with I/O devices, each of these
address is known as an <em>I/O port</em>.</li>
</ul></li>
</ul>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-9.png"></p>
<p>  The CPU initiates a disk read by executing three store
instructions:</p>
<ol type="1">
<li><p>The first of these instructions sends a command word that
<strong>tells the disk to initiate a read</strong>, along with
<strong>other parameters</strong> such as whether to interrupt the CPU
when the read is finished.</p></li>
<li><p>The second instruction <strong>indicates the logical block
number</strong> that should be read.</p></li>
<li><p>The third instruction <strong>indicates the main memory
address</strong> where the contents of the disk sector should be
stored.</p></li>
</ol>
<p>  After it issues the request, the CPU will <strong>typically do
other work</strong> while the disk is performing the read.</p>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-10.png"></p>
<p>  When the disk controller receives the read command from the CPU,
it:</p>
<ol type="1">
<li><strong>Translates the logical block number to a sector
address</strong>, reads the contents of the sector, and transfers the
contents directly to main memory.</li>
</ol>
<p>  The process is <strong>without any involvement of the CPU</strong>,
and is known as <em>direct memory access</em>(DMA). The transfer of data
is known as a <em>DMA transfer</em>.</p>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-11.png"></p>
<p>  After the DMA transfer is complete and the contents of the disk
sector are safely stored in main memory, the disk controller notifies
the CPU by <strong>sending an interrupt signal to the CPU</strong>.</p>
<ul>
<li>The basic idea is that an interrupt signals an external pin on the
CPU chip. This <strong>causes the CPU to stop</strong> what it is
currently working on and jump to an operating system routine.</li>
</ul>
<h3 id="3solid-state-disks">3.Solid State Disks</h3>
<p><img src="/2024/08/07/6-1-Storage-Technologies/image-12.png"></p>
<ul>
<li><p>An SSD package plugs into a standard disk slot on the I/O bus and
behave like any other disk.</p></li>
<li><p>SSD package consists of one or more <em>flash memory chips</em>,
which <strong>replace the mechanical drive in a conventional rotating
disk</strong>。</p></li>
<li><p>It contains a <em>flash translation layer</em>, which is a
hardware/firmware device that <strong>plays the same role as a disk
controller</strong>.</p></li>
</ul>
<hr>
<ul>
<li><p>Data are read and written <strong>in units of pages</strong>. A
page can be written <strong>only after the entire block to which it
belongs has been erased</strong>.</p></li>
<li><p>Once a block is erased, <strong>each page in the block can be
written once with no further erasing</strong>.</p></li>
<li><p>When erasing a block, any pages in the same block with useful
data must <strong>be copied to a new(erased) block before the write to
page p can occur</strong>.</p></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 6.The Memory Hierarchy</category>
      </categories>
  </entry>
  <entry>
    <title>5.14.Program Profiling</title>
    <url>/2024/08/05/5-14-Program-Profiling/</url>
    <content><![CDATA[<h1 id="514program-profiling"><span class="math inline">\(5.14.\)</span>Program Profiling</h1>
<p>  Unix systems provide the profiling program gprof.</p>
<ol type="1">
<li>The program must be compiled and linked for profiling. We use
optimization flag <code>-0g</code> to guaranteeing that function calls
will be tracked properly:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linux&gt; gcc -Og -pg prog.c -o prog</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>The program is then executed as usual:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt; ./prog file.txt</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>gprof is invoked to analyze the data in <code>gmon.out</code>:</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt; gprof prog</span><br></pre></td></tr></table></figure>
<p>  The first part of the profile report lists the times spent
executing the different functions, sorted in descending order:</p>
<p><img src="/2024/08/05/5-14-Program-Profiling/image.png"></p>
<ul>
<li><p>The first column indicates the percentage of the overall time
spent on the function.</p></li>
<li><p>The second shows the cumulative time spent by the functions up to
and including the one on this row.</p></li>
<li><p>The third shows the time spent on this particular function, and
the fourth shows how many times it was called (not counting recursive
calls).</p></li>
</ul>
<p>  The second part of the profile report shows the calling history of
the functions. The following is the history for a recursive function
<code>find_ele_rec</code>:</p>
<p><img src="/2024/08/05/5-14-Program-Profiling/image-1.png"></p>
<p>  We can use the gprof to focus our optimization efforts <strong>on
the parts that consume the most time</strong>.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 5.Optimizing Program Performance</category>
      </categories>
  </entry>
  <entry>
    <title>5.13.Performance Improvement Techniques</title>
    <url>/2024/08/05/5-13-Performance-Improvement-Techniques/</url>
    <content><![CDATA[<h1 id="513performance-improvementtechniques"><span class="math inline">\(5.13.\)</span>Performance Improvement
Techniques</h1>
<ul>
<li><p><em>Basic coding principles</em>:</p>
<ul>
<li><p>Eliminate excessive function calls. Move computations out of
loops when possible.</p></li>
<li><p>Eliminate unnecessary memory references. Introduce temporary
variables to hold intermediate results.</p></li>
</ul></li>
<li><p><em>Low-level optimizations</em>:</p>
<ul>
<li><p>Unroll loops.</p></li>
<li><p>Find ways to increase instruction-level parallelism by techniques
such as multiple accumulators and reassociation.</p></li>
<li><p>Rewrite conditional operations in a functional style to enable
compilation via conditional data transfers.</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 5.Optimizing Program Performance</category>
      </categories>
  </entry>
  <entry>
    <title>5.12.Understanding Memory Performance</title>
    <url>/2024/08/05/5-12-Understanding-Memory-Performance/</url>
    <content><![CDATA[<h1 id="512understanding-memoryperformance"><span class="math inline">\(5.12.\)</span>Understanding Memory
Performance</h1>
<h3 id="1store-performance">1.Store Performance</h3>
<p>  A series of store operations cannot create a data dependency. Only
a load operation is affected by the result of a store operation, since
<strong>only a load can read back the memory value that has been written
by the store</strong>.</p>
<p>  The store unit includes a <em>store buffer</em> containing
<strong>the addresses and data of the store operations</strong> that
have been issued to the store unit, but <strong>have not yet been
completed</strong>, where completion involves updating the data
cache.</p>
<p>  This buffer is provided so that a series of store operations can be
executed <strong>without having to wait for each one to update the
cache</strong>.</p>
<p><img src="/2024/08/05/5-12-Understanding-Memory-Performance/image-2.png"></p>
<h3 id="2load-and-store-operations">2.Load and Store Operations</h3>
<h4 id="adifferent-types-of-load-ampstore">  <span class="math inline">\(a.\)</span>Different types of load &amp;
store</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Write to dest, read from src */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_read</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dst, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> cnt = n;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt) &#123;</span><br><span class="line">        *dst = val;</span><br><span class="line">        val = (*src) + <span class="number">1</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/05/5-12-Understanding-Memory-Performance/image-1.png"></p>
<ul>
<li><p>In Example A, the result of the read from <code>src</code>
<strong>is not affected by the write to <code>dest</code></strong>, and
the iterations gives a CPE of 1.3.</p></li>
<li><p>In Example B, each load by the pointer reference
<code>*src</code> will yield the value stored by the previous execution
of the pointer reference <code>*dest</code>.</p></li>
</ul>
<p>  This example illustrates a phenomenon we will call a <em>write/read
dependency</em>—<strong>the outcome of a memory read depends on a recent
memory write</strong>.</p>
<p>  The CPE of Example B is 7.3, The write/read dependency causes a
slowdown in the process.</p>
<p>  The reason of the slowdown can be illustrated in the following
data-flow representation:</p>
<p><img src="/2024/08/05/5-12-Understanding-Memory-Performance/image-3.png"></p>
<p>  For the case of Example A, <strong>with differing source and
destination addresses</strong>, the load and store operations
<strong>can proceed independently</strong>, and hence the only critical
path is formed by the decrementing of variable cnt, resulting in a CPE
bound of 1.0.</p>
<h4 id="bload-performance">  <span class="math inline">\(b.\)</span>Load performance</h4>
<p>   When a load operation occurs, it must <strong>check the entries in
the store buffer</strong> for matching addresses. If it finds a match,
it <strong>retrieves the corresponding data entry</strong> as the result
of the load operation.</p>
<p>  Take the following assembly code as an example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Inner loop of write_read</span><br><span class="line"># src in %rdi, dst in %rsi, val in %rax</span><br><span class="line">.L3:                    # loop:</span><br><span class="line">    movq %rax, (%rsi)     # Write val to dst</span><br><span class="line">    movq (%rdi), %rax     # t = *src</span><br><span class="line">    addq $1, %rax         # val = t + 1</span><br><span class="line">    subq $1, %rdx         # cnt--</span><br><span class="line">    jne .L3               # If != 0, goto loop</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/05/5-12-Understanding-Memory-Performance/image.png"></p>
<ul>
<li><p>The <code>s_addr</code> instruction computes the address for the
store operation, <strong>creates an entry in the store buffer</strong>,
and <strong>sets the address field for that entry</strong>.</p></li>
<li><p>The <code>s_data</code> operation <strong>sets the data field for
the entry</strong>.</p></li>
</ul>
<p>  The arcs on the right of the operators denote a set of implicit
dependencies for these operations:</p>
<ul>
<li><p>For instruction <code>movq (%rdi), %rax</code>, the load
operation must <strong>check the addresses of any pending store
operations</strong>, creating a data dependency between it and the
<code>s_addr</code> operation.</p>
<ul>
<li>If the two addresses match, the load operation must <strong>wait
until the s_data has deposited its result into the store
buffer</strong>, but if the two addresses differ, the two operations
<strong>can proceed independently</strong>.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 5.Optimizing Program Performance</category>
      </categories>
  </entry>
  <entry>
    <title>5.10.Some Limiting Factors</title>
    <url>/2024/08/04/5-10-Some-Limiting-Factors/</url>
    <content><![CDATA[<h1 id="510some-limiting-factors"><span class="math inline">\(5.10.\)</span>Some Limiting Factors</h1>
<h3 id="1register-spilling">1.Register Spilling</h3>
<p>  If a program has a degree of parallelism <span class="math inline">\(P\)</span> that <strong>exceeds the number of
available registers</strong>, then the compiler will resort to
<em>spilling</em>, <strong>storing some of the temporary values in
memory</strong>, typically by <strong>allocating space on the run-time
stack</strong>:</p>
<p><img src="/2024/08/04/5-10-Some-Limiting-Factors/image.png"></p>
<p>  Once the number of loop variables exceeds the number of available
registers, the program must <strong>allocate some on the
stack</strong>.</p>
<p>  Take the following <span class="math inline">\(10 \times
10\)</span> unrolling loop for example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Updating of accumulator acc0 in 10 x 10 urolling</span><br><span class="line">vmulsd (%rdx), %xmm0, %xmm0    # acc0 *= data[i]</span><br></pre></td></tr></table></figure>
<p>  The comparable part of the code for <span class="math inline">\(20
\times 20\)</span> unrolling has a much different form:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Updating of accumulator acc0 in 20 x 20 unrolling</span><br><span class="line">vmovsd 40(%rsp), %xmm0</span><br><span class="line">vmulsd (%rdx), %xmm0, %xmm0</span><br><span class="line">vmovsd %xmm0, 40(%rsp)</span><br></pre></td></tr></table></figure>
<p>  The accumulator is kept as a local variable on the stack, at offset
40 from the stack pointer. The program must <strong>read both its value
and the value of <code>data[i]</code> from memory</strong>, multiply
them, and store the result back to memory.</p>
<h3 id="2branch-prediction">2.Branch Prediction</h3>
<p>  gcc don't use conditional transfers of control to generate code for
branch prediction, but rather <strong>compute the values</strong> along
both branches of a conditional expression or statement and then
<strong>use conditional moves to select the desired value</strong>.</p>
<hr>
<p>  To illustrate this, we use the program with branch prediction and
that without predition as examples:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Include bounds check in loop */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine4b</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; v-&gt;len) &#123;</span><br><span class="line">            acc = acc OP v-&gt;data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/04/5-10-Some-Limiting-Factors/image-1.png"></p>
<p>  The additional computation required to perform bounds checking can
take place <strong>in parallel with the combining operations</strong>.
The processor is able to predict the outcomes of these branches, and so
<strong>none of this evaluation has much effect on the fetching and
processing of the instructions</strong> that form the critical path in
the program execution.</p>
<h3 id="3writecode-suitable-for-implementation-with-conditional-moves">3.Write
Code Suitable for Implementation with Conditional Moves</h3>
<ul>
<li>gcc is able to generate conditional moves for code written in a more
"functional" style, where we use conditional operations to
<strong>compute values</strong> and then update the program state with
these values, as opposed to a more "imperative" style, where we use
conditionals to <strong>selectively update program state</strong>.</li>
</ul>
<p>  Take the program that set <code>a[i]</code> to be the maximum of
<code>a[i], b[i]</code> and <code>b[i]</code> the minimum.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* imperative style */</span></span><br><span class="line"><span class="comment">/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">minmax1</span><span class="params">(<span class="type">long</span> a[], <span class="type">long</span> b[], <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; b[i]) &#123;</span><br><span class="line">            <span class="type">long</span> t = a[i];</span><br><span class="line">            a[i] = b[i];</span><br><span class="line">            b[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* functional style */</span></span><br><span class="line"><span class="comment">/* Rearrange two vectors so that for each i, b[i] &gt;= a[i] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">minmax2</span><span class="params">(<span class="type">long</span> a[], <span class="type">long</span> b[], <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">long</span> min = a[i] &lt; b[i] ? a[i] : b[i];</span><br><span class="line">        <span class="type">long</span> max = a[i] &lt; b[i] ? b[i] : a[i];</span><br><span class="line">        a[i] = min;</span><br><span class="line">        b[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  The method is like <em>data transfer</em>, we use less conditional
expression to reduce misprediction rate.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 5.Optimizing Program Performance</category>
      </categories>
  </entry>
  <entry>
    <title>5.9.Enhancing Parallelism</title>
    <url>/2024/08/03/5-9-Enhancing-Parallelism/</url>
    <content><![CDATA[<h1 id="59enhancing-parallelism">5.9.Enhancing Parallelism</h1>
<h3 id="1multiple-accumulator">1.Multiple Accumulator</h3>
<h4 id="abasicidea">  <span class="math inline">\(a.\)</span>Basic
idea</h4>
<p>  Assume that <span class="math inline">\(P_n\)</span> represents the
product of elements <span class="math inline">\(a_0,a_1, \cdots
,a_{n-1}\)</span>:</p>
<p><span class="math display">\[
P_n = \prod ^{n-1} _{i=0} a_i
\]</span></p>
<p>  We can rewrite this as <span class="math inline">\(P_n=PE_n \times
PO_n\)</span>:</p>
<p><span class="math display">\[
PE_n = \prod ^{ {n \over 2} -1} _{i=0} a_{2i}
\]</span></p>
<p><span class="math display">\[
PO_n = \prod ^{ {n \over 2} -1} _{i=0} a_{2i+1}
\]</span></p>
<p>  By using this method, we use both two-way loop unrolling and
two-way parallelism. We refer to this as <em><span class="math inline">\(2\times 2\)</span> loop unrolling</em>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 2 x 2 loop unrolling */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine6</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> acc1 = IDENT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Combine 2 elements at a time */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += <span class="number">2</span>) &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">        acc1 = acc1 OP data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finish any remaining elements */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc0 OP acc1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  The performance of this program is as below:</p>
<p><img src="/2024/08/03/5-9-Enhancing-Parallelism/image.png"></p>
<p>  We can see that we improve the performance by a factor of around 2.
Most significantly, we have <strong>broken through the barrier imposed
by the latency bound</strong>. The processor no longer needs to delay
the start of one sum or product operation until the previous one has
completed.</p>
<p>  The data-flow representation of <code>combine6</code> is as
below:</p>
<p><img src="/2024/08/03/5-9-Enhancing-Parallelism/image-1.png"></p>
<p>  There are two critical paths, and each of these contains only <span class="math inline">\(n \over 2\)</span> operations, thus leading to a
CPE of around 5.00/2 = 2.50.</p>
<h4 id="bgeneral-analysis">  <span class="math inline">\(b.\)</span>General analysis</h4>
<p><img src="/2024/08/03/5-9-Enhancing-Parallelism/image-2.png"></p>
<p>  In general, a program can <strong>achieve the throughput
bound</strong> for an operation only when it can <strong>keep the
pipelines filled for all of the functional units capable of performing
that operation</strong>. For an operation with latency <span class="math inline">\(L\)</span> and capacity <span class="math inline">\(C\)</span>, this requires an unrolling factor
<span class="math inline">\(k \geq C \cdot L\)</span>.</p>
<ul>
<li>For example, floating-point multiplication has <span class="math inline">\(C=2\)</span> and <span class="math inline">\(L=5\)</span>, necessitating <strong>an unrolling
factor of <span class="math inline">\(k \geq 10\)</span></strong>.</li>
</ul>
<p>  In performing the <span class="math inline">\(k \times k\)</span>
unrolling transformation, we must consider <strong>whether it preserves
the functionality of the original function</strong>.</p>
<ul>
<li><p>Two's-complement arithmetic is commutative and associative, so
the unrolling transformation will get identical result.</p></li>
<li><p>Floating-point multiplication and addition are not associative,
so we may get different result.</p></li>
</ul>
<h3 id="2reassociationtransformation">2.Reassociation
Transformation</h3>
<h4 id="abasicidea">  <span class="math inline">\(a.\)</span>Basic
idea</h4>
<p>  By simply change the code of <span class="math inline">\(k \times
1\)</span> loop unrolling, we can reach better performance. For example,
the code:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acc = (acc OP data[i]) OP data[i+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>  can be changed into:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acc = acc OP (data[i] OP data[i+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>  The performance of the code is nearly the same as <span class="math inline">\(2 \times 2\)</span> loop unrolling:</p>
<p><img src="/2024/08/03/5-9-Enhancing-Parallelism/image-3.png"></p>
<p><img src="/2024/08/03/5-9-Enhancing-Parallelism/image-4.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 5.Optimizing Program Performance</category>
      </categories>
  </entry>
  <entry>
    <title>5.8.Loop Unrolling</title>
    <url>/2024/08/03/5-8-Loop-Unrolling/</url>
    <content><![CDATA[<h1 id="58loopunrolling"><span class="math inline">\(5.8.\)</span>Loop
Unrolling</h1>
<p>  Loop unrolling can improve performance in two ways.</p>
<ol type="1">
<li><p>It reduces the number of operations that do not contribute
directly to the program result, such as loop indexing and conditional
branching.</p></li>
<li><p>It exposes ways in which we can further transform the code to
reduce the number of operations in the critical paths of the overall
computation.</p></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 2 x 1 loop unrolling */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine5</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Combine 2 elements at a time */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += <span class="number">2</span>) &#123;</span><br><span class="line">        acc = (acc OP data[i]) OP data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finish any remaining elements */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  The performance of different unrolling is as below:</p>
<p><img src="/2024/08/03/5-8-Loop-Unrolling/image.png"></p>
<p>  We see that the CPE improves little when <span class="math inline">\(k \geq 2\)</span>. To understand this, consider
the case when <span class="math inline">\(k=2\)</span>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Inner loop of combine5. data_t = double, OP = *</span><br><span class="line"># i in %rdx, data %rax, limit in %rbx, acc in %xmm0</span><br><span class="line">.L35: loop:</span><br><span class="line">    vmulsd   (%rax,%rdx,8), %xmm0, %xmm0    # Multiply acc by data[i]</span><br><span class="line">    vmulsd  8(%rax,%rdx,8), %xmm0, %xmm0    # Multiply acc by data[i+1]</span><br><span class="line">    addq     $2, %rdx                       # Increment i by 2</span><br><span class="line">    cmpq     %rdx, %rbp                     # Compare to limit: i</span><br><span class="line">    jg      .L35                            # If &gt;, goto loop</span><br></pre></td></tr></table></figure>
<p>  The <code>vmulsd</code> instructions each get translated into two
operations: one to load an array element from memory and one to multiply
this value by the accumulated value. The data-flow representation of the
program is as below:</p>
<p><img src="/2024/08/03/5-8-Loop-Unrolling/image-1.png"></p>
<p>  There's still a critical path of <span class="math inline">\(n\)</span></p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 5.Optimizing Program Performance</category>
      </categories>
  </entry>
  <entry>
    <title>5.7.Understanding Modern Processors</title>
    <url>/2024/08/02/5-7-Understanding-Modern-Processors/</url>
    <content><![CDATA[<h1 id="57understanding-modern-processors"><span class="math inline">\(5.7.\)</span>Understanding Modern Processors</h1>
<h3 id="1overall-operation">1.Overall Operation</h3>
<p><img src="/2024/08/02/5-7-Understanding-Modern-Processors/image.png"></p>
<ul>
<li><p>The overall design of the <em>superscalar</em> processor(meaning
that they can perform multiple operations on every clock cycle and out
of order) has two main parts:</p>
<ul>
<li><p>The <em>instruction control unit</em>(ICU), which is responsible
for <strong>reading a sequence of instructions from memory</strong> and
<strong>generating from these a set of primitive operations to perform
on program data</strong>.</p></li>
<li><p>The <em>execution unit</em>(EU), which then <strong>executes
these operations</strong>.</p></li>
</ul></li>
</ul>
<h4 id="aicu">  <span class="math inline">\(a.\)</span>ICU</h4>
<ul>
<li><p>THe ICU reads the instructions from an <em>instruction
cache</em>.</p></li>
<li><p>When a program hits a branch, processors perform <em>branch
prediction</em>. If it later determines that the branch was predicted
incorrectly, it <strong>resets the state to that at the branch
point</strong> and begins <strong>fetching and executing instructions in
the other direction</strong>.</p>
<ul>
<li>The block labeled "Fetch control" incorporates branch prediction to
perform the task of <strong>determining which instructions to
fetch</strong>.</li>
</ul></li>
<li><p>The instruction decoding logic takes the actual program
instructions and <strong>converts them into a set of primitive
operations</strong>(<em>micro-operations</em>).</p>
<ul>
<li>The decoding allows a division of labor among a set of dedicated
hardware units, which then allows parallelism.</li>
</ul></li>
</ul>
<p>  For example, the instruction <code>addq %rax,%rdx</code> will be
decoded as three operations: one to load a value from memory into the
processor, one to add the loaded value to the value in register
<code>%eax</code>, and one to store the result back to memory.</p>
<ul>
<li><p>The retirement unit keeps track of the ongoing processing and
makes sure that it obeys the sequential semantics of the machine-level
program.</p>
<ul>
<li><p>As an instruction is decoded, information about it is placed into
a <strong>first-in, first-out queue</strong>. The information of an
instruction remains in the queue until one of two outcomes occurs:</p>
<ul>
<li><p>Once the operations for the instruction have completed and any
branch points leading to this instruction are confirmed as having been
correctly predicted, <strong>the instruction can be retired, with any
updates to the program registers being made</strong>.</p></li>
<li><p>If some branch point leading to this instruction was
mispredicted, the instruction will be <em>flushed</em>, discarding any
results that may have been computed.</p></li>
</ul></li>
</ul></li>
</ul>
<h4 id="beu">  <span class="math inline">\(b.\)</span>EU</h4>
<ul>
<li><p>The EU receives operations from the <em>instruction fetch
unit</em>. These operations are dispatched to <strong>a set of
functional units that perform the actual operations</strong>.</p></li>
<li><p>Reading and writing memory is implemented by the <em>load and
store units</em>. Both the load unit and store unit have an
<em>adder</em> to perform address computations. They access memory via a
<em>data cache</em>.</p></li>
<li><p>With speculative execution, the operations are evaluated, but
<strong>the final results are not stored in the program registers or
data memory</strong> until <strong>the processor can be certain that
these instructions should actually have been executed</strong>.</p>
<ul>
<li><p>Branch operations are sent to the EU to <strong>determine whether
or not they were predicted correctly</strong>.</p></li>
<li><p>If the prediction was incorrect, the EU will d<strong>iscard the
results that have been computed beyond the branch point</strong>. It
will also <strong>signal the branch unit that the prediction was
incorrect and indicate the correct branch destination</strong>.</p></li>
</ul></li>
</ul>
<p>  The result of operations is exchanged among the EU. The control of
the communication of operands is called <em>register renaming</em>.</p>
<ul>
<li><p>When an instruction <strong>that updates register r</strong> is
decoded, a tag t is generated giving a unique identifier to the result
of the operation. An entry <span class="math inline">\((r,t)\)</span> is
added to a table maintaining the association <strong>between program
register r and tag t</strong> for an operation that will update this
register.</p></li>
<li><p>When a subsequent instruction using register r as an operand is
decoded, the operation sent to the execution unit will <strong>contain t
as the source for the operand value</strong>.</p></li>
<li><p>When some execution unit completes the first operation, it
generates a result <span class="math inline">\((v,t)\)</span>,
indicating that the operation with tag t produced value v. Any operation
waiting for t as a source will then <strong>use v as the source
value</strong></p></li>
</ul>
<p>  This form of <strong>data forwarding</strong> enables values to be
forwarded without being written to and read from the register file, so
that <strong>the second operation to begin as soon as the first has
completed</strong>.</p>
<h3 id="2functional-unit-performance">2.Functional Unit Performance</h3>
<p><img src="/2024/08/02/5-7-Understanding-Modern-Processors/image-1.png"></p>
<ul>
<li><p>The addition and multiplication operations all have issue times
of 1, meaning that <strong>on each clock cycle, the processor can start
a new one of these operations</strong>. They are called <em>fully
pipelined</em>.</p></li>
<li><p>The divider isn't pipelined-its issue time equals its latency. It
means that the divider <strong>must perform a complete division before
it can begin a new one</strong>.</p></li>
</ul>
<hr>
<p><img src="/2024/08/02/5-7-Understanding-Modern-Processors/image-2.png"></p>
<ul>
<li><p>The <em>latency bound</em> gives <strong>a minimum value for the
CPE for any function</strong> that must perform the combining operation
in a strict sequence.</p></li>
<li><p>The <em>throughput bound</em> gives <strong>a minimum bound for
the CPE</strong> based on the maximum rate at which the functional units
can produce results.</p></li>
</ul>
<h3 id="3an-abstract-model-ofprocessor-operation">3.An Abstract Model of
Processor Operation</h3>
<p>  We will take <code>combine4</code> as an example. First, let's see
the CPE measurements of the program:</p>
<p><img src="/2024/08/02/5-7-Understanding-Modern-Processors/image-3.png"></p>
<ul>
<li>The performance of these functions is dictated by <strong>the
latency of the sum or product computation being performed</strong>.
Computing the product or sum of <span class="math inline">\(n\)</span>
elements <strong>requires around <span class="math inline">\(L \cdot
n+K\)</span> clock cycles</strong>, where <span class="math inline">\(L\)</span> is the latency of the combining
operation and <span class="math inline">\(K\)</span> represents the
overhead of calling the function and initiating and terminating the
loop. The CPE is therefore <span class="math inline">\(L+{K \over
n}\)</span>, which is close to <span class="math inline">\(L\)</span>
when <span class="math inline">\(n\)</span> is large.</li>
</ul>
<h4 id="adata-flow-graphs">  <span class="math inline">\(a.\)</span>Data-flow graphs</h4>
<p>  First take a look at the assembly codes of
<code>combine4</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Inner loop of combine4. data_t = double, OP = *</span><br><span class="line"># acc in %xmm0, data+i in %rdx, data+length in %rax</span><br><span class="line"></span><br><span class="line">.L25: loop:</span><br><span class="line">    vmulsd (%rdx), %xmm0, %xmm0   # Multiply acc by data[i]</span><br><span class="line">    addq $8, %rdx                 # Increment data+i</span><br><span class="line">    cmpq %rax, %rdx               # Compare to data+length</span><br><span class="line">    jne .L25                      # If !=, goto loop</span><br></pre></td></tr></table></figure>
<p>  The graphical representation of inner-loop code for
<code>combine4</code> is as below:</p>
<p><img src="/2024/08/02/5-7-Understanding-Modern-Processors/image-4.png"></p>
<p>  And the data-flow representation of <span class="math inline">\(n\)</span> iterations in the inner loop is as
below:</p>
<p><img src="/2024/08/02/5-7-Understanding-Modern-Processors/image-5.png"></p>
<p>  We can see that the program has two chains of data dependencies,
corresponding to the updating of program values <code>acc</code> and
<code>data+i</code> with operations <code>mul</code> and
<code>add</code>, respectively. And since <strong>the left chain is the
longest</strong>, it will form a <em>critical path</em>, requiring <span class="math inline">\(5n\)</span> cycles to execute.</p>
<p>  The figure shows that when executing the function, <strong>the
floating-point multiplier becomes the limiting resource</strong>. The
other operations required during the loop—manipulating and testing
pointer value <code>data+i</code> and reading data from memory—proceed
<strong>in parallel with the multiplication</strong>.</p>
<h4 id="botherfactors">  <span class="math inline">\(b.\)</span>Other
factors</h4>
<p>  The critical paths in a data-flow representation provide
<strong>only a lower bound on how many cycles a program will
require</strong>. Other factors can also limit performance, including
the total number of functional units available and the number of data
values that can be passed among the functional units on any given
step.</p>
<hr>
<p>  <span class="math inline">\(e.g.\)</span>(CPE analysis)Illustrate
why the CPE of the former program is 5.00 while the latter is 8.00:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">poly</span><span class="params">(<span class="type">double</span> a[], <span class="type">double</span> x, <span class="type">long</span> degree)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">double</span> result = a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">double</span> xpwr = x; <span class="comment">/* Equals x^i at start of loop */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= degree; i++) &#123;</span><br><span class="line">        result += a[i] * xpwr;</span><br><span class="line">        xpwr = x * xpwr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Apply Horner&#x27;s method */</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">polyh</span><span class="params">(<span class="type">double</span> a[], <span class="type">double</span> x, <span class="type">long</span> degree)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">double</span> result = a[degree];</span><br><span class="line">    <span class="keyword">for</span> (i = degree - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        result = a[i] + x * result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <span class="math inline">\(solution:\)</span>The CPE of the
<code>poly</code> is decided by the instruction
<code>result += a[i] * xpwr;</code> and
<code>xpwr = x * xpwr;</code>.</p>
<p>  For <code>result += a[i] * xpwr</code>, after the first sequential
operation of 8 cycle, the <code>+</code> and <code>*</code> can be
executed in pipeline. So the CPE is $ $.</p>
<p>  The analysis for <code>polyh</code> is the same. The
<code>result = a[i] + x * result</code> cannot be executed in
pipeline(because both LHS and RHS contain <code>result</code>), so the
CPE is 5+3=8.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 5.Optimizing Program Performance</category>
      </categories>
  </entry>
  <entry>
    <title>5.3.Optimizing Methods</title>
    <url>/2024/08/02/5-3-Optimizing-Methods/</url>
    <content><![CDATA[<h1 id="53optimizing-methods">5.3.Optimizing Methods</h1>
<h3 id="1code-motion">1.Code Motion</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine1</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vec_length(v); i++) &#123;</span><br><span class="line">        <span class="type">data_t</span> val;</span><br><span class="line">        get_vec_element(v, i, &amp;val);</span><br><span class="line">        *dest = *dest OP val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Since the length of <code>v</code> is fixed, it's needless to
compute its length for each iteration. So we can take this computation
alone:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine2</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="type">data_t</span> val;</span><br><span class="line">        get_vec_element(v, i, &amp;val);</span><br><span class="line">        *dest = *dest OP val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2reduce-procedure-calls">2.Reduce Procedure Calls</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">data_t</span> *<span class="title function_">get_vec_start</span><span class="params">(vec_ptr v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Direct access to vector data */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine3</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        *dest = *dest OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3eliminating-unneededmemory-references">3.Eliminating Unneeded
Memory References</h3>
<p>  The assembly code for <code>combine3</code> is as below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Inner loop of combine3. data_t = double, OP = * </span><br><span class="line"># dest in %rbx, data+i in %rdx, data+length in %rax</span><br><span class="line"></span><br><span class="line">.L17: loop:</span><br><span class="line">    vmovsd (%rbx), %xmm0          # Read product from dest</span><br><span class="line">    vmulsd (%rdx), %xmm0, %xmm0   # Multiply product by data[i]</span><br><span class="line">    vmovsd %xmm0, (%rbx)          # Store product at dest</span><br><span class="line">    addq $8, %rdx                 # Increment data+i</span><br><span class="line">    cmpq %rax, %rdx               # Compare to data+length</span><br><span class="line">    jne .L17                      # If !=, goto loop</span><br></pre></td></tr></table></figure>
<p>  We can see that the accumulated values read from and written to
memory on each iteration. We can eliminate this needless reading and
writing of memory by rewriting the code in the style of
<code>combine4</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  With the following assembly code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Inner loop of combine4. data_t = double, OP = *</span><br><span class="line"># acc in %xmm0, data+i in %rdx, data+length in %rax</span><br><span class="line">.L25: loop:</span><br><span class="line">    vmulsd (%rdx), %xmm0, %xmm0   # Multiply acc by data[i]</span><br><span class="line">    addq $8, %rdx                 # Increment data+i</span><br><span class="line">    cmpq %rax, %rdx               # Compare to data+length</span><br><span class="line">    jne .L25                      # If !=, goto loop</span><br></pre></td></tr></table></figure>
<p>  The key is to <strong>dereference the pointer as fewer as
possible</strong>.</p>
<p>  However, this program will lead to different result due to
<em>memory alias</em>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">combine3(v, get_vec_start(v) + <span class="number">2</span>);</span><br><span class="line">combine4(v, get_vec_start(v) + <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/02/5-3-Optimizing-Methods/image.png"></p>
<hr>
<p>  As a result, we modify the <code>combine3</code> as below:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Make sure dest updated on each iteration */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine3w</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize in event length &lt;= 0 */</span></span><br><span class="line">    *dest = acc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">        *dest = acc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  with the following assembly code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Inner loop of combine3. data_t = double, OP = *. Compiled -O1</span><br><span class="line"># dest in %rbx, data+i in %rdx, data+length in %rax</span><br><span class="line">.L17: loop:</span><br><span class="line">    vmovsd (%rbx), %xmm0          # Read product from dest</span><br><span class="line">    vmulsd (%rdx), %xmm0, %xmm0   # Multiply product by data[i]</span><br><span class="line">    vmovsd %xmm0, (%rbx)          # Store product at dest</span><br><span class="line">    addq $8, %rdx                 # Increment data+i</span><br><span class="line">    cmpq %rax, %rdx               # Compare to data+length</span><br><span class="line">    jne .L17                      # If !=, goto loop</span><br></pre></td></tr></table></figure>
<p>  This program dereferences the <code>dest</code> less while avoiding
the memory alias.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 5.Optimizing Program Performance</category>
      </categories>
  </entry>
  <entry>
    <title>5.2.Expressing Program Performance</title>
    <url>/2024/08/01/5-2-Expression-Program-Performance/</url>
    <content><![CDATA[<h1 id="52expressing-program-performance"><span class="math inline">\(5.2.\)</span>Expressing Program Performance</h1>
<p>  We introduce the metric <strong>cycles per element, abbreviated
CPE</strong>, to express program performance in a way that can guide us
in improving the code.</p>
<hr>
<p>  The time required by a iteration procedure can be characterized as
<strong>a constant plus a factor proportional to the number of elements
processed</strong>. Take the following two C programs as an example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compute prefix sum of vector a */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">psum1</span><span class="params">(<span class="type">float</span> a[], <span class="type">float</span> p[], <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>] + a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">psum2</span><span class="params">(<span class="type">float</span> a[], <span class="type">float</span> p[], <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">float</span> mid_val = p[i<span class="number">-1</span>] + a[i];</span><br><span class="line">        p[i] = mid_val;</span><br><span class="line">        p[i+<span class="number">1</span>] = mid_val + a[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* For even n, finish remaining element */</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; n)</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/01/5-2-Expression-Program-Performance/image.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 5.Optimizing Program Performance</category>
      </categories>
  </entry>
  <entry>
    <title>4.5.Pipelined Y86-64 Implementations</title>
    <url>/2024/07/26/4-5-Pipelined-Y86-64-Implementations/</url>
    <content><![CDATA[<h1 id="45pipelined-y86-64-implementations"><span class="math inline">\(4.5.\)</span>Pipelined Y86-64 Implementations</h1>
<h3 id="1seq-rearranging-thecomputation-stages">1.SEQ+ Rearranging the
Computation Stages</h3>
<p>  We slightly rearrange the order of the five stages in SEQ so that
<strong>the PC update stage comes at the beginning of the clock
cycle</strong>, rather than at the end. We refer to this modified design
as SEQ+.</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image.png"></p>
<ul>
<li><p>The old SEQ computes the PC register based on the values of
signals computed during the current clock cycle.</p></li>
<li><p>While with SEQ+, we <strong>create state registers to hold the
signals computed during an instruction</strong>. Then as the new clock
cycle begins, <strong>the values propagate through the exact same logic
to compute the PC for the now-current instruction</strong>.</p></li>
</ul>
<blockquote>
<p>In SEQ+, there is no hardware register storing the program counter.
Instead, the PC <strong>is computed dynamically based on some state
information stored from the previous instruction</strong>.</p>
</blockquote>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-1.png"></p>
<h3 id="2inserting-pipelineregisters">2.Inserting Pipeline
Registers</h3>
<p>  We first try to insert pipeline registers between the stages of
SEQ+. This kind of processor is called <em>PIPE-</em>, where the '-'
represents the decrement in performance. It uses the same hardware as
before, but with the pipeline registers separating the stages:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-2.png"></p>
<ul>
<li><p><em>F</em> holds a predicted value of the program
counter.</p></li>
<li><p><em>D</em> holds <strong>information about the most recently
fetched instruction</strong> for processing <strong>by the decode
stage</strong>.</p></li>
<li><p><em>E</em> holds information about <strong>the most recently
decoded instruction</strong> and <strong>the values read from the
register file</strong> for processing by the execute stage.</p></li>
<li><p><em>M</em> holds <strong>the results of the most recently
executed instruction</strong> for processing by the memory stage. It
also holds <strong>information about branch conditions and branch
targets</strong> for processing conditional jumps.</p></li>
<li><p><em>W</em> supply <strong>the computed results to the register
file</strong> for writing and <strong>the return address to the PC
selection logic</strong> when completing a <code>ret</code>
instruction.</p></li>
</ul>
<blockquote>
<p>Since normal program flow goes from top to bottom of a listing, we
preserve this ordering by having the pipeline flow go from bottom to
top.</p>
</blockquote>
<h3 id="3rearranging-and-relabelingsignals">3.Rearranging and Relabeling
Signals</h3>
<h4 id="asome-name-reference">  <span class="math inline">\(a.\)</span>Some name reference</h4>
<ul>
<li><p>We use uppercase suffix to specified where data is stored. For
example, <code>D_stat</code>.</p></li>
<li><p>We use lowercase suffix to specified which stage data has been
computed. For example, <code>f_stat</code>.</p></li>
</ul>
<blockquote>
<p>The uppercase letters refer to pipeline registers, while the
lowercase letters refer to pipeline stages.</p>
</blockquote>
<h4 id="bdetails">  <span class="math inline">\(b.\)</span>Details</h4>
<p>  The decode stages generate <code>dstE</code> and
<code>dstM</code>:</p>
<ul>
<li><p>In SEQ+, we <strong>connect these signals directly to the address
inputs of the register file write ports</strong>.</p></li>
<li><p>With PIPE−, these signals are directed to the register file
<strong>only once they reach</strong>.</p></li>
</ul>
<p>  These are to make sure <strong>the write port address and data
inputs hold values from the same instruction</strong>.</p>
<ul>
<li><p>The "Select A" block generates the value <code>valA</code> for
the pipeline register E by <strong>choosing either <code>valP</code>
from pipeline register D or the value read from the A port of the
register file</strong>. This block is included to <strong>reduce the
amount of state that must be carried forward to pipeline registers E and
M</strong>.</p>
<ul>
<li>This is because only <code>call</code> instruction requires
<code>valP</code> in the memory stage, only <code>jump</code>
instruction requires <code>valP</code> in the execute stage(when the
jump isn't taken). None of these instructions requires a value read from
the register file.</li>
</ul></li>
</ul>
<h3 id="4next-pc-prediction">4.Next PC Prediction</h3>
<h4 id="abranch-prediction">  <span class="math inline">\(a.\)</span>Branch prediction</h4>
<p>  When we fetch a conditional branch instruction, to decide which
branch to take, we try to predict the next value of the PC.</p>
<ul>
<li><p>For conditional jumps, if we predict that a jump will be taken,
the PC will be <code>valC</code>(computed by the PC
incrementer).</p></li>
<li><p>If we predict that it won't be taken, the PC will be
<code>valP</code>(from the fetch instruction).</p></li>
</ul>
<p>  There are several prediction strategies:</p>
<ol type="1">
<li><p><em>Always Taken</em>.</p></li>
<li><p><em>Never Taken</em>.</p></li>
<li><p><em>Backward Taken, Forward Not Taken</em>. That is, branches to
lower addresses than the next instruction will be taken, while those to
higher addresses will not be taken. This strategy stems from the fact
that <strong>loops are closed by backward branches and loops are
generally executed multiple times</strong>.</p></li>
</ol>
<p>  We simply use "Always Taken" for branch prediction.</p>
<p>  the block labeled "Predict PC" chooses either <code>valP</code> or
<code>valC</code>. This value <strong>is stored in pipeline register
F</strong> as the predicted value of the program counter.</p>
<h4 id="bret">  <span class="math inline">\(b.\)</span><code>ret</code></h4>
<p>  For <code>ret</code> instruction, we don't use any prediction.
Instead, we will simply <strong>hold off processing any more
instructions until the <code>ret</code> instruction passes through the
write-back stage</strong>.</p>
<h3 id="5pipeline-hazards">5.Pipeline Hazards</h3>
<p>  When the dependencies referred before have the potential to cause
an erroneous computation by the pipeline, they are called
<em>hazards</em>. Hazards can be classified as either <em>data
hazards</em> or <em>control hazards</em>.</p>
<h4 id="astalling">  <span class="math inline">\(a.\)</span>Stalling</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-3.png"></p>
<p>  One very general technique for avoiding hazards involves stalling,
where the processor holds back one or more instructions in the pipeline
until the hazard condition no longer holds.</p>
<ul>
<li>Our processor can avoid data hazards by <strong>holding back an
instruction in the decode stage</strong> until <strong>the instructions
generating its source operands have passed through the write-back
stage</strong>.</li>
</ul>
<p>  In holding back the <code>addq</code> instruction in the decode
stage, we must also <strong>hold back the <code>halt</code> instruction
following it in the fetch stage</strong>. We can do this by
<strong>keeping the program counter at a fixed value</strong>, so that
the halt instruction will be fetched repeatedly until the stall has
completed.</p>
<p>  During the processing of <code>addq</code>, to perform the
stalling, we <strong>inject a <em>bubble</em></strong>, which is a
dynamically generated <code>nop</code> instruction, <strong>into the
execute stage</strong>.</p>
<h4 id="bforwarding">  <span class="math inline">\(b.\)</span>Forwarding</h4>
<h5 id="iforwarding-process">  <span class="math inline">\(i.\)</span>Forwarding process</h5>
<p>  Rather than stalling until the write has completed, it can simply
<strong>pass the value</strong> that is about to be written to pipeline
register E <strong>as the source operand</strong>. This technique of
<strong>passing a result value directly from one pipeline stage to an
earlier one</strong> is commonly known as <em>data forwarding</em>:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-4.png"></p>
<p>  For forwarding, we can <strong>pass the newly computed values from
the execute stage to the decode stage</strong>.</p>
<ul>
<li><p>The decode-stage logic <strong>detects a pending write to
register <code>%rdx</code> in the memory stage</strong>, and also that
<strong>the value being computed by the ALU in the execute stage will
later be written to register <code>%rax</code></strong>.</p></li>
<li><p>It can use the value in the memory stage(signal
<code>M_valE</code>) for operand <code>valA</code>. It can also use the
ALU output(signal <code>e_valE</code>) for operand
<code>valB</code>.</p></li>
</ul>
<p>  Forwarding can also be used with values read from the memory and
destined for write port M:</p>
<ul>
<li><p>From the memory stage, we can forward <strong>the value that has
just been read from the data memory</strong>(signal
<code>m_valM</code>).</p></li>
<li><p>From the write-back stage, we can forward <strong>the pending
write to port M(signal <code>W_valM</code>)</strong>.</p></li>
</ul>
<p>  This gives a total of five different forwarding
sources(<code>e_valE</code>, <code>m_valM</code>, <code>M_valE</code>,
<code>W_valM</code>, and <code>W_valE</code>) and two different
forwarding destinations (<code>valA</code> and <code>valB</code>).</p>
<p>  The following figure shows the structure of PIPE that can handle
data hazards by forwarding. We can see that the values from the five
forwarding sources are fed back to the <strong>two blocks labeled
'Sel+Fwd A" and "Fwd B" in the decode stage</strong>.</p>
<ul>
<li>The block labeled "Sel+Fwd A" combines the role of the block labeled
"Select A" in PIPE with the forwarding logic.</li>
</ul>
<h5 id="iiforwarding-judgement">  <span class="math inline">\(ii.\)</span>Forwarding judgement</h5>
<p>  Associated with every value that will be written back to the
register file is the destination register ID. The logic can compare
these IDs with the source register IDs srcA and srcB to detect a case
for forwarding.</p>
<h4 id="cloaduse-hazards">  <span class="math inline">\(c.\)</span>Load/Use hazards</h4>
<p>  One class of data hazards cannot be handled purely by forwarding is
called <em>load/use hazards</em>:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-5.png"></p>
<p>  The <code>addq</code> instruction requires the value of the
register in cycle 7, but <strong>it is not generated by the
<code>mrmovq</code> instruction until cycle 8. In order to "forward"
from the <code>mrmovq</code> to the <code>addq</code></strong>, the
forwarding logic would have to make the value go backward in time(or no
register will store our desired value)!</p>
<p>  We can avoid a load/use data hazard <strong>with a combination of
stalling and forwarding</strong>:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-6.png"></p>
<p>  This technique is called <em>load interlock</em>. Since only load
interlocks reduce the pipeline throughput, we can nearly achieve our
throughput goal of issuing one new instruction on every clock cycle.</p>
<h4 id="davoiding-control-hazards">  <span class="math inline">\(d.\)</span>Avoiding control hazards</h4>
<p>  Control hazards arise when the processor <strong>cannot reliably
determine the address of the next instruction</strong> based on the
current instruction in the fetch stage.</p>
<h5 id="iret">  <span class="math inline">\(i.\)</span><code>ret</code></h5>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-7.png"></p>
<ul>
<li><p>While the <code>ret</code> instruction passes through the decode,
execute, and memory stages, the pipeline cannot do any useful
activity.</p></li>
<li><p>Once the <code>ret</code> instruction reaches the write-back
stage, the PC selection logic will <strong>set the program counter to
the return address</strong>, and therefore the fetch stage will fetch
the <code>irmovq</code> instruction at the return point(address
0x013).</p></li>
</ul>
<h5 id="iijump-instruction">  <span class="math inline">\(ii\)</span>Jump instruction</h5>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-8.png"></p>
<ul>
<li><p>By the time the branch logic detects that the jump should not be
taken during cycle 4, two instructions have been fetched that should not
continue being executed.</p></li>
<li><p>Neither of these instructions has caused a change in the
programmer-visible state. So the pipeline can simply cancel (sometimes
called <em>instruction squashing</em>) the two misfetched instructions
by <strong>injecting bubbles into the decode and execute stages</strong>
on the following cycle while also fetching the instruction following the
jump instruction.</p></li>
</ul>
<h3 id="6exception-handling">6.Exception Handling</h3>
<h4 id="aseveral-exception-subleties">  <span class="math inline">\(a.\)</span>Several exception subleties</h4>
<ol type="1">
<li><p>It is possible to have exceptions <strong>triggered by multiple
instructions simultaneously</strong>.</p>
<ul>
<li>For example, we could have a <code>halt</code> instruction in the
fetch stage, and the data memory could report an out-of-bounds data
address for the instruction in the memory stage.</li>
</ul></li>
<li><p>When an instruction is first fetched and begins execution, causes
an exception, and later is canceled due to a mispredicted branch. But we
want to avoid rasing the exception.</p></li>
<li><p>It's possible for an instruction following one causing an
exception to <strong>alter some part of the state before the excepting
instruction completes</strong>.</p>
<ul>
<li>Take the assembly program below as an example, The exception of
<code>pushq %rax</code> is detected in memory stage, while the
<code>addq %rax, %rax</code> has reached execute stage, and has already
cause the condition codes to be set to new values(and other
<code>stat</code>):</li>
</ul></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">irmovq $1,%rax           </span><br><span class="line">xorq %rsp,%rsp   # Set stack pointer to 0 and CC to 100</span><br><span class="line">pushq %rax       # Attempt to write to 0xfffffffffffffff8</span><br><span class="line">addq %rax,%rax   # (Should not be executed) Would set CC to 000</span><br></pre></td></tr></table></figure>
<h4 id="bhandling-exception">  <span class="math inline">\(b.\)</span>Handling exception</h4>
<p>  When an exception occurs in one or more stages of a pipeline,
<strong>the information is simply stored in the status fields of the
pipeline registers</strong>. The event has no effect on the flow of
instructions in the pipeline <strong>until an excepting instruction
reaches the final pipeline stage</strong>, except to <strong>disable any
updating of the programmer-visible state</strong>.</p>
<ul>
<li><p>For the first problem, we are guaranteed that the first
instruction encountering an exception will <strong>arrive first in the
write-back stage</strong>, at which point <strong>program execution can
stop</strong> and <strong>the status code in pipeline register W can be
recorded as the program status</strong>.</p></li>
<li><p>For the second problem, if some instruction is fetched but later
canceled, <strong>any exception status information about the instruction
gets canceled as well</strong>.</p></li>
<li><p>For the third problem, no instruction following one that causes
an exception can alter the programmer-visible state.</p></li>
</ul>
<h3 id="7pipe-stage-implementation">7.PIPE Stage Implementation</h3>
<h4 id="apc-selection-and-fetch-stage">  <span class="math inline">\(a.\)</span>PC selection and Fetch stage</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-9.png"></p>
<ul>
<li><p>The hardware units for reading the instruction from memory and
for extracting the different instruction fields are the same as those we
considered for SEQ.</p></li>
<li><p>The PC selection logic chooses between three program counter
sources:</p>
<ul>
<li><p>For <em>mispredicted branches</em>, The value of
<code>valP</code>(indicating the address of the following instruction)
is read from pipeline register M(signal <code>M_valA</code>).</p></li>
<li><p>For <em><code>ret</code> instruction</em>, the return address is
read from pipeline register W(signal <code>W_valM</code>).</p></li>
<li><p>All other cases use <em>the predicted value of the PC</em>,
stored in pipeline register F (signal <code>F_predPC</code>)</p></li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word f_pc = [</span><br><span class="line">    # Mispredicted branch. Fetch at incremented PC</span><br><span class="line">    M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">    # Completion of RET instruction</span><br><span class="line">    W_icode == IRET : W_valM;</span><br><span class="line">    # Default: Use predicted value of PC</span><br><span class="line">    1 : F_predPC;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<ul>
<li>The PC prediction logic chooses <code>valC</code> for the fetched
instruction when <strong>it is either a call or a jump</strong>, and
<code>valP</code> otherwise:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word f_predPC = [</span><br><span class="line">    f_icode in &#123; IJXX, ICALL &#125; : f_valC;</span><br><span class="line">    1 : f_valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>  Unlike in SEQ, we must <strong>split the computation of the
instruction status into two parts</strong>:</p>
<ul>
<li><p>In the fetch stage, we can test for a memory error <strong>due to
an out-of-range instruction address</strong>, and we can <strong>detect
an illegal instruction or a <code>halt</code>
instruction</strong>.</p></li>
<li><p>Detecting an invalid data address must <strong>be deferred to the
memory stage</strong>.</p></li>
</ul>
<h4 id="bdecode-and-write-back-stages">  <span class="math inline">\(b.\)</span>Decode and Write-back stages</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-10.png"></p>
<ul>
<li><p>The register IDs supplied to the write ports come from the
write-back stage(signals <code>W_dstE</code> and <code>W_dstM</code>),
rather than from the decode stage. This is to ensure that the final
result is written back to the specified register <strong>only after the
instruction has actually completed all operations</strong>, including
memory access and execution.</p></li>
<li><p>The block labeled "Sel+Fwd A" serves two roles: It <strong>merges
the <code>valP</code> signal into the <code>valA</code> signal</strong>
for later stages in order to reduce the amount of state in the pipeline
register. It also <strong>implements the forwarding logic for source
operand <code>valA</code></strong>.</p></li>
<li><p><strong>Only the <code>call</code> and jump instructions need the
value of <code>valP</code> in later stages</strong>, and these
instructions do not need the value read from the A port of the register
file.</p>
<ul>
<li>This selection is controlled by the <code>icode</code> signal for
this stage. When <strong>signal <code>D_icode</code> matches the
instruction code for either <code>call</code> or
<code>jXX</code></strong>, this block should <strong>select
<code>D_valP</code> as it output</strong>.</li>
</ul></li>
</ul>
<p>  there are five different forwarding sources, each with a data word
and a destination register ID:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-11.png"></p>
<p>  If <strong>none of the forwarding conditions hold</strong>, the
block should select <code>d_rvalA</code>, the value read from register
port A, as its output.</p>
<p>  The overall HCL description for the <code>d_valA</code> is as
below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word d_valA = [</span><br><span class="line">    D_icode in &#123; ICALL, IJXX &#125; : D_valP; # Use incremented PC</span><br><span class="line">    d_srcA == e_dstE : e_valE; # Forward valE from execute</span><br><span class="line">    d_srcA == M_dstM : m_valM; # Forward valM from memory</span><br><span class="line">    d_srcA == M_dstE : M_valE; # Forward valE from memory</span><br><span class="line">    d_srcA == W_dstM : W_valM; # Forward valM from write back</span><br><span class="line">    d_srcA == W_dstE : W_valE; # Forward valE from write back</span><br><span class="line">    1 : d_rvalA; # Use value read from register file</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>  The priority given to the five forwarding sources in the above HCL
code is very important. This priority is determined in the HCL code
<strong>by the order in which the five destination register IDs are
tested</strong>.</p>
<blockquote>
<p>To imitate this behavior, our pipelined implementation should always
give priority to the forwarding source <strong>in the earliest pipeline
stage</strong>, since it holds the latest instruction in the program
sequence setting the register.</p>
</blockquote>
<p>  In previous part, we know that the overall processor status
<code>Stat</code> is computed by a block based on the status value:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-12.png"></p>
<p>  Since pipeline register W holds the state of the most recently
completed instruction, it is natural to <strong>use this value as an
indication of the overall processor status</strong>. The only special
case to consider is when <strong>there is a bubble in the write-back
stage</strong>. This is part of normal operation, and so we want
<strong>the status code to be AOK for this case as well</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word Stat = [</span><br><span class="line">    W_stat == SBUB : SAOK;</span><br><span class="line">    1 : W_stat;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h4 id="cexecute-stage">  <span class="math inline">\(c.\)</span>Execute stage</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-13.png"></p>
<p>  The logic labeled "Set CC", which <strong>determines whether or not
to update the condition codes</strong>, has signals <code>m_stat</code>
and <code>W_stat</code> as inputs. These signals are used to detect
cases where an instruction causing an exception is passing through later
pipeline stages, and therefore <strong>any updating of the condition
codes should be suppressed</strong>.</p>
<blockquote>
<p>We need to ensure that <strong>the impact of the exception
instruction is dealt with first</strong> to avoid incorrect barcode
updates, so we suppress the condition codes.</p>
</blockquote>
<h4 id="dmemorystage">  <span class="math inline">\(d.\)</span>Memory
stage</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-14.png"></p>
<h3 id="8pipeline-control-logic">8.Pipeline Control Logic</h3>
<h4 id="adesired-handling-of-special-controlcases">  <span class="math inline">\(a.\)</span>Desired handling of special control
cases</h4>
<p>  Implement the pipeline flow requires d<strong>etecting the hazard
condition</strong>, <strong>keeping pipeline registers F and D
fixed</strong>, and <strong>injecting a bubble into the execute
stage</strong>.</p>
<ul>
<li>The pipeline holds back an instruction in the decode stage by
<strong>keeping pipeline register D in a fixed state</strong>. It should
also keep pipeline register F in a fixed state, <strong>so that the next
instruction will be fetched a second time</strong>.</li>
</ul>
<h5 id="iret">  <span class="math inline">\(i.\)</span><code>ret</code></h5>
<p>  The figure below provides a detailed view of the processing of the
<code>ret</code> instruction for the example program:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-15.png"></p>
<ul>
<li>The fetch stage stalls, causing the <code>rrmovq</code> instruction
to be fetched but then replaced by a bubble in the decode stage.</li>
</ul>
<h5 id="iimispredicted-branch">  <span class="math inline">\(ii.\)</span>Mispredicted branch</h5>
<p>  When a mispredicted branch occurs, the control logic
<strong>injects bubbles into the decode and execute stages on the next
cycle</strong>, causing the two incorrectly fetched instructions to be
canceled. On the same cycle, <strong>the pipeline reads the correct
instruction into the fetch stage</strong>.</p>
<p>  For an instruction that causes an exception, to make the pipeline
implementation matches the desired ISA behaviour:</p>
<ul>
<li><p>We record the status of each instruction by the status code
<code>stat</code>, and continue fetching, decoding, and executing
instructions as if nothing were amiss.</p></li>
<li><p>As the excepting instruction reaches the memory stage, we take
steps to prevent later instructions from modifying the
programmer-visible state by:</p>
<ol type="1">
<li><p>disabling the setting of condition codes by instructions in the
execute stage,</p></li>
<li><p>injecting bubbles into the memory stage to disable any writing to
the data memory,</p></li>
<li><p><strong>stalling the write-back stage when it has an excepting
instruction</strong>, thus bringing the pipeline to a halt.</p></li>
</ol></li>
</ul>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-16.png"></p>
<ul>
<li>We disable the setting of condition codes when an excepting
instruction is in the memory or write-back stage(by examining the
signals <code>m_stat</code> and <code>W_stat</code> and then setting the
signal <code>set_cc</code> to zero)</li>
</ul>
<h4 id="bdetecting-special-controlconditions">  <span class="math inline">\(b.\)</span>Detecting special control
conditions</h4>
<p>  The following figure give expressions describing the conditions
under which the three special cases arise:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-17.png"></p>
<ul>
<li><p>Detecting a <code>ret</code> instruction involves
<strong>checking the instruction codes of the instructions in the
decode, execute, and memory stages</strong>.</p></li>
<li><p>Detecting a load/use hazard involves <strong>checking the
instruction type(<code>mrmovq</code> or <code>popq</code>) of the
instruction in the execute stage</strong> and <strong>comparing its
destination register with the source registers of the instruction in the
decode stage</strong>.</p></li>
<li><p>The pipeline control logic should detect a mispredicted branch
while <strong>the jump instruction is in the execute stage</strong>, so
that it can <strong>set up the conditions required to recover from the
misprediction</strong> as the instruction enters the memory
stage.</p></li>
</ul>
<h4 id="cpipeline-control-mechanisms">  <span class="math inline">\(c.\)</span>Pipeline control mechanisms</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-18.png"></p>
<ul>
<li>When the bubble signal is set to 1, the state of the register
<strong>will be set to some fixed reset configuration</strong>, giving
<strong>a state equivalent to that of a nop instruction</strong>.</li>
</ul>
<h4 id="dcontrol-logic-implementation">  <span class="math inline">\(d.\)</span>Control logic implementation</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-19.png"></p>
<ul>
<li>Pipeline register F must be stalled for either a load/use hazard or
a <code>ret</code> instruction:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool F_stall =</span><br><span class="line">    # Conditions for a load/use hazard</span><br><span class="line">    E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp;</span><br><span class="line">    E_dstM in &#123; d_srcA, d_srcB &#125; ||</span><br><span class="line">    # Stalling at fetch while ret passes through pipeline</span><br><span class="line">    IRET in &#123; D_icode, E_icode, M_icode &#125;;</span><br></pre></td></tr></table></figure>
<p>  Pipeline register E must be set to bubble for a load/use hazard or
for a mispredicted branch:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool E_bubble =</span><br><span class="line">    # Mispredicted branch</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # Conditions for a load/use hazard</span><br><span class="line">    E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp;</span><br><span class="line">    E_dstM in &#123; d_srcA, d_srcB&#125;;</span><br></pre></td></tr></table></figure>
<p>  Pipeline register D must be stalled for a load/use hazard:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool D_stall =</span><br><span class="line">    # Conditions for a load/use hazard</span><br><span class="line">    E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp;</span><br><span class="line">    E_dstM in &#123; d_srcA, d_srcB &#125;;</span><br></pre></td></tr></table></figure>
<p>  Pipeline register D must be set to bubble for a mispredicted branch
or a <code>ret</code> instruction. However, it should not inject a
bubble when there is a load/use hazard in combination with a
<code>ret</code> instruction:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool D_bubble =</span><br><span class="line">    # Mispredicted branch</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # Stalling at fetch while ret passes through pipeline</span><br><span class="line">    # but not condition for a load/use hazard</span><br><span class="line">    !(E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM in &#123; d_srcA, d_srcB &#125;) &amp;&amp;</span><br><span class="line">    IRET in &#123; D_icode, E_icode, M_icode &#125;;</span><br></pre></td></tr></table></figure>
<p>  Pipeline register E must be set to bubble for a load/use hazard or
for a mispredicted branch:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool E_bubble =</span><br><span class="line">    # Mispredicted branch</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # Conditions for a load/use hazard</span><br><span class="line">    E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp;</span><br><span class="line">    E_dstM in &#123; d_srcA, d_srcB&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="9performance-analysis">9.Performance Analysis</h3>
<p>  We measure the overall performance by computing an estimate of
<strong>the average number of clock cycles PIPE would require per
instruction it executes</strong>, a measure known as the CPI (for
"cycles per instruction").</p>
<ul>
<li>If the stage processes a total of <span class="math inline">\(C_i\)</span> instructions and <span class="math inline">\(C_b\)</span> bubbles, then the processor has
required around <span class="math inline">\(C_i+C_b\)</span> total clock
cycles to execute <span class="math inline">\(C_i\)</span> instructions,
and we can calculate the CPI as follows:</li>
</ul>
<p><span class="math display">\[
CPI={ {C_i+C_b} \over C_i}=1.0+ {C_b \over C_i}
\]</span></p>
<p>  We can analyze the total penalty like below:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-20.png"></p>
<h3 id="9multicycle-instructions">9.Multicycle Instructions</h3>
<p>  In a more complete instruction set, we would also need to implement
instructions requiring more complex operations such as integer
multiplication and division and floating-point operations. However,
these operations require more than 1 cycle, so they need to be computed
specially.</p>
<p>  We can design a functional unit for performing integer
multiplication and division, and another for performing floating-point
operations.</p>
<ul>
<li><p>As an instruction enters the decode stage, it can be issued to
the special unit. <strong>While the unit performs the operation, the
pipeline continues processing other instructions</strong>.</p></li>
<li><p>Typically, <strong>the floating-point unit is itself
pipelined</strong>, and thus multiple operations can execute
concurrently in the main pipeline and in the different units</p></li>
</ul>
<p>  The operations of the different units must be synchronized to avoid
incorrect behavior. Often, <strong>different forms of
forwarding</strong> are used to convey results from one part of the
system to other parts, just as we saw between the different stages of
PIPE.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 4.Processor Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>4.4.General Principles of Pipelining</title>
    <url>/2024/07/26/4-4-General-Principles-of-pipelining/</url>
    <content><![CDATA[<h1 id="44general-principles-of-pipelining"><span class="math inline">\(4.4.\)</span>General Principles of Pipelining</h1>
<h3 id="1computational-pipelines">1.Computational Pipelines</h3>
<p><img src="/2024/07/26/4-4-General-Principles-of-pipelining/image.png"></p>
<p>  The detail at the timing and operation of this process are shown as
below:</p>
<p><img src="/2024/07/26/4-4-General-Principles-of-pipelining/image-2.png"></p>
<p><img src="/2024/07/26/4-4-General-Principles-of-pipelining/image-1.png"></p>
<ul>
<li>Slowing down the clock would not change the pipeline behavior. The
signals propagate to the pipeline register inputs, but <strong>no change
in the register states will occur until the clock rises</strong>.</li>
</ul>
<h3 id="2limitations-of-pipelining">2.Limitations of Pipelining</h3>
<h4 id="athroughput">  <span class="math inline">\(a.\)</span>Throughput</h4>
<p>  Suppose the maximum delay of a process is <span class="math inline">\(x\)</span> ps, then we can calculate the
<em>throughput</em> as:</p>
<p><span class="math display">\[
throughput={ {1\;instruction}\over{x\;ps} } \cdot { {1000\;ps} \over
{1\;ns}}={1000\over x}GIPS
\]</span></p>
<p>  And the <em>latency</em> is the <strong>overall time the process
takes</strong>.</p>
<h4 id="bnonuniform-partition">  <span class="math inline">\(b.\)</span>Nonuniform partition</h4>
<p><img src="/2024/07/26/4-4-General-Principles-of-pipelining/image-3.png"></p>
<ul>
<li><p>The latency of piplining is decided by <strong>the slowest clock
rate</strong>.</p>
<ul>
<li>For the process above, delays of A and C are 50ps and 100+20 = 120
ps, while delay of B is 150+20 = 170ps, so we have to <strong>set the
clock cycle to 170ps</strong>.</li>
</ul></li>
</ul>
<blockquote>
<p>Note that the delay of pipeline register is included in
<strong>register that fetch data from it</strong>. So in the process
above, B and C should add the 20ps delay.</p>
</blockquote>
<h4 id="cdiminishing-returns-of-deeppipelining">  <span class="math inline">\(c.\)</span>Diminishing returns of deep
pipelining</h4>
<p><img src="/2024/07/26/4-4-General-Principles-of-pipelining/image-4.png"></p>
<h3 id="3piplining-a-system-withfeedback">3.Piplining a System with
Feedback</h3>
<p>  For a system that executes machine programs such as Y86-64, there
are <strong>potential dependencies between successive
instructions</strong>.</p>
<ul>
<li>The following codes describe what is called <em>data
dependency</em>. The <code>irmovq</code> instruction stores its result
in <code>%rax</code>, which then must be read by the <code>addq</code>
instruction.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">irmovq $50, %rax</span><br><span class="line">addq %rax, %rbx</span><br><span class="line">mrmovq 100(%rbx), %rdx</span><br></pre></td></tr></table></figure>
<ul>
<li>The following codes describe what is called <em>control
dependency</em>. The outcome of the conditional test determines whether
the next instruction to execute:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop:</span><br><span class="line">    subq %rdx,%rbx</span><br><span class="line">    jne targ</span><br><span class="line">    irmovq $10,%rdx</span><br><span class="line">    jmp loop</span><br><span class="line">targ:</span><br><span class="line">    halt</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/26/4-4-General-Principles-of-pipelining/image-5.png"></p>
<p><img src="/2024/07/26/4-4-General-Principles-of-pipelining/image-6.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 4.Processor Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>4.3.Sequential Y86-64 Implementation</title>
    <url>/2024/07/25/4-3-Sequential-Y86-64-Implementation/</url>
    <content><![CDATA[<h1 id="43sequential-y86-64-implementation"><span class="math inline">\(4.3.\)</span>Sequential Y86-64 Implementation</h1>
<h3 id="1organizing-processing-intostages">1.Organizing Processing into
Stages</h3>
<h4 id="asummary">  <span class="math inline">\(a.\)</span>Summary</h4>
<p>  The following is an informal description of the stages and the
operations performed within them:</p>
<ol type="1">
<li><p><em>Fetch</em>: The fetch stage <strong>reads the bytes of an
instruction from memory, using the program counter(PC) as the memory
address</strong>.</p>
<ul>
<li><p>From the instruction it <strong>extracts the two 4-bit portions
of the instruction specifier byte</strong>, referred to as
<code>icode</code>(the instruction code) and <code>ifun</code>(the
instruction function).</p></li>
<li><p>It computes <code>valP</code> to be <strong>the address of the
instruction following the current one in sequential order</strong>. That
is, <code>valP</code> equals <strong>the value of the PC plus the length
of the fetched instruction</strong>.</p></li>
</ul></li>
<li><p><em>Decode</em>: The decode stage <strong>reads up to two
operands from the register file</strong>, giving values
<code>valA</code> and/or <code>valB</code>.</p></li>
<li><p><em>Execute</em>: In the execute stage, the arithmetic/logic
unit(ALU) either <strong>performs the operation specified by the
instruction</strong>(according to <strong>the value of
<code>ifun</code></strong>), <strong>computes the effective address of a
memory reference</strong>, or <strong>increments or decrements the stack
pointer</strong>. We refer to the resulting value as
<code>valE</code>.</p>
<ul>
<li>For a conditional move instruction, the stage will evaluate the
condition codes and move condition (given by <code>ifun</code>) and
<strong>enable the updating of the destination register only if the
condition holds</strong>.</li>
</ul></li>
<li><p><em>Memory</em>: The memory stage may write data to memory, or it
may read data from memory. We refer to the value read as
<code>valM</code>.</p></li>
<li><p><em>Write Back</em>: The write-back stage writes up to two
results to the register file.</p></li>
<li><p><em>PC Update</em>: The PC is set to the address of the next
instruction.</p></li>
</ol>
<p>  In our simplified implementation, the processor will stop when any
exception occurs - that is, when it executes a <code>halt</code> or
invalid instruction, or it attempts to read or write an invalid
address.</p>
<h4 id="barithmetic-operations">  <span class="math inline">\(b.\)</span>Arithmetic operations</h4>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image.png"></p>
<ul>
<li><p>For the integer-operation instruction:</p>
<ol type="1">
<li><p>In the fetch stage, we do not require a constant word, and so
<code>valP</code> is computed as <code>PC+2</code>.</p></li>
<li><p>During the decode stage, we read both operands. These are
supplied to the ALU in the execute stage, along with the function
specifier <code>ifun</code>.</p></li>
<li><p><code>valE</code> equals to the instruction result
<code>valB OP valA</code>. The <code>OP</code> is specified by
<code>ifun</code>.</p></li>
</ol></li>
<li><p>For the <code>rmmovq</code> instruction:</p>
<ol type="1">
<li><p>The process is similar to integer-operation operation, but we
don't need to fetch the second register operand. Instead, we <strong>set
the second ALU input to zero and add this to the first</strong>, giving
<code>valE = valA</code>.</p></li>
<li><p>In addition, we must increment the program counter by 10 for
<code>irmovq</code> <strong>due to the long instruction
format</strong>.</p></li>
</ol></li>
</ul>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-1.png"></p>
<h4 id="coperations-involving-memoryoperation">  <span class="math inline">\(c.\)</span>Operations involving memory
operation</h4>
<p>  The following instructions involve memory write and read stage:</p>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-2.png"></p>
<ul>
<li><p>The process <strong>use the ALU to add <code>valC</code> to
<code>valB</code>, giving the effective address for memory
operation</strong>.</p></li>
<li><p>In the memory stage, we either write the register value
<code>valA</code> to memory or read <code>valM</code> from
memory.</p></li>
</ul>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-3.png"></p>
<h4 id="dpushq-amppopq-operations">  <span class="math inline">\(d.\)</span><code>pushq</code> &amp;
<code>popq</code> operations</h4>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-4.png"></p>
<p>  The <code>pushq</code> and <code>popq</code> involve both accessing
memory and incrementing or decrementing the stack pointer.</p>
<ul>
<li><p>For the <code>pushq</code> instruction:</p>
<ol type="1">
<li><p>In decode stage, we use <code>%rsp</code> as the identifier for
the second register operand, giving the stack pointer as
<code>valB</code>.</p></li>
<li><p>In the execute stage, we <strong>use the ALU to decrement the
stack pointer by 8</strong>. This decremented value is used for the
memory write address and is also <strong>stored back to
<code>%rsp</code> in the write-back stage</strong>.</p></li>
<li><p>We use <code>valE</code> as the address for the write
operation.</p></li>
</ol></li>
</ul>
<blockquote>
<p>we adhere to the Y86-64 convention that <code>pushq</code> should
<strong>decrement the stack pointer before writing</strong>.</p>
</blockquote>
<ul>
<li><p>For the <code>popq</code> instruction:</p>
<ol type="1">
<li><p>The <code>popq</code> instruction proceeds much like
<code>pushq</code>, except that we <strong>read two copies of the stack
pointer</strong> in the decode stage. This is clearly redundant, but we
will see that having the stack pointer as both <code>valA</code> and
<code>valB</code> makes the subsequent flow more similar to that of
other instructions, enhancing the overall uniformity of the
design.</p></li>
<li><p>We use <strong>the unincremented value as the address for the
memory operation</strong>.</p></li>
<li><p>In the write-back stage, we update both <strong>the stack pointer
register with the incremented stack pointer</strong> and
<strong>register <code>rA</code> with the value read from
memory</strong>.</p></li>
</ol></li>
</ul>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-5.png"></p>
<h4 id="econtrol-transfer-instructions">  <span class="math inline">\(e.\)</span>Control transfer instructions</h4>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-6.png"></p>
<ul>
<li><p>A jump instruction proceeds through fetch and decode much like
the previous instructions, except that <strong>it does not require a
register specifier byte</strong>.</p></li>
<li><p>In the execute stage, we check the condition codes and the jump
condition to determine whether or not to take the branch, yielding a
1-bit signal <code>Cnd</code>.</p></li>
<li><p>We test this flag and set the PC to <code>valC</code>(the jump
target) if the flag is 1 and to <code>valP</code>(the address of the
following instruction) if the flag is 0.</p></li>
</ul>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-7.png"></p>
<h4 id="fcall-ampret-operations">  <span class="math inline">\(f.\)</span><code>call</code> &amp;
<code>ret</code> operations</h4>
<ul>
<li><p>Instructions <code>call</code> and <code>ret</code> is similar to
<code>pushq</code> and <code>popq</code>, except that we push and pop
program counter values.</p>
<ul>
<li><p>With instruction call, we push <code>valP</code>, <strong>the
address of the instruction that follows the call instruction</strong>.
During the PC update stage, we <strong>set the PC to <code>valC</code>,
the call destination</strong>.</p></li>
<li><p>With instruction <code>ret</code>, we assign <code>valM</code>,
<strong>the value popped from the stack</strong>, to the PC in the PC
update stage.</p></li>
</ul></li>
</ul>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-8.png"></p>
<h3 id="2seq-hardware-structure">2.SEQ Hardware Structure</h3>
<p>  The following figure shows an abstract view of a hardware structure
that performs the six stages:</p>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-9.png"></p>
<ul>
<li><p>Information then flows along wires(shown grouped together as a
heavy gray line), first upward and then around to the right.</p></li>
<li><p>The feedback paths coming back down on the right-hand side
<strong>contain the updated values to write to the register file and the
updated program counter</strong>.</p></li>
</ul>
<p>  The six stages are executed as below:</p>
<ol type="1">
<li><p><em>Fetch</em>: <strong>Using the program counter register as an
address</strong>, the <em>instruction memory</em> reads the bytes of an
instruction. The PC incrementer computes <code>valP</code>.</p></li>
<li><p><em>Decode</em>: The two register values <code>valA</code> and
<code>valB</code> are read simultaneously from the read ports A and
B.</p></li>
<li><p><em>Execute</em>:</p>
<ul>
<li><p>The ALU do the operations for different purposes.</p></li>
<li><p>The condition code register(CC) holds the three condition code
bits. New values for the condition codes are computed by the ALU. The
execution of move instruction and the <code>Cnd</code> of the jump
instruction is computed based on the CC.</p></li>
</ul></li>
<li><p><em>Memory</em>: The data memory reads or writes a word of memory
when executing a memory instruction.</p>
<ul>
<li>The instruction and data memories access the same memory locations,
but for different purposes.</li>
</ul></li>
<li><p><em>Write Back</em>: The register file has two write ports. Port
E is used to write values computed by the ALU, while port M is used to
write values read from the data memory.</p></li>
<li><p><em>PC Update</em>: The new value of the program counter is
selected to be either <code>valP</code>, <strong>the address of the next
instruction</strong>, <code>valC</code>, <strong>the destination address
specified by a call or jump instruction</strong>, or <code>valM</code>,
<strong>the return address read from memory</strong>.</p></li>
</ol>
<p>  The following figure gives a more detailed view of the hardware
design:</p>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-10.png"></p>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-11.png"></p>
<h3 id="3seq-timing">3.SEQ Timing</h3>
<h4 id="asomebasic-idea">  <span class="math inline">\(a.\)</span>Some
basic idea</h4>
<ul>
<li><p>Combinational logic does not require any sequencing or
control-<strong>values propagate through a network of logic gates
whenever the inputs change</strong>.</p></li>
<li><p>We assume that reading from a random access memory operates much
like combinational logic, with the output word generated based on the
address input.</p></li>
<li><p>The program counter is loaded with a new instruction address
every clock cycle.</p></li>
<li><p>The condition code register is loaded only <strong>when an
integer operation instruction is executed</strong>.</p></li>
<li><p>The data memory is written only when an <code>rmmovq</code>,
<code>pushq</code>, or <code>call</code> instruction is
executed.</p></li>
<li><p>The two write ports of the register file allow two program
registers to be updated on every cycle, but we can use the special
register ID 0xF as a port address to indicate that no write should be
performed for this port.</p></li>
<li><p><em>Principle</em>: The processor <strong>never needs to read
back the state updated by an instruction</strong> in order to complete
the processing of this instruction.</p></li>
</ul>
<h4 id="bprogram-example">  <span class="math inline">\(b.\)</span>Program example</h4>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-12.png"></p>
<p>  Every time the clock transitions from low to high, the processor
begins executing a new instruction.</p>
<h3 id="4seq-stage-implementation">4.SEQ Stage Implementation</h3>
<p>  The used constant are shown below:</p>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-13.png"></p>
<h4 id="afetchstage">  <span class="math inline">\(a.\)</span>Fetch
stage</h4>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-14.png"></p>
<ul>
<li><p>The instruction memory hardware unit reads 10 bytes from memory
at a time, <strong>using the PC as the address of the first byte(byte
0)</strong>. This byte is interpreted as the instruction byte and is
<strong>split(by the unit labeled "Split") into two 4-bit
quantities</strong>.</p></li>
<li><p>The control logic blocks labeled "icode" and "ifun" then compute
the instruction and function codes as equaling either <strong>the values
read from memory</strong> or the values corresponding to a nop
instruction(as indicated by the signal
<code>imem_error</code>).</p></li>
</ul>
<p>  Based on the value of <code>icode</code>, we can compute three
1-bit signals:</p>
<ol type="1">
<li><p><code>instr_valid</code>: This signal is used to <strong>detect
an illegal instruction</strong>.</p></li>
<li><p><code>need_regids</code>: Does this instruction <strong>include a
register specifier byte</strong>?</p></li>
<li><p><code>need_valC</code>: Does this instruction <strong>include a
constant word</strong>?</p></li>
</ol>
<p>  The signals <code>instr_valid</code> and
<code>imem_error</code>(generated when the instruction address is out of
bounds) are used to <strong>generate the status code in the memory
stage</strong>.</p>
<p>  The HCL description for <code>need_regids</code> and
<code>need_valC</code> are as below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool need_regids =</span><br><span class="line">    icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ,</span><br><span class="line">               IIRMOVQ, IRMMOVQ, IMRMOVQ &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool need_valC =</span><br><span class="line">    icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The remaining 9 bytes read from the instruction memory encode
some combination of the register specifier byte and the constant
word.</p>
<ul>
<li>Byte 1 <strong>is split into register specifiers <code>rA</code> and
<code>rB</code> when the computed signal need_regids is 1</strong>. If
<code>need_regids</code> is 0, both register specifiers are set to
0xF(<code>RNONE</code>).</li>
</ul></li>
<li><p>The PC incrementer hardware unit generates the signal
<code>valP</code>, based on the current value of the PC, and the two
signals <code>need_regids</code> and <code>need_valC</code>. For PC
value <span class="math inline">\(p\)</span>, <code>need_regids</code>
value <span class="math inline">\(r\)</span>, and <code>need_valC</code>
value <span class="math inline">\(i\)</span>, the incrementer generates
the value <span class="math inline">\(p+1+r+8i\)</span>.</p></li>
</ul>
<h4 id="bdecode-and-write-back-stagess">  <span class="math inline">\(b.\)</span>Decode and write-back stagess</h4>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-15.png"></p>
<ul>
<li><p>The register file has four ports. It supports up to two
simultaneous reads(on ports A and B) and two simultaneous writes(on
ports E and M).</p>
<ul>
<li><p>Each port has <strong>both an address connection and a data
connection</strong>, where the address connection is a register ID, and
the data connection is a set of 64 wires serving as either an output
word (for a read port) or an input word (for a write port) of the
register file.</p></li>
<li><p>The two read ports have address inputs <code>srcA</code> and
<code>srcB</code>, while the two write ports have address inputs
<code>dstE</code> and <code>dstM</code>. The 0xF(<code>RNONE</code>) on
an address port indicates that no register should be accessed.</p></li>
</ul></li>
<li><p>The four blocks at the bottom generate <strong>the four different
register IDs</strong> for the register file based on <code>icode</code>,
<code>rA</code>, <code>rB</code> and <code>Cnd</code>.</p>
<ul>
<li><p><code>srcA</code> indicates which register should be read to
generate <code>valA</code>, so as <code>srcB</code>.</p></li>
<li><p><code>dstE</code> indicates <strong>the destination register for
write port E</strong>, where the computed value <code>valE</code> is
stored, so as <code>dstM</code>.</p></li>
</ul></li>
</ul>
<p>  The HCL description of <code>srcA</code> and <code>srcB</code> are
as below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word srcA = [</span><br><span class="line">    icode in &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ &#125; : rA;</span><br><span class="line">    icode in &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">    1 : RNONE; # Don&#x27;t need register</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word srcB = [</span><br><span class="line">    icode in &#123; IOPQ, IRMMOVQ, IMRMOVQ &#125; : rB;</span><br><span class="line">    icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    1 : RNONE; # Don&#x27;t need register</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>  The HCL description of <code>dstM</code> is as below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word dstM = [</span><br><span class="line">    icode in &#123; IMRMOVQ, IPOPQ &#125; : rA;</span><br><span class="line">    1 : RNONE; # Don&#x27;t write any register</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h4 id="cexecute-stage">  <span class="math inline">\(c.\)</span>Execute stage</h4>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-16.png"></p>
<ul>
<li><p>The stage includes ALU, which performs operations based on the
setting of <code>alufun</code> signal. The ALU output becomes the signal
<code>valE</code>.</p></li>
<li><p>The value of <code>aluA</code> can be <code>valA</code>,
<code>valC</code>, or either ?8 or +8, depending on the instruction
type, so as <code>aluB</code></p></li>
</ul>
<p>  They can be described by the following HCL code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word aluA = [</span><br><span class="line">    icode in &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">    icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ &#125; : valC;</span><br><span class="line">    icode in &#123; ICALL, IPUSHQ &#125; : -8;</span><br><span class="line">    icode in &#123; IRET, IPOPQ &#125; : 8;</span><br><span class="line">    # Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word aluB = [</span><br><span class="line">    icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL,</span><br><span class="line">    IPUSHQ, IRET, IPOPQ &#125; : valB;</span><br><span class="line">    icode in &#123; IRRMOVQ, IIRMOVQ &#125; : 0;</span><br><span class="line">    # Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<ul>
<li>The operations in ALU is <strong>mostly an adder</strong>. However,
we want it to use the operation encoded in the <code>ifun</code> field
of the instruction. So we describe the ALU control as below:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word alufun = [</span><br><span class="line">    icode == IOPQ : ifun;</span><br><span class="line">    1 : ALUADD;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<ul>
<li>We only want to set the condition codes when an <code>OPq</code>
instruction is executed. The logic is described in HCL as below:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool set_cc = icode in &#123; IOPQ &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The hardware unit labeled "cond" uses <strong>a combination of
the condition codes and the function code</strong> to <strong>determine
whether a conditional branch or data transfer should take
place</strong>.</p>
<ul>
<li>It generates the <code>Cnd</code> signal used both for the setting
of <code>dstE</code> with conditional moves and in the next PC logic for
conditional branches.</li>
</ul></li>
</ul>
<p>  By using the <code>Cnd</code> signal, we can describe
<code>dstE</code> as below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word dstE = [</span><br><span class="line">    icode in &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">    icode in &#123; IIRMOVQ, IOPQ&#125; : rB;</span><br><span class="line">    icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    1 : RNONE; # Don&#x27;t write any register</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h4 id="dmemorystage">  <span class="math inline">\(d.\)</span>Memory
stage</h4>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-17.png"></p>
<ul>
<li><p>Two control blocks generate the values for the memory address and
the memory input data(for write operations).</p></li>
<li><p>Two other blocks generate the control signals indicating
<strong>whether to perform a read or a write
operation</strong>.</p></li>
<li><p>When a read operation is performed, <strong>the data memory
generates the value <code>valM</code></strong>.</p></li>
</ul>
<p>  The HCL description of <code>mem_addr</code> and
<code>mem_data</code> are as below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word mem_addr = [</span><br><span class="line">    icode in &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ &#125; : valE;</span><br><span class="line">    icode in &#123; IPOPQ, IRET &#125; : valA;</span><br><span class="line">    # Other instructions don&#x27;t need address</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word mem_data = [</span><br><span class="line">    # Value from register</span><br><span class="line">    icode in &#123; IRMMOVQ, IPUSHQ &#125; : valA;</span><br><span class="line">    # Return PC</span><br><span class="line">    icode == ICALL : valP;</span><br><span class="line">    # Default: Don&#x27;t write anything</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<ul>
<li>We set the signal <code>mem_read</code> only for instructions that
read data from memory, so as <code>mem_write</code>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool mem_read = icode in &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool mem_write = icode in &#123; IRMMOVQ, IPUSHQ, ICALL &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>A final function for the memory stage is to compute the status code
<code>Stat</code>. It is generated from <code>icode</code>,
<code>imem_error</code>, <code>instr_valid</code> and
<code>dmem_error</code>. It's described in HCL as below:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Determine instruction status</span><br><span class="line">word Stat = [</span><br><span class="line">    imem_error || dmem_error : SADR;</span><br><span class="line">    !instr_valid: SINS;</span><br><span class="line">    icode == IHALT : SHLT;</span><br><span class="line">    1 : SAOK;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h4 id="epcupdate-stage">  <span class="math inline">\(e.\)</span>PC
update stage</h4>
<p><img src="/2024/07/25/4-3-Sequential-Y86-64-Implementation/image-18.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word new_pc = [</span><br><span class="line">    # Call. Use instruction constant</span><br><span class="line">    icode == ICALL : valC;</span><br><span class="line">    # Taken branch. Use instruction constant</span><br><span class="line">    icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">    # Completion of RET instruction. Use value from stack</span><br><span class="line">    icode == IRET : valM;</span><br><span class="line">    # Default: Use incremented PC</span><br><span class="line">    1 : valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 4.Processor Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>4.2.Logical Design and the HCL</title>
    <url>/2024/07/24/4-2-Logical-Design-and-the-HCL/</url>
    <content><![CDATA[<h1 id="42logical-design-and-the-hcl"><span class="math inline">\(4.2.\)</span>Logical Design and the HCL</h1>
<h3 id="1combinationalcircuits-amp-hcl-boolean-expressions">1.Combinational
Circuits &amp; HCL Boolean Expressions</h3>
<p>  By assembling a number of logic gates into a network, we can
construct computational blocks known as <em>combinational circuits</em>.
There are several restrictions:</p>
<ol type="1">
<li><p>Every logic gate input must be connected to exactly one of the
following:</p>
<ol type="1">
<li><p>one of the system inputs (known as a <em>primary
input</em>)</p></li>
<li><p>the output connection of some memory element</p></li>
<li><p>the output of some logic gate.</p></li>
</ol></li>
<li><p>The outputs of two or more logic gates cannot be connected
together. <strong>Otherwise, the two could try to drive the wire toward
different voltages</strong>, possibly causing an invalid voltage or a
circuit malfunction.</p></li>
<li><p>The network must be acyclic. That is, there cannot be a path
through a series of gates that forms a loop in the network.</p></li>
</ol>
<p>  The following shows an example of a combinational circuit:</p>
<p><img src="/2024/07/24/4-2-Logical-Design-and-the-HCL/image.png"></p>
<p>  The network is written in HCL as:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b)</span><br></pre></td></tr></table></figure>
<p>  The HCL uses C-sytle syntax. However, we don't view the code as
performing a computation and assigning the result to some memory
location. Instead, it is simply a way to <strong>give a name to an
expression</strong>.</p>
<p>  There are some other differences that are worth noting:</p>
<ul>
<li><p>The combinational circuit has the property that the outputs
continually respond to changes in the inputs. By contrast, a C
expression <strong>is only evaluated when it is encountered</strong>
during the execution of a program.</p></li>
<li><p>The combinational circuit only operates over the bit value 0 and
1.</p></li>
<li><p>Logical expressions in C have the property that <strong>they
might only be partially evaluated</strong>. If the outcome of an and or
or operation can be determined by just evaluating the first argument,
then the second argument will not be evaluated. In contrast,
combinational logic <strong>doesn't have any partial evaluation
rules</strong>.</p></li>
</ul>
<h3 id="2word-levelcombinational-circuits-and-hcl-integer-expression">2.Word-Level
Combinational Circuits and HCL Integer Expression</h3>
<p>  Combinational circuits that perform word-level computations are
constructed using logic gates to compute the individual bits of the
output word, based on the individual bits of the input words. The
following circuit tests if two words A and B are equal:</p>
<p><img src="/2024/07/24/4-2-Logical-Design-and-the-HCL/image-1.png"></p>
<p>  HCL allows words to be compared for equality. So we can express the
circuit as <code>bool Eq = (A == B)</code></p>
<hr>
<p>  Multiplexing functions are described in HCL using <em>casing
expressions</em>. A case expressions has the following general form:</p>
<p><span class="math display">\[
\begin{bmatrix}
\text{select}_1 : \text{expr}_1; \\
\text{select}_2 : \text{expr}_2; \\
\vdots \\
\text{select}_k : \text{expr}_k;
\end{bmatrix}
\]</span></p>
<ul>
<li><p><span class="math inline">\(select_i\)</span> indicates when this
case should be selected.</p></li>
<li><p>The integer expression <span class="math inline">\(expr_i\)</span> indicates the resulting
value.</p></li>
<li><p>The selection expressions can be <strong>arbitrary Boolean
expressions</strong>, and there can be <strong>an arbitrary number of
cases</strong>.</p></li>
</ul>
<p>  Logically, the selection expressions are evaluated in sequence, and
the case <strong>for the first one yielding 1 is selected</strong>.</p>
<p>  For example, the figure below shows the circuit of the word-level
multiplexor:</p>
<p><img src="/2024/07/24/4-2-Logical-Design-and-the-HCL/image-2.png"></p>
<p>  it can be expressed in HCL as:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word Out = [</span><br><span class="line">    s: A;</span><br><span class="line">    1: B;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>  And a 4-way multiplexor can be expressed in HCL as:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word Out4 = [</span><br><span class="line">    !s1 &amp;&amp; !s0: A; </span><br><span class="line">    !s1       : B;</span><br><span class="line">    !s0       : C;</span><br><span class="line">    1         : D; </span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>  If we want to design a logic circuit that finds the minimum value
among a set of words A, B and C, we can write the following HCL
program:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word MIN3 = [</span><br><span class="line">    A &lt;= B &amp;&amp; A &lt;= C: A;</span><br><span class="line">    B &lt;= A &amp;&amp; B &lt;= C: B;</span><br><span class="line">    1               : C;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h3 id="3set-membership">3.Set Membership</h3>
<p>  The general form of a set membership test is:</p>
<p><span class="math display">\[
\text{iexpr} \in \{\text{iexpr}_1, \text{iexpr}_2, \ldots,
\text{iexpr}_k\}
\]</span></p>
<p>  where the value being tested(<span class="math inline">\(iexpr\)</span>) and the candidate matches(<span class="math inline">\(iexpr_1\)</span> through <span class="math inline">\(iexpr_k\)</span>) are <strong>all integer
expressions</strong>.</p>
<h3 id="4memory-and-clock">4.Memory and Clock</h3>
<h4 id="asummary">  <span class="math inline">\(a.\)</span>Summary</h4>
<p>  Combinational circuits don't store any information, they simply
react to the signals at their inputs. So we must introduce devices that
<strong>store information represented as bits</strong>.</p>
<p>  Our storage devices are all controlled by a single clock, a
periodic signal that <strong>determines when new values are to be loaded
into the devices</strong>.</p>
<p>  We consider two classes of memory devices:</p>
<ul>
<li><p><em>Clocked registers(simple registers)</em>: It stores
individual bits or words. <strong>The clock signal controls the loading
of the register with the value at its input</strong>.</p>
<ul>
<li>Our Y86-64 processors will use clocked registers to hold the program
counter(PC), the condition codes(CC), and the program status(Stat).</li>
</ul></li>
<li><p><em>Random access memories</em>(<em>simply memories</em>):It
store multiple words, <strong>using an address to select which word
should be read or written</strong>.</p>
<ul>
<li><p>Examples of random access memories include</p>
<ul>
<li><p>the virtual memory system of a processor, where a combination of
hardware and operating system software make it appear to a processor
that it can access any word within a large address space;</p></li>
<li><p>the register file, where register identifiers serve as the
addresses.</p></li>
</ul></li>
<li><p>In a Y86-64 processor, <strong>the register file holds the 15
program registers</strong>(<code>%rax</code> through
<code>%r14</code>).</p></li>
</ul></li>
</ul>
<blockquote>
<p>In hardware, a register <strong>is directly connected to the rest of
the circuit by its input and output wires</strong>. In machine-level
programming, the registers <strong>represent a small collection of
addressable words in the CPU</strong>, where <strong>the addresses
consist of register IDs</strong>.</p>
</blockquote>
<p>  The following figure shows the detailed register operation:</p>
<p><img src="/2024/07/24/4-2-Logical-Design-and-the-HCL/image-3.png"></p>
<p>  In the figure, the register serves as <strong>barriers between the
combinational logic</strong> in different parts of the circuit.</p>
<h4 id="bregister-file">  <span class="math inline">\(b.\)</span>Register file</h4>
<p>  The following g diagram shows a typical register file:</p>
<p><img src="/2024/07/24/4-2-Logical-Design-and-the-HCL/image-4.png"></p>
<ul>
<li><p>The <em>multiported</em> RAM allows <strong>multiple read and
write operations to take place simultaneously</strong>.</p></li>
<li><p>Each port has an <em>address input</em>, indicating <strong>which
program register should be selected</strong>, and a <em>data output or
input</em> <strong>giving a value for that program
register</strong>.</p></li>
<li><p>Every time the clock rises, the value on input <code>valW</code>
is written to the program register indicated by the register ID on input
<code>dstW</code>.</p>
<ul>
<li>When <code>dstW</code> is set to <code>0xF</code>, no program
register is written.</li>
</ul></li>
</ul>
<h4 id="cdatamemory">  <span class="math inline">\(c.\)</span>Data
memory</h4>
<p>  The Data memory is used to store program data:</p>
<p><img src="/2024/07/24/4-2-Logical-Design-and-the-HCL/image-5.png"></p>
<ul>
<li><p>This memory has a single address input, a data input for writing,
and a data output for reading.</p></li>
<li><p>We set <code>address</code> to the desired address,
<code>data in</code> to the desired value.</p></li>
<li><p>The <code>error</code> signal will be set to 1 if the
<code>address</code> is out of range.</p></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 4.Processor Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>4.1.Y86-64 Instruction Set Architecture</title>
    <url>/2024/07/24/4.1.Y86-64-Instruction-Set-Architecture/</url>
    <content><![CDATA[<h1 id="41y86-64-instruction-setarchitecture"><span class="math inline">\(4.1.\)</span>Y86-64 Instruction Set
Architecture</h1>
<h3 id="1programmer-visible-state">1.Programmer-Visible State</h3>
<p>  The programmer-visible state is where the programmer can generate
machine-level code.</p>
<p><img src="/2024/07/24/4.1.Y86-64-Instruction-Set-Architecture/image.png"></p>
<ul>
<li>The <code>Stat</code> indicates the overall state of program
execution. It will indicate either normal operation or that some sort of
exception has occurred.</li>
</ul>
<h3 id="2y86-64-instruction-set">2.Y86-64 Instruction Set</h3>
<p><img src="/2024/07/24/4.1.Y86-64-Instruction-Set-Architecture/image-1.png"></p>
<ul>
<li><p>The integer operation instructions operate only on register data.
This instructions set the three condition codes <code>ZF</code>,
<code>SF</code>, and <code>OF</code> (zero, sign, and
overflow).</p></li>
<li><p>The <code>call</code> instruction <strong>pushes the return
address on the stack</strong> and <strong>jumps to the destination
address</strong>. The <code>ret</code> instruction returns from such a
call.</p></li>
<li><p>The <code>halt</code> instruction stops instruction execution,
and the status code is set to <code>HLT</code>.</p></li>
</ul>
<h3 id="3instruction-encoding">3.Instruction Encoding</h3>
<p><img src="/2024/07/24/4.1.Y86-64-Instruction-Set-Architecture/image-1.png"></p>
<p><img src="/2024/07/24/4.1.Y86-64-Instruction-Set-Architecture/image-2.png"></p>
<ul>
<li>Every instruction has an <strong>initial byte identifying the
instruction type</strong>. This byte is split into two 4-bit parts: the
high-order, or code, part, and the low-order, or function, part.</li>
</ul>
<p>  Instructions that need operands have longer encodings:</p>
<ul>
<li><p>There can be an additional register specifier byte
<strong>specifying either one or two registers</strong>. These register
fields are called <code>rA</code> and <code>rB</code> in figure
above.</p>
<ul>
<li><p>Instructions that have no register operands do not have a
register specifier byte.</p></li>
<li><p>Those that require just one register operand have the other
register specifier set to 0xF.</p></li>
</ul></li>
<li><p>Some instructions require an additional 8-byte constant word.
This word can serve as the immediate data for <code>irmovq</code>, the
displacement for <code>rmmovq</code> and <code>mrmovq</code> address
specifiers, and the destination of branches and calls.</p>
<ul>
<li>Note that branch and call destinations are given as <strong>absolute
addresses</strong>, rather than using the PC-relative addressing seen in
x86-64.</li>
</ul></li>
</ul>
<p><img src="/2024/07/24/4.1.Y86-64-Instruction-Set-Architecture/image-3.png"></p>
<ul>
<li>The program registers are stored within the CPU in a register file,
a small random access memory where <strong>the register IDs serve as
addresses</strong>.</li>
</ul>
<p>  Let's take the instruction
<code>rmmovq %rsp, 0x123456789abcd(%rdx)</code> as an example:</p>
<ol type="1">
<li><p><code>rmmovq</code> has initial byte <code>40</code>.</p></li>
<li><p>The source register <code>%rsp</code> is encoded in
<code>rA</code> field, and base register <code>%rdx</code> is encoded in
<code>rB</code> field. So we get the register specifier byte of
<code>42</code>.</p></li>
<li><p>The displacement is encoded in the 8-byte constant word:
<code>00 01 23 45 67 89 ab cd</code>, and we write it in byte-reversed
order.</p></li>
</ol>
<p>  So the final result is <code>4042cdab896745230100</code>.</p>
<ul>
<li><p>One important property of any instruction set is that <strong>the
byte encodings must have a unique interpretation</strong>. An arbitrary
sequence of bytes either encodes a unique instruction sequence or is not
a legal byte sequence</p>
<ul>
<li>This property ensures that a processor can execute an object-code
program without any ambiguity about the meaning of the code. However, if
we do not know the starting position of a code sequence, we cannot
reliably determine how to split the sequence into individual
instructions.</li>
</ul></li>
</ul>
<h3 id="4exceptions">4.Exceptions</h3>
<p>  The programmer-visible state includes a status code
<code>Stat</code> describing the overall state of the executing program.
The possible values for this code are as below:</p>
<p><img src="/2024/07/24/4.1.Y86-64-Instruction-Set-Architecture/image-4.png"></p>
<ul>
<li><p>The <code>ADR</code>indicates that the processor attempted to
read from or write to an invalid memory address, either while fetching
an instruction or while reading or writing data.</p>
<ul>
<li>We limit the maximum address, and <strong>any access to an address
beyond this limit will trigger an ADR exception</strong>.</li>
</ul></li>
</ul>
<h3 id="5y86-64-programs">5.Y86-64 Programs</h3>
<p>  Take the following C program as an example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> *start, <span class="type">long</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += *start;</span><br><span class="line">        start++;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  the x86-64 and Y86-64 assembly code are as below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># x86-64 ver</span><br><span class="line"># long sum(long *start, long count)</span><br><span class="line"># start in %rdi, count in %rsi</span><br><span class="line">sum:</span><br><span class="line">    movl $0, %eax        # sum = 0</span><br><span class="line">    jmp .L2              # Goto test</span><br><span class="line">.L3:                     # loop:</span><br><span class="line">    addq (%rdi), %rax    # Add *start to sum</span><br><span class="line">    addq $8, %rdi        # start++</span><br><span class="line">    subq $1, %rsi        # count--</span><br><span class="line">.L2:                     # test:</span><br><span class="line">    testq %rsi, %rsi     # Test sum</span><br><span class="line">    jne .L3              # If !=0, goto loop</span><br><span class="line">    rep; ret             # Return</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Y86-64 ver</span><br><span class="line"># long sum(long *start, long count)</span><br><span class="line"># start in %rdi, count in %rsi</span><br><span class="line">sum:</span><br><span class="line">    irmovq $8,%r8       # Constant 8</span><br><span class="line">    irmovq $1,%r9       # Constant 1</span><br><span class="line">    xorq %rax,%rax      # sum = 0</span><br><span class="line">    andq %rsi,%rsi      # Set CC</span><br><span class="line">    jmp test            # Goto test</span><br><span class="line">loop:</span><br><span class="line">    mrmovq (%rdi),%r10  # Get *start</span><br><span class="line">    addq %r10,%rax      # Add to sum</span><br><span class="line">    addq %r8,%rdi       # start++</span><br><span class="line">    subq %r9,%rsi       # count--. Set CC</span><br><span class="line">test:</span><br><span class="line">    jne loop            # Stop when 0</span><br><span class="line">    ret                 # Return</span><br></pre></td></tr></table></figure>
<p>  The Y86-64 codes have the following differences:</p>
<ol type="1">
<li><p>The Y86-64 code <strong>loads constants into registers</strong>
(lines 2�C3), since it cannot use immediate data in arithmetic
instructions.</p></li>
<li><p>The Y86-64 code requires two instructions (lines 8�C9) to
<strong>read a value from memory and add it to a
register</strong>.</p></li>
</ol>
<p>  The following shows a complete program file written in Y86-64
assembly code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.pos 0                                      # Execution begins at address 0</span><br><span class="line">irmovq stack, %rsp                          # Set up stack pointer</span><br><span class="line">call main                                   # Execute main program</span><br><span class="line">halt                                        # Terminate program</span><br><span class="line"></span><br><span class="line">.align 8                                    # Array of 4 elements</span><br><span class="line">array:</span><br><span class="line">.quad 0x000d000d000d</span><br><span class="line">.quad 0x00c000c000c0</span><br><span class="line">.quad 0x0b000b000b00</span><br><span class="line">.quad 0xa000a000a000</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">irmovq array, %rdi</span><br><span class="line">irmovq $4, %rsi</span><br><span class="line">call sum                                    # sum(array, 4)</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">sum:                                        # long sum(long *start, long count)</span><br><span class="line">irmovq $8, %r8                              # Constant 8</span><br><span class="line">irmovq $1, %r9                              # Constant 1</span><br><span class="line">xorq %rax, %rax                             # sum = 0</span><br><span class="line">andq %rsi, %rsi                             # Set CC</span><br><span class="line">jmp test                                    # Goto test</span><br><span class="line">loop:</span><br><span class="line">mrmovq (%rdi), %r10                         # Get *start</span><br><span class="line">addq %r10, %rax                             # Add to sum</span><br><span class="line">addq %r8, %rdi                              # start++</span><br><span class="line">subq %r9, %rsi                              # count--. Set CC</span><br><span class="line">test:</span><br><span class="line">jne loop                                    # Stop when 0</span><br><span class="line">ret                                         # Return</span><br><span class="line"></span><br><span class="line">.pos 0x200                                  # Stack starts here and grows to lower addresses</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Words beginning with '.' are assembler directives telling the
assembler to <strong>adjust the address at which it is generating code
or to insert some words of data</strong>.</p>
<ul>
<li><p>The directive <code>.pos 0</code> indicates that <strong>the
assembler should begin generating code starting at address
0</strong>.</p></li>
<li><p>The next instruction <code>irmovq stack, %rsp</code> initializes
the stack pointer.</p>
<ul>
<li>The label <code>stack</code> is declared at the end of the program,
to indicate address 0x200 using a .pos directive. Our stack will
therefore <strong>start at this address and grow toward lower
addresses</strong>.</li>
</ul></li>
<li><p>The label <code>array</code> denotes the start of this array, and
is aligned on an 8-byte boundary using the <code>.align</code>
directive. The array stores 4 words.</p></li>
</ul></li>
</ul>
<p>  Since our only tool for creating Y86-64 code is an assembler, the
programmer must perform tasks we ordinarily delegate to the compiler,
linker, and run-time system.</p>
<p>  The <code>YIS</code> tools is used to simulate the execution of the
Y86-64 machine-code program. If we run our object code on
<code>YIS</code>, we will get the following output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stopped in 34 steps at PC = 0x13. Status &#x27;HLT&#x27;, CC Z=1 S=0 O=0</span><br><span class="line">Changes to registers:</span><br><span class="line">%rax:   0x0000000000000000 0x0000abcdabcdabcd</span><br><span class="line">%rsp:   0x0000000000000000 0x0000000000000200</span><br><span class="line">%rdi:   0x0000000000000000 0x0000000000000038</span><br><span class="line">%r8:    0x0000000000000000 0x0000000000000008</span><br><span class="line">%r9:    0x0000000000000000 0x0000000000000001</span><br><span class="line">%r10:   0x0000000000000000 0x0000a000a000a000</span><br><span class="line"></span><br><span class="line">Changes to memory:</span><br><span class="line">0x01f0: 0x0000000000000000 0x0000000000000055</span><br><span class="line">0x01f8: 0x0000000000000000 0x0000000000000013</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The first line of the simulation output summarizes the execution
and the resulting values of the PC and program status.</p></li>
<li><p>The original values of the register are shown on the
left.</p></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 4.Processor Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>3.11.Floating-Point Code</title>
    <url>/2024/07/19/3-11-Floating-Point-Code/</url>
    <content><![CDATA[<h1 id="311floating-point-code"><span class="math inline">\(3.11.\)</span>Floating-Point Code</h1>
<h3 id="1floating-pointmovement-and-conversion-operations">1.Floating-Point
Movement and Conversion Operations</h3>
<h4 id="abasic-instructions">  <span class="math inline">\(a.\)</span>Basic instructions</h4>
<ul>
<li><p>For floating-point, the data are held either in memory (indicated
in the table as <span class="math inline">\(M_{32}\)</span> and <span class="math inline">\(M_{64}\)</span>) or in XMM registers (shown in the
table as <code>X</code>).</p>
<ul>
<li>Each YMM register is 32 bytes long. When operating on scalar data,
these registers only hold floating-point data, and <strong>only the
low-order 32 bits (for float) or 64 bits (for double) are
used</strong>.</li>
</ul></li>
</ul>
<p><img src="/2024/07/19/3-11-Floating-Point-Code/image.png"></p>
<hr>
<p><img src="/2024/07/19/3-11-Floating-Point-Code/image-1.png"></p>
<ul>
<li>The 'a' stands for 'aligned'.</li>
</ul>
<hr>
<p><img src="/2024/07/19/3-11-Floating-Point-Code/image-2.png"></p>
<p><img src="/2024/07/19/3-11-Floating-Point-Code/image-3.png"></p>
<ul>
<li>When converting floating-point values to integers, the two-operand
floating-point conversion operations <strong>perform truncation,
rounding values toward zero</strong>.</li>
</ul>
<p>  For three-operand floating-point conversion operations, we can
<strong>ignore the second operand, since its value only affects the
upper bytes of the result</strong>. In common use, both the second
source and the destination oprands are identical:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vcvtsi2sdq %rax, %xmm1, %xmm1</span><br></pre></td></tr></table></figure>
<p>  This instruction reads a long integer from register
<code>%rax</code>, converts it to data type double, and <strong>stores
the result in the lower bytes of XMM register
<code>%xmm1</code></strong>.</p>
<h4 id="bconversion-between-floating-point">  <span class="math inline">\(b.\)</span>Conversion between floating-point</h4>
<p>  To convert between two different floating-point format, suppose the
low-order 4 bytes of <code>%xmm0</code> hold a single-precision value;
then it would seem straightforward to convert this to a double-precision
value and store the result in the lower 8 bytes of register
<code>%xmm0</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vcvtss2sd %xmm0, %xmm0, %xmm0</span><br></pre></td></tr></table></figure>
<p>  However, GCC will generate the following code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Conversion from single to double precision</span><br><span class="line">vunpcklps %xmm0, %xmm0, %xmm0   # Replicate first vector element</span><br><span class="line">vcvtps2pd %xmm0, %xmm0          # Convert two vector elements to double</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The <code>vunpcklps</code> instruction <strong>interleaves the
values in two XMM registers and store them in a third</strong>. That is,
if one source register contains words <span class="math inline">\([s_3,
s_2, s_1, s_0]\)</span> and the other contains words <span class="math inline">\([d_3, d_2, d_1, d_0]\)</span>, then the value of
the destination register will be <span class="math inline">\([s_1, d_1,
s_0, d_0]\)</span>.</p></li>
<li><p>The <code>vcvtps2pd</code> instruction <strong>expands the two
low-order single precision values in the source XMM register to be the
two double-precision values in the destination XMM register</strong>.
Applying this to the result of the preceding <code>vunpcklps</code>
instruction would give values <span class="math inline">\([dx_0,dx_0]\)</span>, where <span class="math inline">\(dx_0\)</span> is the result of converting <span class="math inline">\(x\)</span> to double precision.</p></li>
</ul>
<p>  GCC generates similar code for converting from double precision to
single precision:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Conversion from double to single precision</span><br><span class="line">vmovddup %xmm0, %xmm0    # Replicate first vector element</span><br><span class="line">vcvtpd2ps %xmm0, %xmm0  # Convert two vector elements to single</span><br></pre></td></tr></table></figure>
<p>  rather than by using the single instruction:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vcvtsd2ss %xmm0, %xmm0, %xmm0</span><br></pre></td></tr></table></figure>
<h3 id="2floating-point-code-inprocedure">2.Floating-Point Code in
Procedure</h3>
<p><img src="/2024/07/19/3-11-Floating-Point-Code/image.png"></p>
<p>  The following conventions are observed:</p>
<ul>
<li><p>Up to eight floating-point arguments can be passed in XMM
registers <code>%xmm0~%xmm7</code>. These registers are used in the
order the arguments are listed. Additional floating-point arguments can
be passed on the stack.</p></li>
<li><p>A function that returns a floating-point value does so in
register <code>%xmm0</code>.</p></li>
<li><p><strong>All XMM registers are caller saved</strong>. The callee
may overwrite any of these registers without first saving it.</p></li>
</ul>
<p>  When a function contains a combination of pointer, integer, and
floating-point arguments, the pointers and integers are passed in
general-purpose registers, while the floating-point values are passed in
XMM registers. This means that <strong>the mapping of arguments to
registers depends on both their types and their ordering</strong>.</p>
<p>  <span class="math inline">\(e.g.\)</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">g1</span><span class="params">(<span class="type">double</span> a, <span class="type">long</span> b, <span class="type">float</span> c, <span class="type">int</span> d)</span></span><br></pre></td></tr></table></figure>
<p>  Registers: <code>a</code> in <code>%xmm0</code>, <code>b</code> in
<code>%rdi</code>, <code>c</code> in<code>%xmm1</code>, <code>d</code>
in <code>%esi</code>.</p>
<h3 id="3floating-pointarithmetic-operations">3.Floating-Point
Arithmetic Operations</h3>
<p><img src="/2024/07/19/3-11-Floating-Point-Code/image-4.png"></p>
<ul>
<li><p>The first source operand S1 can be <strong>either an XMM register
or a memory location</strong>.</p></li>
<li><p>The second source operand and the destination operands
<strong>must be XMM registers</strong>.</p></li>
</ul>
<p>  Take the following C program as an example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct</span><span class="params">(<span class="type">double</span> a, <span class="type">float</span> x, <span class="type">double</span> b, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * x - b / i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># double funct(double a, float x, double b, int i)</span><br><span class="line"># a in %xmm0, x in %xmm1, b in %xmm2, i in %edi</span><br><span class="line"></span><br><span class="line">funct:</span><br><span class="line">    vunpcklps %xmm1, %xmm1, %xmm1  # Convert x to double</span><br><span class="line">    vcvtps2pd %xmm1, %xmm1         # Convert x to double</span><br><span class="line">    vmulsd %xmm0, %xmm1, %xmm0     # Multiply a by x</span><br><span class="line">    vcvtsi2sd %edi, %xmm1, %xmm1   # Convert i to double</span><br><span class="line">    vdivsd %xmm1, %xmm2, %xmm2     # Compute b/i</span><br><span class="line">    vsubsd %xmm2, %xmm0, %xmm0     # Subtract from a*x</span><br><span class="line">    ret                            # Return</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="/2024/07/19/3-11-Floating-Point-Code/image-5.png"></p>
<p>  Sometimes the bitwise operations are a useful way to manipulate
floating-point values. The following are some examples:</p>
<p>  <span class="math inline">\(a.\)</span>Taking absolute value:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmovsd .LC1(%rip), %xmm1</span><br><span class="line">vandpd %xmm1, %xmm0, %xmm0</span><br><span class="line"></span><br><span class="line">.LC1:</span><br><span class="line">    .long 4294967295</span><br><span class="line">    .long 2147483647</span><br><span class="line">    .long 0</span><br><span class="line">    .long 0</span><br></pre></td></tr></table></figure>
<p>  <span class="math inline">\(b.\)</span>Set value to zero:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vxorpd %xmm0, %xmm0, %xmm0</span><br></pre></td></tr></table></figure>
<p>  <span class="math inline">\(c.\)</span>Negate</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmovsd .LC2(%rip), %xmm1</span><br><span class="line">vxorpd %xmm1, %xmm0, %xmm0</span><br><span class="line"></span><br><span class="line">.LC2:</span><br><span class="line">    .long 0</span><br><span class="line">    .long -2147483648</span><br><span class="line">    .long 0</span><br><span class="line">    .long 0</span><br></pre></td></tr></table></figure>
<h3 id="4defining-andusing-floating-point-constants">4.Defining and
Using Floating-Point Constants</h3>
<p>  AVX floating-point operations cannot have immediate values as
oprands. Instead, the compiler must <strong>allocate and initialize
storage for any constant values</strong>.</p>
<p>  Take the following C program as an example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">cel2fahr</span><span class="params">(<span class="type">double</span> temp)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.8</span> * temp + <span class="number">32.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cel2fahr:</span><br><span class="line">vmulsd .LC2(%rip), %xmm0, %xmm0  # Multiply by 1.8</span><br><span class="line">vaddsd .LC3(%rip), %xmm0, %xmm0  # Add 32.0</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.LC2:</span><br><span class="line">.long 3435973837                 # Low-order 4 bytes of 1.8</span><br><span class="line">.long 1073532108                 # High-order 4 bytes of 1.8</span><br><span class="line"></span><br><span class="line">.LC3:</span><br><span class="line">.long 0                          # Low-order 4 bytes of 32.0</span><br><span class="line">.long 1077936128                 # High-order 4 bytes of 32.0</span><br></pre></td></tr></table></figure>
<p>  the function reads the value 1.8 from the memory location labeled
<code>.LC2</code> and the value 32.0 from the memory location labeled
<code>.LC3</code>.</p>
<h3 id="5floating-pointcomparison-operations">5.Floating-Point
Comparison Operations</h3>
<p><img src="/2024/07/19/3-11-Floating-Point-Code/image-6.png"></p>
<ul>
<li><p>These instructions are similar to the <code>cmp</code>
instructions for integer: they <strong>compare operands S1 and S2 and
set the condition codes to indicate their relative
values</strong>.</p></li>
<li><p>As with <code>cmpq</code>, they follow the ATT-format convention
of <strong>listing the operands in reverse order</strong>.</p></li>
<li><p>Argument S2 must be in <strong>an XMM register</strong>, while S1
can be <strong>either in an XMM register or in memory</strong>.</p></li>
</ul>
<p>  The floating-point comparison instructions set three condition
codes: the zero flag, the carry flag, and the parity flag:</p>
<p><img src="/2024/07/19/3-11-Floating-Point-Code/image-7.png"></p>
<ul>
<li><p>The parity flag is set when <strong>either operand is <span class="math inline">\(NaN\)</span></strong>.</p></li>
<li><p>By convention, <strong>any comparison in C is considered to fail
when one of the arguments is <span class="math inline">\(NaN\)</span></strong>, and this flag is used to
detect such a condition. For example, even the comparison
<code>x == x</code> yields 0 when x is <span class="math inline">\(NaN\)</span>.</p></li>
<li><p>The unordered case occurs when <strong>either operand is <span class="math inline">\(NaN\)</span></strong>.</p></li>
</ul>
<p>  There are also three relative jump statements:</p>
<ul>
<li><p><code>jp</code>: It conditionally jump when a floating-point
comparison <strong>yields an unordered result</strong>.</p></li>
<li><p><code>ja</code>: It conditionally jump when <code>CF=0</code> and
<code>ZF=0</code>.</p></li>
<li><p><code>jb</code>: It conditionally jump when
<code>CF=1</code></p></li>
</ul>
<p>  Take the following C program as an example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>NEG, ZERO, POS, OTHER&#125; <span class="type">range_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">range_t</span> <span class="title function_">find_range</span><span class="params">(<span class="type">float</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        result = NEG;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        result = ZERO;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">        result = POS;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = OTHER;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_range:</span><br><span class="line">    vxorps %xmm1, %xmm1, %xmm1  # Set %xmm1 = 0</span><br><span class="line">    vucomiss %xmm0, %xmm1       # Compare 0:x</span><br><span class="line">    ja .L5                      # If &gt;, goto neg</span><br><span class="line">    vucomiss %xmm1, %xmm0       # Compare x:0</span><br><span class="line">    jp .L8                      # If NaN, goto posornan</span><br><span class="line">    movl $1, %eax               # result = ZERO</span><br><span class="line">    je .L3                      # If =, goto done</span><br><span class="line">.L8: posornan:</span><br><span class="line">    vucomiss .LC0(%rip), %xmm0  # Compare x:0</span><br><span class="line">    setbe %al                   # Set result = NaN?1:0</span><br><span class="line">    movzbl %al, %eax            # Zero-extend</span><br><span class="line">    addl $2, %eax               # result += 2 (POS for &gt; 0, OTHER for NaN)</span><br><span class="line">    ret                         # Return</span><br><span class="line">.L5: neg:</span><br><span class="line">    movl $0, %eax               # result = NEG</span><br><span class="line">.L3: done:</span><br><span class="line">    rep; ret                    # Return</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 3.Machine-level Representation of Program</category>
      </categories>
  </entry>
  <entry>
    <title>3.10.Combining Control and Data in Machine-Level Programs</title>
    <url>/2024/07/18/3-10-Combining-Control-and-Data-in-Machine-Level-Programs/</url>
    <content><![CDATA[<h1 id="310combining-control-and-data-inmachine-level-programs"><span class="math inline">\(3.10.\)</span>Combining Control and Data in
Machine-Level Programs</h1>
<h3 id="1understanding-pointers">1.Understanding Pointers</h3>
<p>  Pointers serve as a uniform way to <strong>generate references to
elements</strong> within different data structures.</p>
<p>  They are some key principles of pointers:</p>
<ol type="1">
<li><p>Every pointer has an associated type. This type indicates
<strong>what kind of object the pointer points to</strong>. The
<code>void *</code> pointer represents a generic pointer.</p></li>
<li><p>Every pointer has a value. This value is <strong>an address of
some object of the designated type</strong>.</p></li>
<li><p>Pointers are created with the <code>&amp;</code> operator. This
operator can be applied to any C expression that is categorized as an
<em>lvalue</em>, meaning an expression that <strong>can appear on the
left side of an assignment</strong>.</p>
<ul>
<li>The operation is often realized by <code>leaq</code>.</li>
</ul></li>
<li><p>Pointers are dereferenced with the `*`` operator. It's
implemented by a memory reference.</p></li>
<li><p><em>Casting</em> the type of pointer <strong>don't change its
value</strong> but lead to other changes. One effect is to
<strong>change any scaling of pointer arithmetic</strong>.</p>
<ul>
<li>For example, if we have a char pointer with value <code>p</code>,
then <code>(int*)p + 7</code> computes <code>p + 28</code>, while
<code>(int*)(p + 7)</code> computes <code>p + 7</code>.</li>
</ul></li>
<li><p>Pointers can also point to functions, and the value of a function
pointer is <strong>the address of the first instruction in the
machine-code representatio</strong>n of the function.</p>
<ul>
<li>Take the following function as an example:</li>
</ul></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> *p)</span>;</span><br></pre></td></tr></table></figure>
<p>    and we declare a fucntions pointer <code>fp</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span> *);</span><br><span class="line">fp = fun;</span><br></pre></td></tr></table></figure>
<p>    Then we can use <code>fp</code> to invoke the function:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> result = fp(<span class="number">3</span>, &amp;y);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>The parentheses around <code>*fp</code> are
required</strong>, or it will be recognized as
<code>(int *) fp(int, int *)</code>, which is a function prototype.</p>
</blockquote>
<h3 id="2thwarting-buffer-overflowattacks">2.Thwarting Buffer Overflow
Attacks</h3>
<h4 id="abuffer-overflow-amp-attacks">  <span class="math inline">\(a.\)</span>Buffer overflow &amp; attacks</h4>
<p>  <em>Buffer overflow</em> is a specific type of out-of-bound memory
reference. A typical case of <em>buffer overflow</em> is that: some
character array is allocated on the stack to hold a string, but
<strong>the size of the string exceeds the space allocated for the
array</strong>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> *dest = s;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF)</span><br><span class="line">        *dest++ = c;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line">        <span class="comment">/* No characters read */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    *dest++ = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* Terminate string */</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read input line and write it back */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">/* Way too small! */</span></span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  The problem with <code>gets</code> is that <strong>it has no way to
determine whether sufficient space has been allocated to hold the entire
string</strong>. In our <code>echo</code> example, any string longer
than seven characters will cause an out-of-bounds write. This will
<strong>overwrite some of the information stored on the stack</strong>,
and as the string gets longer, the following information will get
corrupted.</p>
<ul>
<li><p>Buffer overflow is used to <strong>get a program to perform a
function that it would otherwise be unwilling to do</strong>.</p>
<ul>
<li>Typically, the program is fed with a string that contains the byte
encoding of some executable code, called the <em>exploit code</em>, plus
some extra bytes that <strong>overwrite the return address with a
pointer to the exploit code</strong>. The effect of executing the
<code>ret</code> instruction is then to <strong>jump to the exploit
code</strong>.</li>
</ul></li>
</ul>
<h4 id="bstack-randomization">  <span class="math inline">\(b.\)</span>Stack randomization</h4>
<p>  In order to insert exploit code into a system, the attacker needs
to inject <strong>both the code as well as a pointer</strong> to this
code as part of the attack string. Generating this pointer requires
<strong>knowing the stack address</strong> where the string will be
located.</p>
<ul>
<li><p>The idea of stack randomization is to <strong>make the position
of the stack vary from one run of a program to another</strong>. This is
implemented by <strong>allocating a random amount of space between 0 and
n bytes on the stack at the start of a program</strong>.</p>
<ul>
<li>for example, by using the allocation function <code>alloca</code>,
which allocates space for a specified number of bytes on the stack.
<strong>This allocated space is not used by the program, but it causes
all subsequent stack locations to vary from one execution of a program
to another</strong>.</li>
</ul></li>
</ul>
<p>  Stack randomization is one of a larger class of techniques known as
<strong>address-space layout randomization, or ASLR</strong>. With ASLR,
different parts of the program, including program code, library code,
stack, global variables, and heap data, <strong>are loaded into
different regions of memory each time a program is run</strong>.</p>
<h4 id="cstack-corruption-detection">  <span class="math inline">\(c.\)</span>Stack corruption detection</h4>
<p>  A second line of defense is to <strong>be able to detect when a
stack has been corrupted</strong>. It' hard to prevent the behavious,
however, the program can attempt to <strong>detect when such a write has
occurred before it can have any harmful effects</strong>.</p>
<ul>
<li><p>The GCC use a mechanisim known as a <em>stack protector</em> into
the generated code to detect buffer overruns.</p>
<ul>
<li><p>The idea is to <strong>store a special <em>canary value(guard
value)</em> in the stack frame between any local buffer and the rest of
the stack state</strong>. The value is generated randomly each time the
program runs:</p></li>
<li><p>Before restoring the register state and returning from the
function, <strong>the program checks if the canary has been altered by
some operation of this function or one that it has called</strong>. If
so, the program <strong>aborts with an error</strong>.</p></li>
</ul></li>
</ul>
<p><img src="/2024/07/18/3-10-Combining-Control-and-Data-in-Machine-Level-Programs/image.png"></p>
<p>  Recent version of GCC inserts this type of overflow detection
automatically. We have to give the command-line option
<code>-fno-stack-protector</code>.</p>
<p>  The following code uses the overflow detection techniques:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo:</span><br><span class="line">    subq $24, %rsp        # Allocate 24 bytes on stack</span><br><span class="line">    movq %fs:40, %rax     # Retrieve canary</span><br><span class="line">    movq %rax, 8(%rsp)    # Store on stack</span><br><span class="line">    xorl %eax, %eax       # Zero out register</span><br><span class="line">    movq %rsp, %rdi       # Compute buf as %rsp</span><br><span class="line">    call gets             # Call gets</span><br><span class="line">    movq %rsp, %rdi       # Compute buf as %rsp</span><br><span class="line">    call puts             # Call puts</span><br><span class="line">    movq 8(%rsp), %rax    # Retrieve canary</span><br><span class="line">    xorq %fs:40, %rax     # Compare to stored value</span><br><span class="line">    je .L9                # If =, goto ok</span><br><span class="line">    call __stack_chk_fail # Stack corrupted!</span><br><span class="line">.L9:</span><br><span class="line">    addq $24, %rsp        # Deallocate stack space</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>   The instruction argument <code>%fs:40</code> is an indication that
<strong>the canary value is read from memory using <em>segmented
addressing</em></strong>.</p>
<ul>
<li><p>By storing the canary in a special segment, it can be marked as
<strong>"read only"</strong>, so that an attacker cannot overwrite the
stored canary value.</p></li>
<li><p>Before restoring the register state and returning, the function
<strong>compares the value stored at the stack location with the canary
value</strong> (<strong>via the <code>xorq</code> instruction on line
11</strong>). <strong>A nonzero value indicates that the canary on the
stack has been modified</strong>, and so the code will call an error
routine.</p></li>
</ul>
<h4 id="dordering-rearrangement">  <span class="math inline">\(d.\)</span>Ordering rearrangement</h4>
<p>  <span class="math inline">\(e.g.\)</span>Let's discuss the
following C program:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">len</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iptoa</span><span class="params">(<span class="type">char</span> *s, <span class="type">long</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">long</span> val = *p;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%ld&quot;</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">intlen</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="type">long</span> v;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line">    v = x;</span><br><span class="line">    iptoa(buf, &amp;v);</span><br><span class="line">    <span class="keyword">return</span> len(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  And the following show portions of the code for
<code>intlen</code>, compiled both with and without stack protector:</p>
<p>  <span class="math inline">\(a.\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># int intlen(long x)</span><br><span class="line"># x in %rdi</span><br><span class="line">intlen:</span><br><span class="line">    subq $40, %rsp</span><br><span class="line">    movq %rdi, 24(%rsp)</span><br><span class="line">    leaq 24(%rsp), %rsi</span><br><span class="line">    movq %rsp, %rdi</span><br><span class="line">    call iptoa</span><br></pre></td></tr></table></figure>
<p>  <span class="math inline">\(b.\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># int intlen(long x)</span><br><span class="line"># x in %rdi</span><br><span class="line">intlen:</span><br><span class="line">    subq $56, %rsp</span><br><span class="line">    movq %fs:40, %rax</span><br><span class="line">    movq %rax, 40(%rsp)</span><br><span class="line">    xorl %eax, %eax</span><br><span class="line">    movq %rdi, 8(%rsp)</span><br><span class="line">    leaq 8(%rsp), %rsi</span><br><span class="line">    leaq 16(%rsp), %rdi</span><br><span class="line">    call iptoa</span><br></pre></td></tr></table></figure>
<p>  In the protected code, <strong>local variable <code>v</code> is
positioned closer to the top of the stack than
<code>buf</code></strong>, and so a<strong>n overrun of <code>buf</code>
will not corrupt the value of <code>v</code></strong>.</p>
<h4 id="elimiting-executable-code-regions">  <span class="math inline">\(e.\)</span>Limiting executable code regions</h4>
<p>  A final step is to eliminate the ability of an attacker to insert
executable code into a system. One method is to <strong>limit which
memory regions hold executable code</strong>. In typical programs,
<strong>only the portion of memory holding the code generated by the
compiler need be executable</strong>. <strong>The other portions can be
restricted to allow just reading and writing</strong>.</p>
<ul>
<li><p>Many systems allow control over three forms of access:
<strong>read</strong> (reading data from memory), <strong>write</strong>
(storing data into memory), and <strong>execute</strong> (treating the
memory contents as machine-level code).</p></li>
<li><p><code>AMD</code> introduced an <code>NX</code> (for "no-execute")
bit into the memory protection for its 64-bit processors,
<strong>separating the read and execute access modes</strong>. With this
feature, the stack can be marked as being readable and writable, but not
executable, and <strong>the checking of whether a page is executable is
performed in hardware</strong>, with no penalty in efficiency.</p></li>
</ul>
<h3 id="3variable-size-stack-frames">3.Variable-Size Stack Frames</h3>
<p>  Some functions require a variable amount of space that must be
allocated for their stack frames, such as a local array declared with
variable size:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">vframe</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> idx, <span class="type">long</span> *q)</span> &#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> *p[n];</span><br><span class="line">    p[<span class="number">0</span>] = &amp;i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        p[i] = q;</span><br><span class="line">    <span class="keyword">return</span> *p[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  To manage a variable-size stack frame, x86-64 code uses
<code>%rbp</code> to serve as a <em>frame pointer</em>(sometimes
referred to as a <em>base pointer</em>). When using a frame pointer, the
stack frame is organized as below:</p>
<p><img src="/2024/07/18/3-10-Combining-Control-and-Data-in-Machine-Level-Programs/image-1.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long vframe(long n, long idx, long *q)</span><br><span class="line"># n in %rdi, idx in %rsi, q in %rdx</span><br><span class="line"># Only portions of code shown</span><br><span class="line"></span><br><span class="line">vframe:</span><br><span class="line">    pushq %rbp      # Save old %rbp</span><br><span class="line">    movq %rsp, %rbp # Set frame pointer</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    leave           # Restore %rbp and %rsp</span><br><span class="line">    ret             # Return</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The code must save the previous version of <code>%rbp</code> on
the stack, since it is a callee-saved register. It then <strong>keeps
<code>%rbp</code> pointing to this position throughout the execution of
the function</strong>, and it references fixed-length local variables,
such as <code>i</code>, at <strong>offsets relative to
<code>%rbp</code></strong>.</p>
<ul>
<li>So the code start by pushing the current value of <code>%rbp</code>
onto the stack and setting %rbp to point to this stack position</li>
</ul></li>
<li><p>At the end of the function, the frame pointer is restored to its
previous value using the <code>leave</code> instruction. This
instruction takes no arguments. It is equivalent to executing the
following two instructions:</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq %rbp, %rsp     # Set stack pointer to beginning of frame</span><br><span class="line">popq %rbp           # Restore saved %rbp and set stack ptr</span><br><span class="line">                    # to end of caller��s frame</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 3.Machine-level Representation of Program</category>
      </categories>
  </entry>
  <entry>
    <title>3.9.Heterogeneous Data Structures</title>
    <url>/2024/07/17/3-9-Heterogeneous-Data-Structures/</url>
    <content><![CDATA[<h1 id="39heterogeneous-data-structures"><span class="math inline">\(3.9.\)</span>Heterogeneous Data Structures</h1>
<h3 id="1structures">1.Structures</h3>
<p>  The implementation of structures is similar to that of arrays: all
of the components of a structure are stored <strong>in a contiguous
region of memory</strong> and <strong>a pointer to a structure is the
address of its first byte</strong>.</p>
<p>  The compiler maintains information about each structure type
indicating <strong>the byte offset of each field</strong>.</p>
<ul>
<li>It generates references to structure elements <strong>using these
offsets as displacements</strong> in memory referencing
instructions.</li>
</ul>
<p>  For example, the structure below:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  is represented in memory like this:</p>
<p><img src="/2024/07/17/3-9-Heterogeneous-Data-Structures/image.png"></p>
<p>  and the compiler access the code by <strong>adding the appropriate
offset to the address of the structure</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Registers: r in %rdi</span><br><span class="line">movl (%rdi), %eax   # Get r-&gt;i</span><br><span class="line">movl %eax, 4(%rdi)  # Store in r-&gt;j</span><br></pre></td></tr></table></figure>
<ul>
<li>To generate a pointer to an object within a structure, we simply add
the field's offset to the structure address:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Registers: r in %rdi, i %rsi</span><br><span class="line">leaq 8(%rdi,%rsi,4), %rax    # Set %rax to &amp;r-&gt;a[i]</span><br></pre></td></tr></table></figure>
<p>  The selection of the different fields of a structure is handled
completely <strong>at compile time</strong>. The machine code contains
no information about the field declarations or the names of the
fields.</p>
<h3 id="2unions">2.Unions</h3>
<p>  Unions allow a single object to be referenced according to multiple
types. Rather than having the different fields reference different
blocks of memory, they all <strong>reference the same
block</strong>.</p>
<ul>
<li>The overall size of a union equals <strong>the maximum size of any
of its fields</strong>.</li>
</ul>
<p>  Unions are used in several cases:</p>
<ol type="1">
<li>We know in advance that the use of two different fields in a data
structure will be <strong>mutually exclusive</strong>.</li>
</ol>
<p>  For example, we can represent a binary tree using structure:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_s</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_s</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="type">double</span> data[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  which use 32 bytes. But if we use union:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">node_u</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">node_u</span> *<span class="title">left</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">node_u</span> *<span class="title">right</span>;</span></span><br><span class="line">    &#125; internal;</span><br><span class="line">    <span class="type">double</span> data[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  it will only take up 16 bytes.</p>
<p>  Moreover, to identify <code>leaf</code> with <code>internal</code>
node, we can use <strong>an enumerated type defining the different
possible choices for the union</strong>, and then create a structure
<strong>containing a tag field and the union</strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> N_LEAF, N_INTERNAL &#125; <span class="type">nodetype_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="type">nodetype_t</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">left</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">right</span>;</span></span><br><span class="line">        &#125; internal;</span><br><span class="line">        <span class="type">double</span> data[<span class="number">2</span>];</span><br><span class="line">    &#125; info;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// leaves</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">leaf</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">node_t</span>));</span><br><span class="line">    leaf-&gt;type = N_LEAF;</span><br><span class="line">    leaf-&gt;info.data[<span class="number">0</span>] = <span class="number">1.23</span>;</span><br><span class="line">    leaf-&gt;info.data[<span class="number">1</span>] = <span class="number">4.56</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// internal</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">internal</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">node_t</span>));</span><br><span class="line">    internal-&gt;type = N_INTERNAL;</span><br><span class="line">    internal-&gt;info.internal.left = leaf;</span><br><span class="line">    internal-&gt;info.internal.right = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>The union <strong>won't change the bit it stored according to
different types</strong>, even if the value is stored in one type but
access in another.</li>
</ol>
<p>  Say we convert a <code>double d</code> to an
<code>unsigned long</code> variable:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> u = (<span class="type">unsigned</span> <span class="type">long</span>) d;</span><br></pre></td></tr></table></figure>
<p>  Value <code>u</code> will be an integer representation of
<code>d</code>. Except for the case where <code>d</code> is
<code>0.0</code>, the bit representation of <code>u</code> will
<strong>be very different from that of <code>d</code></strong>.</p>
<p>  However, if we use unions:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">double2bits</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> u;</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.d = d;</span><br><span class="line">    <span class="keyword">return</span> temp.u;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  The result will be that <strong><code>u</code> will have the same
bit representation as <code>d</code></strong>, including fields for the
sign bit, the exponent, and the significand.</p>
<p>  And with this characteristic, we can design the following program
that gets the words of a double number:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">uu2double</span><span class="params">(<span class="type">unsigned</span> word0, <span class="type">unsigned</span> word1)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> u[<span class="number">2</span>];</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.u[<span class="number">0</span>] = word0; <span class="comment">// low-order 4 bytes</span></span><br><span class="line">    temp.u[<span class="number">1</span>] = word1; <span class="comment">// high-order 4 bytes</span></span><br><span class="line">    <span class="keyword">return</span> temp.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3data-alignment">3.Data Alignment</h3>
<p>  <em>Data alignment</em> is operation that <strong>enforce the
address of some objects must be a multiple of some valueK (typically 2,
4, or 8)</strong>.</p>
<p><img src="/2024/07/17/3-9-Heterogeneous-Data-Structures/image-1.png"></p>
<ul>
<li>The align operation can be declared by the following statement:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.align 8</span><br></pre></td></tr></table></figure>
<p>  This ensures that <strong>the data following it will start with an
address that is a multiple of 8</strong>.</p>
<p>  To do data alignment, the compiler uses these two techniques. Take
the following C struction as an example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><em>Byte gap</em>:</li>
</ol>
<p><img src="/2024/07/17/3-9-Heterogeneous-Data-Structures/image-2.png"></p>
<ol start="2" type="1">
<li><em>End padding</em>: This is to ensure that the latter data will
also be aligned:</li>
</ol>
<p><img src="/2024/07/17/3-9-Heterogeneous-Data-Structures/image-3.png"></p>
<blockquote>
<p><span class="math inline">\(p.s.\)</span>Each type of data has its
own alignment requirement, so we can minimize the wasted place by
<strong>rearrange the fields of structure</strong>. Note that <strong>we
don't have to make all variables applied to an only alignment
rule</strong>!</p>
</blockquote>
<p><span class="math inline">\(e.g.\)</span> The structure:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">short</span> d;</span><br><span class="line">    <span class="type">long</span> e;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line">    <span class="type">char</span> *h;</span><br><span class="line">&#125; rec;</span><br></pre></td></tr></table></figure>
<p>  is rearranged to the structure below:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> f;   <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="type">long</span> e;     <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="type">int</span> *a;     <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="type">char</span> *h;    <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="type">int</span> g;      <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="type">float</span> b;    <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="type">short</span> d;    <span class="comment">// 2 bytes</span></span><br><span class="line">    <span class="type">char</span> c;     <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="comment">// 3 bytes padding to make the total size a multiple of 8</span></span><br><span class="line">&#125; rec;</span><br></pre></td></tr></table></figure>
<p>  Following the strategy of <strong>putting the fields required for
larger alignment first</strong>.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 3.Machine-level Representation of Program</category>
      </categories>
  </entry>
  <entry>
    <title>3.8.Array Allocation and Access</title>
    <url>/2024/07/17/3-8-Array-Allocation-and-Access/</url>
    <content><![CDATA[<h1 id="38array-allocation-and-access"><span class="math inline">\(3.8.\)</span>Array Allocation and Access</h1>
<h3 id="1pointer-arithmetic">1.Pointer Arithmetic</h3>
<p>  Suppose the starting address of integer array <code>E</code> and
integer index <code>i</code> are stored in registers <code>%rdx</code>
and <code>%rcx</code>. Below are some assembly-code implementation of
array expressions, with the result being stored in either
<code>%eax</code>(for data) or register <code>%rax</code>(for
pointers):</p>
<p><img src="/2024/07/17/3-8-Array-Allocation-and-Access/image.png"></p>
<blockquote>
<p>The dereference of a pointer is through
<code>(register_name)</code>.</p>
</blockquote>
<blockquote>
<p>The final example shows that one can compute the difference of two
pointers within the same data structure, with the result being data
having type long and value equal to <strong>the difference of the two
addresses divided by the size of the data type</strong>.</p>
</blockquote>
<h3 id="2nested-arrays">2.Nested Arrays</h3>
<p>  The array elements are ordered in memory in row-major order:</p>
<p><img src="/2024/07/17/3-8-Array-Allocation-and-Access/image-1.png"></p>
<p>  Array element <code>M[i][j]</code> can be easily reached through a
series of arithmetic operations. For example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># A in %rdi, i in %rsi, and j in %rdx</span><br><span class="line">leaq (%rsi,%rsi,2), %rax  # Compute 3i</span><br><span class="line">leaq (%rdi,%rax,4), %rax  # Compute xA + 12i</span><br><span class="line">movl (%rax,%rdx,4), %eax  # Read from M[xA + 12i + 4]</span><br></pre></td></tr></table></figure>
<h3 id="3fixed-sized-arrays">3.Fixed-sized Arrays</h3>
<p>  The C compiler is able to make many optimizations for code
operating on multi-dimensional arrays of fixed size. Take the inner
product calculation program as an example. The original form is as
below:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compute i,k of fixed matrix product */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fix_prod_ele</span><span class="params">(fix_matrix A, fix_matrix B, <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        result += A[i][j] * B[j][k];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  The optimized C code is as below:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compute i,k of fixed matrix product */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fix_prod_ele_opt</span><span class="params">(fix_matrix A, fix_matrix B, <span class="type">long</span> i, <span class="type">long</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *Aptr = &amp;A[i][<span class="number">0</span>]; <span class="comment">/* Points to elements in row i of A */</span></span><br><span class="line">    <span class="type">int</span> *Bptr = &amp;B[<span class="number">0</span>][k]; <span class="comment">/* Points to elements in column k of B */</span></span><br><span class="line">    <span class="type">int</span> *Bend = &amp;B[N][k]; <span class="comment">/* Marks stopping point for Bptr */</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;                         <span class="comment">/* No need for initial test */</span></span><br><span class="line">        result += *Aptr * *Bptr; <span class="comment">/* Add next product to sum */</span></span><br><span class="line">        Aptr ++;                 <span class="comment">/* Move Aptr to next column */</span></span><br><span class="line">        Bptr += N;               <span class="comment">/* Move Bptr to next row */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (Bptr != Bend);      <span class="comment">/* Test for stopping point */</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  The optimization follows the following steps:</p>
<ol type="1">
<li><p>Generating a pointer, which we have named <code>Aptr</code>, that
points to successive elements in row <code>i</code> of
<code>A</code>.</p></li>
<li><p>Generating a pointer, which we have named <code>Bptr</code>, that
points to successive elements in column <code>k</code> of
<code>B</code>.</p></li>
<li><p>Generating a pointer, which we have named <code>Bend</code>, that
equals the value <code>Bptr</code> will have <strong>when it is time to
terminate the loop</strong>.</p></li>
</ol>
<p>  The key points of optimization are as below:</p>
<ol type="1">
<li><p>Decide the <strong>starting address and end address of the
array</strong>.</p></li>
<li><p>Decide <strong>how to move the address forward</strong>.</p></li>
</ol>
<p>  <span class="math inline">\(e.g.\)</span>The C program below:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set all diagonal elements to val */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fix_set_diag</span><span class="params">(fix_matrix A, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        A[i][i] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  With the properties:</p>
<ul>
<li><p>Starting address: <code>&amp;A[0][0]</code>.</p></li>
<li><p>Ending address: <code>&amp;A[N+1][0]</code>.</p></li>
<li><p>Moving stride: <code>index += N + 1</code>.</p></li>
</ul>
<p>  And the optimized program:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fix_set_diag_opt</span><span class="params">(fix_matrix A, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *Abase = &amp;A[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> iend = N * (N + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Abase[i] = val;</span><br><span class="line">        i += (N + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (i != iend);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4variable-size-arrays">4.Variable-Size Arrays</h3>
<p>  Programmers requiring variable-size arrays had to allocate storage
for these arrays using functions such as <code>malloc</code> or
<code>calloc</code>, and they had to explicitly encode the mapping of
multidimensional arrays into single-dimension ones via row-major
indexing.</p>
<p>  If we declare an array <code>int A[exp1][exp2]</code>, the
dimensions of the array are determined by evaluating the expressions
<code>expr1</code> and <code>expr2</code> <strong>at the time the
declaration is encountered</strong>.</p>
<p>  For example, the following C program:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">var_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">long</span> i, <span class="type">long</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  can be translated into the following assembly code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var_ele:</span><br><span class="line">    imulq %rdx, %rdi          # Compute n * i</span><br><span class="line">    leaq (%rsi,%rdi,4), %rax  # Compute xA + 4(n * i)</span><br><span class="line">    movl (%rax,%rcx,4), %eax  # Read from M[xA + 4(n * i) + 4 * j]</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>  <strong>Instead of using <code>leaq</code>, the dynamic version
must use <code>imul</code> to scale <code>i</code> by
<code>n</code></strong>. This is because we don't know the exact size of
array until encounter the declaration.</p>
<p>  The optimization of variable-size arrays is similar to that of the
fixed-size:</p>
<p>  For example, the C program:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">var_prod_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">int</span> B[n][n], <span class="type">long</span> i, <span class="type">long</span> k)</span> &#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        result += A[i][j] * B[j][k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  can be optimized as:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compute i,k of variable matrix product */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">var_prod_ele_opt</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">int</span> B[n][n], <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *Arow = A[i];</span><br><span class="line">    <span class="type">int</span> *Bptr = &amp;B[<span class="number">0</span>][k];</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += Arow[j] * *Bptr;</span><br><span class="line">        Bptr += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>We can see that <code>GCC</code> is able to recognize patterns that
arise when a program steps through the elements of a multidimensional
array, and generate the <strong>pointer-based code</strong> or the
<strong>array-based code</strong> to <strong>avoid direct multiple
calculation</strong>.</p>
</blockquote>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 3.Machine-level Representation of Program</category>
      </categories>
  </entry>
  <entry>
    <title>3.7.Procedure</title>
    <url>/2024/07/16/3-7-Procedures/</url>
    <content><![CDATA[<h1 id="37procedure"><span class="math inline">\(3.7.\)</span>Procedure</h1>
<h3 id="1procedure-in-a-highprospective">1.Procedure in A High
Prospective</h3>
<ul>
<li>Procedures are a key abstraction in software. They provide a way to
<strong>package code that implements some functionality with a
designated set of arguments and an optional return value</strong>.</li>
</ul>
<p>  Well-designed software uses procedures as an abstraction mechanism,
<strong>hiding the detailed implementation of some action</strong> while
p<strong>roviding a clear and concise interface definition of what
values will be computed and what effects the procedure will have on the
program state</strong>.</p>
<p>  To provide machine-level support for procedures, we need to take
the following aspect into consideration:</p>
<ol type="1">
<li><p><em>Passing control</em>.</p></li>
<li><p><em>Passing data</em>.</p></li>
<li><p><em>Allocating and deallocating memory</em>.</p></li>
</ol>
<h3 id="2the-run-time-stack">2.The Run-time Stack</h3>
<ul>
<li><p>A program can manage the storage required by its procedures using
a stack, where the stack and the program registers <strong>store the
information required for passing control and data, and for allocating
memory</strong>. As P calls Q, <strong>control and data information are
added to the end of the stack</strong>. This information <strong>gets
deallocated when P returns</strong>.</p></li>
<li><p>When an x86-64 procedure requires storage beyond what it can hold
in registers, it <strong>allocates space on the stack</strong>. This
region is referred to as the procedure's <strong>stack
frame</strong>.</p>
<ul>
<li>When procedure P calls procedure Q, it will <strong>push the return
address onto the stack</strong>, indicating where <strong>within P the
program should resume</strong> execution once Q returns. We consider the
return address to be <strong>part of P's stack frame</strong>, since it
holds state relevant to P.</li>
</ul></li>
</ul>
<p>  The stack frames for most procedures are <strong>of fixed
size</strong>, allocated at the beginning of the procedure. Some
procedures, however, require variable-size frames.</p>
<h3 id="3control-transfer">3.Control Transfer</h3>
<ul>
<li><p>Passing control from function P to function Q involves simply
<strong>setting the program counter (PC) to the starting address of the
code for Q</strong>. This information is recorded in x86-64 machines by
invoking procedure Q with the instruction <code>call Q</code>.</p>
<ul>
<li>This instruction <strong>pushes an address A onto the stack</strong>
and <strong>sets the PC to the beginning of Q</strong>. The pushed
address A is referred to as <strong>the return address</strong> and is
computed as <strong>the address of the instruction immediately following
the call instruction</strong>.</li>
</ul></li>
</ul>
<p>  The general forms of the <code>call</code> and <code>ret</code>
instructions are as below:</p>
<p><img src="/2024/07/16/3-7-Procedures/image.png"></p>
<p><img src="/2024/07/16/3-7-Procedures/image-1.png"></p>
<h3 id="4data-transfer">4.Data Transfer</h3>
<p>  In x86-64, data passing to and from a procedure takes place via
registers.</p>
<p>  <strong>Up to six</strong> integral (i.e., integer and pointer)
arguments can be passed via registers. The registers are used in a
specified order:</p>
<p><img src="/2024/07/16/3-7-Procedures/image-2.png"></p>
<p>  Arguments are allocated to these registers according to
<strong>their ordering in the argument list</strong>, and arguments
smaller than 64 bits can be accessed using the appropriate
<strong>subsection of the 64-bit register</strong>.</p>
<p>  When a function has more than six integral arguments, the other
ones are passed <strong>on the stack</strong>. When passing parameters
on the stack, all data size <strong>are rounded up to be multiples of
8</strong>.</p>
<p>  Let's take the following code as an example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># void proc(a1, a1p, a2, a2p, a3, a3p, a4, a4p)</span><br><span class="line"># Arguments passed as follows:</span><br><span class="line"># a1 in %rdi (64 bits)</span><br><span class="line"># a1p in %rsi (64 bits)</span><br><span class="line"># a2 in %edx (32 bits)</span><br><span class="line"># a2p in %rcx (64 bits)</span><br><span class="line"># a3 in %r8w (16 bits)</span><br><span class="line"># a3p in %r9 (64 bits)</span><br><span class="line"># a4 at %rsp+8 ( 8 bits)</span><br><span class="line"># a4p at %rsp+16 (64 bits)</span><br><span class="line"></span><br><span class="line">proc:</span><br><span class="line">    movq 16(%rsp), %rax # Fetch a4p (64 bits)</span><br><span class="line">    addq %rdi, (%rsi)   # *a1p += a1 (64 bits)</span><br><span class="line">    addl %edx, (%rcx)   # *a2p += a2 (32 bits)</span><br><span class="line">    addw %r8w, (%r9)    # *a3p += a3 (16 bits)</span><br><span class="line">    movl 8(%rsp), %edx  # Fetch a4 (8 bits)</span><br><span class="line">    addb %dl, (%rax)    # *a4p += a4 (8 bits)</span><br><span class="line">    ret                 # Return</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/16/3-7-Procedures/image-3.png"></p>
<h3 id="5local-storage-on-the-stack">5.Local Storage on the Stack</h3>
<p>  In most cases, local data is stored in registers. However, there
are cases that local data must be stored in memory:</p>
<ol type="1">
<li><p>There are not enough registers to hold all of the local
data.</p></li>
<li><p>The address operator '&amp;' is applied to a local variable, and
hence we must be able to <strong>generate an address for it</strong>.
However, data that is stored in register doesn't have unique
address.</p></li>
<li><p>Some of the local variables are arrays or structures and hence
must be accessed by array or structure references.</p></li>
</ol>
<p>  Take the following program as an example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">swap_add</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> x = *xp;</span><br><span class="line">    <span class="type">long</span> y = *yp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    *yp = x;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">caller</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> arg1 = <span class="number">534</span>;</span><br><span class="line">    <span class="type">long</span> arg2 = <span class="number">1057</span>;</span><br><span class="line">    <span class="type">long</span> sum = swap_add(&amp;arg1, &amp;arg2);</span><br><span class="line">    <span class="type">long</span> diff = arg1 - arg2;</span><br><span class="line">    <span class="keyword">return</span> sum * diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># long caller()</span><br><span class="line">caller:</span><br><span class="line">subq $16, %rsp       # Allocate 16 bytes for stack frame</span><br><span class="line">movq $534, (%rsp)    # Store 534 in arg1</span><br><span class="line">movq $1057, 8(%rsp)  # Store 1057 in arg2</span><br><span class="line">leaq 8(%rsp), %rsi   # Compute &amp;arg2 as second argument</span><br><span class="line">movq %rsp, %rdi      # Compute &amp;arg1 as first argument</span><br><span class="line">call swap_add        # Call swap_add(&amp;arg1, &amp;arg2)</span><br><span class="line">movq (%rsp), %rdx    # Get arg1</span><br><span class="line">subq 8(%rsp), %rdx   # Compute diff = arg1 - arg2</span><br><span class="line">imulq %rdx, %rax     # Compute sum * diff</span><br><span class="line">addq $16, %rsp       # Deallocate stack frame</span><br><span class="line">ret                  # Return</span><br></pre></td></tr></table></figure>
<p>  Because we need to use the address of <code>arg1</code> and
<code>arg2</code>, we need to store them in memory. We do this by
leaving enough place in the stack and push the arguments onto the
stack:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subq $16, %rsp       # Allocate 16 bytes for stack frame</span><br><span class="line">movq $534, (%rsp)    # Store 534 in arg1</span><br><span class="line">movq $1057, 8(%rsp)  # Store 1057 in arg2</span><br></pre></td></tr></table></figure>
<p>  Once we need to use the value, we fetch it from the stacK:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leaq 8(%rsp), %rsi   # Compute &amp;arg2 as second argument</span><br><span class="line">movq %rsp, %rdi      # Compute &amp;arg1 as first argument</span><br></pre></td></tr></table></figure>
<p>  The following program is a more complicated one. It includes the
details of setting up the stack frame for the local variables and
function parameters:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call_proc:</span><br><span class="line"></span><br><span class="line">    # set up arguments to proc</span><br><span class="line">    subq $32, %rsp          # Allocate 32-byte stack frame</span><br><span class="line">    movq $1, 24(%rsp)       # Store 1 in &amp;x1</span><br><span class="line">    movl $2, 20(%rsp)       # Store 2 in &amp;x2</span><br><span class="line">    movw $3, 18(%rsp)       # Store 3 in &amp;x3</span><br><span class="line">    movb $4, 17(%rsp)       # Store 4 in &amp;x4</span><br><span class="line">    leaq 17(%rsp), %rax     # Create &amp;x4</span><br><span class="line">    movq %rax, 8(%rsp)      # Store &amp;x4 as argument 8</span><br><span class="line">    movl $4, (%rsp)         # Store 4 as argument 7</span><br><span class="line">    leaq 18(%rsp), %r9      # Pass &amp;x3 as argument 6</span><br><span class="line">    movl $3, %r8d           # Pass 3 as argument 5</span><br><span class="line">    leaq 20(%rsp), %rcx     # Pass &amp;x2 as argument 4</span><br><span class="line">    movl $2, %edx           # Pass 2 as argument 3</span><br><span class="line">    leaq 24(%rsp), %rsi     # Pass &amp;x1 as argument 2</span><br><span class="line">    movl $1, %edi           # Pass 1 as argument 1</span><br><span class="line"></span><br><span class="line">    # call proc</span><br><span class="line">    call proc               # Call proc</span><br><span class="line"></span><br><span class="line">    # retrieve changes to memory</span><br><span class="line">    movslq 20(%rsp), %rdx   # Get x2 and convert to long</span><br><span class="line">    addq 24(%rsp), %rdx     # Compute x1+x2</span><br><span class="line">    movswl 18(%rsp), %eax   # Get x3 and convert to int</span><br><span class="line">    movsbl 17(%rsp), %ecx   # Get x4 and convert to int</span><br><span class="line">    subl %ecx, %eax         # Compute x3-x4</span><br><span class="line">    cltq                    # Convert to long</span><br><span class="line">    imulq %rdx, %rax        # Compute (x1+x2) * (x3-x4)</span><br><span class="line">    addq $32, %rsp          # Deallocate stack frame</span><br><span class="line">    ret                     # Return</span><br></pre></td></tr></table></figure>
<h3 id="6local-storage-in-registers">6.Local Storage in Registers</h3>
<p>  When calling another procedure, we must make sure that <strong>the
callee does not overwrite some register value that the caller planned to
use later</strong>.</p>
<ul>
<li><p>By convention, registers <code>%rbx</code>, <code>%rbp</code>,
and <code>%r12�C%r15</code> are classified as <strong>callee saved
registers</strong>.</p>
<ul>
<li>When procedure P calls procedure Q, <strong>Q must preserve the
values of these registers</strong>, ensuring that they have the same
values when Q returns to P as they did when Q was called.</li>
</ul></li>
<li><p>Procedure Q can preserve a register value by either <strong>not
changing it at all</strong> or by <strong>pushing the original value on
the stack, altering it, and then popping the old value from the stack
before returning</strong>.</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushq %rbp  # Save %rbp</span><br><span class="line">pushq %rbx  # Save %rbx</span><br><span class="line">...</span><br><span class="line">popq %rbx   # Restore %rbx</span><br><span class="line">popq %rbp   # Restore %rbp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note how they are popped is <strong>in the reverse order
from</strong> how they were pushed, to account for the last-in,
first-out discipline of a stack.</p>
</blockquote>
<ul>
<li>All other registers, except for the stack pointer <code>%rsp</code>,
are classified as <strong>caller saved registers</strong>.</li>
</ul>
<h3 id="7recursive-procedures">7.Recursive Procedures</h3>
<p>  The stack discipline of allocation and deallocation naturally
matches the call-return ordering of functions. So the recursive
procedures is the same as other procedures:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfact</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rfact:</span><br><span class="line">    pushq %rbx              # Save %rbx</span><br><span class="line">    movq %rdi, %rbx         # Store n in callee-saved register</span><br><span class="line">    movl $1, %eax           # Set return value = 1</span><br><span class="line">    cmpq $1, %rdi           # Compare n:1</span><br><span class="line">    jle .L35                # If &lt;=, goto done</span><br><span class="line">    leaq -1(%rdi), %rdi     # Compute n-1</span><br><span class="line">    call rfact              # Call rfact(n-1)</span><br><span class="line">    imulq %rbx, %rax        # Multiply result by n</span><br><span class="line">.L35: done:</span><br><span class="line">    popq %rbx               # Restore %rbx</span><br><span class="line">    ret                     # Return</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 3.Machine-level Representation of Program</category>
      </categories>
  </entry>
  <entry>
    <title>3.6.Control</title>
    <url>/2024/07/15/3-6-Control/</url>
    <content><![CDATA[<h1 id="36-control"><span class="math inline">\(3.6.\)</span> Control</h1>
<h3 id="1condition-code">1.Condition Code</h3>
<p>  In addition to the integer registers, the CPU maintains <em>a set
of single-bit condition code registers</em> <strong>describing
attributes of the most recent arithmetic or logical operation</strong>.
These registers can then be tested to perform conditional branches</p>
<p><img src="/2024/07/15/3-6-Control/image.png"></p>
<ul>
<li><p>The <code>leaq</code> instruction <strong>doesn't alter any
condition codes</strong>, since it is intended to be used in address
computations.</p></li>
<li><p>For the logical operations, such as <code>xor</code>, <strong>the
carry and overflow flags are set to zero</strong>.</p></li>
<li><p>For the shift operations, <strong>the carry flag is set to the
last bit shifted out</strong>, while <strong>the overflow flag is set to
zero</strong>.</p></li>
<li><p>The <code>inc</code> and <code>dec</code> instructions
<strong>set the overflow and zero flags</strong>, but they <strong>leave
the carry flag unchanged</strong>.</p></li>
</ul>
<p>  There are two instruction classes that set condition codes without
altering any other registers:</p>
<p><img src="/2024/07/15/3-6-Control/image-1.png"></p>
<ul>
<li>In <code>TEST</code>, typically, <strong>the same operand is
repeated</strong> (e.g., <code>testq %rax,%rax</code> to see whether
<code>%rax</code> is negative, zero, or positive), or <strong>one of the
operands is a mask indicating which bits should be tested</strong>.</li>
</ul>
<h3 id="2accessing-condition-codes">2.Accessing Condition Codes</h3>
<p><img src="/2024/07/15/3-6-Control/image-2.png"></p>
<ul>
<li><p>A set instruction has either one of the low-order single-byte
register elements or a single-byte memory location as its destination,
<strong>setting this byte to either 0 or 1</strong>.</p></li>
<li><p>To generate a 32-bit or 64-bit result, we must also <strong>clear
the high-order bits</strong>. For example:</p></li>
</ul>
<p><img src="/2024/07/15/3-6-Control/image-3.png"></p>
<p>  The <code>movzbl</code> not only set the high-order 3 bytes of
<code>%eax</code> to 0, but also set the high-order 4 bytes of
<code>%rax</code> to 0 due to the 32-bit <code>mov</code>
convention.</p>
<blockquote>
<p>It is important to understand that assembly code does not keep track
of the type of a program value. Instead, <strong>the different
instructions determine the operand sizes and whether they are signed or
unsigned</strong>:</p>
<p><span class="math inline">\(e.g.\)</span></p>
<p><img src="/2024/07/15/3-6-Control/image-4.png"></p>
<p><img src="/2024/07/15/3-6-Control/image-5.png"></p>
</blockquote>
<h3 id="3jump-instructions">3.Jump Instructions</h3>
<p><img src="/2024/07/15/3-6-Control/image-6.png"></p>
<p>  There are two kinds of jump instructions:</p>
<ul>
<li><p><em>Direct jump</em>: It jumps to a label. The jump target is
encoded as part of the instructions.</p></li>
<li><p><em>Indirect jump</em>: It is written <strong>using
<code>*</code> followed by an operand specifier</strong>.</p>
<ul>
<li><p><code>jmp *%rax</code> uses <strong>the value in
<code>%rax</code></strong> as the jump target.</p></li>
<li><p><code>jmp *(%rax)</code> reads the jump target from memory, using
the value in <code>%rax</code> <strong>as the read
address</strong>.</p></li>
</ul></li>
</ul>
<h3 id="4jump-instruction-encodings">4.Jump Instruction Encodings</h3>
<p>  There are several kinds of encoding jump targets:</p>
<ol type="1">
<li><p><em>PC relative</em>. They encode <strong>the difference between
the address of the target instruction and the address of the instruction
immediately following the jump</strong>.</p></li>
<li><p>A second encoding method is to <strong>give an ��absolute��
address</strong>, using 4 bytes to directly specify the target.</p></li>
</ol>
<p>  Let's look at an PC relative example:</p>
<p><img src="/2024/07/15/3-6-Control/image-7.png"></p>
<p>  In the annotations on the right, the jump targets are indicated as
<code>0x8</code> for the jump instruction on line 2, which is equal to
<code>0x5+0x3</code>. This is because the encoding is calculated by
<strong><span class="math inline">\(the\;address\;of\;next\;instruction+offset\)</span></strong>.</p>
<p>  In this case, the address of next instruction is 3+2=5, and the
offset is <code>03</code>, as is shown in the assembly code.</p>
<p>  Even though the instructions may be relocated to different
addresses, the encoding of the target <strong>remain unchanged</strong>.
This is because the relative position between instructions remains
unchanged.</p>
<h3 id="5conditional-move">5.Conditional Move</h3>
<p>  The conventional way to implement conditional operations is through
a <em>conditional transfer of control</em>, where the program follows
one execution path when a condition holds and another when it does
not:</p>
<p><img src="/2024/07/15/3-6-Control/image-8.png"></p>
<p>  An alternate strategy is through <em>condition transfer of
data</em>. This approach <strong>computes both outcomes of a conditional
operation</strong> and then <strong>selects one based on whether or not
the condition holds</strong>:</p>
<p><img src="/2024/07/15/3-6-Control/image-9.png"></p>
<p>  This strategy makes sense only in restricted cases, but it can then
be implemented by a simple conditional move instruction that is better
matched to the performance characteristics of modern processors due to
the pipelining.</p>
<blockquote>
<p>However, due to the preprocess, If <strong>one of those two
expressions could possibly generate an error condition or a side
effect</strong>, this could lead to invalid behavior.</p>
</blockquote>
<p>  The conditional move instructions are as below:</p>
<p><img src="/2024/07/15/3-6-Control/image-10.png"></p>
<ul>
<li><p>The instructions has two operands: <strong>a source register or
memory location S</strong>, and <strong>a destination register
R</strong>.</p></li>
<li><p>The assembler can infer the operand length of a conditional move
instruction, so it doesn't need suffix.</p></li>
</ul>
<h3 id="6loops">6.Loops</h3>
<h4 id="ado-while">  <span class="math inline">\(a.\)</span><code>do-while</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    body-statement</span><br><span class="line">    <span class="title function_">while</span> <span class="params">(test-expr)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto loop;</span><br></pre></td></tr></table></figure>
<h4 id="bwhile">  <span class="math inline">\(b.\)</span><code>while</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (test-expr)</span><br><span class="line">    body-statement</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    goto test;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">test:</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto loop;</span><br></pre></td></tr></table></figure>
<p>  The second translation method is called <em>guarded do</em>, which
uses a <code>do-while</code> style loop:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line">if (!t)</span><br><span class="line">    goto done;</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>  By this way, we only need to check the condition once before we
enter the loop. This reduce the possibility of branch prediction
failure.</p>
<h4 id="cfor">  <span class="math inline">\(c.\)</span><code>for</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (init-expr; test-expr; update-expr)</span><br><span class="line">    body-statement</span><br></pre></td></tr></table></figure>
<p>  is equal to the following <code>while</code> statements:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init-expr;</span><br><span class="line"><span class="keyword">while</span> (test-expr) &#123;</span><br><span class="line">    body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  And there are also two forms of <code>for</code> translation:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    init-expr;</span><br><span class="line">    goto test;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">test:</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto loop;</span><br></pre></td></tr></table></figure>
<p>  and:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    init-expr;</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (!t)</span><br><span class="line">        goto done;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>  However, the simple translation from <code>for</code> to
<code>while</code> will be a little tricky. Take the
<code>continue</code> statement as an example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  If we simply use <code>continue</code>, this will lead to an
infinite loop:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">    <span class="comment">/* This will cause an infinite loop */</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    sum += i;</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  The general solution is to replace the continue statement with a
goto statement that skips the rest of the loop body and goes directly to
the update portion:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">goto</span> update;</span><br><span class="line">    sum += i;</span><br><span class="line"></span><br><span class="line">update:</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7switch-statements">7.Switch Statements</h3>
<p>  The ordinary <code>switch</code> statements looks like this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_eg</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val = x;</span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        val *= <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">        val += <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/* Fall through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">103</span>:</span><br><span class="line">        val += <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">104</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">106</span>:</span><br><span class="line">        val *= val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  We can rewrite this using a <em>jump table</em>. A jump table is an
array where entry i is the address of a code segment the program should
take when the switch index equals i.</p>
<p>  With jump table, the previous program will looks like this:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_eg_impl</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Table of code pointers */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> *jt[<span class="number">7</span>] = &#123;</span><br><span class="line">        &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B,</span><br><span class="line">        &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def,</span><br><span class="line">        &amp;&amp;loc_D&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> index = n - <span class="number">100</span>;</span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">6</span>)</span><br><span class="line">        <span class="keyword">goto</span> loc_def;</span><br><span class="line">    <span class="comment">/* Multiway branch */</span></span><br><span class="line">    <span class="keyword">goto</span> *jt[index];</span><br><span class="line"></span><br><span class="line">loc_A: <span class="comment">/* Case 100 */</span></span><br><span class="line">    val = x * <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_B: <span class="comment">/* Case 102 */</span></span><br><span class="line">    x = x + <span class="number">10</span>;</span><br><span class="line"><span class="comment">/* Fall through */</span></span><br><span class="line">loc_C: <span class="comment">/* Case 103 */</span></span><br><span class="line">    val = x + <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_D: <span class="comment">/* Cases 104, 106 */</span></span><br><span class="line">    val = x * x;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_def: <span class="comment">/* Default case */</span></span><br><span class="line">    val = <span class="number">0</span>;</span><br><span class="line">done:</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The <code>switch</code> locations are defined by <strong>the
labels prefixed by <code>&amp;&amp;</code></strong>.
<code>&amp;&amp;</code>is used to create a pointer for a code
location.</p></li>
<li><p>To simplify, the case value is subtracted by 100.</p></li>
</ul>
<p>  In the assembly code, we use this statement to access the jump
table:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp *.L4(, %rsi, 8)  #Goto *jg[index]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The base address is <code>L4</code>, which is the base address of
the jump table array.</p></li>
<li><p>The <code>(, %rsi, 8)</code> is the index, judging which case to
switch to.</p></li>
</ul>
<p>  In the assembly code, the jump table is indicated by the following
declarations:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section.rodata</span><br><span class="line">    .align 8  # Align address to multiple of 8</span><br><span class="line">    .L4 :</span><br><span class="line">    .quad.L3  # Case 100 : loc_A</span><br><span class="line">    .quad.L8  # Case 101 : loc_def</span><br><span class="line">    .quad.L5  # Case 102 : loc_B</span><br><span class="line">    .quad.L6  # Case 103 : loc_C</span><br><span class="line">    .quad.L7  # Case 104 : loc_D</span><br><span class="line">    .quad.L8  # Case 105 : loc_def</span><br><span class="line">    .quad.L7  # Case 106 : loc_D</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The <code>rodata</code> refers to <em>read-only
data</em>.</p></li>
<li><p><code>L4</code> marks the start of the allocation.</p></li>
</ul>
<p>  In assembly code, the number of <code>case</code> is judged by
<strong>the offset of the label in the jump table</strong>.</p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 3.Machine-level Representation of Program</category>
      </categories>
  </entry>
  <entry>
    <title>3.5.Arithmetic and Logical Operations</title>
    <url>/2024/07/15/3-5-Arithmetic-and-Logical-Operations/</url>
    <content><![CDATA[<h1 id="35arithmetic-and-logicaloperations"><span class="math inline">\(3.5.\)</span>Arithmetic and Logical
Operations</h1>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image.png"></p>
<h3 id="1load-effective-address">1.Load Effective Address</h3>
<ul>
<li>The <code>leaq</code> instruction <strong>doesn't reference memory
at all</strong>. Instead of reading from the designated location, it
<strong>copies the effective address to the destination</strong>.</li>
</ul>
<p>  The instruction can be used to <strong>generate pointers for later
memory reference</strong>. For example, if register <code>%rdx</code>
represents <span class="math inline">\(x\)</span>, then
<code>leaq 7(%rdx, %rdx, 4), %rdx</code> will set <code>%rdx</code> to
<span class="math inline">\(5x+7\)</span>.</p>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-1.png"></p>
<h3 id="2unary-amp-binary-operations">2.Unary &amp; Binary Operations</h3>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-2.png"></p>
<p>  Operations in the first group are unary operations:</p>
<ul>
<li><p>The single operand serves as both source and
destination.</p></li>
<li><p>This operand can be either a register or a memory
location.</p></li>
</ul>
<p>  The second group consists of binary operations.</p>
<ul>
<li>The second operand is used as both a source and a destination, the
first operand is another operand.</li>
</ul>
<blockquote>
<p>This syntax is reminiscent of the C assignment operators, such as
<code>x -= y</code>.</p>
</blockquote>
<ul>
<li>The first operand can be either an immediate value, a register, or a
memory location. The second can be either a register or a memory
location.</li>
</ul>
<blockquote>
<p>The operation: <code>xor %rcx %rcx</code> is simply to set</p>
</blockquote>
<h3 id="3shift-operations">3.Shift operations</h3>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-3.png"></p>
<ul>
<li><p>The shift amount is either <strong>an immediate value</strong> or
<strong>a single-byte register <code>%cl</code></strong>.</p></li>
<li><p>In x86-64, if the data values are <span class="math inline">\(w\)</span> bits, then its shift amount will be
<strong>the low-order <span class="math inline">\(m\)</span> bits of
<code>%cl</code>, where <span class="math inline">\(2^m=w\)</span></strong>. For example, when
<code>%cl</code> has value 0xFF, then <code>salb</code> would shift by
7, while <code>salw</code> would shift by 15.</p></li>
</ul>
<p>  <span class="math inline">\(e.g.\)</span>(Convert 64-bits into
32-bits)</p>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-4.png"></p>
<p>  <span class="math inline">\(solution:\)</span></p>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-5.png"></p>
<ul>
<li>The <code>movl %esi %ecx</code> is worth noting. Because we only
need 4 bytes of data, we can use <code>movl</code> operation to set the
low-order 32 bits of <code>rcx</code> to <code>%esi</code> while
high-order 32 bits to 0. Since we only need the low-order 4 bytes, doing
this implies that the high-order 4 bytes is meaningless, which makes
code safer, more accurate and more readable.</li>
</ul>
<h3 id="4special-arithmeticoperations">4.Special Arithmetic
Operations</h3>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-6.png"></p>
<h4 id="aone-operand-multiply">  <span class="math inline">\(a.\)</span>"One-operand" multiply</h4>
<p>  The <code>mulq</code>(unsigned) and <code>imulq</code>(signed) can
also act as "one-operand" instructions to <strong>compute the full
128-bits product of 2 64-bits values</strong>.</p>
<ul>
<li><p><strong>One of the multiplicand is value in
<code>%rax</code></strong>, another is the operand.</p></li>
<li><p>The product is stored in <code>%rdx</code> (high-order 64 bits)
and <code>%rax</code> (low-order 64 bits).</p></li>
</ul>
<p>  We will need to take two steps to store an oct word:</p>
<p>  <span class="math inline">\(e.g.\)</span></p>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-7.png"></p>
<h4 id="bdivision">  <span class="math inline">\(b.\)</span>Division</h4>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-8.png"></p>
<ul>
<li><p>For a division, <code>%rdx</code> stores the remainder and
<code>%rax</code> stores the quotient.</p></li>
<li><p>For most applications of 64-bit addition, the dividend is given
as a 64-bit value. The bits of <code>%rdx</code> should then be set to
either <strong>all zeros (unsigned arithmetic) or the sign bit of %rax
(signed arithmetic)</strong>.</p>
<ul>
<li><p>The former can be implemented by <code>movl $0 %reg</code>, this
can set upper 8 bytes of diviend to 0.</p></li>
<li><p>The latter can be implemented by <code>cqto</code>. It takes no
operands, implicitly reads the sign bit from %rax and copies it across
all of %rdx.</p></li>
</ul></li>
</ul>
<p>  <span class="math inline">\(e.g.\)</span>(Signed and Unsigned)</p>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-9.png"></p>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-10.png"></p>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-11.png"></p>
<p><img src="/2024/07/15/3-5-Arithmetic-and-Logical-Operations/image-12.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 3.Machine-level Representation of Program</category>
      </categories>
  </entry>
  <entry>
    <title>3.4.Accessing Information</title>
    <url>/2024/07/14/3-4-Accessing%20Information/</url>
    <content><![CDATA[<h1 id="34accessing-information"><span class="math inline">\(3.4.\)</span>Accessing Information</h1>
<h3 id="1machine-code-properties">1.Machine code properties</h3>
<ul>
<li><p>x86-64 instructions can range in length from 1 to 15 bytes, it
isn't fixed.</p></li>
<li><p>The instruction format is designed to insure that <strong>there's
a unique decoding of the bytes into machine instructions</strong>. For
example, only <code>pushq %rbx</code> can start with <code>53</code>(can
be analogied with opcode in RISC-V).</p></li>
<li><p>The disassembler determines the assembly code based
<strong>purely on the byte sequences in the machine-code
file</strong>.</p></li>
</ul>
<h3 id="2registers">2.Registers</h3>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-1.png"></p>
<ul>
<li><p>When we present instructions copying and generating 1-, 2-, 4-,
8-byte values, we follow the two conventions:</p>
<ul>
<li><p>Those that generate 1- or 2-byte quantities <strong>leave the
remaining bytes unchanged</strong>.</p></li>
<li><p>Those that generate 4-byte quantities <strong>set the upper 4
bytes of the register to zero</strong>.</p></li>
</ul></li>
<li><p>A function returns a value by <strong>storing it in register
<code>%rax</code></strong>, or <strong>in one of the low-order portions
of this register</strong>.</p></li>
</ul>
<h3 id="3operand-specifiers">3.Operand specifiers</h3>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-2.png"></p>
<p>  There are three types of operand possibilities:</p>
<ul>
<li><p><em>Immediate</em>: It refers to constant value. In ATT format
assembly code, it is written with a <code>$</code> along with an
integer.</p></li>
<li><p><em>Register</em>: It denotes the content of a register. We use
the notation <span class="math inline">\(r_a\)</span> to denote a
register <span class="math inline">\(a\)</span> and indicate its value
with <span class="math inline">\(R{[r_{a}]}\)</span>.</p></li>
<li><p><em>Memory</em>: The most general form of it is <span class="math inline">\(Imm({r_b},{r_i},s)\)</span>, which is computed as
<span class="math inline">\(Imm+R[{r_b}]+R[{r_s}] \cdot s\)</span>.</p>
<ul>
<li><span class="math inline">\(Imm\)</span> is the immediate offset,
<span class="math inline">\(r_b\)</span> is the base register, <span class="math inline">\(r_i\)</span> is the index register.</li>
</ul></li>
</ul>
<p>  <span class="math inline">\(e.g.\)</span></p>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-3.png"></p>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-4.png"></p>
<h3 id="4data-movement-instructions">4.Data Movement Instructions</h3>
<h4 id="asimple-data-movement-instructions">  <span class="math inline">\(a.\)</span>Simple data movement instructions</h4>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-5.png"></p>
<ul>
<li><p>The source operand designates a value that is <strong>immediate,
stored in a register, or stored in memory</strong>.</p></li>
<li><p>The destination operand designates a location that is
<strong>either a register or a memory address</strong>.</p></li>
<li><p>The value is first passed <strong>from source to a register, then
from the register to the destination</strong>.</p></li>
</ul>
<blockquote>
<p>The regular <code>movq</code> instruction can only have immediate
source operands that can be represented as 32-bit two�s-complement
numbers. This value is then sign extended to produce the 64-bit value
for the destination. The <code>movabsq</code> instruction can have an
<strong>arbitrary 64-bit immediate value</strong> as its source operand
and can only have a register as a destination.</p>
</blockquote>
<blockquote>
<p>In x86-64, any instruction that generates a 32-bit value for a
register also <strong>sets the high-order portion of the register to
0</strong>.</p>
</blockquote>
<h4 id="bbit-extending-data-movementinstructions">  <span class="math inline">\(b.\)</span>Bit-extending data movement
instructions</h4>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-6.png"></p>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-7.png"></p>
<ul>
<li><p>Each instruction name has <strong>size designators</strong> as
its final two characters�the first specifying the source size, and the
second specifying the destination size.</p></li>
<li><p>The source can be either a register or stored in memory.</p></li>
<li><p>The destination is a register.</p></li>
</ul>
<p>  <span class="math inline">\(e.g.\)</span>(Suffix decision)</p>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-8.png"></p>
<p>  <span class="math inline">\(solution:\)</span>There are several
points to note:</p>
<ol type="1">
<li><p>In x86-64, we always <strong>give quad word registers to memory
reference</strong>, such as <code>%rax</code>.</p></li>
<li><p>We <strong>first decide which suffix to use by the
destination</strong>. For example, <code>movb $0xFF %bl</code>.</p></li>
<li><p>If <strong>the destination is a memory address(such as
<code>(%rax)</code>)</strong>, we <strong>decide which suffix to use by
the source</strong>.</p></li>
</ol>
<blockquote>
<p>Note that if both the source and the destination are from memory,
<strong>we can use all four suffix</strong>. The x86-64 imposes the
restriction that <strong>a move instruction cannot have both operands
refer to memory locations</strong>.</p>
</blockquote>
<h4 id="cdata-movement-example">  <span class="math inline">\(c.\)</span>Data movement example</h4>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-9.png"></p>
<ul>
<li><p>Procedure parameters <code>xp</code> and <code>y</code> are
stored in registers <code>%rdi</code> and <code>%rsi</code>.</p></li>
<li><p>Dereferencing a pointer involves <strong>copying that pointer
into a register</strong>, and then <strong>using this register in a
memory reference</strong>.</p></li>
</ul>
<p>  <span class="math inline">\(e.g.\)</span>(Casting)</p>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-10.png"> <img src="/2024/07/14/3-4-Accessing%20Information/image-11.png"> <img src="/2024/07/14/3-4-Accessing%20Information/image-12.png"></p>
<p>  <span class="math inline">\(solution:\)</span>The casting is in
fact <strong>the extension of bits</strong>. For example, if we want to
convert <code>char</code> to <code>int</code>, because <code>char</code>
takes word bits while <code>int</code> takes 32 bits, we use
<code>movsbl</code> to implement operations
like<code>int x = (int) char_element</code>:</p>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-13.png"> <img src="/2024/07/14/3-4-Accessing%20Information/image-14.png"></p>
<h4 id="dstack-operation">  <span class="math inline">\(d.\)</span>Stack operation</h4>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-15.png"></p>
<p><img src="/2024/07/14/3-4-Accessing%20Information/image-16.png"> <img src="/2024/07/14/3-4-Accessing%20Information/image-17.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 3.Machine-level Representation of Program</category>
      </categories>
  </entry>
  <entry>
    <title>3.2.Program Encoding</title>
    <url>/2024/07/14/3-2-Program-Encoding/</url>
    <content><![CDATA[<h1 id="32program-encoding"><span class="math inline">\(3.2.\)</span>Program Encoding</h1>
<h3 id="1program-execution-process">1.Program execution process</h3>
<p>  Say we want to compile two C program <code>p1.c</code> and
<code>p2.c</code>, we input the command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linux&gt; gcc -0g -o p p1.c p2.c</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>The C preprocessor expands the source code to <strong>include any
files specified with <code>#include</code> commands and with
<code>#define</code> declarations</strong>.</p></li>
<li><p>Compiler generates assembly code having name <code>p1.s</code>
and <code>p2.s</code>.</p></li>
<li><p>Assembler converts the assembly code into <em>binary
object-code</em> files <code>p1.o</code> and <code>p2.o</code>.</p></li>
</ol>
<blockquote>
<p>The object code contains binary representations of all instructions,
but doesn't include the address of the global value.</p>
</blockquote>
<ol start="4" type="1">
<li>Linker merges these two object-code files along with <em>code
implementing library functions</em> (e.g., <code>printf</code>) and
generates the final executable code file <code>p</code>(specified by
<code>-o p</code>).</li>
</ol>
<h3 id="2machine-code">2.Machine code</h3>
<h4 id="aprogram-memory">  <span class="math inline">\(a.\)</span>Program memory</h4>
<p>  The program memory contains:</p>
<ul>
<li><p>the executable machine code for the program</p></li>
<li><p>some information required by the operating system</p></li>
<li><p>a run-time stack for managing procedure calls and
returns</p></li>
<li><p>blocks of memory allocated by the user (e.g., by using the
<code>malloc</code> library function).</p></li>
</ul>
<h4 id="bsomecommand">  <span class="math inline">\(b.\)</span>Some
command</h4>
<p>  We use <code>-S</code> to see the assembly code generated by the
compiler:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -0g -S mstore.c</span><br></pre></td></tr></table></figure>
<p>  We use <code>-c</code> to both compile and assemble the code:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -0g -c mstore.c</span><br></pre></td></tr></table></figure>
<p>  This will generate an object-code file <code>mstore.o</code>.</p>
<p>  To inspect the contents of machine-code, we can use the
<em>disassembler</em>. The program <code>objdump</code> can serve the
role:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d mstore.o</span><br></pre></td></tr></table></figure>
<p>  The result is as below:</p>
<p><img src="/2024/07/14/3-2-Program-Encoding/image.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>Chapter 3.Machine-level Representation of Program</category>
      </categories>
  </entry>
  <entry>
    <title>5.6.Cache Coherence</title>
    <url>/2024/06/29/5-6-Cache-coherence/</url>
    <content><![CDATA[<h1 id="56cache-coherence">5.6.Cache Coherence</h1>
<h3 id="1cache-model">1.Cache model</h3>
<p><img src="/2024/06/29/5-6-Cache-coherence/image.png"></p>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-1.png"></p>
<h3 id="2coherence-concept">2.Coherence concept</h3>
<h4 id="acoherence-in-detail">  <span class="math inline">\(a.\)</span>Coherence in detail</h4>
<p>  Caching shared data introduces a new problem. The following is an
example:</p>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-2.png"></p>
<p>  The two different processors have two different values for the same
location, this is referred to as <em>cache coherence problem</em>.</p>
<p>  Informally, we could say that a memory system is coherent if
<strong>any read of a data item returns the most recently written value
of that data item</strong>. This simple concept contains two different
aspects of memory system behaviour:</p>
<ul>
<li><em>coherence</em>: defines <em>what</em> values can be returned by
a read.</li>
<li><em>consistency</em>: determines <em>when</em> a written value will
be returned by a read.</li>
</ul>
<p>  A memory system is coherent if:</p>
<ol type="1">
<li>A read by a processor P to location X that follows <em>only one
write</em> by P to X always returns the value written by P.</li>
</ol>
<blockquote>
<p>This preserves program order.</p>
</blockquote>
<ol start="2" type="1">
<li>A read by a processor to location X that follows <em>only one
write</em> by another processor to X returns the written value if the
read and write are sufficiently separated in time.</li>
</ol>
<blockquote>
<p>This defines memory coherence.</p>
</blockquote>
<ol start="3" type="1">
<li>Writes to the same location are <strong>serialized</strong>; that
is, two writes to the same location by any two processors <strong>are
seen in the same order by all processors</strong>. For example, if CPU B
stores 2 into memory at address X after time step 3, processors can
never read the value at location X as 2 and then later read it as
1.</li>
</ol>
<h4 id="bsnooping-based-cache-coherence">  <span class="math inline">\(b.\)</span>Snooping-based cache coherence</h4>
<p>  One method of enforcing coherence is to ensure that a processor
<strong>has exclusive access to a data item</strong> before it writes
that item. This style of protocol is called a <em>write invalidate
protocol</em> because it <strong>invalidates copies in other caches on a
write</strong>.</p>
<p>  Take the same example before, when we write 1 into location X by
CPU A, the CPU B will get a cache miss, and is forced to fetch a new
copy of data:</p>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-3.png"></p>
<blockquote>
<p>Block size plays an important role in cache coherency. Large blocks
can cause what's called <em>false sharing</em>, when two unrelated
shared variables are located in the same cache block, the whole block is
exchanged between processors even though the processors are accessing
different variables.</p>
</blockquote>
<h3 id="3mosel-cache-coherencyprotocol">3.MOSEL cache coherency
protocol:</h3>
<h4 id="aprotocol-design">  <span class="math inline">\(a.\)</span>Protocol design</h4>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-7.png"></p>
<hr>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-8.png"></p>
<h4 id="bbasicconcepts">  <span class="math inline">\(b.\)</span>Basic
concepts</h4>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-5.png"></p>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-6.png"></p>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-4.png"></p>
<hr>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-9.png"></p>
<h4 id="cexample">  <span class="math inline">\(c.\)</span>Example</h4>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-10.png"></p>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-11.png"></p>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-12.png"></p>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-13.png"></p>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-14.png"></p>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-15.png"></p>
<p><img src="/2024/06/29/5-6-Cache-coherence/image-16.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 5.Parallelism</category>
      </categories>
  </entry>
  <entry>
    <title>5.5.Synchronization</title>
    <url>/2024/06/29/5-5-Synchronization/</url>
    <content><![CDATA[<h1 id="55synchronization">5.5.Synchronization</h1>
<h3 id="1some-concepts">1.Some concepts</h3>
<p><img src="/2024/06/29/5-5-Synchronization/image.png"></p>
<h3 id="2lock-synchronization">2.Lock synchronization</h3>
<p><img src="/2024/06/29/5-5-Synchronization/image-1.png"></p>
<p><img src="/2024/06/29/5-5-Synchronization/image-2.png"></p>
<h3 id="3hardware-synchronization">3.Hardware synchronization</h3>
<h4 id="apossible-lock-problem">  <span class="math inline">\(a.\)</span>Possible lock problem</h4>
<p><img src="/2024/06/29/5-5-Synchronization/image-3.png"></p>
<p>  To solve the problem, the multiprocessor must have the ability ot
<strong>atomically read and modify a memory location</strong>. That is,
<strong>nothing else can interpose itself between the read and the write
of the memory location</strong>.</p>
<blockquote>
<p>For example, consider two processors that each try to do
<code>lw</code> operation. This race is prevented, since exactly one of
the processors will perform <code>lw</code> first, returning 0, and the
second processor will return 1 when it does this. This is because
<strong>the operation is atomic: the exchange is indivisible, and two
simultaneous exchanges will be ordered by the hardware.</strong></p>
</blockquote>
<p><img src="/2024/06/29/5-5-Synchronization/image-4.png"></p>
<h4 id="binstruction-pair">  <span class="math inline">\(b.\)</span>instruction pair</h4>
<p>  To implement atomical property, we can <strong>set a pair of
instructions</strong> in which the second instruction <strong>returns a
value showing whether the pair of instructions was executed as if the
pair was atomic</strong>.</p>
<p>  In RISC-V, this pair of instructions includes a
<code>(lr, d)</code> and a <code>(sc, d)</code>:</p>
<p><img src="/2024/06/29/5-5-Synchronization/image-5.png"></p>
<ul>
<li>Thus, <code>sc.d</code> specifies three registers: one to hold the
address, one to indicate whether the atomic operation failed or
succeeded, and one to hold the value to be stored in memory if it
succeeded.</li>
</ul>
<blockquote>
<p>Notice that <code>(lr, d)</code> operation not only load a word into
pointed memory, but also <strong>record the memory address
internally</strong>, namely <em>reservation</em>. That's why we can use
<code>(sc, d)</code> to check if the operation is atomical.</p>
</blockquote>
<p>  We can use this pair to implement atomic swap:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">again: lr.d x10, (x20)</span><br><span class="line">       sc.d x11, x23, (x20)</span><br><span class="line">       bne x11, x0, again   // branch if store fails</span><br><span class="line">       addi x23, x10, 0     // put loaded value in x23</span><br></pre></td></tr></table></figure>
<p>  Any time a processor intervenes and modifies the value in memory
between the <code>lr.d</code> and <code>sc.d</code> instructions, the
<code>sc.d</code> writes a nonzero value into <code>x11</code>, causing
the code sequence to try again.</p>
<blockquote>
<p>Since the store-conditional will fail after either another attempted
store to the load reservation address or any exception, care must be
taken in choosing which instructions are inserted between the two
instructions. In particular, only <strong>integer arithmetic, forward
branches, and backward branches out of the
load-reserved/store-conditional block</strong> can safely be permitted;
otherwise, it is possible to create <em>deadlock situations</em> where
the processor can never complete the sc.d because of repeated page
faults. In addition, the number of instructions between the
load-reserved and the store-conditional should be small to minimize the
probability that <strong>either an unrelated event or a competing
processor causes the store-conditional to fail frequently</strong>.</p>
</blockquote>
<p>  Other atomic memory operations can be built using
<code>lr/sc</code> pairs, some are listed below:</p>
<p><img src="/2024/06/29/5-5-Synchronization/image-6.png"></p>
<h4 id="ctest-and-set-instruction">  <span class="math inline">\(c.\)</span>Test-and-Set instruction</h4>
<p><img src="/2024/06/29/5-5-Synchronization/image-7.png"></p>
<p><img src="/2024/06/29/5-5-Synchronization/image-8.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 5.Parallelism</category>
      </categories>
  </entry>
  <entry>
    <title>5.4.Multicore and Other Shared Memory Multiprocessors</title>
    <url>/2024/06/29/5-4-Multicore-and-Other-Shared-Memory-Multiprocessors/</url>
    <content><![CDATA[<h1 id="54multicoreand-other-shared-memory-multiprocessors">5.4.Multicore
and Other Shared Memory Multiprocessors</h1>
<h3 id="1amdarls-law">1.Amdarl's Law</h3>
<p><img src="/2024/06/29/5-4-Multicore-and-Other-Shared-Memory-Multiprocessors/image-6.png"></p>
<p><img src="/2024/06/29/5-4-Multicore-and-Other-Shared-Memory-Multiprocessors/image-7.png"></p>
<h3 id="2multiprocessor-design">2.Multiprocessor design</h3>
<p>  There are two kinds of multiprocessor designs: one is to
<strong>provide a single physical address space that all processors can
share</strong>, another is to <strong>have a separate address space per
processor that requires that sharing must be explicit</strong>.</p>
<p>  A <em>Shared memory multiprocessor(SMP)</em> is one that offers the
programmer <strong>a single physical address space across all
processors</strong>:</p>
<p><img src="/2024/06/29/5-4-Multicore-and-Other-Shared-Memory-Multiprocessors/image-8.png"></p>
<p>  In this multiprocessor, Processors communicate through shared
variables in memory, with all processors capable of accessing any memory
location via loads and stores.</p>
<h3 id="3multiprocessor-operations">3.Multiprocessor operations</h3>
<p>  Processors need to coordinate when operating on shared data, which
is called <em>synchronization</em>. One way is to <strong>use a lock for
a shared variable</strong>: <strong>Only one processor r at a time can
acquire the lock, and other processors interested in shared data must
wait until the original processor unlocks the variable.</strong></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 5.Parallelism</category>
      </categories>
  </entry>
  <entry>
    <title>5.3.Hardware Multithreading</title>
    <url>/2024/06/29/5-3-Hardware-Multithreading/</url>
    <content><![CDATA[<h1 id="53hardware-multithreading">5.3.Hardware Multithreading</h1>
<h3 id="1basic-concepts-of-threads">1.Basic concepts of threads</h3>
<p><img src="/2024/06/29/5-3-Hardware-Multithreading/image.png"></p>
<p><img src="/2024/06/29/5-3-Hardware-Multithreading/image-1.png"></p>
<h3 id="2multithreading-intro">2.Multithreading intro</h3>
<p><img src="/2024/06/29/5-3-Hardware-Multithreading/image-2.png"></p>
<p>  Hardware multithreading allows multiple threads to <strong>share
the functional units of a single processor in an overlapping
fashion</strong> to try to utilize the hardware resources
efficiently.</p>
<p>  To permit this sharing, the processor must <strong>duplicate the
independent state of each thread</strong>.</p>
<p><img src="/2024/06/29/5-3-Hardware-Multithreading/image-3.png"></p>
<hr>
<p><img src="/2024/06/29/5-3-Hardware-Multithreading/image-4.png"></p>
<h3 id="3types-of-hardwaremultithreading">3.Types of hardware
multithreading</h3>
<p>  There are 3 types of hardware multithreading approaches:</p>
<ul>
<li><p><em>Fine-grained multithreading</em>: It <strong>switches between
threads on each instruction</strong>, resulting in interleaved execution
of multiple threads.</p>
<ul>
<li><p>It's advantage is that it can hide the throughput losses that
arise from both short and long stalls, since instructions from other
threads can be executed when one thread stalls. Also, since it switches
threads frequently, it doesn't need to clear the pipeline
everytime.</p></li>
<li><p>However, it slows down the execution of the individual
threads.</p></li>
</ul></li>
<li><p><em>Coarse-grained multithreading</em>: It switch threads
<strong>only on expensive stalls</strong>, such as last-level cache
misses.</p>
<ul>
<li><p>It's much less likely to slow down individual execution.</p></li>
<li><p>However, it is limited from overcoming throughput losses for
pipeline start-up time.</p></li>
</ul></li>
<li><p><em>Simultaneous multithreading</em>: It uses a multiple-issue,
dynamically scheduled <em>pipelined processor</em> to <strong>exploit
thread-level parallelism while exploiting ILP</strong>.</p></li>
</ul>
<blockquote>
<p>With register renaming and dynamic scheduling, multiple instructions
from independent threads can be issued without regard to the dependences
among them; <strong>the resolution of the dependences can be handled by
the dynamic scheduling capability</strong>.</p>
</blockquote>
<p>  SMT is always executing instructions from multiple threads, leaving
it up to the hardware to associate instruction slots and renamed
registers with their proper threads.</p>
<p><img src="/2024/06/29/5-3-Hardware-Multithreading/image-5.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 5.Parallelism</category>
      </categories>
  </entry>
  <entry>
    <title>5.1.Parallelism via Instruction</title>
    <url>/2024/06/29/5-1-Parallelism-via-Instructions/</url>
    <content><![CDATA[<h1 id="51parallelism-via-instructions"><span class="math inline">\(5.1.\)</span>Parallelism via Instructions</h1>
<h3 id="1pipelining">1.Pipelining</h3>
<p>  Exploiting the potential parallelism among instructions is called
<em>instruction-level parallelism</em>.</p>
<ul>
<li><p>The first is <strong>increasing the depth of the pipeline to
overlap more instructions</strong>.</p></li>
<li><p>We also need to <strong>reblance the remaining steps so they are
the same length</strong>.</p></li>
<li><p>Another approach is to <strong>replicate the internal components
so that it can launch multiple instruction in every pipeline
stage</strong>. The general name of this approach is <em>multiple
issue</em>.</p></li>
</ul>
<h3 id="2multiple-issue-processor">2.Multiple issue processor</h3>
<p>  There are two main ways to implement a multiple-issue processor,
with the major difference being <strong>the division of work between the
compiler and the hardware</strong>. One is called <em>static multiple
issue</em> and the other <em>dynamic multiple issue</em>.</p>
<p>  There are two primary distinct responsibilities within a
multiple-issue pipeline:</p>
<ol type="1">
<li><p>Packaging instructions into <em>issue slots</em>. It refers to
<strong>the position from which instructions could issue in a given
clock cycle</strong>. In dynamic multiple issue, it is normally dealt
with <strong>at runtime by processor</strong>.</p></li>
<li><p>Dealing with data and control hazards. The compiler handles it
statically. In contrast, most dynamic issue processors attempt to
alleviate them <strong>using hardware techniques operation at execution
time</strong>.</p></li>
</ol>
<h3 id="3speculationconceptsextracted-from-textbook">3.Speculation
concepts(extracted from textbook)</h3>
<p>  Speculation is an approach that <strong>allows the
compilator/processor to "guess" about the properties of an
instruction</strong>. Any speculation mechanism must include both a
method to <strong>check if the guess was right</strong> and a method to
<strong>unroll or back out the effects of the instructions that were
executed speculatively</strong>.</p>
<p>  Speculation may be done in the compiler or by the hardware. For
example,the compiler can use speculation to <strong>reorder
instructions, moving an instruction across a branch or a load across a
store</strong>. The processor hardware can perform the same
transformation at runtime using techniques we discuss later in this
section.</p>
<p>  The recovery mechanisms used for incorrect speculation are rather
different. In the case of speculation in software, the compiler usually
<strong>inserts additional instructions that check the accuracy of the
speculation and provide a fix-up routine to use when the speculation is
wrong</strong>. In hardware speculation, the processor usually
<strong>buffers the speculative results until it knows they are no
longer speculative</strong>. If the speculation is correct, the
instructions are completed by <strong>allowing the contents of the
buffers to be written to the registers or memory</strong>. If the
speculation is incorrect, the hardware flushes the buffers and
re-executes the correct instruction sequence. Misspeculation typically
requires the pipeline to be flushed, or at least stalled, and thus
further reduces performance.</p>
<p>  Speculation introduces one other possible problem: speculating on
certain instructions may <strong>introduce exceptions that were formerly
not present</strong>. For example, suppose a load instruction is moved
in a speculative manner, but the address it uses is not within bounds
when the speculation is incorrect. The result would be that an exception
that should not have occurred would occur. The problem is complicated by
the fact that if the load instruction were not speculative, then the
exception must occur! In compiler-based speculation, such problems are
avoided by <strong>adding special speculation support that allows such
exceptions to be ignored until it is clear that they really should
occur</strong>. In hardware-based speculation, <strong>exceptions are
simply buffered until it is clear that the instruction causing them is
no longer speculative and is ready to complete;</strong> at that point,
the exception is raised,and normal exception handling proceeds.</p>
<h3 id="4static-multiple-issue">4.Static multiple issue</h3>
<p>  Static multiple-issue processors all use the compiler to assist
with packaging instructions and handling hazards. In a static issue
processor, we can think of the set of instructions issued in a given
clock cycle called <em>issue packet</em>. And it's useful to think of
the issue packet as a single instuction allowing weveral operations in
certain predefined fields.</p>
<p>  When it comes to the certain instructions:</p>
<ul>
<li><p>We require that the instructions <strong>be paired and aligned on
a 64-bit boundary</strong>.</p></li>
<li><p>If on instruction of the pair cannot be used, we require that
<strong>it be replaced with nop</strong>.</p></li>
</ul>
<p>  However, the overlapping of instructions <strong>increase the
relative performance loss from data and control hazards</strong>.</p>
<blockquote>
<p>For example, in our simple five-stage pipeline, loads have a use
latency of one clock cycle, which <strong>prevents one instruction from
using the result without stalling</strong>. In the two-issue, five-stage
pipeline the result of a load instruction <strong>cannot be used on the
next clock cycle</strong>. This means that the next two instructions
cannot use the load result without stalling.</p>
</blockquote>
<p>  An important compiler technique to get more performance from loops
is <em>loop unrolling</em>:</p>
<ul>
<li>Say we are going to deal with this program:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    A[i] = B[i] + C[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loop:</span><br><span class="line">    ld  x1, 0(xA)       ; Load A[i]</span><br><span class="line">    ld  x2, 0(xB)       ; Load B[i]</span><br><span class="line">    ld  x3, 0(xC)       ; Load C[i]</span><br><span class="line">    add x4, x2, x3      ; A[i] = B[i] + C[i]</span><br><span class="line">    sd  0(xA), x4       ; Store A[i]</span><br><span class="line">    addi xA, xA, 8      ; Increment A pointer</span><br><span class="line">    addi xB, xB, 8      ; Increment B pointer</span><br><span class="line">    addi xC, xC, 8      ; Increment C pointer</span><br><span class="line">    addi xI, xI, 1      ; Increment loop counter</span><br><span class="line">    blt  xI, 8, Loop    ; Branch if loop counter &lt; 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  We can do this iteration part for more times:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    A[i]   = B[i]   + C[i];</span><br><span class="line">    A[i+<span class="number">1</span>] = B[i+<span class="number">1</span>] + C[i+<span class="number">1</span>];</span><br><span class="line">    A[i+<span class="number">2</span>] = B[i+<span class="number">2</span>] + C[i+<span class="number">2</span>];</span><br><span class="line">    A[i+<span class="number">3</span>] = B[i+<span class="number">3</span>] + C[i+<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loop:</span><br><span class="line">    ld  x1, 0(xA)       ; Load A[i]</span><br><span class="line">    ld  x2, 0(xB)       ; Load B[i]</span><br><span class="line">    ld  x3, 0(xC)       ; Load C[i]</span><br><span class="line">    add x4, x2, x3      ; A[i] = B[i] + C[i]</span><br><span class="line">    sd  0(xA), x4       ; Store A[i]</span><br><span class="line"></span><br><span class="line">    ld  x5, 8(xA)       ; Load A[i+1]</span><br><span class="line">    ld  x6, 8(xB)       ; Load B[i+1]</span><br><span class="line">    ld  x7, 8(xC)       ; Load C[i+1]</span><br><span class="line">    add x8, x6, x7      ; A[i+1] = B[i+1] + C[i+1]</span><br><span class="line">    sd  8(xA), x8       ; Store A[i+1]</span><br><span class="line"></span><br><span class="line">    ld  x9, 16(xA)      ; Load A[i+2]</span><br><span class="line">    ld  x10, 16(xB)     ; Load B[i+2]</span><br><span class="line">    ld  x11, 16(xC)     ; Load C[i+2]</span><br><span class="line">    add x12, x10, x11   ; A[i+2] = B[i+2] + C[i+2]</span><br><span class="line">    sd  16(xA), x12     ; Store A[i+2]</span><br><span class="line"></span><br><span class="line">    ld  x13, 24(xA)     ; Load A[i+3]</span><br><span class="line">    ld  x14, 24(xB)     ; Load B[i+3]</span><br><span class="line">    ld  x15, 24(xC)     ; Load C[i+3]</span><br><span class="line">    add x16, x14, x15   ; A[i+3] = B[i+3] + C[i+3]</span><br><span class="line">    sd  24(xA), x16     ; Store A[i+3]</span><br><span class="line"></span><br><span class="line">    addi xA, xA, 32     ; Increment A pointer by 4</span><br><span class="line">    addi xB, xB, 32     ; Increment B pointer by 4</span><br><span class="line">    addi xC, xC, 32     ; Increment C pointer by 4</span><br><span class="line">    addi xI, xI, 4      ; Increment loop counter by 4</span><br><span class="line">    blt  xI, 8, Loop    ; Branch if loop counter &lt; 8</span><br></pre></td></tr></table></figure>
<p>  This operation has the following advantages:</p>
<ol type="1">
<li><p><strong>Reduce cycle control overhead</strong>: cycle control
operations are less frequent when the cycle is expanded. In the above
example, the loop control operation is reduced from one generation per
generation to one generation per four.</p></li>
<li><p><strong>Increase instruction level parallelism</strong>: the more
instructions expanded, the compiler can better schedule these
instructions, improve parallelism.</p></li>
<li><p><strong>Reduced branch prediction failure</strong>: the
probability of branch prediction failure is reduced due to the reduction
in the number of branch instructions and the frequency of loop control
operations.</p></li>
</ol>
<p>  During the unrolling process, the compiler introduce additional
registers. The goal of the process, called <em>register renaming</em>,
it to <strong>eliminate dependences that are not true data
dependences</strong>, but could either lead to potential hazards or
prevent the compiler from flexibly scheduling the code.</p>
<h3 id="5dynamic-multiple-issueprocessor">5.Dynamic multiple-issue
processor</h3>
<p>  Dynamic multiple-issue processors are also known as <em>superscalar
processors</em>.</p>
<p>  Many superscalars extend the basic framework of dynamic issue
decisions to include <em>dynamic pipeline scheduling</em>. Dynamic
pipeline scheduling <strong>chooses which instructions to execute in a
given clock cycle while trying to avoid hazards and stalls</strong>.</p>
<ul>
<li><p><em>Dynamic pipeline scheduling</em> <strong>chooses which
instructions to execute next, possibly reordering them to avoid
stalls</strong>. The pipeline is divided into three major units: an
instruction fetch and issue unit, multiple functional units, and a
commit unit.</p>
<ul>
<li><p>The first unit fetch instructions, decodes them and sends them to
corresponding function unit for execution.</p></li>
<li><p>Each function unit has <em>buffers</em> called <em>reservation
stations</em>, which <strong>hold the operands and the
operation</strong>. As soon as the buffer contains all its operands and
the functional unit is ready to execute, the result calculated. The
result is sent to <strong>any reservation stations waiting for this
particular result</strong> and <strong>the commit
unit</strong>.</p></li>
<li><p>The commit unit <strong>buffers the result until it's safe to put
the result into the register file/memory</strong>. The buffer in the
commit unit, often called the <em>reorder buffer</em>, is also used to
supply operands.</p></li>
<li><p>Once a result is committed to the register file, it can be
fetched directly from there like in a normal pipeline.</p></li>
</ul></li>
</ul>
<p><img src="/2024/06/29/5-1-Parallelism-via-Instructions/image-23.png"></p>
<blockquote>
<p>If an operand is not in the register file or reorder buffer, it must
<strong>be waiting to be produced by a functional unit</strong>.
<strong>The name of the functional unit that will produce the result is
tracked</strong>. When that unit eventually produces the result,
<strong>it is copied directly into the waiting reservation
statio</strong>n from the functional unit bypassing the registers.</p>
</blockquote>
<p>  We may think of a dynamically scheduled pipeline as an
<em>out-of-order execution</em>. To make programs behave as if they were
running on a simple in-order pipeline, the instruction fetch and decode
unit is required to <strong>issue instructions in order</strong>, which
allows dependences to be tracked, and the commit unit is required to
<strong>write results to registers and memory in program fetch
order</strong>. This conservative mode is called <em>in-order
commit</em>. Hence, if an exception occurs, the computer can point to
the last instruction executed.</p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 5.Parallelism</category>
      </categories>
  </entry>
  <entry>
    <title>5.2.SIMD, MIMD, SIMD, SPMD and Vector</title>
    <url>/2024/06/29/5-2-SIMD-MIMD-SIMD-SPMD-and-Vector/</url>
    <content><![CDATA[<h1 id="52simd-mimd-simd-spmd-andvector"><span class="math inline">\(5.2.\)</span>SIMD, MIMD, SIMD, SPMD and
Vector</h1>
<h3 id="1basic-concepts">1.Basic concepts</h3>
<p><img src="/2024/06/29/5-2-SIMD-MIMD-SIMD-SPMD-and-Vector/image.png"></p>
<p><img src="/2024/06/29/5-2-SIMD-MIMD-SIMD-SPMD-and-Vector/image-1.png"></p>
<ul>
<li><p>In SIMD, all the parallel execution units are
<strong>synchronized</strong>, and they all respond to a single
instruction <strong>that emanates from a single program
counter</strong>.</p></li>
<li><p>Each execution unit <strong>has its own address register, and so
have different data address</strong>.</p></li>
</ul>
<blockquote>
<p>The original motivation behind SIMD was to <strong>amortize the cost
of the control unit over execution units</strong>. The SIMD can also
save instrustion bandwidth and space: SIMD needs <strong>only one copy
of the code that is being simultaneously executed</strong>.</p>
</blockquote>
<blockquote>
<p>Since the instruction is single, SIMD works best when dealing with
<strong>identically structured data</strong>, which is called
<em>data-level parallelism</em>, e.g., for loop.</p>
</blockquote>
<p><img src="/2024/06/29/5-2-SIMD-MIMD-SIMD-SPMD-and-Vector/image-2.png"></p>
<ul>
<li><p>SPMD: The programmer write a single program that runs on all
processors of a <em>MIMD computer</em>, relying on conditional
statements when different processors should execute distinct section of
code.</p></li>
<li><p>The SIMD computers operate on <strong>vectors of
data</strong>.</p></li>
</ul>
<h3 id="2vector">2.Vector</h3>
<h4 id="aconcepts-and-characteristics">  <span class="math inline">\(a.\)</span>Concepts and characteristics</h4>
<p>  The basic philosophy of vector architecture is to <strong>collect
data elements from memory, put them in order into a large set of
registers</strong>, and operate on them sequentially in registers using
<em>pipelined execution units</em>.</p>
<ul>
<li>A key feature of vector architectures is <strong>a set of vector
registers</strong>.</li>
</ul>
<p>  Take the following expression as an example(it's called DAXPY
loop):</p>
<p><span class="math display">\[
Y = a \times X + Y
\]</span></p>
<p>  In conventional RISC-V, it's written as below:</p>
<p><img src="/2024/06/29/5-2-SIMD-MIMD-SIMD-SPMD-and-Vector/image-3.png"></p>
<p>  By using vector, we can write it in a more concise way:</p>
<p><img src="/2024/06/29/5-2-SIMD-MIMD-SIMD-SPMD-and-Vector/image-4.png"></p>
<p>  No only does the code reduce the dynamic instruction bandwidth, but
also the pipeline stalls are required only <strong>once per vector
operation</strong>, rather than once per vector element.</p>
<p>  Vector also holds the following characteristic:</p>
<ol type="1">
<li><p>The compiler indicates that <strong>the computation of each
result in the vector is independent</strong>. So compiler doesn't have
to check for data hazards within an instruction.</p></li>
<li><p>Since the element in a vector is adjacent, <strong>the cost of
the latency to main memory is seen only once for the entire
vector</strong>.</p></li>
<li><p>Because a complete loop is replaced by a vector instruction whose
<strong>behaviour is predetermined</strong>, control hazards are
nonexistent.</p></li>
</ol>
<h4 id="brelated-architecture">   <span class="math inline">\(b.\)</span>Related architecture</h4>
<ul>
<li>Unlike multimedia extensions, the number of elements in a vector
operation isn't in the opcode but in <strong>a separate
register</strong>.</li>
</ul>
<blockquote>
<p>This means different versions of the vector architecture can simply
be implemented by changing the contents of the register, thus retain
binary compatibility.</p>
</blockquote>
<ul>
<li>The parallel semantics of a vector instruction allows using a
<em>deeply pipelined functional unit</em> to execute vector
operations:</li>
</ul>
<p><img src="/2024/06/29/5-2-SIMD-MIMD-SIMD-SPMD-and-Vector/image-5.png"></p>
<p>  Vector arithmetic instructions only allow element N of one vector
register to take part in operations with element N from other vector
registers, and the structure is called <em>vector lanes</em>:</p>
<p><img src="/2024/06/29/5-2-SIMD-MIMD-SIMD-SPMD-and-Vector/image-6.png"></p>
<p>  As with a traffic highway, we can increase the peak throughput of a
vector unit by <strong>adding more lanes</strong>.</p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 5.Parallelism</category>
      </categories>
  </entry>
  <entry>
    <title>4.1.Caches</title>
    <url>/2024/06/14/4-1-Caches/</url>
    <content><![CDATA[<h1 id="41caches"><span class="math inline">\(4.1.\)</span>Caches</h1>
<h3 id="1-some-concepts-amp-libraryanalogy">1. Some concepts &amp; Library
analogy</h3>
<blockquote>
<p>Suppose you were a student writing a term paper on important
historical developments in computer hardware. You are sitting at a desk
in a library with a collection of books that you have pulled from the
shelves and are examining. You find that several of the important
computers that you need to write about are described in the books you
have, but there is nothing about the EDSAC. Therefore, you go back to
the shelves and look for an additional book. You find a book on early
British computers that covers the EDSAC. Once you have a good selection
of books on the desk in front of you, there is a high probability that
<strong>many of the topics you need can be found in them, and you may
spend most of your time just using the books on the desk without
returning to the shelves</strong>. Having several books on the desk in
front of you saves time compared to having only one book there and
constantly having to go back to the shelves to return it and take out
another.</p>
<p>The same principle allows us to create the illusion of a large memory
that we can access as fast as a very small memory. Just as you did not
need to access all the books in the library at once with equal
probability, <strong>a program does not access all of its code or data
at once with equal probability</strong>. Otherwise,it would be
impossible to make most memory accesses fast and still have large memory
in computers, just as it would be impossible for you to fit all the
library books on your desk and still find what you wanted quickly.</p>
</blockquote>
<p>  The above line illustrates the <em>principel of locality</em>.
There are two kinds of localities:</p>
<ul>
<li><p>Temporal locality(locality in time): <strong>If an item is
referenced, it will tend to be referenced again soon.</strong> (If you
recently brought a book to your desk to look at, you will probably need
to look at it again soon.)</p></li>
<li><p>Spatial locality (locality in space): <strong>If an item is
referenced, items whose addresses are close by will tend to be
referenced soon.</strong> (For example, when you brought out the book on
early English computers to learn about the EDSAC, you also noticed that
there was another book shelved next to it about early mechanical
computers, so you likewise brought back that book and, later on, found
something useful in that book.)</p></li>
</ul>
<p>  We take advantage of the principle of locality by implementing the
memory as a <em>memory hierarchy</em>. It contains multiple levels, but
<strong>data are copied between only two adjacent levels at a
time</strong>.</p>
<p><img src="/2024/06/14/4-1-Caches/image.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-1.png"></p>
<blockquote>
<p>The faster memories are <strong>more expensive per bit</strong> than
the slower and thus are <strong>smaller</strong>.</p>
</blockquote>
<p><img src="/2024/06/14/4-1-Caches/image-2.png"></p>
<ul>
<li>If <strong>the data requested by the processor appear in some block
in the upper level</strong>, it's called a <em>hit</em>(like you find a
book on your desk). Else it's called a <em>miss</em>.</li>
</ul>
<p><img src="/2024/06/14/4-1-Caches/image-28.png"></p>
<h3 id="2memory-technologies">2.Memory technologies</h3>
<p><img src="/2024/06/14/4-1-Caches/image-3.png"></p>
<h3 id="3caches-basics">3.Caches basics</h3>
<h4 id="adirect-mapped-structure">  <span class="math inline">\(a.\)</span>Direct-mapped structure</h4>
<p>  For each word, we can assign a location in cache based on the
<em>address</em> of the word in memory, and this is called
<strong>direct-mapped</strong>.</p>
<p>  The struction uses this mapping to find a block:</p>
<p><span class="math display">\[
(blockAddress)\mod (numberOfBlockInCache)
\]</span></p>
<ul>
<li>We add a set of <em>tags</em> to the cache to judge if the data in
the cache corresponds to a requested word. The tag needs to contain
<strong>the upper portion of the address</strong>:</li>
</ul>
<p><img src="/2024/06/14/4-1-Caches/image-4.png"></p>
<ul>
<li><p>We add a <em>valid bit</em> to <strong>indicate whether an entry
contains a valid address</strong>. If the bit isn's set, there cannot be
a match for this block.</p></li>
<li><p>A <em>cache index</em> is used to <strong>select the
block</strong>.</p></li>
</ul>
<p><img src="/2024/06/14/4-1-Caches/image-5.png"></p>
<p>  The digit capacity of tage field and the total number of bits in
the struction can be calculated by the following steps:</p>
<p><img src="/2024/06/14/4-1-Caches/image-6.png"></p>
<h4 id="bdealing-with-missing-rate">  <span class="math inline">\(b.\)</span>Dealing with missing rate</h4>
<ul>
<li><p><strong>Larger blocks exploit spatial locality to lower miss
rates</strong>. This is because larger blocks <strong>contain more
adjacent data</strong>, taking advantage of locality of reference,
making it more likely that programs will hit the cache when they access
the data.</p></li>
<li><p>However, the miss rate may go up eventually if <strong>the block
size becomes a significant fraction of the cache size</strong>, for
<strong>there will be a great deal of competition for those
blocks</strong>. As a result, a block will be bumped out of the cache
before its words are accessed.</p></li>
<li><p>Also, enlarging the block size makes the <em>miss penalty</em>
larger.</p>
<ul>
<li><p>The miss penalty is determined by <strong>the time required to
fetch the block from the next lower level of the hierarchy and load it
into the cache</strong>.</p></li>
<li><p>The time to fetch the block has two parts: <strong>the latency to
the first word</strong> and <strong>the transfer time for the rest of
the block</strong>.</p></li>
</ul></li>
</ul>
<h3 id="4handling-cache-misses">4.Handling cache misses</h3>
<p>  The cache miss handling is done in collaboration with the
<em>process control unit</em> and with a separate <em>controller</em>
that initiates the memory access and refills the cache.</p>
<ul>
<li>The control unit in cache must detect a miss and process the miss by
fetching the requested data from memory. If the cache reports a hit, it
uses the data as usual.</li>
</ul>
<p>  To handle the <em>instruction misses</em>, we need to:</p>
<ol type="1">
<li><p>Send the original PC value to the memory. It equals to
<code>PC-4</code>.</p></li>
<li><p>Instruct main memory to perform a read and wait for the memory to
complete its access.</p></li>
<li><p>Write the cache entry, putting the data from memory in the data
portion of the entry, writing the upper bits of the address(from the
ALU)into the tag field, and turning the valid bit on.</p></li>
<li><p><strong>Restart the instruction execution at the first
step</strong>, which will refetch the instruction, this time
<strong>finding it in the cache</strong>.</p></li>
</ol>
<h3 id="5handling-writes">5.Handling writes</h3>
<h4 id="awrite-through">  <span class="math inline">\(a.\)</span>Write-through</h4>
<p>  One simple way to deal with write hit is <strong>always to write
the data into both the memory and the cache</strong>. However, the write
to main memory takes a long time, thus reduce the performance.</p>
<p>  One solution is to use a <em>write buffer</em>. It <strong>stores
the data while they are waiting to be written to memory</strong>.</p>
<ul>
<li><p>After writing the data into the cache and the write buffer, the
processor continues execution.</p></li>
<li><p>When a write to main memory completes, the entry in the write
buffer is freed.</p></li>
<li><p>If the write buffer is full when the processor reaches a write,
the processor must <strong>stall until there's an empty position in the
buffer</strong>.</p></li>
</ul>
<h4 id="bwrite-back">  <span class="math inline">\(b.\)</span>Write-back</h4>
<p>  When a write occurs, the new value is written only to the block in
the cache. The modified block is written to the lower level of the
hierarchy when <strong>it's replaced</strong>. This scheme is called
<em>write-back</em>. It can improve performance especially if
<strong>processors can generate writes faster than writes can be handled
by the main memory</strong>.</p>
<ul>
<li><p>In the write-through process, we can simply overwrite the block.
But in a write-back process, if we overwrite a block <strong>before we
knew whether the store had hit the cache</strong>, we may destroy the
contents of the block which isn't backed up. To avoid this, we take the
two methods:</p>
<ul>
<li><p>We use two cycles, one to <strong>check for hit</strong> and one
to <strong>perform the write</strong>.</p></li>
<li><p>Or we can use a <em>store buffer</em> to hold the data. When it's
used, the processor does the cache lookup and <strong>places the data in
the store buffer during the normal cache access cycle</strong>. The new
data <strong>are written from the store buffer into the cache on the
next unused cache access cycle</strong>.</p></li>
</ul></li>
</ul>
<blockquote>
<p>By comparison, we can always use one cycle to do writing in
write-through process. We read the tag and write the data portion of the
selected block. If the tag matches the address of the current block, the
processor continues normally, since the correct block has been updated.
Otherwise, the processor <strong>generates a write miss to fetch the
rest of the block corresponding to that address</strong>.</p>
</blockquote>
<p>  Many write-back caches also include <em>write buffers</em> that are
used to <strong>reduce the miss penalty when a miss replaces a modified
block</strong>. In such a case, <strong>the modified block is moved to a
write-back buffer associated with the cache</strong> while the requested
block is read from memory. The write-back buffer is later written back
to memory.</p>
<blockquote>
<p>The main idea is not to touch the main memory as much as
possible.</p>
</blockquote>
<p><img src="/2024/06/14/4-1-Caches/image-11.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-20.png"></p>
<h4 id="cwrite-allocate-amp-nowrite-allocate">  <span class="math inline">\(c.\)</span>Write-allocate &amp; No
write-allocate</h4>
<p>  In write-through process, to deal with the write miss, we
<strong>allocate a block in the cache called write allocate</strong>.
The block is fetched from memory and then the appropriate portion of the
block is overwritten.</p>
<blockquote>
<p>This reduces the number of accesses to main memory and increases the
speed of access.</p>
</blockquote>
<p>  Another strategy is to update the portion of the block <strong>in
memory but not put it in the cache</strong>. This is because sometimes
we need to write in the entire blocks of data, and in such situation
writing in cache is unnecessary.</p>
<p><img src="/2024/06/14/4-1-Caches/image-21.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-22.png"></p>
<blockquote>
<p>Since write-through strategy ensures the consistence between memory
and cache, if we use write-allocate strategy, the cache will contain
reduntant data block, which makes cache management more difficult.</p>
<p>And for write-back, this ensures the data consistence.</p>
</blockquote>
<h4 id="danexample">  <span class="math inline">\(d.\)</span>An
example</h4>
<p><img src="/2024/06/14/4-1-Caches/image-7.png"></p>
<p>  In this design, the steps for reading request are as follows:</p>
<ol type="1">
<li><p>Send the address to the appropriate cache.</p></li>
<li><p>If the cache signal hit, the requested word is available on the
data lines. A <em>block index</em> field is used to control the
multiplexor to select the required word from the 16 words in the indexed
block.</p></li>
<li><p>If the cache signals miss, <strong>we send the address to the
main memory. When the memory returns with the data</strong>, we write it
into the cache and then read it to fulfill the request.</p></li>
</ol>
<h3 id="6cache-performanceimprovement">6.Cache performance
improvement</h3>
<p>  There are two different techniques to improve cache performance.
One focuses on reducing the miss rate by <strong>reducing the
probability that two distinct memory blocks will contend for the same
cache location</strong>. The other reduces the miss penalty by
<strong>adding an additional level to the hierarchy</strong>. The second
technique is called <em>multilevel caching</em>.</p>
<h4 id="amore-flexible-placement-of-blocks">  <span class="math inline">\(a.\)</span>More flexible placement of blocks</h4>
<ul>
<li><p><em>Fully associative</em>: In this scheme, a block can be placed
in <strong>any location in the cache</strong>, that is, <strong>the
block may be associated with any entry in the cache</strong>.</p>
<ul>
<li><p>To find a given block in a fully-associative cache, <strong>all
the entries in the cache must be searched</strong>.</p></li>
<li><p>This process is done <strong>in parallel with a comparator
associated with each cache entry</strong>. This comparators
significantly increase the hardware cost, so the scheme only suits for
caches with small numbers of blocks.</p></li>
</ul></li>
<li><p><em>Set associative</em>: In this scheme, there are a fixed
number of locations where each block can be placed. An <em>n-way set
associative</em> cache consists of a number of sets, each of which has
<span class="math inline">\(n\)</span> blocks.</p></li>
</ul>
<p><img src="/2024/06/14/4-1-Caches/image-8.png"></p>
<p>  The advantage of increasing the degree of associativity is that
<strong>it usually decrease the miss rate</strong>. However, there's
little further improvement in going to rather higher associativity.</p>
<h4 id="blocating-a-block-in-the-cache">  <span class="math inline">\(b.\)</span>Locating a block in the cache</h4>
<p>  Let's first take a block in a set-associative cache for
example:</p>
<p><img src="/2024/06/14/4-1-Caches/image-9.png"></p>
<ul>
<li><p>The <em>tag</em> is checked to see <strong>if it matches the
block address from the processor</strong>.</p></li>
<li><p>The <em>index</em> is used to <strong>select the set containing
the address of interest</strong>.</p></li>
<li><p>All the tags in the selected set are searched <strong>in
parallel</strong>.</p></li>
</ul>
<p>  In a direct-mapped cache, only a single comparator is needed, and
we access the cache simply by indexing. In a <em>four-way
set-associative</em> cache, four comparators are needed, together with a
<strong>4-to-1 multiplexor to choose among the four potential
sets</strong>. The cache access consists of indexing the appropriate set
and then searching the tags of the set.</p>
<p><img src="/2024/06/14/4-1-Caches/image-10.png"></p>
<p>  The choice among these three scheme depends on <strong>the cost of
a miss</strong> versus <strong>the cost of implementing
associativity</strong>.</p>
<h4 id="cchoosing-which-block-to-replace">  <span class="math inline">\(c.\)</span>Choosing which block to replace</h4>
<p>  There are two primary strategies for replacement in set-associative
or fully associative caches:</p>
<ul>
<li><p><em>Random</em>: Candidate blocks are randomly selected, possibly
using some hardware assistance.</p></li>
<li><p><em>Least recently used</em>(LRU): The block replaced is the one
that has been unused for the longest time.</p></li>
</ul>
<p>  In practice, LRU is too costly to implement for hierarchies with
more than a small degree of associativity, since <strong>tracking the
usage information is expensive</strong>.</p>
<h5 id="iapproximate-lru">  <span class="math inline">\(i.\)</span>Approximate LRU</h5>
<p><img src="/2024/06/14/4-1-Caches/image-23.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-24.png"></p>
<h4 id="dmultilevel-caches">  <span class="math inline">\(d.\)</span>Multilevel caches</h4>
<p>  To close the gap between the fast clock rates of processors and the
long time to access DRAMs, most microprocessors support <strong>an
addition level of caching</strong>.</p>
<ul>
<li><p>The second-level cache is normally on the chip, and is access
<strong>whenever a miss occurs in the primary cache</strong>.</p></li>
<li><p>If the second-level cache contains the desired data, the miss
penalty for the first-level cache will be <strong>the access time of the
second-level cache</strong>, which is much less time.</p></li>
</ul>
<p>  The design considerations for a primary and secondary cache are
different. This two-level structure allows the primary cache to focus on
<strong>minimizing hit time</strong> to yield a shorter clock cycle or
fewer pipeline stages, while allowing the second cache to focus on
<strong>miss rate</strong> to reduce the penalty of long memory access
times.</p>
<ul>
<li><p>The primary cache is <strong>smaller</strong>, and may use
<strong>a smaller block size</strong> to go with the smaller cache size
and reduce miss penalty.</p></li>
<li><p>The second cache will be <strong>much larger than in a
single-level cache</strong>. It also use higher associativity than the
primary cache, both for reducing the miss rates.</p></li>
</ul>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-41.png"></p>
<h3 id="7three-cs">7.Three Cs</h3>
<p>  In the hierarchy model, all misses are classified into one of three
categories:</p>
<ul>
<li><p>Compulsory misses: These are cache misses caused by <strong>the
first access to a block that has never been in the cache</strong>. These
are also called cold-start misses.</p></li>
<li><p>Capacity misses: These are cache misses caused when <strong>the
cache cannot contain all the blocks needed during execution of a
program</strong>. Capacity misses occur <strong>when blocks are replaced
and then later retrieved</strong>.</p></li>
<li><p>Conflict misses: These are cache misses that occur in
set-associative or direct-mapped caches when <strong>multiple blocks
compete for the same set</strong>. These cache misses are also called
collision misses.</p></li>
</ul>
<hr>
<ul>
<li><p>Increasing associativity reduces conflict misses, but
associativity may <strong>slow access time</strong>, leading to lower
overall performance.</p></li>
<li><p>Capacity misses can be reduced by enlarging the cache(so
second-level caches is large). Meanwhile, when we make the cache larger,
we must also be careful about <strong>increasing the access
time</strong>(so the first-level caches is small).</p></li>
<li><p>Since compulsory misses are generated by the first reference to a
block, we can simple increase the block size to reduce the block
number.</p></li>
</ul>
<h3 id="8using-fsm-to-control-acache">8.Using FSM to control a
cache</h3>
<h4 id="afinite-state-machines">  <span class="math inline">\(a.\)</span>Finite-State Machines</h4>
<p>  A FSM consists of a set of states and directions on how to change
states.</p>
<ul>
<li><p>The directions are defined by a <em>next-state function</em>,
which maps the current state and the inputs to a new state.</p></li>
<li><p>Each state of FSM specifies a set of outputs that are asserted
when the machine is in this state.</p></li>
<li><p>A FSM can be implemented with a temporary register that
<strong>holds the current state</strong> and <strong>a block of
combinatinoal logic</strong> that determines both the data-path signals
to be asserted and the next state.</p></li>
</ul>
<p><img src="/2024/06/14/4-1-Caches/image-12.png"></p>
<h4 id="bcontroller">  <span class="math inline">\(b.\)</span>Controller</h4>
<p><img src="/2024/06/14/4-1-Caches/image-13.png"></p>
<ul>
<li><p><em>Ideal</em>: This state <strong>waits for a valid read or
write request from the processor</strong>, which <strong>moves the FSM
to the Compare Tag state</strong>.</p></li>
<li><p><em>Compare Tag</em>: This state tests to see <strong>if the
requested read or write is a hit or a miss</strong>. The index portion
of the address <strong>selects the tag to be compared</strong>. If the
data in the cache block referred to by the index portion of the address
are valid, and the tag portion of the address matches the tag, then it
is a hit. Either the data are read from the selected word if it is a
load or written to the selected word if it is a store. The Cache Ready
signal is then set. <strong>If it is a write,the dirty bit is set to
1</strong>. Note that a write hit also sets the valid bit and the tag
field; while it seems unnecessary, it is included because the tag is a
single memory, so <strong>to change the dirty bit we likewise need to
change the valid and tag fields</strong>. If it is a hit and the block
is valid, the FSM <strong>returns to the idle state</strong>. A miss
<strong>first updates the cache tag</strong> and then goes either to the
Write-Back state, if the block at this location has dirty bit value of
1, or to the Allocate state if it is 0.</p></li>
<li><p><em>Write-Back</em>: This state writes the 128-bit block to
memory using <strong>the address composed from the tag and cache
index</strong>. We remain in this state waiting for the Ready signal
from memory. When the memory write is complete, the FSM <strong>goes to
the Allocate state</strong>.</p></li>
<li><p><em>Allocate</em>: The new block <strong>is fetched from
memory</strong>. We <strong>remain in this state waiting for the Ready
signal from memory</strong>. When the memory read is complete, the FSM
goes to the Compare Tag state.</p></li>
</ul>
<h3 id="9fully-associative-cacheintroduction">9.Fully associative cache
introduction</h3>
<p><img src="/2024/06/14/4-1-Caches/image-14.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-15.png"></p>
<h3 id="10direct-mapped-cacheintroduction">10.Direct-mapped cache
introduction</h3>
<p><img src="/2024/06/14/4-1-Caches/image-16.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-17.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-29.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-30.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-31.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-32.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-33.png"></p>
<h3 id="11set-associativeintroduction">11.Set-associative
introduction</h3>
<p><img src="/2024/06/14/4-1-Caches/image-18.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-19.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-34.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-35.png"></p>
<h3 id="12fully-associativeintroduction">12.Fully-associative
introduction</h3>
<p><img src="/2024/06/14/4-1-Caches/image-25.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-26.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-27.png"></p>
<h3 id="13analyzing-cache-performance">13.Analyzing cache performance</h3>
<p><img src="/2024/06/14/4-1-Caches/image-36.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-37.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-38.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-39.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-40.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 4.Cache</category>
      </categories>
  </entry>
  <entry>
    <title>3.5.Pipelined Datapath and Control</title>
    <url>/2024/06/07/3-5-Pipelined-Datapath-and-Control/</url>
    <content><![CDATA[<h1 id="35pipelined-datapath-and-control"><span class="math inline">\(3.5.\)</span>Pipelined Datapath and Control</h1>
<h3 id="1some-point">1.Some point</h3>
<ul>
<li><p>All the instructions go from left to right through the datapath
except the write-back stage and the selection of the next value of PC,
and they never move backward.</p>
<ul>
<li>So the first right-to-left flow of data can lead to data hazards
while the second leads to control hazards.</li>
</ul></li>
<li><p>One way to show what happens in pipelined execution is to pretend
that each instruction has its own datapath, and then to place these
datapaths on a timeline to show their relationship:</p></li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image.png"></p>
<p>  All instructions advance during each clock cycle from one pipeline
register to the next.</p>
<h3 id="2pipeline-registers">2.Pipeline registers</h3>
<ul>
<li><p>A separate pipeline register is redundant to the state that is
updated. For example, a load instruction will place its result in one of
the 32 registers, and any later instruction that needs that data will
<strong>simply read the appropriate register</strong>.</p>
<ul>
<li>Every instruction updates PC, and the PC can be thought of as a
pipeline register: one <strong>that feeds the IF stage of the
pipeline</strong>.</li>
</ul></li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-1.png"></p>
<p>  We use the command <code>ld</code> to illustrate the pipe stage
that is active in each stage:</p>
<ol type="1">
<li><em>Instruction fetch</em>: The PC is saved in the IF/ID pipeline
register in case it's needed later for an instruction. This stage occurs
<strong>before the instruction is identified</strong>.</li>
</ol>
<blockquote>
<p>The computer cannot know which type of instruction is being fetched,
so it must <strong>prepare for any instruction, passing potentially
needed information down the pipeline</strong>.</p>
</blockquote>
<ol start="2" type="1">
<li><em>Instruction decode and register file read</em>: Both the two
read value and sign-extended immediate are stored in the ID/EX pipeline
register, along with PC address.</li>
</ol>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-2.png"></p>
<ol start="3" type="1">
<li><em>Execute/address calculation</em>: It reads the information from
the ID/EX pipeline register and add then using ALU. The result is placed
in EX/MEM pipeline register.</li>
</ol>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-3.png"></p>
<ol start="4" type="1">
<li><em>Memory access</em>: It uses the data from EX/MEM register and
loads the data into MEM/WB pipeline register.</li>
</ol>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-4.png"></p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-5.png"></p>
<ol start="5" type="1">
<li><em>Write back</em>: There's nothing to do in this stage.</li>
</ol>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-6.png"></p>
<p>  From the analysis above, we can get some key point:</p>
<ul>
<li><p>The information must be placed in a pipeline register, otherwise,
<strong>the information is lost when the next instruction enters that
pipeline stage</strong>.</p></li>
<li><p>Each logical component of the datapath(ALU, data memory, etc),
can be used <strong>only within a single pipeline stage</strong>. That
is, <strong>each pipeline register can only be used by one phase in one
clock cycle</strong>, which ensures that <strong>no more than one
instruction can access the same hardware resources simultaneously in one
clock cycle</strong>, thus avoiding structural dangers.</p></li>
</ul>
<p>  We know that the instruction in IF/ID pipeline register supplies
the writer register number, but the instruction fetch procedure occurs
after the <code>ld</code> instruction(because it is conducted before an
instruction is identified, so only when we complete the <code>ld</code>
instruction will this step be done)! Hence, we need to <strong>preserve
the distination register number in the <code>ld</code>
instruction</strong>. The <code>ld</code> must pass the register number
from ID/EX through EX/MEM to the MEM/WB pipeline register for use in the
WB stage.</p>
<h3 id="3data-hazards-amp-forwarding">3.Data hazards &amp; forwarding</h3>
<h4 id="adatahazards">  <span class="math inline">\(a.\)</span>Data
hazards</h4>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-7.png"></p>
<h4 id="bdetact-hazards">  <span class="math inline">\(b.\)</span>Detact hazards</h4>
<p>  We first introduce a notation: we use "ID/EX.RegisterRs1" to refer
to the number of 1 register whose value is found in the pipeline
register ID/EX.</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-8.png"></p>
<p>  Using this notation, the two pairs of hazard conditions are:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-9.png"></p>
<ul>
<li>The <code>sub-and</code> is a type 1a hazard:</li>
</ul>
<p><span class="math display">\[
MEM/WB.RegisterRd=ID/EX.RegisterRs2=x2
\]</span></p>
<ul>
<li><p>The <code>sub-or</code> is a type 2a hazard.</p></li>
<li><p>There's no data hazard between <code>sub</code> and
<code>sd</code> because <strong><code>sd</code> reads <code>x2</code>
the clock cycle after <code>sub</code> writes
<code>x2</code></strong>.</p></li>
</ul>
<blockquote>
<p>Pay attention to the clock cycle, not the name!!!</p>
</blockquote>
<p>  One way to detact the hazards is simple <strong>check if the
<code>RegWrite</code> signal is active</strong>. This can be done by
<strong>examing the <code>WB</code> control field of the pipeline
register during the <code>EX</code> and <code>MEM</code>
stages</strong>.</p>
<blockquote>
<p>Recall that RISC-V requires that <code>x0</code> is taken as an
oprand value of 0, if an instruction in the pipeline has <code>x0</code>
as its destination, we want to <strong>avoid forwarding its possibly
nonzero value</strong>.</p>
</blockquote>
<h4 id="csolution">  <span class="math inline">\(c.\)</span>Solution</h4>
<p>  If we can take the inputs to the ALU <strong>from any pipeline
register rather than just ID/EX</strong>, then we can forward the
correct data.</p>
<p>  By <strong>adding multiplexors to the input of the ALU, and with
the proper controls</strong>, we can run the pipeline at full speed in
the presence of these data hazards:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-10.png"></p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-11.png"></p>
<blockquote>
<p>Before forwarding, the ID/EX register has no need to include space to
hold the rs1 and rs2 fields, so they are added to ID/EX.</p>
</blockquote>
<h4 id="ddetailed-detection-ampresolution">  <span class="math inline">\(d.\)</span>Detailed detection &amp;
resolution</h4>
<ul>
<li><p>EX hazard:</p>
<ul>
<li>If there's a write operation and a load operation at the same time,
and the loaded object is under writting, then there's an EX hazard:</li>
</ul></li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-12.png"></p>
<p>  This case forwards the result from the previous instruction to
either input of the ALU instead of the pipeline register EX/MEM</p>
<ul>
<li><p>MEM hazard</p>
<ul>
<li>If the writting part is just loaded.</li>
</ul></li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-13.png"> <img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-14.png"></p>
<blockquote>
<p>What happens when a register is read and written in the same clock
cycle? We assume that <strong>the write is in the first half of the
clock cycle and the read is in the second half</strong>, so the read
delivers what is written. As is the case for many implementations of
register files, we have no data hazard in this case.</p>
<p>As mentioned above, there is no hazard in the WB stage, because
<strong>we assume that the register file supplies the correct
result</strong> if the instruction in the ID stage reads the same
register written by the instruction in the WB stage.</p>
</blockquote>
<p>  One complication occurs when we all read and write to a same
register:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add x1 x1 x2</span><br><span class="line">add x1 x1 x3</span><br><span class="line">add x1 x1 x4</span><br></pre></td></tr></table></figure>
<p>  In this case, <strong>the result should be forwarded from the MEM
stage, because the MEM stage is the more recent result</strong>. Thus,
the control for the MEM should be:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-15.png"></p>
<blockquote>
<p>Why <code>not EX/MEM.RegisterRd = ID/EX.RegisterRs1</code>? Because
if this is true, then <strong>the instruction of EX/MEM should be
written back into the register</strong>(because it's the most current),
and it will cover the result of MEM/WB. So we take EX/MEM first.</p>
</blockquote>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-16.png"></p>
<h4 id="estalls">  <span class="math inline">\(e.\)</span>Stalls</h4>
<p>  One case where forwarding cannot help is when <strong>an
instruction tries to read a register following a load instruction that
writes the same register</strong>:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-17.png"></p>
<blockquote>
<p>The RAM is used by <code>add</code> before it's updated, and it won't
be updated until the <code>lw</code> ends. Since it must be used in the
first step, forwarding cannot help.</p>
</blockquote>
<p>  Hence, we also need a <em>hazard detection unit</em>. It operates
during the ID stage so that it can insert the stall between the load and
the instruction depentent on it:</p>
<ul>
<li>If it's in a load process, and the being-loaded object involves in
other process.</li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-18.png"></p>
<p>  If the instruction in the ID stage is stalled, then the instruction
in the IF stage must also be stalled, or we will lose the fetch of
instruction. Therefore, <strong>the instruction in the IF stage will
continue to be read using the same PC</strong>. The EX stage must also
be doing something, so we let it <strong>execute instructions that have
no effect: nops</strong>.</p>
<p>  <strong>Deasserting all seven control signals(setting them to 0) in
the EX, MEM, WB stages</strong> will create a nop instruction:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-19.png"></p>
<ul>
<li><p>The forwarding unit controls the ALU multiplexor s to replace the
value from a general-purpose register with that in the pipeline
register.</p></li>
<li><p>The hazard detection unit controls the writing of the PC and
IF/ID registers plus the multiplexor that choose between the real
control values and all 0s.</p></li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-20.png"></p>
<h3 id="4control-hazards">4.Control hazards</h3>
<h4 id="aassume-branch-not-taken">  <span class="math inline">\(a.\)</span>Assume branch not taken</h4>
<p>  We can assume the branch is not taken. If the condition branch is
taken instead, <strong>the instructions that are being fetched and
decoded must be discarded</strong>.</p>
<p>  To discard instructions, we merely change the original control
values to 0s. Notice that we must also change the three instructions in
the IF, ID and EX stages when the branch reaches the MEM stage, which is
called <em>flush</em>.</p>
<p>  To flush instructions in the IF, we <strong>add a control line
called IF.Flush</strong>, it zeros the instruction field of the IF/ID
pipeline register.</p>
<h4 id="breducing-the-delay-of-branches">  <span class="math inline">\(b.\)</span>Reducing the delay of branches</h4>
<p>  One way to improve conditional branch performance is to reduce the
cost of taken branch. We have assumed that the next PC for a branch is
selected in the MEM stage, but <strong>if we move the conditional branch
execution earlier in the pipeline, then fewer instructions need be
flushed</strong>.</p>
<p>  Moving the branch decision up requires two actions to occur
earlier: computing the branch target address and evaluating the branch
decision.</p>
<p>  Moving up the address calculation is easy, we can <strong>move the
branch adder from EX stage to ID stage</strong>.</p>
<p>  The harder part is branch decision itself. We must deal with two
complicate factors:</p>
<ol type="1">
<li><p>The introduction of equlity test unit.</p></li>
<li><p>Because <strong>the value in a branch comparison is needed during
ID but may be produced later in time</strong>, it is possible that a
data hazard can occur and a stall will be needed.</p></li>
</ol>
<h3 id="5dynamic-branch-prediction">5.Dynamic branch prediction</h3>
<ul>
<li>This method looks up the address of the instruction to see
<strong>if the conditional branch was taken the last time this
instruction was executed</strong>, and, if so, to <strong>begin fetching
new instructions from the same place as the last time</strong>.</li>
</ul>
<p>  One implementation of this approach is a <em>branch prediction
buffer</em> or <em>branch history table</em>. A branch prediction buffer
is a small memory indexed by the lower portion of the address of the
branch instruction. The memory contains <strong>a bit that says whether
the branch was recently taken or not</strong>.</p>
<ul>
<li>Fetching begins in the predicted direction. If the predition turns
out to be wrong, the incorrectly predicted instructions are deleted, the
predition bit is inverted and stored back, and the proper sequence is
fetched and executed.</li>
</ul>
<blockquote>
<p>  To improve the accuracy, the <em>2-bit prediction schemes</em> are
often used. In a 2-bit scheme, <strong>a prediction must be wrong twive
before it is changed</strong>:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-21.png"></p>
</blockquote>
<hr>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-22.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 3.Program Process</category>
      </categories>
  </entry>
  <entry>
    <title>3.4.Building a Datapath</title>
    <url>/2024/06/05/3-4-Building-a-Datapath/</url>
    <content><![CDATA[<h1 id="34building-a-datapath"><span class="math inline">\(3.4.\)</span>Building a Datapath</h1>
<h3 id="1basic-devices">1.Basic devices</h3>
<ul>
<li><p><em>Registers</em>: It contains:</p>
<ul>
<li><p>Two data words from the register file, and <strong>write one data
word into the register file</strong> for each instruction.</p></li>
<li><p>An input. It <strong>specifies the register number to be
read</strong>.</p></li>
<li><p>An output. It <strong>carries the value that has been read from
the register</strong>.</p></li>
<li><p>To write a data word, we need two more inputs: one to
<strong>specify the register number to be written</strong> and one to
<strong>supply the data to be written into the
register</strong>.</p></li>
</ul></li>
</ul>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image.png"></p>
<ul>
<li><em>ALU</em></li>
</ul>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-1.png"></p>
<ul>
<li><em>Immediate generation unit</em>: In operations like
<code>addi x1 x2 10</code>, the immediate number <code>10</code> is
written in 12-bit offset in the instruction. So we need to
<strong>sign-extend the number to a 64-bit signed value</strong>. The
Imm-Gen does the job:</li>
</ul>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-4.png"></p>
<h3 id="2basic-phases-ofinstruction-execution">2.Basic phases of
instruction execution</h3>
<p>  The phases of instruction execution can be divided into 5
parts:</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-2.png"></p>
<hr>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-3.png"></p>
<h3 id="3implementation-ofdifferent-statement">3.Implementation of
different statement</h3>
<h4 id="aaddinstruction">  <span class="math inline">\(a.\)</span>Add
instruction</h4>
<p>  The <code>add</code> is simple, we just get value from
<code>DataA</code> and <code>DataB</code>, and calculate the result by
ALU.</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-7.png"></p>
<p>  To perform <code>addi</code>, we get one of out input from Imm-Gen
rather than <code>DataB</code>. The source of Imm-Gen is from
<code>IMEM</code>, from which we can get the instruction, and
<code>inst[31:20]</code> is the immediate we want:</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-8.png"></p>
<h4 id="bload-ampsave-instruction">  <span class="math inline">\(b.\)</span><code>load</code> &amp;
<code>save</code> instruction</h4>
<p>  To implement the instructions, we can add a <code>DMEM</code> to
read or write data.</p>
<ul>
<li><code>DMEM</code>: It's input is <code>Addr</code> and outputs
<code>DataR</code>. When in "read" mode, it gets information from the
address. Else, it writes the information into the address:</li>
</ul>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-10.png"></p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-11.png"></p>
<h4 id="cbranch-instruction">  <span class="math inline">\(c.\)</span>Branch instruction</h4>
<p>  The basic form of branch instruction is
<code>beq x1 x2 offset</code>. To implement this instruction, we must
compute the branch target address by <strong>adding the sign- extended
offset field of the instruction to the PC</strong>. There are two
details in the definition of branch instructions to which we must pay
attention:</p>
<ul>
<li><p>The instruction set architecture specifies that <strong>the base
for the branch address calculation is the address of the branch
instruction</strong>.</p></li>
<li><p>The architecture also states that <strong>the offset field is
shifted left 1 bit so that it is a half word offset</strong>; this shift
<strong>increases the effective range of the offset field by a factor of
2</strong>.</p></li>
</ul>
<p>  If the branch condtion is true, the branch target address becomes
the new PC, and we say the branch is <strong>taken</strong>. Else, we
say the branch is <strong>not taken</strong>.</p>
<p>  We first get the address of <code>PC+4</code> and branch through
this struction:</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-5.png"></p>
<p>  To select from multiple address, we use a multiplexor and control
signal</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-6.png"></p>
<p>  Combined with the previous struction, we get this design:</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-9.png"></p>
<h4 id="djal-ampjalr-instructions">  <span class="math inline">\(d.\)</span><code>jal</code> &amp;
<code>jalr</code> instructions</h4>
<p>  <code>jalr</code> does the following things:</p>
<ol type="1">
<li><p>Set <code>PC=Reg[rs1]+immediate</code></p>
<ul>
<li>Uses same immediate as arithmetic and loads. <strong>No multiple by
2 bytes!</strong></li>
</ul></li>
<li><p>Set <code>PC=PC+offset</code></p>
<ul>
<li>Since the offset is calculated by ALU, we <strong>connect the output
of ALU with input of PC</strong>.</li>
</ul></li>
</ol>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-12.png"></p>
<p>  <code>jal</code> does the following things:</p>
<ol type="1">
<li>Save <code>PC+4</code> in <code>Reg[rd]</code>(namely
<code>DataD</code>)</li>
<li>Set <code>PC=PC+offset</code></li>
</ol>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-13.png"></p>
<h3 id="4datapath-control">4.Datapath control</h3>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-14.png"></p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-15.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 3.Program Process</category>
      </categories>
  </entry>
  <entry>
    <title>3.3.Synchronous Digital Systems</title>
    <url>/2024/06/05/3-3-Synchronous-Digital-Systems/</url>
    <content><![CDATA[<h1 id="33synchronous-digital-systems"><span class="math inline">\(3.3.\)</span>Synchronous Digital Systems</h1>
<h3 id="1clock-concepts">1.Clock concepts</h3>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image.png"></p>
<h3 id="2d-flip-flops">2.D Flip-flops</h3>
<h4 id="a-dffconcept">  <span class="math inline">\(a.\)</span> DFF
concept</h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-1.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-2.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-3.png"></p>
<blockquote>
<p>The <span class="math inline">\(Q\)</span> is the output of DFF, the
<span class="math inline">\(D\)</span> is the data input.</p>
</blockquote>
<blockquote>
<p>DFF only responds to the input signal on the rising edge of the clock
signal, it captures and latches the value of data input. <strong>It will
hold the value until the next rising edge of the clock
signal</strong>.</p>
</blockquote>
<ul>
<li><p><em>Clock-to-Q delay</em> is <strong>the amount of time that it
take for the input to propagate to the output after the clock
trigger</strong>.</p></li>
<li><p><em>Setup time</em> is the amount of time that the input needs to
be stable BEFORE the clock trigger</p></li>
</ul>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-4.png"></p>
<ul>
<li><em>Hold time</em> is the amount of time that the input needs to be
stable AFTER the clock trigger</li>
</ul>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-6.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-5.png"></p>
<h3 id="3register">3.Register</h3>
<h4 id="asomeconcept">  <span class="math inline">\(a.\)</span>Some
concept</h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-7.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-8.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-9.png"></p>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-10.png"></p>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-11.png"></p>
<blockquote>
<p>Why this? Because the max hold time is to <strong>ensure that data
input D remains stable for a period of time after the rising edge of the
clock arrives</strong>. And the period of time equals to the delay of
<span class="math inline">\(A\)</span> plus the combinational delay.</p>
</blockquote>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-12.png"></p>
<blockquote>
<p>Why this? Because the min clock cycle is to <strong>ensure that the
signal is properly transmitted during the clock cycle and captured by
the next register</strong>. So we must take the longest time into
consideration.</p>
</blockquote>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-13.png"></p>
<h3 id="4transitor">4.Transitor</h3>
<h4 id="ametal-oxide-semiconductor-field-effecttransistormosfet">  <span class="math inline">\(a.\)</span>Metal-Oxide Semiconductor Field Effect
Transistor(MOSFET)</h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-14.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-15.png"></p>
<p>  To know how the result comes from, we can <strong>view the value of
<span class="math inline">\(S\)</span>, <span class="math inline">\(G\)</span> and <span class="math inline">\(D\)</span> as the voltage</strong>. Take this as
an example:</p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-16.png"></p>
<ul>
<li><p>First we need to know <strong>whether the switch is
closed</strong>. <strong>If the switch is closed, then the state of
<span class="math inline">\(D\)</span> is decided by the outside
circuits</strong>.</p></li>
<li><p>When the switch is on, we then judge <strong>if the voltage of
<span class="math inline">\(S\)</span> is higher than that of <span class="math inline">\(G\)</span></strong>. If it's true, then the FET is
conducting, and vice versa.</p></li>
</ul>
<p>  In this example, the voltage of <span class="math inline">\(S\)</span> is lower than <span class="math inline">\(G\)</span>, so the <span class="math inline">\(D\)</span> can't get the electronic, thus it's
0.</p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-17.png"></p>
<h4 id="bvddand-ground">  <span class="math inline">\(b.\)</span>Vdd
and Ground</h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-18.png"></p>
<h4 id="cbuilding-an-inverter">  <span class="math inline">\(c.\)</span>Building an Inverter</h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-19.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-20.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-21.png"></p>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-22.png"></p>
<h4 id="dbuilding-other-gates">  <span class="math inline">\(d.\)</span>Building other gates</h4>
<p>  To build a CMOS, we:</p>
<ol type="1">
<li><p>Implement the pull-up network and pull-down network separately to
fit the truth table.</p>
<ul>
<li>It's OK to get the opposite of truth table. <strong>We can simply
convert it through an invertor</strong>.</li>
</ul></li>
<li><p>Connect the pull-up with Vdd, and the pull-down with
Ground.</p></li>
</ol>
<p>  We take the <code>NAND</code> gate for example:</p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-23.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-24.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-25.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-26.png"></p>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-27.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-28.png"></p>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-29.png"></p>
<h4 id="ethe-use-of-demorgans-law">  <span class="math inline">\(e.\)</span>The use of DeMorgan's Law</h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-30.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-31.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-32.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 3.Program Process</category>
      </categories>
  </entry>
  <entry>
    <title>3.2.Introduction to Digital System</title>
    <url>/2024/06/04/3-2-Introduction-to-Digital-System/</url>
    <content><![CDATA[<h1 id="32introduction-to-digital-system"><span class="math inline">\(3.2.\)</span>Introduction to Digital System</h1>
<h3 id="1logic-gate-representation">1.Logic gate representation</h3>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-1.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-2.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-3.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-4.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-5.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-6.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-7.png"></p>
<h3 id="2using-booleanalgebra-to-simplify-circuits">2.Using boolean
algebra to simplify circuits</h3>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-8.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-9.png"></p>
<h3 id="3build-an-adder">3.Build an Adder</h3>
<h4 id="ahalfadder">  <span class="math inline">\(a.\)</span>Half
adder</h4>
<p>  A half adder's output consists of:</p>
<ul>
<li>The <em>sum</em>. It can be computed by <code>xor</code>
method.</li>
<li>The <em>carry</em>. It can be computed by <code>and</code>
method.</li>
</ul>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-10.png"></p>
<h4 id="bfulladder">  <span class="math inline">\(b.\)</span>Full
adder</h4>
<p>  To implement full adder, we just need to add <code>A</code>,
<code>B</code> and the carry at the position <span class="math inline">\(C_i\)</span>.</p>
<p>  The output of a full adder is the same as the half adder. Then how
can we calculate each of them?</p>
<ul>
<li><p>For <span class="math inline">\(C_0\)</span>, it's decided by the
sum of <code>A</code> and <code>B</code> &amp; the current carry in the
position. There are two cases that make the carry 1:</p>
<ol type="1">
<li><code>A + B</code> is 1, and current carry is 1.</li>
<li><code>A + B</code> is 2, and current carry can be 0 or 1.</li>
</ol></li>
</ul>
<p>  So we can compute <span class="math inline">\(C_0\)</span> by this
expression:</p>
<p><span class="math display">\[
C_0 = C_i(A+B) + AB
\]</span></p>
<ul>
<li>The sum is easy, it becomes 1 when 1 or 3 of <code>A</code>,
<code>B</code> and current carry is 1:</li>
</ul>
<p><span class="math display">\[
S = A \; xor B \; xor C_i
\]</span></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-11.png"></p>
<h4 id="c4-bit-adder">  $c.$4-bit Adder</h4>
<p>  To make a multi-bit Adder, we simply <strong>connect full adder
together</strong>:</p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-12.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 3.Program Process</category>
      </categories>
  </entry>
  <entry>
    <title>3.1.Translating &amp; Starting a Program</title>
    <url>/2024/06/03/3-1-Translating-Starting-a-Program/</url>
    <content><![CDATA[<h1 id="31translating-amp-starting-aprogram"><span class="math inline">\(3.1.\)</span>Translating &amp; Starting a
Program</h1>
<h3 id="1a-complex-example">1.A complex example</h3>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image.png"></p>
<p>  When we are going to translate the program, we should follow the
following process:</p>
<ol type="1">
<li><p>Need to decide on what variables go in what registers</p></li>
<li><p>Need to determine which registers we need to save on function
entry (the function preamble/prolog)</p>
<ol type="1">
<li>Decrement the stack</li>
<li>Save all the callee saved registers we will use</li>
<li>Save ra or any other caller saved registers we need to live across
calls to other functions</li>
</ol></li>
<li><p>Translate the code itself</p></li>
<li><p>Restore all the registers necessary (the function
postamble/epilog)</p>
<ol type="1">
<li>Restore the callee saved registers we used</li>
<li>Restore <code>ra</code></li>
<li>Increment the stack</li>
</ol></li>
<li><p>Return using <code>jr</code></p></li>
</ol>
<p>  There are some points in the process:</p>
<ul>
<li>Return <code>null</code>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li a0 0</span><br><span class="line">j postamble</span><br></pre></td></tr></table></figure>
<ul>
<li>When calling function, we can <strong>use the <code>call</code>
pseudo-instruction for <code>jal ra (location)</code></strong>. For
example, <code>call malloc</code>.</li>
</ul>
<h3 id="2interpretation">2.Interpretation</h3>
<ul>
<li><p>Interpreter <strong>directly executes a program in the source
language</strong>.</p></li>
<li><p>Since interpreter <strong>is closer to high-level</strong>, it
can give better error messages during interpreting.</p></li>
<li><p>Because the interpreter executes intermediate representations
rather than direct machine code, <strong>the same source code can be run
from one machine to another without modification of the source
code</strong>.</p></li>
</ul>
<h3 id="3calling-chain">3.Calling chain</h3>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-1.png"></p>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-2.png"></p>
<h3 id="4compilation">4.Compilation</h3>
<h4 id="aconcepts">  <span class="math inline">\(a.\)</span>Concepts</h4>
<p>  The compiler transforms the C program into <strong>an assembly
language program</strong>, a symbolic form of what the machine
understands. High-level language programs take many fewer lines of code
than assembly language, so programmer productivity is much higher.</p>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-3.png"></p>
<h4 id="bassembler">  <span class="math inline">\(b.\)</span>Assembler</h4>
<ul>
<li><p>The assembler <strong>converts the assembly language instruction
into machine language</strong>. It turns the assembly language program
into an <strong>object file, which is a combination of machine language
instructions, data, and information needed to place instructions
properly in memory.</strong></p></li>
<li><p>Assembler will also <strong>accept numbers in a variety of
bases</strong>.</p></li>
</ul>
<p>  To produce the binary version of each instruction in the assembly
language program, the assembler must determine the address corresponding
to all labels. This is done by a <strong>symbol table</strong>.</p>
<ul>
<li><p>The object file for UNIX mainly consists of:</p>
<ul>
<li><p>The object file header describes <strong>the size and position of
the other pieces of the object file</strong>.</p></li>
<li><p>The text segment contains <strong>the machine language
code</strong>.</p></li>
<li><p>The static data segment contains <strong>data allocated for the
life of the program</strong>.</p></li>
<li><p>The relocation information identifies instructions and data words
that <strong>depend on absolute addresses when the program is loaded
into memory</strong>.</p></li>
<li><p>The symbol table contains <strong>the remaining labels that are
not defined</strong>, such as external references.</p>
<ul>
<li>Use <strong>dummy "placeholders"</strong> for unresolved absolute
and external references.</li>
</ul></li>
<li><p>The debugging information contains <strong>a concise description
of how the modules were compiled</strong>.</p></li>
</ul></li>
</ul>
<hr>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-4.png"></p>
<blockquote>
<p><span class="math inline">\(p.s.\)</span> The <code>auipc</code>
instruction <strong>adds an immediate number to the current PC
value</strong>. This means that the generated address <strong>is
relative to the current instruction</strong>. It add an offset to the PC
(upper 20 bits to the left of the instant number by 12 bits), and use
<code>addi</code> to load the lower 12 bits.</p>
<p><code>lui</code> instructions are used to generate absolute
addresses, which are fixed addresses of data in memory. This approach
works for memory addresses that do not move. It loads an instant number
to the upper 20 bits of the register.</p>
</blockquote>
<h4 id="clinker">  <span class="math inline">\(c.\)</span>Linker</h4>
<p>  Linker is used for <strong>compiling and assembling each procedure
independently</strong>, so that a change to one line would require
resolving only one procedure. It's a system that <strong>combines
independently assembled machine language programs</strong> and
<strong>resolves all undefined labels into an executable
file</strong>.</p>
<p>  There are three steps for the linker:</p>
<ol type="1">
<li>Place code and data modules symbolically in memory.</li>
<li>Determine the addresses of data and instruction labels.</li>
<li>Patch both the internal and external references.</li>
</ol>
<p>  The linker uses the relocation information and symbol table in each
object module to <strong>resolve all undefined labels</strong>.</p>
<ul>
<li>For each entry in the relocation table, it replaces it with
<strong>the actual address for the symbol table of the item</strong> we
are linking to.</li>
</ul>
<p>  If all external references are resolved, the linker next
<strong>determines the memory locations each module will
occupy</strong>. Since the files were assembled in isolation,
<strong>the assembler couldn't know where a module's instructions and
data would be placed relative to other modules</strong>. So when the
linker places a module in memory, all <strong>absolute references, that
is, memory addresses that are not relative to a register</strong>, must
<strong>be relocated to reflect its true location</strong>.</p>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-7.png"></p>
<h4 id="dtype-of-addressing">  <span class="math inline">\(d.\)</span>Type of addressing</h4>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-5.png"></p>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-6.png"></p>
<h4 id="eloader">  <span class="math inline">\(e.\)</span>Loader</h4>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-8.png"></p>
<h3 id="5dynamically-linkedlibraries">5.Dynamically linked
libraries</h3>
<p>  In tradition, before the program is run, the library has been
linked. Although this static approach is the fastest way to call library
routines,it has a few disadvantages:</p>
<ol type="1">
<li><p>The library routines become <strong>part of the executable
code</strong>. If a new version of the library is released, <strong>the
statically linked program keeps using the old version</strong>.</p></li>
<li><p>It loads <strong>all routines in the library that are called
anywhere in the executable</strong>, even if those calls are not
executed.</p></li>
</ol>
<p>  A replacement of it is called <em>dynamically linked
libraries</em>, where the library routines are not linked and loaded
<strong>until the program is run</strong>.</p>
<ol type="1">
<li><p>The first time the library routine is called, the program
<strong>calls the dummy entry and follows the indirect branch</strong>,
which points to a piece of code.</p></li>
<li><p>The code <strong>puts a number in a register</strong> to
<strong>identify the desired library routine</strong>.</p></li>
<li><p>Then it branches to the dynamic linker/loader.</p></li>
<li><p>The linker/loader finds the wanted routine, <strong>remaps it
into the memory</strong>, and <strong>changes the address in the
indirect branch location to point to that routine</strong>. Then it
branches to it.</p></li>
</ol>
<blockquote>
<p>The dynamic linker loads the library function into memory on the
first call and updates the indirect branch address. In this way, if the
following call to the library function, the program can directly jump to
the correct memory address, avoid repeated symbol parsing and address
calculation, which improves the efficiency of the program.</p>
</blockquote>
<ol start="5" type="1">
<li>When the routine completes, it <strong>returns to the original
calling site</strong>.</li>
</ol>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 3.Program Process</category>
      </categories>
  </entry>
  <entry>
    <title>1.1~1.5的一些概念</title>
    <url>/2024/05/31/1.1-1.5%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="someconceptsinfrom11to15"><span class="math inline">\(some\;concepts\;in\;from\;1.1\;to\;1.5\)</span></h1>
<h3 id="1environment">1.<span class="math inline">\(Environment\)</span></h3>
<blockquote>
<p>  An environment in which an expression is evaluated consists of a
sequence of frames, depicted as boxes. Each frame contains bindings,
each of which associates a name with its corresponding value. Assignment
and import statements add entries to the first frame of the current
environment.</p>
</blockquote>
<h3 id="2function-as-abstractions">2.<span class="math inline">\(Function\)</span> <span class="math inline">\(as\)</span> <span class="math inline">\(abstractions\)</span></h3>
<p>  我们以下面这个简单的程序为例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add, mul</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> mul(x, x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_squares</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> add(square(x), square(y))</span><br></pre></td></tr></table></figure></p>
<p>  我们可以<strong>写出求和平方，而不必考虑如何求一个数的平方</strong>。如何计算平方的细节可以去掉，以后再考虑。事实上，就<span class="math inline">\(sum\_square\)</span>而言，<span class="math inline">\(square\)</span>不是一个特定的函数体，而是<strong>一个函数的抽象，即函数抽象</strong>。我们可以将<span class="math inline">\(square\)</span>看作一个“黑匣子”，我们放入一个值，然后函数输出一个值，而<strong>中间的实现细节我们并不关心</strong>。</p>
<p>  为了掌握函数抽象的使用，考虑它的三个核心属性通常是有用的：</p>
<ul>
<li><strong>函数的域(domain)</strong> 是它可以接受的一组参数。</li>
<li><strong>函数的范围(range)</strong> 是它可以返回的值的集合。</li>
<li><strong>函数的目的(intent)</strong>
是它计算输入和输出之间的关系(以及它可能产生的任何副作用)，可以看作是输入到输出的抽象映射。</li>
</ul>
<p>  例如对于<span class="math inline">\(sum\_square\)</span>，其：</p>
<ul>
<li><span class="math inline">\(domain\)</span>：两个数。</li>
<li><span class="math inline">\(range\)</span>：非负实数。</li>
<li><span class="math inline">\(intent\)</span>：返回两个数的平方和。</li>
</ul>
<p>  这些属性没有指定如何执行意图；<strong>这些细节被抽象掉了</strong>。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 1.Building Abstractions with Functions</category>
      </categories>
  </entry>
  <entry>
    <title>1.6.高阶函数</title>
    <url>/2024/05/31/1.6.%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="16高阶函数"><span class="math inline">\(1.6\)</span>高阶函数</h1>
<h3 id="1引入">1.引入</h3>
<p>  由前面的讲解我们知道，<strong>函数是一种抽象方法，它描述独立于其参数的特定值的复合操作。</strong>
例如对函数<span class="math inline">\(square\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br></pre></td></tr></table></figure>
  我们讨论的并不是某个特定的数的平方，而是对任何数的平方的普遍规律。同时，函数中的<code>*</code>也是一种抽象映射，代表乘法。当抽象映射较简单时，我们可以直接用符号来表示；但当抽象映射非常复杂时，我们就会<strong>用一个特定函数来实现这个抽象映射</strong>。</p>
<p>  然而，在将相应的抽象映射转化为特定函数后，我们要<strong>将这个特定函数放入原有函数中，构造出能够接受该特定函数作为参数或返回函数作为值的函数</strong>。这样的函数即被称为<strong>高阶函数</strong>。</p>
<h3 id="2作为参数的函数">2.作为参数的函数</h3>
<p>  我们考虑对下面三种求和的代码实现：</p>
<ul>
<li><p><span class="math inline">\(1+2+\cdots +n\)</span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum1</span>(<span class="params">n</span>):</span><br><span class="line">    tot,k=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        tot,k=tot+k,k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure></p></li>
<li><p><span class="math inline">\(1^3+2^3+\cdots +n^3\)</span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum2</span>(<span class="params">n</span>):</span><br><span class="line">    tot,k=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        tot,k=tot+k,k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> tot </span><br></pre></td></tr></table></figure></p></li>
<li><p><span class="math inline">\({4\over{1·3}}+{4\over{3·5}}+\cdots+{4\over{(2n-1)·(2n+1)}}\)</span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum2</span>(<span class="params">n</span>):</span><br><span class="line">    tot,k=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        tot,k=tot+<span class="number">4</span>/((<span class="number">2</span>*k-<span class="number">1</span>)*(<span class="number">2</span>*k+<span class="number">1</span>)),k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure>   可以看出，上述求和都可以归纳为以下模式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">n</span>):</span><br><span class="line">    tot,k=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        tot,k=f(k),k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure>
  这种<strong>公共模式的存在强有力地证明了有一个有用的抽象正等待着被提出来。</strong>通过更进一步的抽象，我们的函数将不止能求解这些特定类型的求和，而是可以求出所有普遍意义上的求和。于是我们<strong>使用函数作为参数</strong>，将原来程序改写如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_abstraction</span>(<span class="params">n,f</span>):</span><br><span class="line">    tot,k=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        tot,k=tot+f(k),k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> tot</span><br><span class="line"></span><br><span class="line"><span class="comment">#以第2个求和为例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n*n*n</span><br><span class="line"><span class="comment">#则sum2可以写成</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum2</span>:</span><br><span class="line">    <span class="keyword">return</span> sum_abstraction(n,f2)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="3作为一般方法的函数">3.作为一般方法的函数</h3>
<p>  上一节“作为参数的函数”中，我们用函数表示某种抽象数值运算模式，将某个具体的运算抽象化。在这一节中，我们<strong>将设计一些函数来表示一般的计算方法，它们独立于调用它们的函数</strong>。</p>
<p>  我们考虑下面这个求解黄金分割比<span class="math inline">\(\varphi\)</span>的程序。我们采用迭代的求法来求。函数的主体为迭代函数<span class="math inline">\(update\)</span>与检查函数<span class="math inline">\(close\)</span>，这里的每个函数都对应着一个一般方法。</p>
<p>  对于迭代函数，由黄金分割比的性质：<span class="math inline">\(\varphi=1+{1\over{1+{1\over{1+{1\over{\cdots}}}}}}\)</span>可以得到如下程序：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> check(guess):</span><br><span class="line">        guess=<span class="number">1</span>/guess+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> guess</span><br></pre></td></tr></table></figure></p>
<p>  对于<span class="math inline">\(check\)</span>函数，也即<span class="math inline">\(update\)</span>的边界函数，由黄金分割比满足的方程：<span class="math inline">\(x^2=x+1\)</span>可得如下程序： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> close(guess*guess,guess+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">a,b,tolerance=<span class="number">1e-15</span></span>):</span><br><span class="line">    <span class="keyword">return</span>(<span class="built_in">abs</span>(a-b)&lt;tolerance)</span><br></pre></td></tr></table></figure></p>
<p>  从而得到最终的程序如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">update,check,guess=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> check(guess):</span><br><span class="line">        guess=update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br></pre></td></tr></table></figure></p>
<p>  通过本题可以看出模块化编程思想的重要性：我们<strong>将整个程序拆成几个小的组件，在编写完每个组件后再进行合并，实现复杂的功能。</strong>同时我们在编写组件时，对每个抽象过程都可以<strong>先命名一个函数，把这个过程抽象化</strong>，然后再实现这一过程，这样可以有效降低函数的复杂性。</p>
<h3 id="4函数的嵌套定义">4.函数的嵌套定义</h3>
<p>  上面的示例演示了<strong>将函数作为参数传递</strong>的做法如何将<strong>每个一般概念或方程都映射到它自己的短函数上</strong>。但在这种方法中，由于每个短函数是在全局独立定义的，全局框架会因为众多函数的加入变得杂乱无章。同时，在某些场合中，我们需要让函数只保持一个参数，这时我们可以考虑建立嵌套函数。</p>
<p>  以平方根的计算为例。我们一般通过以下程序迭代实现平方根的计算：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> (x+y)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt_update</span>(<span class="params">x,a</span>):</span><br><span class="line">    <span class="keyword">return</span> average(x,a/x)</span><br></pre></td></tr></table></figure></p>
<p>  这两个函数都是双参的函数，而待实现的<span class="math inline">\(sqrt\)</span>是单参函数；并且这两个函数单独调用只能实现一次更新。解决这个问题的方法是<strong>将函数定义放在其他定义的主体中。</strong>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> average(x,a/x)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> close(x*x,a)</span><br><span class="line">    <span class="keyword">return</span> solve(update,close)</span><br></pre></td></tr></table></figure></p>
<p>  与局部赋值一样，局部<span class="math inline">\(def\)</span>语句只影响当前的局部内容。当<span class="math inline">\(sqrt\)</span>被计算时，这些函数只在作用域中。与我们的计算过程一致，<strong>在调用<span class="math inline">\(sqrt\)</span>之前，这些本地<span class="math inline">\(def\)</span>语句甚至不会被计算</strong>。由此可引出新概念：</p>
<blockquote>
<p>  <strong>词法范围</strong>：在函数内部被定义的函数可以共享定义它们的函数的参数。例如本例的<span class="math inline">\(update\)</span>，其引用参数<span class="math inline">\(a\)</span>就是封闭函数<span class="math inline">\(sqrt\)</span>的参数。对于在封闭函数内定义的函数，<span class="math inline">\(a\)</span>就相当于一个可以任意调用的常数。</p>
</blockquote>
<p>  由此，我们的变量环境就分成了两个环境：</p>
<ul>
<li>每个用户自定义函数都有一个父环境：<strong>定义它的环境</strong></li>
<li>当调用用户定义函数时，<strong>调用函数的内部扩展出的新环境</strong></li>
</ul>
<p>  仍然以<span class="math inline">\(sqrt\)</span>为例讲解嵌套函数。利用嵌套函数实现的<span class="math inline">\(sqrt\)</span>计算如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> (x+y)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">update,check,guess=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> check(guess):</span><br><span class="line">        guess=update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eq</span>(<span class="params">x,y,tolerance=<span class="number">1e-15</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x-y)&lt;tolerance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x,a/x</span>):</span><br><span class="line">        <span class="keyword">return</span> average(x,a/x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>:</span><br><span class="line">        <span class="keyword">return</span> eq(x*x,a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solve(update,check)</span><br><span class="line"></span><br><span class="line">result=sqrt(<span class="number">256</span>)</span><br></pre></td></tr></table></figure></p>
<p>  该函数的执行流程及对应范围如下： 1.
定义函数，此时所有函数均为全局范围 2. 调用<span class="math inline">\(sqrt\)</span>，此时<span class="math inline">\(def\)</span>内部的<span class="math inline">\(update\)</span>、<span class="math inline">\(check\)</span>函数为词法范围，同时<span class="math inline">\(update\)</span>、<span class="math inline">\(check\)</span>继承词法范围内的变量<span class="math inline">\(a\)</span> 3. 执行<span class="math inline">\(solve\)</span>，通过迭代计算出<span class="math inline">\(sqrt\)</span>的值。</p>
<p><img src="/2024/05/31/1.6.%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/image-1.png"></p>
<p>  通过本例我们也可以了解拓展环境的概念：</p>
<blockquote>
<p>  <strong>拓展环境</strong>：一个环境可以<strong>由任意长的框架链组成，框架链总是以全局框架结束</strong>。在<span class="math inline">\(sqrt\)</span>之前，环境最多只有两个帧:
局部帧和全局帧。通过调用在其他函数中定义的函数，通过嵌套的<span class="math inline">\(def\)</span>语句，我们可以创建更长的链。调用 <span class="math inline">\(update\)</span>的环境由三个框架组成:
<strong>局部<span class="math inline">\(update\)</span>框架、定义 <span class="math inline">\(update\)</span>的<span class="math inline">\(sqrt\)</span>框架和全局框架</strong>。</p>
</blockquote>
<p>  由上述框架的概念，我们可以得出框架的优先级：<span class="math inline">\(update\)</span>先在本地框架中找<span class="math inline">\(a\)</span>的值，没找到；于是<span class="math inline">\(update\)</span>去定义<span class="math inline">\(update\)</span>的<span class="math inline">\(sqrt\)</span>框架找，找到<span class="math inline">\(256\)</span>，于是<span class="math inline">\(a=256\)</span>。</p>
<p>  由此，我们得出了词法范围的优点：</p>
<ul>
<li><p>局部函数的名称不会干扰定义它的函数的外部名称，<strong>因为局部函数名称将绑定在定义它的当前局部环境中，而不是全局环境中。</strong></p></li>
<li><p>局部函数<strong>可以访问封闭函数的环境</strong>，因为局部函数体是在扩展其定义的封闭函数环境中进行定义的。</p></li>
</ul>
<p>  这种在本地框架中定义的函数被称为<strong>闭包</strong>，例如本题中的<span class="math inline">\(sqrt\)</span>函数。在闭包中定义的函数可以获取闭包内的数据信息，而且闭包内的信息是封闭的、不会泄露到外部环境中。</p>
<h3 id="5作为返回值的函数">5.作为返回值的函数</h3>
<p>  词法范围的一个重要特性是：<strong>本地定义的函数在返回时维护其父环境</strong>。下面举一个应用该特性的例子。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">f,g</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> f(g(x))</span><br><span class="line">    <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>
  这是复合函数的程序。正是通过本地定义函数继承父环境的性质，该函数实现了多个函数间的复合。</p>
<p>  一般地，返回函数的函数具有以下优点：</p>
<ul>
<li><p><strong>灵活性和可复用性</strong>：
函数作为返回值可以增加代码的灵活性。通过返回函数，你可以根据需要在运行时动态选择返回不同的实现，使得代码更加灵活和可复用。</p></li>
<li><p><strong>封装和抽象</strong>：
函数作为返回值有助于封装和抽象代码。你可以将一些复杂的逻辑封装在函数内部，然后返回这个函数，从而隐藏内部实现细节，使得接口更加简洁，提高代码的可维护性。</p></li>
<li><p><strong>延迟执行</strong>：
返回函数可以支持延迟执行的模式。例如，你可以返回一个函数对象，该对象在调用时才会执行具体的逻辑。这种延迟执行的方式有助于提高性能，特别是在涉及昂贵计算或者需要从外部获取资源的情况下。</p></li>
<li><p><strong>函数封装</strong>：
返回函数的能力使得函数成为一种函数工厂。你可以根据一些参数或者条件返回不同的函数，从而实现更加通用和可配置的代码结构。</p></li>
</ul>
<h3 id="6高阶函数的经典应用">6.高阶函数的经典应用</h3>
<h4 id="a牛顿迭代法">  <span class="math inline">\(a.\)</span>牛顿迭代法</h4>
<h5 id="i牛顿迭代的原理">  <span class="math inline">\(i.\)</span>牛顿迭代的原理</h5>
<p><img src="/2024/05/31/1.6.%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/image.png"></p>
<h5 id="ii牛顿迭代法的实现">  <span class="math inline">\(ii.\)</span>牛顿迭代法的实现</h5>
<p>  我们考虑实现<span class="math inline">\(\sqrt[n]{a}\)</span>的计算。首先令<span class="math inline">\(\sqrt[n]{a}=x\)</span>，则问题转化为求<span class="math inline">\(x^n=a\)</span>的实根。我们根据牛顿迭代法将程序拆分为以下模块：
*
牛顿迭代函数的实现：由于我们要实现一个函数的封装，采用返回函数的高阶函数：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">newton_update</span>(<span class="params">f,df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x-f(x)/df(x)</span><br><span class="line">    <span class="keyword">return</span> update</span><br></pre></td></tr></table></figure>   我们将抽象过程<span class="math inline">\(f\)</span>与<span class="math inline">\(df\)</span>命名为了两个函数，下面考虑如何实现两者。</p>
<ul>
<li><p><span class="math inline">\(f\)</span>：<span class="math inline">\(f\)</span>即为<span class="math inline">\(x^n\)</span> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> power(x,n)</span><br><span class="line">```   </span><br><span class="line">&amp;emsp;&amp;emsp;同理：</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> n*power(x,n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>   接下来是实现<span class="math inline">\(power\)</span>：</p></li>
<li><p><span class="math inline">\(power\)</span>:简单的连乘即可：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x,n</span>):</span><br><span class="line">    mul,cnt=<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> cnt&lt;n:</span><br><span class="line">        mul,cnt=mul*x,cnt+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> mul</span><br></pre></td></tr></table></figure></p></li>
<li><p>寻找零点函数的实现：寻找零点分为两步：检验是否为零点与牛顿迭代。我们分别实现这两个功能，然后将它们封装为寻找零点函数：</p>
<ul>
<li>检验是否为零点：判断<span class="math inline">\(f(x)-a\)</span>是否在误差范围即可：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">iszero</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> eq(f(x),<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>函数封装： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">update, is_zero</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iteratively_solve</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_approx_zero(x):</span><br><span class="line">            x = update(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> iteratively_solve</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_zero</span>(<span class="params">f,df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_zero</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> eq(f(x),<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> solve(newton_update(f,df),is_zero)</span><br></pre></td></tr></table></figure></p></li>
<li><p>最终函数封装： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nth_root_of_a</span>(<span class="params">n,a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> power(x,n)-a</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> n*power(x,n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> find_zero(f,df)</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">newton_update</span>(<span class="params">f, df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x - f(x) / df(x)</span><br><span class="line">    <span class="keyword">return</span> update</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">update, is_approx_zero, max_iter=<span class="number">1000</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iteratively_improve</span>(<span class="params">x</span>):</span><br><span class="line">        iteration = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_approx_zero(x) <span class="keyword">and</span> iteration &lt; max_iter:</span><br><span class="line">            x = update(x)</span><br><span class="line">            iteration += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> iteratively_improve</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_zero</span>(<span class="params">f, df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">near_zero</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> approx_eq(f(x), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> improve(newton_update(f, df), near_zero)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return x * x * x * ... * x for x repeated n times.&quot;&quot;&quot;</span></span><br><span class="line">    product, k = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; n:</span><br><span class="line">        product, k = product * x, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">approx_eq</span>(<span class="params">a, b, epsilon=<span class="number">1e-6</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a - b) &lt; epsilon</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nth_root_of_a</span>(<span class="params">n, a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> power(x, n) - a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> n * power(x, n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> find_zero(f, df)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="bcurry化">  <span class="math inline">\(b.\)</span><span class="math inline">\(Curry\)</span>化</h4>
<h5 id="i一般的curry化">  <span class="math inline">\(i.\)</span>一般的<span class="math inline">\(Curry\)</span>化</h5>
<p>  我们可以通过高阶函数的方法，可以将一个有很多参数的函数拆分成一个函数链，每个函数链节都是单参函数。</p>
<p>  以双参函数<span class="math inline">\(pow(a,n)\)</span>为例。我们可以用以下程序将<span class="math inline">\(pow(a,n)\)</span>转化为<span class="math inline">\(h(a)(n)\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curried_pow</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x,y)</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>curried_pow(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
  除了满足单参的需求，由于将原函数拆成了多个函数，<span class="math inline">\(Curry\)</span>化的函数还可以通过改动某个函数，使<span class="math inline">\(Curry\)</span>化后的函数能实现不同的功能。例如下面计算<span class="math inline">\(2^1\sim 2^{10}\)</span>的程序： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">map_to_range</span>(<span class="params">start,end,f</span>):</span><br><span class="line">    <span class="keyword">while</span> start&lt;end:</span><br><span class="line">        <span class="built_in">print</span>(f(start))</span><br><span class="line">        start+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">map_to_range(<span class="number">1</span>,<span class="number">10</span>,<span class="built_in">pow</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
  这里，<span class="math inline">\(Curry\)</span>函数<span class="math inline">\(pow(2)\)</span>只执行“以<span class="math inline">\(2\)</span>为底”这一模块。而另一个参数“<span class="math inline">\(n\)</span>次幂”则由<span class="math inline">\(map\_to\_range\)</span>传递。</p>
<h5 id="ii自动化">  <span class="math inline">\(ii.\)</span>自动化</h5>
<p>  以下程序可以实现对输入函数的<span class="math inline">\(Curry\)</span>化与<span class="math inline">\(Uncurry\)</span>化： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curry</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">            <span class="keyword">return</span> f(x,y)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uncurry</span>(<span class="params">g</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x,y</span>):</span><br><span class="line">        <span class="keyword">return</span> g(x)(y)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">pow_curried=curry(<span class="built_in">pow</span>)</span><br><span class="line"><span class="built_in">pow</span>=uncurry(pow_curried)</span><br></pre></td></tr></table></figure></p>
<h4 id="clambda表达式">  <span class="math inline">\(c.\)</span><span class="math inline">\(lambda\)</span>表达式</h4>
<p>  <span class="math inline">\(lambda\)</span>表达式可以在不声明函数的情况下，将变量转换为一个函数。下面这个程序就是<span class="math inline">\(lambda\)</span>表达式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">composel</span>(<span class="params">f,g</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:f(g(x))</span><br></pre></td></tr></table></figure>
  我们可以用如下表格理解<span class="math inline">\(lambda\)</span>表达式的概念：</p>
<p><img src="/2024/05/31/1.6.%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/image-2.png"></p>
<p>  <span class="math inline">\(lambda\)</span>表达式的返回值称作
<strong><span class="math inline">\(lambda\)</span>函数</strong> 。<span class="math inline">\(lambda\)</span>函数没有内置名称，但可以和普通的函数一样调用：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0xf3f490</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s(<span class="number">12</span>)</span><br><span class="line"><span class="number">144</span></span><br></pre></td></tr></table></figure></p>
<p>  对于较简单的函数，利用<span class="math inline">\(lambda\)</span>表达式可以简化代码；但如果函数较为复杂，<span class="math inline">\(lambda\)</span>就很可能给人带来理解上的困难。因此在代码较复杂、层层嵌套时，还是用传统的<code>def</code>为佳。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 1.Building Abstractions with Functions</category>
      </categories>
  </entry>
  <entry>
    <title>1.7.递归函数</title>
    <url>/2024/05/31/1.7.%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="17递归函数"><span class="math inline">\(1.7\)</span>递归函数</h1>
<h2 id="一-递归函数的概念与分类">一、递归函数的概念与分类</h2>
<h3 id="1概念">1.概念</h3>
<p>  如果<strong>函数体直接或间接调用函数本身</strong>，则函数称为递归函数。也就是说，执行递归函数体的过程可能反过来又需要再次应用该函数。</p>
<h3 id="2递归的原理">2.递归的原理</h3>
<p>  一般的递归由以下结构构成：</p>
<ul>
<li>基本情况：当递归函数递归到一个或多个基本情况时，函数将直接返回某个值，跳出递归</li>
<li>递归调用：随着递归调用，问题逐渐得到简化</li>
</ul>
<p>  以阶乘的求解为例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n*f(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>   递归函数<span class="math inline">\(fact\)</span>用一个更简单的问题：<span class="math inline">\(fact(n-1)\)</span>表示了<span class="math inline">\(fact(n)\)</span>。该递归的基本情况是<span class="math inline">\(1!=1,0!=1\)</span>。</p>
<p>  当递归<strong>通过递归函数的连续调用“展开”到越来越简单的问题时，结果最终会从基本情况开始构建</strong>。递归结束时将参数<span class="math inline">\(1\)</span>传递给<span class="math inline">\(fact\)</span>;
<strong>每个调用的结果取决于下一个调用，直到达到基本情况。</strong></p>
<p>  在我们利用以上计算模型得出递归的最终结果时，也可<strong>将递归调用看作函数抽象</strong>。在阶乘中，我们不关心<span class="math inline">\(fact(n-1)\)</span>是怎么计算出来的，我们应该简单地相信它计算的是<span class="math inline">\(n-1\)</span>的阶乘。这种对递归函数的看法被称作<span class="math inline">\(recursive\;leap\;of\;faith\)</span>，即<strong>我们相信递归调用简单情况时函数会得出正确结果，在这个认知的基础上去计算复杂情况</strong>。例如计算阶乘时，我们相信<span class="math inline">\(fact(n-1)\)</span>能正确计算出<span class="math inline">\((n-1)!\)</span>，<strong>只需检查<span class="math inline">\(n!\)</span>在这个假设成立下是否能得到正确计算</strong>。通过这种方式，验证递归函数的正确性是一种<strong>数学归纳法</strong>。</p>
<h3 id="3递归与循环函数的区别">3.递归与循环函数的区别</h3>
<p>  我们以阶乘函数的循环写法为例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact_iter</span>(<span class="params">n</span>):</span><br><span class="line">        total, k = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total * k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></p>
<p>  我们从两个角度看待它们的区别：</p>
<h4 id="a实现方式">  <span class="math inline">\(a.\)</span>实现方式：</h4>
<p>  阶乘的循环写法是通过逐项相乘实现的，而阶乘的递归写法是通过当前项<span class="math inline">\(fact(n)\)</span>与前一项<span class="math inline">\(fact(n-1)\)</span>的关系实现的。</p>
<h4 id="b调用参数">  <span class="math inline">\(b.\)</span>调用参数</h4>
<p>  阶乘的循环写法需要调用两个额外参数<span class="math inline">\(total,k\)</span>，而递归则没有这两个参数。在递归中，<span class="math inline">\(fact(n)\)</span>本身的返回值及相当于循环中的<span class="math inline">\(total\)</span>，而<span class="math inline">\(n\)</span>则用来隐式地跟踪<span class="math inline">\(n!\)</span>计算到哪一步，相当于循环中的<span class="math inline">\(k\)</span>。</p>
<h2 id="二-相互递归调用">二、相互递归调用</h2>
<h3 id="1概念">1.概念</h3>
<p>  当一个递归过程分为<strong>两个相互调用的函数</strong>时，这两个函数被称为相互递归的。</p>
<p>  对于<strong>多主体</strong>的问题，利用相互递归调用可以得到很完美的解决。</p>
<h3 id="2实例讲解">2.实例讲解</h3>
<p>  <span class="math inline">\(e.g.1.\)</span>考虑如下所述对于奇偶的定义：</p>
<ul>
<li><span class="math inline">\(0\)</span>为偶数</li>
<li>若<span class="math inline">\(n-1\)</span>为偶数，则<span class="math inline">\(n\)</span>为奇数</li>
<li>若<span class="math inline">\(n-1\)</span>为奇数，则<span class="math inline">\(n\)</span>为偶数 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> is_odd(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_odd</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> is_even(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  <span class="math inline">\(p.s.\)</span>通过<strong>打破两个函数之间的抽象边界</strong>，可以将相互递归的函数转换为单个递归函数。如上述函数可如下改写：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> (n-<span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> is_even((n-<span class="number">1</span>)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(e.g.2.\)</span>考虑一个两人博弈，在这个博弈中，一张桌子上有
<span class="math inline">\(n\)</span>个初始卵石。玩家轮流从桌子上移走一个或两个鹅卵石，移走最后一个鹅卵石的玩家获胜。假设爱丽丝和鲍勃玩这个游戏，每个人都使用一个简单的策略:</p>
<ul>
<li>爱丽丝总是拿走一块鹅卵石</li>
<li>如果桌子上的鹅卵石数量是偶数，那么鲍勃就会移除两个鹅卵石，另一个是偶数</li>
</ul>
<p>  给定<span class="math inline">\(n\)</span>个最初的卵石和爱丽丝开始，谁赢得了比赛？</p>
<p>  <span class="math inline">\(solve\)</span>：这里爱丽丝与鲍勃是不同主体，分设为两个函数即可：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">alice</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Bob wins&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> bob(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bob</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Alice wins&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> alice(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="三-树形递归">三、树形递归</h2>
<h3 id="1树形递归的概念">1.树形递归的概念</h3>
<p>  树形递归是一种常用的递归，在树形递归中，递归函数被调用不止一次。</p>
<p>  我们以斐波那契数列的递归求解为例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">2</span>) + fib(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>  可以看到，递归的写法与斐波那契的定义<span class="math inline">\(Fib_n=Fib_{n-1}+Fib_{n-2}\)</span>是完全契合的。</p>
<h3 id="2实例讲解">2.实例讲解</h3>
<p>  <span class="math inline">\(e.g.1.\)</span>将<span class="math inline">\(n\)</span>分解为某个单调递增的序列，且序列中数的最大值不超过<span class="math inline">\(m\)</span>。给出<span class="math inline">\(n,m\)</span>，求出满足条件序列的数量。</p>
<p>  <span class="math inline">\(solve\)</span>：我们考虑下面两件事：</p>
<ol type="1">
<li><p>分组方法：为了保证不重不漏，我们从序列中最大值<span class="math inline">\(m\)</span>入手，可分为以下情况：</p>
<ul>
<li>选一个<span class="math inline">\(m\)</span>，然后对<span class="math inline">\(n-m\)</span>执行相同操作</li>
<li>不选<span class="math inline">\(m\)</span>，此时序列中最大值变为<span class="math inline">\(m-1\)</span>，然后继续执行相同操作</li>
</ul></li>
<li><p>基本情况：</p>
<ul>
<li><code>n==0</code>：<span class="math inline">\(return
1\)</span></li>
<li><code>n&lt;0</code>：<span class="math inline">\(return
0\)</span></li>
<li><code>m==0</code>：<span class="math inline">\(return
0\)</span></li>
</ul></li>
</ol>
<p>  于是可写出如下代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">n,m</span>):</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> div(n-m,m)+div(n,m-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
  我们可以把一个树形递归函数看作是在<strong>探索不同的可能性</strong>。在这个例子中，我们探索了使用<span class="math inline">\(m\)</span>的可能性以及不使用的可能性。第一个和第二个递归调用对应于这些可能性。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 1.Building Abstractions with Functions</category>
      </categories>
  </entry>
  <entry>
    <title>10.1.二叉搜索树</title>
    <url>/2024/05/31/10.1.Binary%20Search%20Trees/</url>
    <content><![CDATA[<h1 id="101二叉搜索树"><span class="math inline">\(10.1\)</span>二叉搜索树</h1>
<h3 id="1bst相关概念">1.<span class="math inline">\(BST\)</span>相关概念</h3>
<ul>
<li>The tree is made up of <span class="math inline">\(nodes\)</span>
that contain <span class="math inline">\(links\)</span> that are either
<span class="math inline">\(null\)</span> or references to other
nodes.</li>
<li>Every node is pointed to by just one other node, which is called its
<span class="math inline">\(parent\)</span> (except for one node, the
<span class="math inline">\(root\)</span>, which has no nodes pointing
to it).</li>
<li>Each node has exactly two links, which are called its <span class="math inline">\(left\)</span> and <span class="math inline">\(right\)</span> links, that point to nodes called
its <span class="math inline">\(left child\)</span> and <span class="math inline">\(right child\)</span>.</li>
<li>we can define a binary tree as a either a null link or a node with a
left link and a right link, each references to (disjoint) subtrees that
are themselves <span class="math inline">\(binary trees\)</span>. In a
binary search tree, each node also has a key and a value, with an
ordering restriction to support efficient search</li>
</ul>
<p><img src="/2024/05/31/10.1.Binary%20Search%20Trees/image.png"></p>
<p>  <span class="math inline">\(BST\)</span>也遵循如下的性质：</p>
<p><img src="/2024/05/31/10.1.Binary%20Search%20Trees/image-1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">BST</span>&lt;Key&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Key key;</span><br><span class="line">    <span class="keyword">private</span> BST left;</span><br><span class="line">    <span class="keyword">private</span> BST right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key, BST lf, BST rt)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.left = lf;</span><br><span class="line">        <span class="built_in">this</span>.right = rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2bst操作">2.<span class="math inline">\(BST\)</span>操作</h3>
<h4 id="afind">  <span class="math inline">\(a.\)</span><code>find</code></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">find</span><span class="params">(BST T, Key sk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sk.equals(T.key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sk &lt; T.key) &#123;</span><br><span class="line">        <span class="keyword">return</span> find(T.left, sk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(T.right, sk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="binsert">  <span class="math inline">\(b.\)</span><code>insert</code></h4>
<p>  我们永远只插入左节点！ <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">insert</span><span class="params">(BST T, Key sk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BST</span>(sk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sk &lt; T.key) &#123;</span><br><span class="line">        T.left = insert(T.left, sk);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sk &gt; T.key) &#123;</span><br><span class="line">        T.right = insert(T.right, sk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="cdelete">  <span class="math inline">\(c.\)</span><code>delete</code></h4>
<p>  我们可以通过将一个节点替代为它的后继节点，来实现该节点的删除。一个节点的后继节点(<span class="math inline">\(successor\)</span>)是它右子树的最小节点。我们可以通过以下步骤实现<code>delete</code>：</p>
<ol type="1">
<li>保存待删除节点(<span class="math inline">\(x\)</span>)的链接(<span class="math inline">\(link\)</span>)。</li>
<li>让<span class="math inline">\(x\)</span>指向后继节点(<span class="math inline">\(y\)</span>)。</li>
<li>将<span class="math inline">\(x\)</span>的右链接指向<code>deleteMin(t.right)</code>，其中<code>deleteMin</code>会返回指向右子树的链接，而右子树中所有元素都大于(<span class="math inline">\(x\)</span>)。</li>
<li>让后继节点的左链接指向<span class="math inline">\(x\)</span>的左子树。</li>
</ol>
<p>  下面是该过程的图示：</p>
<p><img src="/2024/05/31/10.1.Binary%20Search%20Trees/image-2.png"></p>
<p>  下面我们分部实现<code>delete</code>操作。</p>
<h5 id="ideletemin">  <span class="math inline">\(i.\)</span><code>deleteMin</code></h5>
<p>  我们可以通过如下方式递归实现<code>deleteMin</code>：</p>
<ol type="1">
<li>找到最小的节点，然后返回它的父亲的右儿子(把指向它的链接给忽略掉了，这样就相当于删掉这个元素了)。</li>
<li>把父节点的左链接指向返回的节点。</li>
<li>更新子树的大小。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMin</span><span class="params">()</span> &#123;</span><br><span class="line">    root = deleteMin(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteMin</span><span class="params">(Node p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.left = deleteMin(p.left);</span><br><span class="line">    p.size = p.left.size + p.right.size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="ii最小节点">  <span class="math inline">\(ii.\)</span>最小节点</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">min</span><span class="params">(Node p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(p.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="iiidelete操作">  <span class="math inline">\(iii\)</span><code>delete</code>操作</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">    root = delete(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node p, Key key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(p.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        p.right = delete(p.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        p.left = delete(p.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// solve the one-node condition.</span></span><br><span class="line">        <span class="keyword">if</span> (p.right == <span class="literal">null</span>) <span class="keyword">return</span> p.left;</span><br><span class="line">        <span class="keyword">if</span> (p.left == <span class="literal">null</span>) <span class="keyword">return</span> p.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//store the to-delete node, so that we can connect its subtree.</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> p;</span><br><span class="line">        p = min(t.right);</span><br><span class="line">        p.right = deleteMin(t.right);</span><br><span class="line">        p.left = t.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.size = p.left.size + p.right.size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>10.Trees</category>
      </categories>
  </entry>
  <entry>
    <title>11.1.一些概念</title>
    <url>/2024/05/31/11.1%20Some%20concepts/</url>
    <content><![CDATA[<h1 id="111一些概念"><span class="math inline">\(11.1\)</span>一些概念</h1>
<h3 id="1o与最坏运行时间的区别">1.<span class="math inline">\(O()\)</span>与最坏运行时间的区别</h3>
<p>  大<span class="math inline">\(O\)</span>不等于最坏运行时间！<span class="math inline">\(O\)</span>表示的是运行时间的上界，只要一个函数的运行时间小于<span class="math inline">\(O(times)\)</span>，那么它就算在<span class="math inline">\(O\)</span>内。最坏运行时间比<span class="math inline">\(O\)</span>更为严苛，因为对于最坏运行时间<span class="math inline">\(worst_time\)</span>，函数必须能取到这个时间、而非仅仅小于等于这个时间。</p>
<h3 id="2对bst性能的衡量">2.对<span class="math inline">\(BST\)</span>性能的衡量</h3>
<p>  <span class="math inline">\(BST\)</span>性能的衡量需要考虑以下概念：</p>
<ul>
<li>深度(<span class="math inline">\(depth\)</span>)：节点到树根间链接的数量。</li>
<li>高度(<span class="math inline">\(height\)</span>)：树的最大深度。</li>
<li>平均深度(<span class="math inline">\(average\)</span>)：树所有深度的平均值，可以用<span class="math inline">\({\sum_{i=0}^D d_in_i}\over N\)</span>，<span class="math inline">\(d_i\)</span>代表深度，<span class="math inline">\(n_i\)</span>代表节点的数字。</li>
</ul>
<p>  <span class="math inline">\(BST\)</span>的高度代表了它的最坏运行时间，而平均深度决定了它的平均运行时间。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>11.Balanced Trees</category>
      </categories>
  </entry>
  <entry>
    <title>11.2.B树</title>
    <url>/2024/05/31/11.2%20B-Trees/</url>
    <content><![CDATA[<h1 id="112b树"><span class="math inline">\(11.2\)</span><span class="math inline">\(B\)</span>树</h1>
<h3 id="1b树的引入">1.<span class="math inline">\(B\)</span>树的引入</h3>
<p>  导致<span class="math inline">\(BST\)</span>最坏运行时间的原因是：每次<code>insert</code>操作，我们都选择在叶子上进行，这导致了树的高度的增加。因此，一个自然的想法是：能否在不增加树的高度的前提下插入节点。</p>
<p>  为了达到这个目的，我们可以在一个叶子中插入多个节点，这样就不会导致叶子高度的增加了。</p>
<p>  但如果无限制地在一个叶子中插入，那么这个叶子就会退化成一个链表了。因此，我们可以对单个叶子能够装入节点的数量设置限度(<span class="math inline">\(limit\)</span>)，例如<span class="math inline">\(4\)</span>。当叶子中节点个数超过<span class="math inline">\(4\)</span>个时，就通过弹出中间的节点，把这个叶子分开(<span class="math inline">\(split\)</span>)。</p>
<h3 id="22-3搜索树">2.<span class="math inline">\(2-3\)</span>搜索树</h3>
<p>  一棵<span class="math inline">\(2-3\)</span>搜索树是满足如下条件的树：</p>
<ul>
<li>空的(<span class="math inline">\(empty\)</span>)。</li>
<li>一个叶子存储一个节点，同时有两个链接(<span class="math inline">\(link\)</span>)，和<span class="math inline">\(BST\)</span>类似。</li>
<li>一个叶子存储二个节点，同时有三个链接。设二个节点分别为<span class="math inline">\(x,y\)</span>，则三个链接所指向的其它叶子分别满足<span class="math inline">\(a_i\leq x,x\leq a_i\leq y,a_i\leq
y\)</span>。</li>
</ul>
<p><img src="/2024/05/31/11.2%20B-Trees/image.png"></p>
<h3 id="3查找流程">3.查找流程</h3>
<p>  <span class="math inline">\(2-3\)</span>搜索树查找节点的流程如下：</p>
<p><img src="/2024/05/31/11.2%20B-Trees/image-1.png"></p>
<h3 id="4插入流程">4.插入流程</h3>
<p>  <span class="math inline">\(2-3\)</span>搜索树插入节点的流程如下：</p>
<ol type="1">
<li>我们仍然一直在左叶子进行插入操作。</li>
<li>将节点插入对应的叶子时，如果该叶子的节点个数大于<span class="math inline">\(3\)</span>，则弹出中间靠左的节点(如果是奇数个节点就直接弹出中间的)，然后相应地重新排列子树。</li>
<li>重复上述步骤，直到找到一个有空位的父节点或者遍历到根节点。</li>
</ol>
<p>  一些插入情况对应的图示如下：</p>
<p><img src="/2024/05/31/11.2%20B-Trees/image-2.png"></p>
<p><img src="/2024/05/31/11.2%20B-Trees/image-3.png"></p>
<p>  分开叶子的图示如下：</p>
<p><img src="/2024/05/31/11.2%20B-Trees/image-4.png"></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>11.Balanced Trees</category>
      </categories>
  </entry>
  <entry>
    <title>11.4.树的旋转</title>
    <url>/2024/05/31/11.4.Rotating%20Trees/</url>
    <content><![CDATA[<h1 id="114树的旋转"><span class="math inline">\(11.4\)</span>树的旋转</h1>
<p>  The formal definition of rotation is:</p>
<ul>
<li><p><code>rotateLeft(G): Let x be the right child of G. Make G the new left child of x.</code></p></li>
<li><p><code>rotateRight(G): Let x be the left child of G. Make G the new right child of x.</code></p></li>
</ul>
<p>  As in the picture, it means:</p>
<ul>
<li><span class="math inline">\(RotateLeft(G)\)</span>: G moves left,
promote its right child in the only natural way.(Promoting P means P is
the new parent of G.)</li>
<li><span class="math inline">\(RotateRight(P)\)</span>: P moves right,
promote its left child in the only natural way.</li>
</ul>
<p><img src="/2024/05/31/11.4.Rotating%20Trees/image-5.png"></p>
<p><img src="/2024/05/31/11.4.Rotating%20Trees/image-6.png"></p>
<p>  We can implement these operations by following codes:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.left);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.right = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make a right-leaning link lean to the left</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.right);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>11.Balanced Trees</category>
      </categories>
  </entry>
  <entry>
    <title>11.3.B-树的不变量</title>
    <url>/2024/05/31/11.3.%20B-Tree%20invariants/</url>
    <content><![CDATA[<h1 id="113b-树的不变量"><span class="math inline">\(11.3\)</span><span class="math inline">\(B\)</span>-树的不变量</h1>
<h3 id="1b-树的性质">1.<span class="math inline">\(B\)</span>-树的性质</h3>
<p>  由于<span class="math inline">\(B\)</span>-树会在叶子容量过大时将叶子对半分开、然后重构子树，这使得我们可以以任意次序插入元素，而不用担心最坏运行时间的发生。</p>
<p>  一棵<span class="math inline">\(B\)</span>-树具有如下有用的性质：</p>
<ul>
<li>每个叶子到它的源头(<span class="math inline">\(source\)</span>)的距离必须相等。</li>
<li>一个有<span class="math inline">\(k\)</span>个元素的非叶子节点，它必须有<span class="math inline">\(k+1\)</span>个孩子。</li>
</ul>
<h3 id="2b-树运行时间分析">2.<span class="math inline">\(B\)</span>-树运行时间分析</h3>
<p>  <span class="math inline">\(B\)</span>-树的最坏运行情况是：在树的底部的叶子的最右侧的节点找到某个元素。由于<span class="math inline">\(B\)</span>-树的构造方式，树的深度<span class="math inline">\(O(\log
n)\)</span>，而由于我们限制了每个叶子结点承载元素的数量，因此从叶子左端到右端的搜索时间为常数。则总的运行时间为<span class="math inline">\(O(\log n)\)</span>。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>11.Balanced Trees</category>
      </categories>
  </entry>
  <entry>
    <title>11.5.红黑树</title>
    <url>/2024/05/31/11.5.Red-Black%20Trees/</url>
    <content><![CDATA[<h1 id="115红黑树未完结"><span class="math inline">\(11.5\)</span>红黑树(未完结)</h1>
<h3 id="1红黑树的引入与相关概念">1.红黑树的引入与相关概念</h3>
<p>  前面介绍的<span class="math inline">\(B\)</span>-树很符合我们对运行时间的的需要，但是它很难用代码实现。因此，我们设想创造一种树，它利用<span class="math inline">\(BST\)</span>实现，但结构上与<span class="math inline">\(B\)</span>-树等价。</p>
<p>  在<span class="math inline">\(2-3\)</span>树中，叶子只有一个节点的情况和<span class="math inline">\(BST\)</span>是完全一样的。而对于两个节点的情况，我们考虑将链接分成两种类型：红色(<span class="math inline">\(red\)</span>)的和黑色(<span class="math inline">\(black\)</span>)的。对于一个叶子三个节点的情况，我们可以用如下的形式表示：</p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-7.png"></p>
<p>  这么处理的好处是：我们可以不修改原有的<span class="math inline">\(BST\)</span>来实现<span class="math inline">\(2-3\)</span>树。给定任意一个<span class="math inline">\(2-3\)</span>树，我们都可以立即生成一个对应的<span class="math inline">\(BST\)</span>。例如下面的<span class="math inline">\(2-3\)</span>树到红黑树的转换：</p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-9.png"></p>
<h3 id="2左斜红黑树的性质">2.左斜红黑树的性质</h3>
<p>  为了模拟<span class="math inline">\(2-3\)</span>树，红黑树必须具有以下性质：</p>
<ol type="1">
<li>红色链接左斜。</li>
<li>没有一个节点与两个红色链接相连。</li>
<li>红黑树具有完美的“黑色平衡”：从根节点到空节点间的每个路径都具有相同数量的褐色链接。</li>
</ol>
<p>  如果将红色链接画成水平的，那么可以得到下面的图示，这和<span class="math inline">\(2-3\)</span>树几乎一致：</p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-10.png"></p>
<h3 id="2红黑树的旋转操作">2.红黑树的旋转操作</h3>
<p>  红黑树的左旋操作如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node <span class="title function_">rotateLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-11.png"></p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-12.png"></p>
<p>  红黑树的右旋操作如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node <span class="title function_">rotateRight</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.right = h;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/2024/05/31/11.5.Red-Black%20Trees/image-13.png"></p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-14.png"></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>11.Balanced Trees</category>
      </categories>
  </entry>
  <entry>
    <title>12.1.Hashing的引入</title>
    <url>/2024/05/31/12.1.The%20introduction%20of%20Hashing/</url>
    <content><![CDATA[<h1 id="121hashing的引入"><span class="math inline">\(12.1\)</span><span class="math inline">\(Hashing\)</span>的引入</h1>
<h3 id="1hasing的引入">1.<span class="math inline">\(Hasing\)</span>的引入</h3>
<p>  在先前的树结构中，我们实现了对数据的高效查找。但树的使用有以下的限制：</p>
<ol type="1">
<li>树需要对象具有可比较性(<span class="math inline">\(comparable\)</span>)。对于某些元素(比如字符串)，它们不能进行比较，因此就无法插入<span class="math inline">\(BST\)</span>中了。</li>
<li><span class="math inline">\(BST\)</span>的运行时间为<span class="math inline">\(\Theta(\log
N)\)</span>，但我们希望有更优的运行时间。</li>
</ol>
<p>  假设我们想要实现对整数的查找，我们可以通过检测数组第<span class="math inline">\(i\)</span>位是否为<span class="math inline">\(1\)</span>，从而得到该整数是否存在。该数据结构如下实现：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataIndexedIntegerSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] present;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataIndexedIntegerSet</span><span class="params">()</span> &#123;</span><br><span class="line">        present = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2000000000</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        present[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> present[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>  该数据结构的查找与插入都只需要<span class="math inline">\(\Theta(1)\)</span>的运行时间。然而，它有以下的问题：</p>
<ol type="1">
<li>空间浪费较大。</li>
<li>不具有普适性。该数据结构只适用于整数。</li>
</ol>
<h3 id="2字符串到整数的转换">2.字符串到整数的转换</h3>
<p>  以字符串为例，我们可以考虑将字符串按如下的方式转换成一个整数：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">letterNum</span><span class="params">(String s, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">/** Converts ith character of String to a letter number.</span></span><br><span class="line"><span class="comment">    * e.g. &#x27;a&#x27; -&gt; 1, &#x27;b&#x27; -&gt; 2, &#x27;z&#x27; -&gt; 26 */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ithChar</span> <span class="operator">=</span> s.charAt(i)</span><br><span class="line">    <span class="keyword">if</span> ((ithChar &lt; <span class="string">&#x27;a&#x27;</span>) || (ithChar &gt; <span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ithChar - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">englishToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">intRep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0l</span> i &lt; s.length(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        intRep = intRep * <span class="number">26</span>;</span><br><span class="line">        intRep += letterNum(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intRep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样，我们就实现了字符串到整数的转换。然而，这并未解决我们提出的问题。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>12.Hashing</category>
      </categories>
  </entry>
  <entry>
    <title>12.3.Hashing的实现方法(2)</title>
    <url>/2024/05/31/12.3.The%20solution%20to%20Hashing%20problems(2)/</url>
    <content><![CDATA[<h1 id="123hashing的实现方法2"><span class="math inline">\(12.3\)</span><span class="math inline">\(Hashing\)</span>的实现方法(2)</h1>
<h3 id="1冲突处理">1.冲突处理</h3>
<p>  假如我们得到一个对象的<span class="math inline">\(hashCode\)</span>为<span class="math inline">\(h\)</span>：</p>
<ul>
<li>当<span class="math inline">\(h\)</span>索引不存在时，我们就对<span class="math inline">\(h\)</span>索引创建一个新的<code>LinkedList</code>，并把这个对象插入链表中。</li>
<li>当<span class="math inline">\(h\)</span>索引存在时，我们就将对象插入已有的链表中。</li>
</ul>
<blockquote>
<p>  <span class="math inline">\(p.s.\)</span>我们的数据结构是不允许重复的，因此在插入时，我们必须将待插入对象与链表中所有已插入对象进行比较。当该对象已经存在时，就直接跳过。这说明我们会需要遍历整个链表。</p>
</blockquote>
<p>  这样，我们就可以得到<span class="math inline">\(Hashing\)</span>的具体流程了：</p>
<ul>
<li><p><code>add</code> item</p>
<ul>
<li>Get hashcode (i.e., index) of item.</li>
<li>If index has no item, create new List, and place item there.</li>
<li>If index has a List already, check the List to see if item is
already in there. If not, add item to List.</li>
</ul></li>
<li><p><code>contains</code> item</p>
<ul>
<li>Get hashcode (i.e., index) of item.</li>
<li>If index is empty, return <code>false</code>.</li>
<li>Otherwise, check all items in the List at that index, and if the
item exists, return true.</li>
</ul></li>
</ul>
<h3 id="2内存的处理">2.内存的处理</h3>
<p>  为了避免使用过大的数组，我们可以固定数组的大小，然后采用取模的方法，让所有的<span class="math inline">\(hashCode\)</span>都落入该数组的索引范围内(类似我们在<span class="math inline">\(ArrayList\)</span>中使用的方法)。就算此时发生了哈希冲突，我们也可以用上面的方法处理它。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>12.Hashing</category>
      </categories>
  </entry>
  <entry>
    <title>12.2.Hashing的实现方法(1)</title>
    <url>/2024/05/31/12.2.The%20solution%20to%20Hashing%20problems(1)/</url>
    <content><![CDATA[<h1 id="122hashing的实现方法1"><span class="math inline">\(12.2\)</span><span class="math inline">\(Hashing\)</span>的实现方法(1)</h1>
<h3 id="1整数溢出">1.整数溢出</h3>
<p>  在先前将字符串转换为整数的操作中，我们忽略了一个问题：转换得到的整数过大导致溢出怎么办？例如，溢出后的<code>melt banana</code>与<code>subterresetrial anticosmetic</code>的<span class="math inline">\(Hash\)</span>值是一样的，如果我们通过比较它们的<span class="math inline">\(Hash\)</span>值来确定它们是否相等，会得到相反的答案。</p>
<p>  整数的溢出是无法避免的，因为<span class="math inline">\(Java\)</span>能够表示的最大整数只有<span class="math inline">\(2147483647\)</span>。因此我们引入下面的方法：</p>
<h3 id="2hashcodes">2.<span class="math inline">\(Hash\;Codes\)</span></h3>
<p>  在<span class="math inline">\(Java\)</span>中，每个对象都有一个默认的<code>.hashcode()</code>方法。<span class="math inline">\(Java\)</span>通过该对象在内存中的位置来得出它的<span class="math inline">\(hashCode\)</span>。这个方法对每个独立的对象都会给出不重复的<span class="math inline">\(hashCode\)</span>。</p>
<p>  有时，我们也会自己定义<code>.hashcode()</code>方法，来满足自己定义的一些类的需要。</p>
<p>  <span class="math inline">\(hashCode\)</span>具有如下性质：</p>
<ol type="1">
<li>它是一个整数</li>
<li>对同一对象多次调用<code>.hashcode()</code>，得到的结果都相同。</li>
<li>两个<code>.equal()</code> 的对象必须具有相同的<span class="math inline">\(hashCode\)</span>。</li>
</ol>
<p>  然而，并不是所有<span class="math inline">\(hashCode\)</span>相等的对象都<code>.equal()</code>，因此，我们应当让对象的<span class="math inline">\(.hashode()\)</span>方法生成的<span class="math inline">\(hashCode\)</span>尽可能分布均匀。</p>
<p>  到此为止，我们实现了<span class="math inline">\(Hashing\)</span>的普适性。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>12.Hashing</category>
      </categories>
  </entry>
  <entry>
    <title>12.4.数据结构的最终实现</title>
    <url>/2024/05/31/12.4.Final%20Data%20Structure/</url>
    <content><![CDATA[<h1 id="124数据结构的最终实现"><span class="math inline">\(12.4\)</span>数据结构的最终实现</h1>
<h3 id="1运行时间的优化">1.运行时间的优化</h3>
<p>  假设我们存放索引的数组的大小为<span class="math inline">\(5\)</span>，当我们插入<span class="math inline">\(100\)</span>个元素时，最坏的情况是：所有元素的索引都是一致的。这样，我们就得到了一个长度为<span class="math inline">\(100\)</span>的链表。</p>
<p>  这显然不是我们希望看到的情况。对此，我们有两种处理方法：</p>
<ol type="1">
<li>动态地扩大我们的哈希表。</li>
<li>改进我们的<span class="math inline">\(hashCode\)</span>。</li>
</ol>
<h4 id="a动态扩容">  <span class="math inline">\(a.\)</span>动态扩容</h4>
<p>  假设我们有<span class="math inline">\(M\)</span>个筐和<span class="math inline">\(N\)</span>个元素，我们定义负载系数(<span class="math inline">\(load\;factor\)</span>)为<span class="math inline">\(N\over M\)</span>(这即是我们的最佳运行时间)。</p>
<p>  为了让我们的负载系数维持在一个较低的范围内，我们可以直接让<span class="math inline">\(M\)</span>变为<span class="math inline">\(2M\)</span>，并进行如下操作：</p>
<ul>
<li><p>创建一个新的容量为<span class="math inline">\(2M\)</span>的哈希表。</p></li>
<li><p>迭代遍历原有的哈希表，然后把原有的元素复制到新的哈希表中。</p>
<ul>
<li>我们需要一个一个复制元素，是因为哈希表的容量改变了，因此我们的模数也变了，从而需要用新的模数一个一个将元素复制到新哈希表对应的位置。</li>
</ul></li>
</ul>
<p>  这样，我们得到了一个运行时间<span class="math inline">\(\Theta(N\over
M)\)</span>的哈希表。由于我们限定<span class="math inline">\(N\over
M\)</span>必须小于一个常数，因此最优运行时间为<span class="math inline">\(\Theta(N\over M)=\Theta(1)\)</span>。</p>
<h4 id="b改进hashcode">  <span class="math inline">\(b.\)</span>改进<span class="math inline">\(hashCode\)</span></h4>
<ul>
<li><p>Use a 'base' strategy similar to the one we developed
earlier.</p></li>
<li><p>Use a 'base' that's a small prime.</p>
<ul>
<li>Base 126 isn't actually very good, because using base 126 means that
any string that ends in the same last 32 characters has the same
hashcode.</li>
<li>This happens because of overflow.</li>
<li>Using prime numbers helps avoid overflow issues (i.e., collisions
due to overflow).</li>
<li>Why a small prime? Because it's easier to compute.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>12.Hashing</category>
      </categories>
  </entry>
  <entry>
    <title>13.1.优先队列接口</title>
    <url>/2024/05/31/13.1.PQ%20Interface/</url>
    <content><![CDATA[<h1 id="131优先队列接口"><span class="math inline">\(13.1\)</span>优先队列接口</h1>
<h3 id="1优先队列的引入">1.优先队列的引入</h3>
<p>  我们知道<span class="math inline">\(BST\)</span>可以实现数据的快速搜索，那么如果我们只关心对最大(最小)元素的查找呢？</p>
<p>  这时，我们就可以引入优先队列(<span class="math inline">\(Priority\;Queue\)</span>)的<span class="math inline">\(ADT\)</span>。在优先队列中，我们只能对一组数据中的最小元素进行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** (Min) Priority Queue: Allowing tracking and removal of </span></span><br><span class="line"><span class="comment">  * the smallest item in a priority queue. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MinPQ</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="comment">/** Adds the item to the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="comment">/** Returns the smallest item in the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getSmallest</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/** Removes the smallest item from the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeSmallest</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/** Returns the size of the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2优先队列的实现">2.优先队列的实现</h3>
<p>  假如我们用链表实现以下的问题：</p>
<p>  <span class="math inline">\(question:\)</span></p>
<ul>
<li>Consider the scenario where we are monitoring text messages between
citizens and want to keep track of unharmonious conversations.</li>
<li>Each day, you prepare a report of <span class="math inline">\(M\)</span> messages that are the most unharmonious
using a HarmoniousnessComparator.</li>
</ul>
<p>  用链表将得到如下实现： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">unharmoniousTexts</span><span class="params">(Sniffer sniffer, <span class="type">int</span> M)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt;allMessages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(); timer.hours() &lt; <span class="number">24</span>; ) &#123;</span><br><span class="line">        allMessages.add(sniffer.getNextMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Comparator&lt;String&gt; cmptr = <span class="keyword">new</span> <span class="title class_">HarmoniousnessComparator</span>();</span><br><span class="line">    Collections.sort(allMessages, cmptr, Collections.reverseOrder());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allMessages.sublist(<span class="number">0</span>, M);</span><br></pre></td></tr></table></figure></p>
<p>  然而，这种方式的弊端为：我们只需要<span class="math inline">\(\Theta(M)\)</span>空间内的变量，但该方法使用了<span class="math inline">\(\Theta(N)\)</span>的空间。</p>
<p>  为了优化内存的占用，我们可以尝试用下面的数据结构实现优先队列：</p>
<ul>
<li>Ordered Array
<ul>
<li><code>add</code>:<span class="math inline">\(\Theta(N)\)</span></li>
<li><code>getSmallest</code>:<span class="math inline">\(\Theta(1)\)</span></li>
<li><code>removeSmallest</code>:<span class="math inline">\(\Theta(N)\)</span></li>
</ul></li>
<li>Bushy BST
<ul>
<li><code>add</code>:<span class="math inline">\(\Theta(\log
N)\)</span></li>
<li><code>getSmallest</code>:<span class="math inline">\(\Theta(\log
N)\)</span></li>
<li><code>removeSmallest</code>:<span class="math inline">\(\Theta(\log
N)\)</span></li>
</ul></li>
<li>HashTable
<ul>
<li><code>add</code>:<span class="math inline">\(\Theta(1)\)</span></li>
<li><code>getSmallest</code>:<span class="math inline">\(\Theta(N)\)</span></li>
<li><code>removeSmallest</code>:<span class="math inline">\(\Theta(N)\)</span></li>
</ul></li>
</ul>
<p>  那么，我们有更优秀的实现方法吗？</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>13.Heap &amp; Priority Queue</category>
      </categories>
  </entry>
  <entry>
    <title>13.3.优先队列的实现</title>
    <url>/2024/05/31/13.3.The%20Implementation/</url>
    <content><![CDATA[<h1 id="133优先队列的实现"><span class="math inline">\(13.3\)</span>优先队列的实现</h1>
<p>(注：这里实现的是大根堆)</p>
<h3 id="1优先队列的初始化">1.优先队列的初始化</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] pq; <span class="comment">// heap-ordered complete binary tree</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// in pq[1..N] with pq[0] unused</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPQ</span><span class="params">(<span class="type">int</span> maxN)</span> &#123; </span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[maxN+<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> N; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key v)</span> &#123; </span><br><span class="line">        pq[++N] = v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="type">Key</span> <span class="variable">max</span> <span class="operator">=</span> pq[<span class="number">1</span>]; <span class="comment">// Retrieve max key from top.</span></span><br><span class="line">        swap(<span class="number">1</span>, N--); <span class="comment">// Exchange with last item.</span></span><br><span class="line">        pq[N+<span class="number">1</span>] = <span class="literal">null</span>; <span class="comment">// Avoid loitering.</span></span><br><span class="line">        sink(<span class="number">1</span>); <span class="comment">// Restore heap property.</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2辅助方法的实现">2.辅助方法的实现</h3>
<h4 id="aless-swap方法">  <span class="math inline">\(a.\)</span><code>less</code>、<code>swap</code>方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">Ket</span> <span class="variable">t</span> <span class="operator">=</span> pq[i];</span><br><span class="line">    pq[i] = pq[j];</span><br><span class="line">    pq[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bswim方法">  <span class="math inline">\(b.\)</span><code>swim</code>方法</h4>
<p>  <code>swim</code>方法用于将堆底部的元素向上洄游，以维护堆的性质：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">        swap(k / <span class="number">2</span>, k);</span><br><span class="line">        k = k / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/13.3.The%20Implementation/image-7.png"></p>
<h4 id="csink方法">  <span class="math inline">\(c.\)</span><code>sink</code>方法</h4>
<p>  <code>sink</code>方法用于将堆顶部的元素下沉，以维护堆的性质：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">        <span class="comment">//assure that the parent is the biggest of its children</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>)) &#123;</span><br><span class="line">            swap (j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!less(k, j)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap (k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/13.3.The%20Implementation/image-6.png"></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>13.Heap &amp; Priority Queue</category>
      </categories>
  </entry>
  <entry>
    <title>13.2.堆结构</title>
    <url>/2024/05/31/13.2.Heap%20Structure/</url>
    <content><![CDATA[<h1 id="132堆结构"><span class="math inline">\(13.2\)</span>堆结构</h1>
<h3 id="1堆结构的引入">1.堆结构的引入</h3>
<p>  由先前的分析，我们得出拥有最佳运行时间的是<span class="math inline">\(BST\)</span>。然而，对<span class="math inline">\(BST\)</span>进行修饰后，我们可以得到更好的运行时间。</p>
<p>  我们定义我们的二叉堆遵循以下性质：</p>
<ul>
<li>最小性：每个节点都小于等于它的儿子节点。</li>
<li>完全性：缺失的元素只能位于堆的底部；堆中元素排列应尽可能左偏。</li>
</ul>
<p>  如图，绿色的堆是符合条件的，而红色的是不符合条件的。</p>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image.png"></p>
<h3 id="2树的表示">2.树的表示</h3>
<p>  我们可以用如下的方式表示一棵树： * <span class="math inline">\(Tree1A\)</span>：用指针表示： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1A</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1A left;</span><br><span class="line">  Tree1A middle;</span><br><span class="line">  Tree1A right;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image-1.png"></p>
<ul>
<li><span class="math inline">\(Tree1B\)</span>：用父节点元素与数组混合表示：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1B</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1B[] children;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image-2.png"></p>
<ul>
<li><span class="math inline">\(Tree1C\)</span>：用父节点元素、指向第一个孩子的元素和<span class="math inline">\(next\)</span>指针(<span class="math inline">\(sibling\)</span>)表示： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1C</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1C favoredChild;</span><br><span class="line">  Tree1C sibling;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image-3.png"></p>
<p>  这些表示树的方式都直接引用(<span class="math inline">\(explicit\;reference\)</span>)了节点的儿子。下面介绍一些不存储对儿子的引用的表示方式：</p>
<ul>
<li><span class="math inline">\(Approach\;2\)</span>
<ul>
<li>我们可以用类似并查集的表示方式，创建一个<span class="math inline">\(parents\)</span>数组和一个<span class="math inline">\(key\)</span>数组： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree2</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key[] keys;</span><br><span class="line">  <span class="type">int</span>[] parents;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image-4.png"></p>
<p>  当我们假定我们的堆是完全的时，我们还可以只用一个一维数组来表示： *
<span class="math inline">\(Approach\;3\)</span> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeC</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key[] keys;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image-5.png"></p>
<p>  这种树的表示方法十分简便，我们在堆的实现中将使用这种方法。</p>
<h3 id="3swim方法">3.<code>swim</code>方法</h3>
<p>  在堆的构建中，我们定义如下的<code>swim</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys[parent(k)] ≻ keys[k]) &#123;</span><br><span class="line">       swap(k, parent(k));</span><br><span class="line">       swim(parent(k));              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  如果对<span class="math inline">\(Approach\;3\)</span>进行观察的话，可以发现如下规律：</p>
<p><span class="math display">\[
\begin{cases}
parent=i\\
leftchild=2i+1\\
rightchild=2i+2
\end{cases}
\]</span></p>
<p>  如果我们让数组的<span class="math inline">\(0\)</span>位置为空(不放置元素)，则可以得到更简洁的规律：</p>
<p><span class="math display">\[
\begin{cases}
parent=i\\
leftchild=2i\\
rightchild=2i+1
\end{cases}
\]</span></p>
<p>  这样，我们就可以将数组中的元素与树上的元素一一对应了。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>13.Heap &amp; Priority Queue</category>
      </categories>
  </entry>
  <entry>
    <title>15.2.Trie的实现</title>
    <url>/2024/05/31/15.2.Implementation/</url>
    <content><![CDATA[<h1 id="152trie的实现"><span class="math inline">\(15.2\)</span><span class="math inline">\(Trie\)</span>的实现</h1>
<h3 id="1trie的介绍">1.<span class="math inline">\(Trie\)</span>的介绍</h3>
<p>  在<span class="math inline">\(Trie\)</span>中，我们使用以下的计策来存储一系列单词(字符串)：</p>
<ol type="1">
<li>每个节点只存储一个字母。</li>
<li>每个节点可以被多个键共用。</li>
</ol>
<p>  下面的树结构即是一组单词的<span class="math inline">\(Trie\)</span>，蓝色意味着这是一个单词的结尾：</p>
<p><img src="/2024/05/31/15.2.Implementation/image.png"></p>
<p>  同样地，<span class="math inline">\(Trie\)</span>亦可用作<span class="math inline">\(map\)</span>：</p>
<p><img src="/2024/05/31/15.2.Implementation/image-1.png"></p>
<p>  需要注意，当我们需要处理某个特定(<span class="math inline">\(specificity\)</span>)的问题时，我们可以改进我们原有的、通用的数据结构(通常是对其加以限制(<span class="math inline">\(constraint\)</span>))，来更好地实现我们想要的功能。例如，如果我们用<span class="math inline">\(HashMap\)</span>来实现对单词的存放，那么我们的查找就需要遍历所有已有的字符串，这样的效率显然很低。</p>
<ul>
<li><p><span class="math inline">\(ADT\)</span>与特殊实现(<span class="math inline">\(specific\;implementations\)</span>)是有区别的。例如，并查集是一种<span class="math inline">\(ADT\)</span>，它具有<code>connect(x, y)</code>与<code>isConnected(x, y)</code>两个方法。而这来个方法有四种不同的实现方式：<span class="math inline">\(Quick\;find\)</span>、<span class="math inline">\(Quick\;union\)</span>、<span class="math inline">\(Weight\;QU\)</span>、<span class="math inline">\(WQUPC\)</span>。</p></li>
<li><p>在这里，<span class="math inline">\(Trie\)</span>就是当<span class="math inline">\(Set\)</span>或<span class="math inline">\(Map\)</span>存储的数据类型是字符串时的特殊实现：</p>
<ul>
<li>We give each node a single character and each node can be a part of
several keys inside of the trie.</li>
<li>Searching will only fail if we hit an unmarked node or we fall off
the tree</li>
<li>Short for Retrieval tree, almost everyone pronounces it as "try" but
Edward Fredkin suggested it be pronounced as "tree"</li>
</ul></li>
</ul>
<h3 id="2trie的构建">2.<span class="math inline">\(Trie\)</span>的构建</h3>
<p>  利用先前的策略，我们让每个节点存储字母、孩子和颜色。由于每个节点都是一个字母，我们可以用<code>DataIndexedCharMap</code>来存储节点的所有孩子：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataIndexedCharMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> V[] items;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataIndexedCharMap</span><span class="params">(<span class="type">int</span> R)</span> &#123;</span><br><span class="line">        items = (V[]) <span class="keyword">new</span> <span class="title class_">Object</span>[R];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">char</span> c, V val)</span> &#123;</span><br><span class="line">        items[c] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">// ASCII</span></span><br><span class="line">   <span class="keyword">private</span> Node root;    <span class="comment">// root of trie</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">char</span> ch;  </span><br><span class="line">      <span class="keyword">private</span> <span class="type">boolean</span> isKey;   </span><br><span class="line">      <span class="keyword">private</span> DataIndexedCharMap next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> c, <span class="type">boolean</span> blue, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">         ch = c; </span><br><span class="line">         isKey = blue;</span><br><span class="line">         next = <span class="keyword">new</span> <span class="title class_">DataIndexedCharMap</span>&lt;Node&gt;(R);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/15.2.Implementation/image-2.png"></p>
<p>  然而，当我们的节点只有很少的孩子时，由于我们创建了<span class="math inline">\(128\)</span>个空间，只有很少的空间是真正被使用的。</p>
<p>  注意到两个节点间存在链接当且仅当两个节点都存储了字符，我们可以删掉<span class="math inline">\(Node\)</span>的<span class="math inline">\(ch\)</span>变量，而用该节点在父节点的<span class="math inline">\(next\)</span>中的位置来表征： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">// ASCII</span></span><br><span class="line">   <span class="keyword">private</span> Node root;    <span class="comment">// root of trie</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">boolean</span> isKey;   </span><br><span class="line">      <span class="keyword">private</span> DataIndexedCharMap next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(<span class="type">boolean</span> blue, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">         isKey = blue;</span><br><span class="line">         next = <span class="keyword">new</span> <span class="title class_">DataIndexedCharMap</span>&lt;Node&gt;(R);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/15.2.Implementation/image-3.png"></p>
<p>  同时，为了减少空间浪费，我们可以用<span class="math inline">\(HashMap\)</span>代替<span class="math inline">\(DataIndexedCharMap\)</span>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;    <span class="comment">// root of trie</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isKey;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Character, Node&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(<span class="type">boolean</span> isKey)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.isKey = isKey;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3trie的运行时间">3.<span class="math inline">\(Trie\)</span>的运行时间</h3>
<p>  给定字符串的<span class="math inline">\(Trie\)</span>，其对应的<span class="math inline">\(Map\)</span>、<span class="math inline">\(Set\)</span>操作运行时间如下：</p>
<ul>
<li><code>add</code>：<span class="math inline">\(\Theta(1)\)</span></li>
<li><code>contains</code>：<span class="math inline">\(\Theta(1)\)</span></li>
</ul>
<p>  这是因为<span class="math inline">\(Trie\)</span>的运行时间只取决于单词的长度，而与<span class="math inline">\(Trie\)</span>中键的多少无关。我们在查询时只会遍历我们需要的单词。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>15.Tries</category>
      </categories>
  </entry>
  <entry>
    <title>15.3.字符串操作</title>
    <url>/2024/05/31/15.3.Trie%20String%20Operations/</url>
    <content><![CDATA[<h1 id="153字符串操作"><span class="math inline">\(15.3\)</span>字符串操作</h1>
<h3 id="1键的收集与前缀匹配">1.键的收集与前缀匹配</h3>
<p>  由于在<span class="math inline">\(trie\)</span>中，字符和键(<span class="math inline">\(key\)</span>)都是被隐性表示的，当我们想让我们的键变得可迭代时，我们不能只在<span class="math inline">\(trie\)</span>中直接寻找它们。我们可以用一个可迭代的<code>collect</code>方法，该方法会维护一个字符串，它用于储存路径上的字符：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> get(root, key, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">get</span><span class="params">(Node x, String key, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (d == key.length()) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(d);<span class="comment">// use dth key char of key to find subtrie</span></span><br><span class="line">    <span class="keyword">return</span> get(x.next[c], key, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title function_">keys</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> keysWithPrefix(<span class="string">&quot;&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//collect keys in a trie.</span></span><br><span class="line"><span class="comment">//the &quot;get&quot; method will return the node containing the prefix</span></span><br><span class="line"><span class="comment">//so we can collect any string that starts from this node</span></span><br><span class="line"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String pre)</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;String&gt;();</span><br><span class="line">    collect(get(root, pre, <span class="number">0</span>), pre, q);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(Node x, String pre, Queue&lt;String&gt; q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x.value != <span class="literal">null</span>) q.enqueue(pre);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c += <span class="number">1</span>) &#123;</span><br><span class="line">        collect(x.next[c], pre + c, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  整个搜索键的过程如下：</p>
<p><img src="/2024/05/31/15.3.Trie%20String%20Operations/image-4.png"></p>
<p>  <code>keysWithPrefix</code>方法的执行过程如下：</p>
<p><img src="/2024/05/31/15.3.Trie%20String%20Operations/image-5.png"></p>
<h3 id="2通配符匹配">2.通配符匹配</h3>
<p>  为了实现<code>keysThatMatch()</code>方法，我们使用一个类似的程序，但添加一个参数<span class="math inline">\(pat\)</span>来表示我们需要<span class="math inline">\(collect()\)</span>的字符串。当模式字符是通配符(<span class="math inline">\(wildcard\)</span>)时，我们调用它的所有链接；否则，我们只调用和通配符相关的链接。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title function_">keysThatMatch</span><span class="params">(String pat)</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;String&gt;();</span><br><span class="line">    collect(root, <span class="string">&quot;&quot;</span>, pat, q);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(Node x, String pre, String pat, Queue&lt;String&gt; q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> pre.length();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (d == pat.length() &amp;&amp; x.val != <span class="literal">null</span>) q.enqueue(pre);</span><br><span class="line">    <span class="keyword">if</span> (d == pat.length()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> <span class="variable">next</span> <span class="operator">=</span> pat.charAt(d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="string">&#x27;.&#x27;</span> || next == c) &#123;</span><br><span class="line">            collect(x.next[c]. pre + c, pat, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>15.Tries</category>
      </categories>
  </entry>
  <entry>
    <title>16.1.四叉树</title>
    <url>/2024/05/31/16.1.QuadTrees/</url>
    <content><![CDATA[<h1 id="161四叉树"><span class="math inline">\(16.1\)</span>四叉树</h1>
<h3 id="1问题的引入">1.问题的引入</h3>
<p>  考虑这样的问题：给定下面一系列点，求落入矩形区域的点的数量。</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image.png"></p>
<p>  我们希望不用遍历所有的点，一个自然的想法是利用<span class="math inline">\(BST\)</span>的性质进行搜索。在对一系列的点坐标<span class="math inline">\((x,y)\)</span>构建<span class="math inline">\(BST\)</span>时。对于单个的<span class="math inline">\(x\)</span>坐标或<span class="math inline">\(y\)</span>坐标，我们可以很容易地构建出对应的<span class="math inline">\(BST\)</span>。但对于二维的坐标，当一个点的<span class="math inline">\(x\)</span>坐标大于另一个点、而<span class="math inline">\(y\)</span>坐标小于另一个点时，我们该怎么排序呢？</p>
<h3 id="2四叉树">2.四叉树</h3>
<p>  该问题的解决办法为：让我们的树从四个方向同时(<span class="math inline">\(simultaneously\)</span>)分割空间，实现这一操作的结构称作四叉树。</p>
<h4 id="a四叉树的构建">  <span class="math inline">\(a.\)</span>四叉树的构建</h4>
<p>  四叉树具有四个指针，每个指针分别指向东南、东北、西南、西北区域。假如我们以<span class="math inline">\(A\)</span>为根节点，则初始的四叉树如下：</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-1.png"></p>
<p>  对应的二维空间如下：</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-2.png"></p>
<p>  接下来，我们插入<span class="math inline">\(B(2,2)\)</span>这个节点。由于<span class="math inline">\(B\)</span>在<span class="math inline">\(A\)</span>的东北方向，<span class="math inline">\(A\)</span>的<span class="math inline">\(NE\)</span>指针指向<span class="math inline">\(B\)</span>：</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-3.png"></p>
<p>  此时对应的二维空间如下：</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-4.png"></p>
<p>  我们以同样地方式插入<span class="math inline">\(C\)</span>、<span class="math inline">\(D\)</span>、<span class="math inline">\(E\)</span>，可得到以下的四叉树和二维空间：</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-5.png"></p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-6.png"></p>
<h4 id="b四叉树的搜索">  <span class="math inline">\(b.\)</span>四叉树的搜索</h4>
<p>  回到开篇的问题，我们用我们构建的四叉树来搜索符合条件的节点。</p>
<ol type="1">
<li>从根节点<span class="math inline">\(A\)</span>开始搜索。<span class="math inline">\(A\)</span>不属于矩形区域，故返回<span class="math inline">\(null\)</span>。</li>
<li>然后，我们考虑：<span class="math inline">\(A\)</span>的哪个子空间(<span class="math inline">\(subspace\)</span>)可能会有符合条件的点？由于矩形区域在<span class="math inline">\(A\)</span>的东北方向，因此我们只需搜索<span class="math inline">\(A\)</span>的<span class="math inline">\(NE\)</span>子树：</li>
</ol>
<p><img src="/2024/05/31/16.1.QuadTrees/image-7.png"></p>
<ol start="3" type="1">
<li>接着我们搜索<span class="math inline">\(B\)</span>节点，<span class="math inline">\(B\)</span>在矩形区域内，所以返回它的坐标。</li>
<li>接着我们考虑：<span class="math inline">\(B\)</span>的哪个子空间可能会有符合条件的点？可以看到<span class="math inline">\(B\)</span>的四个方向都符合条件。</li>
<li>......</li>
</ol>
<p>  可以看到，四叉树具有良好的剪枝(<span class="math inline">\(pruning\)</span>)效果，这提高了我们的搜索效率，我们可以利用递归进行我们的搜索流程。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>16.QuadTrees</category>
      </categories>
  </entry>
  <entry>
    <title>16.2.K-D树</title>
    <url>/2024/05/31/16.2.K-D%20Trees/</url>
    <content><![CDATA[<h1 id="162k-dtrees"><span class="math inline">\(16.2\)</span><span class="math inline">\(K-D\;Trees\)</span></h1>
<h3 id="1引入">1.引入</h3>
<p>  对于二维的空间，我们可以利用四叉树完成搜索。那对于更高维的空间呢？比如下面的例子：</p>
<ul>
<li><p>Example: Want to find songs with the following features:</p>
<ul>
<li>Length between 3 minutes and 6 minutes.</li>
<li>Between 1000 and 20,000 listens.</li>
<li>Between 120 to 150 BPM.</li>
<li>Were recorded after 2004.</li>
</ul></li>
</ul>
<p>  这时，我们就可以采用<span class="math inline">\(K-D\;Tree\)</span>的数据结构来对数据进行划分，从而优化搜索。</p>
<h4 id="2k-d树的原理与构造">2.<span class="math inline">\(K-D\)</span>树的原理与构造</h4>
<p>  以二维坐标为例，我们按照以下的规则构建<span class="math inline">\(K-D\;Tree\)</span>：</p>
<ul>
<li><p>Each level has a "cutting dimension"</p></li>
<li><p>Cycle through the dimensions as you walk down the tree.</p></li>
<li><p>Each node contains a point P = (x,y)</p></li>
<li><p>To find (x',y') you only compare coordinate from the cutting
dimension</p>
<ul>
<li>e.g. if cutting dimension is x, then you ask: is x’ &lt; x</li>
</ul></li>
</ul>
<p>  每个节点都拥有两个子空间。在搜索中，我们像在四叉树中做的一样，只在可能有最优解的子空间进行搜索。</p>
<p>  例如，我们可以如下插入以下坐标：</p>
<p><img src="/2024/05/31/16.2.K-D%20Trees/image-8.png"></p>
<h4 id="3k-d树的搜索">3.<span class="math inline">\(K-D\)</span>树的搜索</h4>
<p>  以搜索到某个点距离最小的点为例，我们可以按照以下的步骤进行搜索：</p>
<ul>
<li><p>Start at the root and store that point as the "best so far".
Compute its distance to the query point, and save that as the "score to
beat". In the image above, we start at A whose distance to the flagged
point is 4.5.</p></li>
<li><p>This node partitions the space around it into two subspaces. For
each subspace, ask: "Can a better point be possibly found inside of this
space?" This question can be answered by computing the shortest distance
between the query point and the edge of our subspace (see dotted purple
line below).</p></li>
<li><p>Continue recursively for each subspace identified as containing a
possibly better point.</p></li>
<li><p>In the end, our "best so far" is the best point; the point
closest to the query point.</p></li>
</ul>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>16.QuadTrees</category>
      </categories>
  </entry>
  <entry>
    <title>18.1.选择排序</title>
    <url>/2024/05/31/18.1.Selection%20Sort/</url>
    <content><![CDATA[<h1 id="181selection-sort"><span class="math inline">\(18.1\)</span>Selection Sort</h1>
<h3 id="1the-step-of-selection-sort">1.The step of Selection sort</h3>
<p>  In selection sort, we basically do these three things:</p>
<ol type="1">
<li>Find the smallest item.</li>
<li>Move it to the front.</li>
<li>Selection sort the rest(using recursion).</li>
</ol>
<p>  For each step, we can design an individual method to implement
it.</p>
<h3 id="2step-implementation">2.Step implementation</h3>
<p>  As the moving step requires the index of the to-moving element, the
value we return should be index of elements, too.</p>
<h4 id="afind">  <span class="math inline">\(a.\)</span><code>Find</code></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;</span><br><span class="line">            i = minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Given that we may need to <code>Find</code> the minimun in asked
range, we may improve our method by passing an extra parameter which
point to the start index(We'll use it in the following procedure)：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> st)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (st &gt;= arr.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;</span><br><span class="line">            i = minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="bswap">  <span class="math inline">\(b.\)</span><code>swap</code></h4>
<p>  We are going to implement the method by manipulating the index of
the elements: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[x];</span><br><span class="line">    arr[x] = arr[y];</span><br><span class="line">    arr[y] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="cmainmethod">  <span class="math inline">\(c.\)</span>Main
method</h4>
<p>  Since we would like to do the sorting recursively, we may introduce
a helper method and invoke it recursively: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        sortHelper(arr, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sortHelper</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//basic situation</span></span><br><span class="line">        <span class="keyword">if</span> (index == arr.length()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//find the smallest item</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> find(arr, index);</span><br><span class="line">        <span class="comment">//Move it to the front</span></span><br><span class="line">        swap(arr, index, minIndex);</span><br><span class="line">        <span class="comment">//Recursively call the method</span></span><br><span class="line">        sortHelper(arr, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>18.Basic Sorting</category>
      </categories>
  </entry>
  <entry>
    <title>17.1.图的构建</title>
    <url>/2024/05/31/17.1.The%20construction%20of%20Graphs/</url>
    <content><![CDATA[<h1 id="171图的构建"><span class="math inline">\(17.1\)</span>图的构建</h1>
<h3 id="1图的api">1.图的<span class="math inline">\(API\)</span></h3>
<p><img src="/2024/05/31/17.1.The%20construction%20of%20Graphs/image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="built_in">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[])<span class="keyword">new</span> <span class="title class_">Bag</span>[V];<span class="comment">// Create array of lists.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v += <span class="number">1</span>) &#123;</span><br><span class="line">            adj[v] = <span class="keyword">new</span> <span class="title class_">Bag</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(In in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(in.readInt()); <span class="comment">// Read V and construct this graph.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">E</span> <span class="operator">=</span> in.readInt(); <span class="comment">// Read E.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; E; i++) &#123; <span class="comment">// Add an edge.</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> in.readInt(); <span class="comment">// Read a vertex,</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> in.readInt(); <span class="comment">// read another vertex,</span></span><br><span class="line">            addEdge(v, w); <span class="comment">// and add edge connecting them.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        adj[w].add(v);</span><br><span class="line">        E += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2dfs">2.<span class="math inline">\(dfs\)</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepthFirstSearch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepthFirstSearch</span><span class="params">(Graph G, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V];</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        marked[v] = <span class="literal">true</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w : G.adj[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) dfs(G, w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">marked</span><span class="params">(<span class="type">int</span> w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3路径的寻找">3.路径的寻找</h3>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>17.Graphs</category>
      </categories>
  </entry>
  <entry>
    <title>18.3.归并排序</title>
    <url>/2024/05/31/18.3.Merge%20Sort/</url>
    <content><![CDATA[<h1 id="183mergesort"><span class="math inline">\(18.3.\)</span>Merge
Sort</h1>
<h3 id="1the-step-of-merge-sort">1.The step of Merge Sort</h3>
<ul>
<li>Split items into 2 roughly even pieces.</li>
<li>Mergesort each half (steps not shown, this is a recursive
algorithm!)</li>
<li>Merge the two sorted halves to form the final result.</li>
</ul>
<h3 id="2step-implementation">2.Step implementation</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">merge</span><span class="params">(<span class="type">double</span>[] a, <span class="type">double</span>[] b)</span> &#123;</span><br><span class="line">    <span class="type">double</span>[] c = <span class="keyword">new</span> <span class="title class_">double</span>[a.length + b.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; c.length; k += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= a.length) c[k] = b[j++];</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= b.length) c[k] = a[i++];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= b[j]) c[k] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> c[k] = b[j++]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span>[] mergeSort(<span class="type">double</span>[] input) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> input.length;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> input;</span><br><span class="line">    <span class="type">double</span>[] a = <span class="type">double</span>[N / <span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span>[] b = <span class="type">double</span>[N - N / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i += <span class="number">1</span>) a[i] = input[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; b.length; j += <span class="number">1</span>) b[j] = input[j + N / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(a), mergeSort(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>18.Basic Sorting</category>
      </categories>
  </entry>
  <entry>
    <title>18.2.堆排序</title>
    <url>/2024/05/31/18.2.Heap%20Sort/</url>
    <content><![CDATA[<h1 id="182heapsort"><span class="math inline">\(18.2\)</span>Heap
Sort</h1>
<h3 id="1the-step-of-heap-sorting">1.The step of Heap Sorting</h3>
<p>  The simplest method to implement sorting via heap is to put the
whole array into a heap, and pick out top of the heap one by one.</p>
<p>  However, this method will lead to unnecessarily memory waste, for
we can do heap sorting in place without creating a new heap.</p>
<h3 id="2step-impletation">2.Step impletation</h3>
<h4 id="abasic-heap-operation">  <span class="math inline">\(a.\)</span>Basic Heap operation</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(Comparable[] pq, <span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k;<span class="comment">//left child</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; n &amp;&amp; less(pq, j, j + <span class="number">1</span>)) j += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!less(pq, k, j)) <span class="keyword">break</span>;</span><br><span class="line">        swap(pq, k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable[] pq, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pq[i - <span class="number">1</span>].compareTo(pq[j - <span class="number">1</span>]) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Object[] pq, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> pq[i - <span class="number">1</span>];</span><br><span class="line">    pq[i - <span class="number">1</span>] = pq[j - <span class="number">1</span>];</span><br><span class="line">    pq[j - <span class="number">1</span>] = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bheapsorting">  <span class="math inline">\(b.\)</span>Heap
Sorting</h4>
<p>  The in place heap sorting use the following step: 1. Sink the
element in the array one by one, so that the array forms a heap.</p>
<p><img src="/2024/05/31/18.2.Heap%20Sort/image.png"></p>
<p><img src="/2024/05/31/18.2.Heap%20Sort/image-1.png"></p>
<ol start="2" type="1">
<li>Pop the front element one by one, and move the popped element to the
back of the array.</li>
</ol>
<p><img src="/2024/05/31/18.2.Heap%20Sort/image-2.png"></p>
<p><img src="/2024/05/31/18.2.Heap%20Sort/image-3.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] pq)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pq.length;</span><br><span class="line">    <span class="comment">//heapify</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k --) sink(pq, k, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort and swap</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//pop the heaptop</span></span><br><span class="line">        swap(pq, <span class="number">1</span>, k--);</span><br><span class="line">        <span class="comment">//why k--?Because the kth element is sorted, so we only need to care about the k-1 th</span></span><br><span class="line">        <span class="comment">//maintain the heap property</span></span><br><span class="line">        sink(pq, <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>18.Basic Sorting</category>
      </categories>
  </entry>
  <entry>
    <title>18.4.插入排序</title>
    <url>/2024/05/31/18.4.Insertion%20Sort/</url>
    <content><![CDATA[<h1 id="184insertion-sort"><span class="math inline">\(18.4.\)</span>Insertion Sort</h1>
<h3 id="1the-step-of-insertion-sort">1.The step of Insertion Sort</h3>
<p>  The insertion sort follows these general strategies:</p>
<ul>
<li>Starting with an empty output sequence.</li>
<li>Add each item from input, inserting into output at right
places.</li>
</ul>
<p>  Also, this method requires a new array, which takes up some
memory.As a result, we may try in place sorting by using swapping
method.</p>
<p>  Take the below array as example.Suppose we have sorted the first
two elements.It's worth noting that we use a <span class="math inline">\(j\)</span> to track the current spot of the
travelling element:</p>
<p><img src="/2024/05/31/18.4.Insertion%20Sort/image-4.png"></p>
<p>  The <span class="math inline">\(2\)</span> element will experience
the following steps:</p>
<p><img src="/2024/05/31/18.4.Insertion%20Sort/image-5.png"></p>
<p><img src="/2024/05/31/18.4.Insertion%20Sort/image-6.png"></p>
<p>  After these steps, the <span class="math inline">\(2\)</span>
element reach its right place, and we get the first third elements
sorted:</p>
<p><img src="/2024/05/31/18.4.Insertion%20Sort/image-7.png"></p>
<p>  Do it recursively, then we can get a sorted array.</p>
<h3 id="2step-implementation">2.Step implementation</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="comment">//compare with its front element, if it&#x27;s not in order, swap it</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j - <span class="number">1</span>]); j --) &#123;</span><br><span class="line">            swap(a, j, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo + <span class="number">1</span>; i &lt; hi; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; lo &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--) &#123;</span><br><span class="line">                swap(a, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3some-property-of-insertionsort">3.Some property of Insertion
Sort</h3>
<p>  Since the principle of insertion sort is to maintain the order of
each subsequence, for arrays that are almost sorted, we only need to do
few swaps, thus makes sorting fast.</p>
<p>  Suppose that there are <span class="math inline">\(K\)</span>
inversions in the array, the runtime of Insertion Sort is <span class="math inline">\(\Theta (N+K)\)</span>.</p>
<p>  Moreover, we can define an almost sorted array as one in which
numbers of inversions <span class="math inline">\(\leq\;cN\)</span>,
insertion sort is excellent on these arrays.</p>
<p>  Ususally, for small arrays(with N less than 15), insertion sort is
fast.</p>
<h3 id="4sorting-summary">4.Sorting Summary</h3>
<p><img src="/2024/05/31/18.4.Insertion%20Sort/image-8.png"></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>18.Basic Sorting</category>
      </categories>
  </entry>
  <entry>
    <title>18.6.基数排序</title>
    <url>/2024/05/31/18.5.Radix%20Sort/</url>
    <content><![CDATA[<h1 id="186radixsort"><span class="math inline">\(18.6.\)</span>Radix
Sort</h1>
<h3 id="1counting-sort">1.Counting Sort</h3>
<p>   In the previous text, we have proved that sorting using comparison
has a worst case running time of <span class="math inline">\(\Theta(n\log n)\)</span>.However, what if we don't
compare at all?</p>
<p>  Suppose we have a couple of characters, saying <span class="math inline">\(acdsjlfkm\)</span>, we can sort them in alphabet
order through the following steps:</p>
<ol type="1">
<li>Creat an array with the same size of an alphabet(<span class="math inline">\(26\)</span>).</li>
<li>For each character, put it in the <span class="math inline">\(ch-&#39;a&#39;\)</span> index.</li>
<li>Scan the whole array, and the former character are always less than
the latter. Insert the character into a new array in order, then we get
a sorted array.</li>
</ol>
<p>  This kind of sorting method is called counting sort. If the length
of data is <span class="math inline">\(N\)</span>, and the size of
alphabet is <span class="math inline">\(R\)</span>, then the runtime of
counting sort is <span class="math inline">\(\Theta(N+R)\)</span>. It's
liner runtime!</p>
<p><img src="/2024/05/31/18.5.Radix%20Sort/image-9.png"></p>
<p>  However, the algorithm falls to sort hard-to-count items like
String, so we need improvement.</p>
<h3 id="2lsd-radix-sort">2.LSD Radix Sort</h3>
<p>  The LSD(Least Significant Digit) radix sort sort each digit of the
item independently form rightmost digit towards left, take the below
table as example:</p>
<p><img src="/2024/05/31/18.5.Radix%20Sort/image-10.png"></p>
<p>  The runtime of LSD radix sort is <span class="math inline">\(\Theta(WN+WR)\)</span>,where N is Number of items,
R is size of alphabet, and W is the maximun length of these items.</p>
<p>  What if the length of each item isn't same? We can treat empty
spaces as less than all other characters:</p>
<p><img src="/2024/05/31/18.5.Radix%20Sort/image-11.png"></p>
<h3 id="3msd-radix-sort">3.MSD Radix Sort</h3>
<p>  The MSD(Most Significant Digit) radix sort is similiar to LSD radix
sort. However, it sorts from the left digit to the right.</p>
<p>  After first sorting process, we may get items as below:</p>
<p><img src="/2024/05/31/18.5.Radix%20Sort/image-12.png"></p>
<p>  The items are not in correct order yet! To solve this, we can treat
items with same left digit as a group, and compare the next left
character within groups:</p>
<p><img src="/2024/05/31/18.5.Radix%20Sort/image-13.png"></p>
<p>  The runtime of MSD radix sort is the same as LSD radix sort.</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>18.Basic Sorting</category>
      </categories>
  </entry>
  <entry>
    <title>2.2.单链表</title>
    <url>/2024/05/31/2.2.SLLists/</url>
    <content><![CDATA[<h1 id="22单链表"><span class="math inline">\(2.2\)</span>单链表</h1>
<p>  在前一章中，我们搭建了整型链表<span class="math inline">\(IntList\)</span>，但在实际应用中，<span class="math inline">\(IntList\)</span>较难使用，并且会导致代码难以理解与维护。</p>
<p>  这些问题的来源是：<span class="math inline">\(IntList\)</span>是一个裸裸递归结构：<span class="math inline">\(IntList\)</span>在函数内部直接调用自身的递归，而没有其他辅助操作或条件检查。</p>
<p>  下面我们对<span class="math inline">\(IntList\)</span>进行一系列优化，来搭建新的类<span class="math inline">\(SLList\)</span>。</p>
<h3 id="1重构">1.重构</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">        item = i;</span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  为了避免<span class="math inline">\(IntList\)</span>的复杂使用，我们创建一个单独的<span class="math inline">\(SLList\)</span>类给用户使用： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IntNode first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(SLList\)</span>的实现隐藏了<span class="math inline">\(IntList\)</span>的一些细节，使得定义链表变得更简洁：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntList</span> <span class="variable">L1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">SLList</span> <span class="variable">L2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="2addfirstgetfirst">2.<code>addFirst</code>，<code>getFirst</code></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> first.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这样优化后的链表很方便使用： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">15</span>);</span><br><span class="line">L.addFirst(<span class="number">10</span>);</span><br><span class="line">L.addFirst(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> L.getFirst();</span><br><span class="line"></span><br><span class="line"><span class="comment">//compared with IntList//</span></span><br><span class="line"><span class="type">IntList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, <span class="literal">null</span>);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">10</span>, L);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, L);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> L.first;</span><br></pre></td></tr></table></figure></p>
<p>  可以看到，<span class="math inline">\(SLList\)</span>类扮演了链表使用者和裸递归数据结构间中介人的角色。</p>
<h3 id="3public和private">3.<code>public</code>和<code>private</code></h3>
<p>  先前定义的<span class="math inline">\(SLList\)</span>有一个问题：用户的一些操作会导致链表的异常。例如：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">15</span>);</span><br><span class="line">L.addFirst(<span class="number">10</span>);</span><br><span class="line">L.first.next.next = L.first.next;</span><br></pre></td></tr></table></figure></p>
<p>  这会导致链表的无限延长，而这是我们不希望看到的。我们可以采用下面的方法来杜绝这件事：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IntNode first;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>  <code>private</code>变量和方法只能被同一个<code>.java</code>文件内的代码访问，其他文件访问它时，会返回<code>first has private access in SLList</code>的错误。</p>
<p>  在软件工程中，<code>private</code>关键字表明一段代码应该被用户忽略、也不需要被用户理解。<code>public</code>关键字则声明了一个方法是可用的、并且永远不会出错(不管用户做出什么更改)。因此，要谨慎使用<code>public</code>关键字。</p>
<blockquote>
<p>  As an analogy, a car has certain public features, e.g. the
accelerator and brake pedals. Under the hood, there are private details
about how these operate. In a gas powered car, the accelerator pedal
might control some sort of fuel injection system, and in a battery
powered car, it may adjust the amount of battery power being delivered
to the motor. While the private details may vary from car to car, we
expect the same behavior from all accelerator pedals. Changing these
would cause great consternation from users, and quite possibly terrible
accidents.</p>
</blockquote>
<h3 id="4嵌套类">4.嵌套类</h3>
<p>  目前为止我们定义了两个类：<span class="math inline">\(IntNode\)</span>和<span class="math inline">\(SLList\)</span>，但是<span class="math inline">\(IntNode\)</span>实际上只是辅助<span class="math inline">\(SLList\)</span>的。</p>
<p>  对此，<span class="math inline">\(Java\)</span>允许我们在一个类里面定义其他类：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">            <span class="keyword">public</span> IntNode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">                item = i;</span><br><span class="line">                next = n;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> IntNode first; </span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">           first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">       &#125; </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>  创建一个嵌套类与分开定义两个类的效果是一样的，只是前者能让代码看起来更为整齐。</p>
<p>  如果嵌套类不需要使用<span class="math inline">\(SLList\)</span>中的任何实例方法或者变量，我们可以用<code>static</code>来声明它。<code>static</code>关键字说明静态类(<span class="math inline">\(static\;class\)</span>)中的方法不能访问任何在封闭类中的成员。在这个例子中，这意味着<span class="math inline">\(IntNode\)</span>不能够访问<code>first</code>，<code>addFirst</code>或者<code>getFirst</code>。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">            <span class="keyword">public</span> IntNode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">                item = i;</span><br><span class="line">                next = n;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> IntNode first;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>  这样的做法可以节约一些内存，因为之后<span class="math inline">\(IntNode\)</span>就不需要再追踪它怎么访问它所处的<span class="math inline">\(SLList\)</span>了，从而<span class="math inline">\(IntNode\)</span>不会调用<span class="math inline">\(SLList\)</span>。</p>
<blockquote>
<p>  if you don't use any instance members of the outer class, make the
nested class static.</p>
</blockquote>
<h3 id="5addlast-size">5.<code>addLast</code>、<code>size</code></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Adds an item to the end of the list. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advance p to the end of the list. */</span></span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the size of the list starting at IntNode p. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(IntNode p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + size(p.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这个<span class="math inline">\(size\)</span>函数也是<span class="math inline">\(O(n)\)</span>复杂度的。为了减少时间消耗，我们可以像创建<span class="math inline">\(SLList\)</span>一样创建一个“中介人”，来实现用户对<span class="math inline">\(Size\)</span>的访问： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Returns the size of the list starting at IntNode p. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(IntNode p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + size(p.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这里出现了两个方法，名称都叫<span class="math inline">\(size\)</span>。这是允许的，因为它们有不同的参数。我们把这种方法名字相同、参数不同的方法称作重载(<span class="math inline">\(overloaded\)</span>)。</p>
<h3 id="6缓存cashing">6.缓存<span class="math inline">\(cashing\)</span></h3>
<p>  除了用上面的方法计算<span class="math inline">\(size\)</span>，我们还可以在<span class="math inline">\(SLList\)</span>类中添加一个<span class="math inline">\(size\)</span>变量： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    ... <span class="comment">/* IntNode declaration omitted. */</span></span><br><span class="line">    <span class="keyword">private</span> IntNode first;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这种通过保存关键信息来加速检索的方法被称为缓存(<span class="math inline">\(cashing\)</span>)。</p>
<h3 id="7空链表">7.空链表</h3>
<p>  我们<span class="math inline">\(SLList\)</span>的框架可以轻松地初始化链表：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;</span><br><span class="line">    first = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="8哨兵节点sentinel">8.哨兵节点(<span class="math inline">\(sentinel\)</span>)</h3>
<p>  我们可以按照上一章的方法实现<code>addLast</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  但是，当传入的链表是空链表时，由于<code>first == null</code>，<code>while(p.next != null),p.next</code>这些方法都会导致<code>null pointer exceptation</code>的错误。</p>
<p>  我们可以单独讨论<code>first == null</code>的情况，但这样会让程序变得复杂。因此我们设法将所有的链表都统一成一种情况。</p>
<p>  我们可以在链表的开头创建一个节点，叫作哨兵节点(<span class="math inline">\(sentinel\;node\)</span>)，不管链表是否为空，这个节点都存在。</p>
<p><img src="/2024/05/31/2.2.SLLists/image-9.png"></p>
<p><img src="/2024/05/31/2.2.SLLists/image-10.png"></p>
<p>  在将所有情况统一后，我们就可以更好地实现<code>addLast</code>：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">    <span class="keyword">while</span>(p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="9不变量invarient">9.不变量<span class="math inline">\(invarient\)</span></h3>
<p>  不变量，就是数据结构中必须要遵守的事实(<span class="math inline">\(fact\;that\;is\;guaranteed\;to\;be\;true\)</span>)。</p>
<p>  一个<span class="math inline">\(SLList\)</span>至少要遵循以下不变量：</p>
<ul>
<li><code>sentinel</code>总是指向哨兵节点。</li>
<li>链表最前面的元素(如果存在的话)永远是<code>sentinel.next.item</code>。</li>
<li><code>size</code>变量永远代指被加入链表的元素的数量。</li>
</ul>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>2.List</category>
      </categories>
  </entry>
  <entry>
    <title>2.1.Java语言特性</title>
    <url>/2024/05/31/2.1.Mystery%20of%20the%20Walrus/</url>
    <content><![CDATA[<h1 id="21-java语言特性"><span class="math inline">\(2.1\)</span> <span class="math inline">\(Java\)</span>语言特性</h1>
<h3 id="1比特bit">1.比特(<span class="math inline">\(bit\)</span>)</h3>
<p>  在计算机中，所有的信息都<strong>以<span class="math inline">\(01\)</span>串的形式</strong>存储于内存中，例如：</p>
<ul>
<li><span class="math inline">\(72\)</span>被存储为<code>01001000</code></li>
<li><span class="math inline">\(H\)</span>字母被存储为<code>01001000</code></li>
</ul>
<p>  <span class="math inline">\(72\)</span>和<span class="math inline">\(H\)</span>的<span class="math inline">\(01\)</span>串是相同的，<span class="math inline">\(Java\)</span>代码通过数据类型(<span class="math inline">\(tyep\)</span>)区分它们： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line"><span class="type">int</span> x=c;</span><br><span class="line">System.out.println(c);</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">H</span><br><span class="line"><span class="number">72</span></span><br></pre></td></tr></table></figure>
<p>  在这个例子中，<code>x</code>和<code>c</code>变量都有相同的<span class="math inline">\(01\)</span>串，但解释器会在打印它们的时候对其进行不同的处理。</p>
<p>  在<span class="math inline">\(Java\)</span>中，有<span class="math inline">\(8\)</span>种基本数据类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>float</code>，<code>double</code>，<code>boolean</code>，<code>char</code>。</p>
<h3 id="2变量的声明简化">2.变量的声明(简化)</h3>
<p>  我们可以将计算机想象成一个一个拥有大量记忆比特(<span class="math inline">\(memory\;bits\)</span>)来存储信息的机器，<strong>每个比特都有独立的地址</strong>。</p>
<p>  在声明某一基本数据类型的变量时，<span class="math inline">\(Java\)</span>会<strong>找到一个区域(<span class="math inline">\(blocks\)</span>)</strong>，这个区域有足够的比特来存储该类型的信息。我们可以把这些区域比喻为
<strong>一个装着比特的盒子(<span class="math inline">\(box\)</span>)</strong>。</p>
<p>  除了安置内存，<span class="math inline">\(Java\)</span>解释器还会<strong>创造一个内部表格的入口(<span class="math inline">\(entry\)</span>)</strong>，它<strong>将每个变量的名字与它们对应盒子的第一个比特相对应(<span class="math inline">\(map\)</span>)</strong>。</p>
<p>  例如，当我们声明<code>int x</code>和<code>double y</code>这两个变量时，<span class="math inline">\(Java\)</span>可能会决定用内存中的第<span class="math inline">\(352\)</span>到第<span class="math inline">\(384\)</span>位比特来存储<code>x</code>，用第<span class="math inline">\(20800\)</span>到第<span class="math inline">\(20864\)</span>位比特来存储<code>y</code>。解释器会接着记录<code>x</code>从第<span class="math inline">\(352\)</span>位比特开始存储，<code>y</code>从第<span class="math inline">\(20800\)</span>位比特开始存储。在执行下面的代码后：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br></pre></td></tr></table></figure></p>
<p>  我们会得到下面两个<span class="math inline">\(32\)</span>位和<span class="math inline">\(64\)</span>位的盒子：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image.png"></p>
<p>  <span class="math inline">\(java\)</span>语言<strong>并没有像<span class="math inline">\(C\)</span>语言一样提供访问盒子地址的途径</strong>。这虽然阻止了某些类型优化，但也防止了一大类非常棘手的编程错误。</p>
<p>  在变量声明后，<span class="math inline">\(Java\)</span>并不会在预留的盒子里写入任何默认的东西，也就是说，<strong>每个变量并没有默认值</strong>。因此，在这个盒子被通过<code>=</code>运算符装满比特之前，<span class="math inline">\(Java\)</span>解释器会阻止我们使用这个变量。而<strong>当我们对内存盒子(<span class="math inline">\(memory\;box\)</span>)进行赋值后，这个盒子就会装入我们指定的值</strong>。</p>
<p>  例如，当我们执行下面的程序时： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = -<span class="number">1431195969</span>;</span><br><span class="line">y = <span class="number">567213.112</span>;</span><br></pre></td></tr></table></figure></p>
<p>  每个变量的内存盒子会像下面这样被填满。这种标记被叫做盒子标记法(<span class="math inline">\(box\;notation\)</span>)：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-1.png"></p>
<p>  为了简化，我们将盒子标记简化为如下格式：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-2.png"></p>
<h3 id="3等式的黄金规则groe">3.等式的黄金规则(<span class="math inline">\(GRoE\)</span>)</h3>
<p>  <strong>当我们写下<code>y=x</code>，我们在告诉<span class="math inline">\(Java\)</span>解释器把<code>x</code>的比特复制给<code>y</code></strong>。这个规则是理解下面这个谜题的基础：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;</span><br><span class="line">b = a;</span><br><span class="line">b.weight = <span class="number">5</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure></p>
<h3 id="4引用类型referencetype">4.引用类型(<span class="math inline">\(reference\;type\)</span>)</h3>
<p>  在之前我们介绍了<span class="math inline">\(Java\)</span>的基本类型，除了基本类型外的其他类型，如数组，被称为<strong>引用类型</strong>。</p>
<h4 id="a对象实例化">  <span class="math inline">\(a.\)</span>对象实例化</h4>
<p>  当我们利用<code>new</code>语句将某个对象实例化(<span class="math inline">\(instantiate\)</span>)后，<span class="math inline">\(Java\)</span>会先<strong>给这个类(<span class="math inline">\(class\)</span>)的每个实例变量分配一个盒子</strong>，然后<strong>在盒子里面装一个默认值</strong>。</p>
<p>  例如，当我们的<span class="math inline">\(Warlus\)</span>类如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Walrus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> tuskSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Walrus</span><span class="params">(<span class="type">int</span> w, <span class="type">double</span> ts)</span> &#123;</span><br><span class="line">          weight = w;</span><br><span class="line">          tuskSize = ts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  并且我们创造了一个实例<code>new Walrus(1000,8.3)</code>，那么我们就会得到下面这两个独立的盒子：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-3.png"></p>
<h4 id="b引用类型变量的声明">  <span class="math inline">\(b.\)</span>引用类型变量的声明</h4>
<p>  我们上面所举的例子是匿名的实例，它没有被存储到一个变量中。</p>
<p>  当我们声明任何一个引用类型的变量时，<span class="math inline">\(Java\)</span><strong>会给这个变量分配一个<span class="math inline">\(64\)</span>比特的盒子，不管这个对象是什么类型的</strong>。这是因为：这个<span class="math inline">\(64\)</span>比特的盒子并不是装这个对象(例如<span class="math inline">\(Walrus\)</span>)的具体数据的，而是装<strong>这个对象在内存中的地址</strong>。</p>
<p>  例如，当我们如下调用变量时： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Walrus someWalrus;</span><br><span class="line">someWalrus = new Walrus(1000, 8.3);</span><br></pre></td></tr></table></figure></p>
<p>  我们假设<span class="math inline">\(Walrus\)</span>的<code>weight</code>存储在开始于<code>5051956592385990207</code>的比特里，而<code>tuskSize</code>存储在开始于<code>5051956592385990239</code>的比特里，我们会<strong>把<code>5051956592385990207</code>存储在<span class="math inline">\(Walrus\)</span>变量中</strong>：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-4.png"></p>
<p>  我们也可以对引用变量赋予特殊值<code>null</code>：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-5.png"></p>
<p>  这样表示引用变量的比特较为复杂，因此我们引入箭头标记：</p>
<ul>
<li>如果一个地址全部为空，就用<code>null</code>来表示。</li>
<li><strong>如果一个地址非空，就用箭头指向它所代指的对象实例</strong>。</li>
</ul>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-6.png"></p>
<p>  回到下面这个问题： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;</span><br><span class="line">b = a;</span><br><span class="line">b.weight = <span class="number">5</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure></p>
<p>  执行完下面的语句后，可以得到下面的标记： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;</span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-7.png"></p>
<h3 id="5参数传递">5.参数传递</h3>
<p>  当我们给一个函数传递参数时，我们也只是<strong>将参数的比特复制过去</strong>。<span class="math inline">\(GRoE\)</span>原则同样适用于参数的传递。比特复制也被称作传递数值(<span class="math inline">\(passing\;by\;value\)</span>)。在<span class="math inline">\(Java\)</span>中，我们经常使用这种做法。</p>
<p>  注意到，<strong>对于基本类型变量，比特表示的是它们的数值而非地址</strong>；而<strong>对于引用类型的变量，比特表示的是它们的地址</strong>，因此<strong>函数对两者的作用并不相同</strong>。</p>
<p>  考虑下面这个例子： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassByValueFigure</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="type">Walrus</span> <span class="variable">walrus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">3500</span>, <span class="number">10.5</span>);</span><br><span class="line">           <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">           doStuff(walrus, x);</span><br><span class="line">           System.out.println(walrus);</span><br><span class="line">           System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doStuff</span><span class="params">(Walrus W, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">           W.weight = W.weight - <span class="number">100</span>;</span><br><span class="line">           x = x - <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   该例子对应的标记图如下：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-8.png"></p>
<p>  可以看到，<span class="math inline">\(doStuff\)</span>只对<span class="math inline">\(Walrus\)</span>的对象有作用，对<code>x</code>并无作用。</p>
<h3 id="6数组的实例化">6.数组的实例化</h3>
<p>  像先前对引用变量的讲解，用于存储数组的变量也遵循相同的规则。例如下面这个整数数组的创建：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">95</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  这里的<code>new</code>关键词会创建<span class="math inline">\(5\)</span>个<span class="math inline">\(32\)</span>比特的盒子，并返回赋值给<code>x</code>的整个对象的地址。</p>
<p>  如果丢失了和对象的地址相关的比特，对象可能被遗失。例如如果上例的<code>x</code>是右侧数组唯一的备份(<span class="math inline">\(copy\)</span>)，那么<code>x=null</code>的赋值语句会导致原先数组的丢失。这并非坏事，因为有时我们的确需要遗忘一些对象。</p>
<h3 id="7整型链表intlist">7.整型链表(<span class="math inline">\(IntList\)</span>)</h3>
<h4 id="a整型链表的构建">  <span class="math inline">\(a.\)</span>整型链表的构建</h4>
<p>  类似<span class="math inline">\(python\)</span>中的<span class="math inline">\(Linked\;list\)</span>，可以用递归的方式实现初步的整型链表：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> first;</span><br><span class="line">    <span class="keyword">public</span> IntList rest;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntList</span><span class="params">(<span class="type">int</span> f, IntList r)</span> &#123;</span><br><span class="line">        first = f;</span><br><span class="line">        rest = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这种形式的链表使用起来非常不方便、容易出错，之后我们将会通过在类中添加辅助方法(<span class="math inline">\(helper\;method\)</span>)的面向对象编程策略来优化它：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line">L.rest = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">10</span>, <span class="literal">null</span>);</span><br><span class="line">L.rest.rest = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">IntList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, <span class="literal">null</span>);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">10</span>, L);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, L);</span><br></pre></td></tr></table></figure></p>
<h4 id="bsize函数的递归与迭代实现">  <span class="math inline">\(b.\)</span><span class="math inline">\(Size\)</span>函数的递归与迭代实现</h4>
<p>  整型链表的<span class="math inline">\(Size\)</span>函数的递归实现如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Return the size of the list using... recursion! */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">this</span>.rest.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这里有一个要点：为什么递归的基本条件不写<code>if(this == null)</code>呢？问题出在<code>L == null</code>这种特殊情况，我们不能对一个<code>null</code>对象使用实例方法。</p>
<p>  <span class="math inline">\(Size\)</span>函数的迭代实现如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Return the size of the list using no recursion! */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">iterativeSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">IntList</span> <span class="variable">p</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        totalSize += <span class="number">1</span>;</span><br><span class="line">        p = p.rest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  需要注意，在迭代时我们需要一个指针<code>p</code>，因为在<span class="math inline">\(java\)</span>中，我们不能重新分配(<span class="math inline">\(reassign\)</span>)<code>this</code>。</p>
<blockquote>
<p><code>this</code>refers to the current object. It's like saying: "I
am" or "my name is". You can't change who you are.</p>
</blockquote>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>2.List</category>
      </categories>
  </entry>
  <entry>
    <title>2.3.双链表</title>
    <url>/2024/05/31/2.3.DLLists/</url>
    <content><![CDATA[<h1 id="23双链表"><span class="math inline">\(2.3\)</span>双链表</h1>
<h3 id="1对addlast的优化">1.对<code>addLast</code>的优化</h3>
<p>  让我们回顾一下<span class="math inline">\(SLList\)</span>的<code>addList</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这个方法的问题在于速度太慢。对此，我们可以像处理<span class="math inline">\(size\)</span>一样，在链表中多存储一个关键信息<span class="math inline">\(last\)</span>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> IntNode last;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        last = last.next;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  但这样会让<code>deleteLast</code>的操作变得困难，因为要删除<span class="math inline">\(last\)</span>，必须知道<span class="math inline">\(last\)</span>前面的元素。如果我们再缓存<span class="math inline">\(secondlast\)</span>，就相应地需要缓存<span class="math inline">\(thirdlast\)</span>...这说明缓存并不能解决问题，这引出了我们下面的解决方案：</p>
<h3 id="2指向前面元素的指针">2.指向前面元素的指针</h3>
<p>  上面问题的解决方案就是给<span class="math inline">\(IntNode\)</span>添加一个指向前面元素的指针：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IntNode prev;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  通过这种操作，我们的链表就与前后两个节点都产生了链接。这种链表被称为双链表(<span class="math inline">\(double\;linked\;list\)</span>)。下面的图示显示了双链表的具体构建：</p>
<p><img src="/2024/05/31/2.3.DLLists/image-11.png"></p>
<h3 id="3哨兵节点的改进">3.哨兵节点的改进</h3>
<p>  向后的指针有时会指向哨兵节点，有时会指向真实节点，在特殊情况下，这会导致原先代码的错误。对此，我们有两种解决办法：</p>
<ol type="1">
<li>在前后各设置一个哨兵节点：</li>
</ol>
<p><img src="/2024/05/31/2.3.DLLists/image-12.png"></p>
<ol start="2" type="1">
<li>将链表变为循环链表：</li>
</ol>
<p><img src="/2024/05/31/2.3.DLLists/image-13.png"></p>
<h3 id="4通用型链表">4.通用型链表</h3>
<p>  有时，链表中的元素不止是<span class="math inline">\(int\)</span>型，还可能是其他类型。我们可以用以下语句声明能表示任何引用类型的数据结构：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*create a class able to contain any type*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span>&lt;T&gt; () &#123;</span><br><span class="line">    <span class="comment">//create an item able to carry any type</span></span><br><span class="line">    <span class="keyword">public</span> T item;</span><br><span class="line">    <span class="comment">//create an array able to carry any type</span></span><br><span class="line">    <span class="keyword">public</span> T[] arr = (T[])<span class="keyword">new</span> <span class="title class_">Object</span>[capacity]; </span><br><span class="line">    <span class="comment">//print this type of item</span></span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>2.List</category>
      </categories>
  </entry>
  <entry>
    <title>2.2.数据抽象</title>
    <url>/2024/05/31/2.2.%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="22数据抽象"><span class="math inline">\(2.2\)</span>数据抽象</h1>
<h3 id="1数据抽象的概念">1.数据抽象的概念</h3>
<p>  将数据分开表示为如何表示数据的部分<span class="math inline">\(constructor\)</span>与如何操作数据的部分<span class="math inline">\(operator\)</span>的方法被称为<strong>数据抽象</strong>。</p>
<p>  数据抽象在概念上与函数抽象类似。当我们创建函数抽象时，函数实现的细节可以被抑制，特定函数本身可以被具有相同整体行为的任何其他函数替换。换句话说，我们可以<strong>制作一个抽象，将函数的使用方式与函数的实现细节分开</strong>。而数据抽象也将对<strong>复合数据的处理方式</strong>与<strong>对复合数据的构造方式</strong>分离开来。</p>
<p>  数据抽象的基本思想是组织程序，使它们能够在抽象的数据上运行。也就是说，我们的程序使用数据的方式应该尽可能少地对数据进行假设(即基本的操作步骤尽可能少)。同时将具体的数据表示定义为程序的一个独立部分。</p>
<p>  程序操作抽象数据的部分和定义数据表示的部分，由一小组函数连接起来，这些函数根据具体表示实现抽象数据。下举一例说明数据抽象流程的实现。</p>
<h3 id="2实例讲解对有理数操作的实现">2.实例讲解——对有理数操作的实现：</h3>
<p>  有理数的定义是两个整数的和。由于计算机的浮点数计算会降低运算精度，我们通过分数实现有理数的表示与运算。</p>
<h4 id="a通过假设实现operator">  <span class="math inline">\(a.\)</span>通过假设实现<span class="math inline">\(operator\)</span></h4>
<p>  通过先前的函数抽象，我们知道，在实现程序的某些部分之前，我们就可以有效地开始编程。让我们<strong>先假设我们已经有了一种方法，可以从分子和分母构造出一个有理数</strong>。我们还假设，<strong>给定一个有理数，我们有一种方法来选择它的分子和分母分量</strong>。我们<strong>进一步假设构造函数和选择函数可以作为以下三个函数使用:</strong></p>
<ul>
<li><code>ration(n,d)</code>：返回<span class="math inline">\(n\over
d\)</span>表示的有理数</li>
<li><code>numer(x)</code>：返回<span class="math inline">\(x\)</span>的分子</li>
<li><code>denom(x)</code>：返回<span class="math inline">\(x\)</span>的分母</li>
</ul>
<p>  在这里我们用到了程序设计的重要思想：<span class="math inline">\(wishful\;thinking\)</span>。我们并不知道这三个函数具体如何实现，但我们假设它们已经实现了，于是就可以通过假设实现加、减、乘、除等基本操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_rationals</span>(<span class="params">x, y</span>):</span><br><span class="line">    nx, dx = numer(x), denom(x)</span><br><span class="line">    ny, dy = numer(y), denom(y)</span><br><span class="line">    <span class="keyword">return</span> rational(nx * dy + ny * dx, dx * dy)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul_rationals</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> rational(numer(x) * numer(y), denom(x) * denom(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_rational</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(numer(x), <span class="string">&#x27;/&#x27;</span>, denom(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rationals_are_equal</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> numer(x) * denom(y) == numer(y) * denom(x)</span><br><span class="line"><span class="comment">#这是未约分后的，约分后结果除以gcd即可</span></span><br></pre></td></tr></table></figure>   现在我们实现了基于<span class="math inline">\(selector\)</span>变量与<span class="math inline">\(constructor\)</span>变量的<span class="math inline">\(operator\)</span>函数，剩下的任务就是具体实现我们的假设。</p>
<h4 id="bselector与constructor的实现">  <span class="math inline">\(b.\)</span><span class="math inline">\(selector\)</span>与<span class="math inline">\(constructor\)</span>的实现</h4>
<p>  我们利用<span class="math inline">\(python\)</span>自带的<span class="math inline">\(list\)</span>功能实现<span class="math inline">\(pair\)</span>的构建： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rational</span>(<span class="params">n, d</span>):</span><br><span class="line">    <span class="keyword">return</span> [n, d]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numer</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">denom</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>  这样，利用我们的数据抽象与基本操作，可以实现有理数的大多数操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>half = rational(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(half)</span><br><span class="line"><span class="number">1</span> / <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>third = rational(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(mul_rationals(half, third))</span><br><span class="line"><span class="number">1</span> / <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(add_rationals(third, third))</span><br><span class="line"><span class="number">6</span> / <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3抽象屏障">3.抽象屏障</h3>
<p>  一般来说，数据抽象的基本思想是<strong>确定一组基本的操作，以此来表示对某种值的所有操作，然后只使用这些操作来操作数据</strong>。通过以这种方式限制操作的使用，更容易在不改变程序行为的情况下改变抽象数据的表示。对有理数的基本操作如下：</p>
<p><img src="/2024/05/31/2.2.%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/image.png"></p>
<p>  在上面的每一层中，<strong>最后一列中的函数强制执行抽象屏障</strong>。这些函数<strong>由较高级别调用，并使用较低抽象级别实现</strong>。</p>
<p>  例如，实现有理数的平方和应如下书写： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square_rational</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> mul_rational(x, x)</span><br></pre></td></tr></table></figure></p>
<p>  抽象屏障使程序更容易维护和修改。<strong>依赖于特定表示形式的函数越少，想要更改该表示形式时所需的更改就越少</strong>。按照如上方式定义的平方和函数，在维护和修改时只需要调整<span class="math inline">\(mul\)</span>函数即可。</p>
<h3 id="4数据的属性">4.数据的属性</h3>
<p>  一般来说，我们可以使用一组选择器<span class="math inline">\(selector\)</span>和构造函数<span class="math inline">\(constructor\)</span>以及一些行为条件<span class="math inline">\(operator\)</span>来表示抽象数据。只要<strong>满足行为条件</strong>(如上面的除法属性)
，<strong>选择器和构造器就构成了一种数据的有效表示</strong>。抽象屏障之下的实现细节可能会改变，但<strong>如果行为没有改变，那么抽象化仍然有效</strong>，并且使用这个抽象化编写的任何程序都将保持正确。</p>
<p>  例如上述对有理数的操作，我们并没有说明什么是<span class="math inline">\(pair\)</span>，只是说该数据提供了用两个元素创建和操作列表的方法。我们需要实现一对的行为是将两个值粘合在一起，并且能够分别调用两值中的任意一个。我们也可以用如下函数实现这个操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pair</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a function that represents a pair.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">index</span>):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> y</span><br><span class="line">        <span class="keyword">return</span> get</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">p, i</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the element at index i of pair p.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> p(i)</span><br><span class="line"></span><br><span class="line">p = pair(<span class="number">20</span>, <span class="number">14</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select(p, <span class="number">0</span>)</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>  由此可以看出，我们对数据的抽象化有很多种表示方式，我们可以在多种表达方式中自由切换。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>2.5.数组型链表</title>
    <url>/2024/05/31/2.5.ALists/</url>
    <content><![CDATA[<h1 id="25数组型链表"><span class="math inline">\(2.5\)</span>数组型链表</h1>
<h3 id="1数组型链表的引入与搭建">1.数组型链表的引入与搭建</h3>
<p>  在<span class="math inline">\(SLList\)</span>与<span class="math inline">\(DLList\)</span>中，我们可以轻易地实现<code>getFirst</code>和<code>getLast</code>，但只能用线性的时间复杂度实现<code>get(int index)</code>。而数组可以实现常数时间复杂度的访问(参考<span class="math inline">\(cs61a\)</span>的懒惰计算)。</p>
<p>  可以初步搭建出以下的<span class="math inline">\(AList\)</span>框架： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AList &#123;</span><br><span class="line">        items = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这一实现遵循了以下不变量：</p>
<ul>
<li>下一个插入元素的插入位置一直是<span class="math inline">\(size\)</span>。</li>
<li><span class="math inline">\(AList\)</span>中的元素数量永远是<span class="math inline">\(size\)</span>。</li>
<li>最后一个元素的位置永远是<span class="math inline">\(size-1\)</span>。</li>
</ul>
<h3 id="2对链表的思考">2.对链表的思考</h3>
<p>  在实现<code>removeLast</code>操作时，我们先明确一个重要的发现：在我们实现某个方法时，对链表的任何改变都应该导致一个或多个内存盒子(<span class="math inline">\(memory\;box\)</span>)的改变。</p>
<p>  链表是一个抽象的概念用户使用我们提供的抽象(<code>addLast</code>，<code>removeLast</code>)来对列表进行的任何更改，而我们必须将这些更改以符合用户期望的方式反映在这些内存盒子中。中间的过程并不重要，我们只需要让数组型链表的行为与用户所设想的相一致就好了。</p>
<p>  而<span class="math inline">\(size\)</span>，<span class="math inline">\(items\)</span>，<span class="math inline">\(items[i]\)</span>的内存盒子(<span class="math inline">\(memory\;boxes\)</span>)是这个概念的具体表示，是我们已经设计好的事实。我们的目标就是通过操作这些具体的表示形式，来实现用户想要的模型。</p>
<h3 id="3removelast的实现">3.<code>removeLast</code>的实现</h3>
<p>  通过上面对链表的思考，我们可以只通过改变<span class="math inline">\(size\)</span>来实现<code>removeLast</code>：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> getLast();</span><br><span class="line">        size = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>  这种<code>removeLast</code>的实现是基于<span class="math inline">\(AList\)</span>的不变量的。只要我们改变<span class="math inline">\(Size\)</span>，那么下一个元素插入的位置就一定是<span class="math inline">\(size\)</span>，不管<span class="math inline">\(size\)</span>这个位置有没有元素，而最后一个元素的位置是<span class="math inline">\(size-1\)</span>，用户并不能去访问<span class="math inline">\(size\)</span>这个位置。因此可以通过这个手段实现元素的删除。至于<span class="math inline">\(size\)</span>位置的元素，我们想把它改为几都可以。</p>
<p>  不过，与<span class="math inline">\(int\)</span>型的链表不同，当我们链表的存储类型为<span class="math inline">\(generic\)</span>时，我们会将<span class="math inline">\(size\)</span>位置的元素置为<code>null</code>，因为如果对<span class="math inline">\(size\)</span>位置的元素置之不理的话，这个元素就会一直占用内存，导致内存的浪费。而设为<code>null</code>后，由于对它的引用丢失了，<span class="math inline">\(Java\)</span>会在内存中删掉它。</p>
<h3 id="4数组大小的调整">4.数组大小的调整</h3>
<p>  在<span class="math inline">\(Java\)</span>中，数组必须有固定的大小，因此在数组容量不够时，我们需要调整数组的大小(<span class="math inline">\(resize\)</span>)。</p>
<p>  实现调整数组的办法很简单：创建一个具有所需大小的数组，然后把原数组的元素复制过来，最后返回这个新数组即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[size + <span class="number">1</span>];</span><br><span class="line">System.arraycopy(items, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">a[size] = <span class="number">11</span>;</span><br><span class="line">items = a;</span><br><span class="line">size = size + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>  但是，这种在需要扩容时增加一部分的做法过于缓慢。例如我们每次扩容<span class="math inline">\(1\)</span>，则当数组扩容到<span class="math inline">\(n\)</span>时，由于每次扩容都要先创建一个新的数组，一共创建了<span class="math inline">\(\sum_{i=1}^n i ={ {n(n+1)}\over
2}\)</span>个单位大小的数组，时间复杂度为<span class="math inline">\(O(n^2)\)</span>，这样的效率十分低。</p>
<p>  因此，我们一般不采用上面的扩容方式，而是在需要扩容的时候适当地多扩大一些，以减少创建数组的次数。一般的做法如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBack</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">           resize(size * RFACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5内存使用率">5.内存使用率</h3>
<p>  数组中的实际元素个数与数组大小之比的数值是内存利用率。下面的数组的内存使用率为<span class="math inline">\(0.04\)</span>：</p>
<p><img src="/2024/05/31/2.5.ALists/image-14.png"></p>
<p>  当数组的内存使用率较低的时候，我们可以考虑<code>resize(size \ 2)</code>，缩小数组空间来节约内存。这种做法被称为以空间换时间。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>2.List</category>
      </categories>
  </entry>
  <entry>
    <title>2.3.序列</title>
    <url>/2024/05/31/2.3.%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="23序列"><span class="math inline">\(2.3.\)</span>序列</h1>
<h3 id="1序列的概念">1.序列的概念</h3>
<p>  序列是一系列<strong>有序</strong>的值的<strong>集合</strong>。序列有很多种不同的表示形式，但它们都有以下共同的性质：</p>
<ul>
<li><strong>长度</strong>：序列都有有限的长度</li>
<li><strong>元素选择</strong>。序列的任意元素<strong>有一个小于其长度的索引元素</strong>，对于第一个元素从<span class="math inline">\(0\)</span>开始。</li>
</ul>
<h2 id="二-序列基础">二、序列基础</h2>
<h3 id="1lists的概念及操作">1.<span class="math inline">\(Lists\)</span>的概念及操作</h3>
<p>  <span class="math inline">\(list\)</span>是一个<strong>可以具有任意长度</strong>的序列。<span class="math inline">\(list\)</span>具有大量的内置行为，以及表示这些行为的特定语法。如下是几个<span class="math inline">\(list\)</span>的例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">digits=[<span class="number">1</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(digits)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits[<span class="number">3</span>]</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>   初始化<span class="math inline">\(list\)</span>、构造一个空<span class="math inline">\(list\)</span>的步骤如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = [[] <span class="keyword">for</span> i <span class="keyword">in</span> player_indices]<span class="comment">#初始化为空列表</span></span><br><span class="line">result = [[<span class="number">0</span> <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(n)-<span class="number">1</span>)] <span class="keyword">for</span> n <span class="keyword">in</span> times_per_player]<span class="comment">#初始化为0</span></span><br></pre></td></tr></table></figure>
  对于<span class="math inline">\(list\)</span>，加法和乘法与数学运算中不同，而是<strong>组合和复制序列本身</strong>。也就是说，运算符模块(和<code>+</code>运算符)中的<code>add</code>函数生成一个列表，该列表是所添加参数的串联。运算符中的<code>mul</code>函数(以及<code>*</code>运算符)可以获取一个列表和一个整数<span class="math inline">\(k\)</span>，以返回由原始列表的<span class="math inline">\(k\)</span>重复组成的列表。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>,<span class="number">7</span>] + digits * <span class="number">2</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
  同时，也可以在<span class="math inline">\(list\)</span>中嵌套<span class="math inline">\(list\)</span>，嵌套与访问的方式如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pairs=[[<span class="number">10</span>,<span class="number">20</span>],[<span class="number">30</span>,<span class="number">40</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs[<span class="number">1</span>]</span><br><span class="line">[<span class="number">30</span>,<span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2序列迭代">2.序列迭代</h3>
<p>  在许多情况下，我们希望<strong>对序列的元素进行迭代，并依次为每个元素执行一些计算</strong>。</p>
<h4 id="afor语句">  <span class="math inline">\(a.\)</span><span class="math inline">\(for\)</span>语句</h4>
<p>  <span class="math inline">\(for\)</span>语句的声明如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(for\)</span>语句的执行过程如下：</p>
<ol type="1">
<li><p>计算<span class="math inline">\(expression\)</span>，<span class="math inline">\(expression\)</span>必须产生一个可迭代的值。</p></li>
<li><p>对于可迭代值的每一个元素值执行：</p>
<ol type="1">
<li>将<code>&lt;name&gt;</code>绑定到当前框架中的值。</li>
<li>执行<code>&lt;suite&gt;</code>。</li>
</ol></li>
</ol>
<h4 id="brange语句">  <span class="math inline">\(b.\)</span><span class="math inline">\(range\)</span>语句</h4>
<p>  <span class="math inline">\(range\)</span>的声明如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>) <span class="comment"># Includes 1, but not 10</span></span><br></pre></td></tr></table></figure>   在<span class="math inline">\(list\)</span>中调用<span class="math inline">\(range\)</span>可返回<span class="math inline">\(range\)</span>范围内的<span class="math inline">\(list\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>,<span class="number">8</span>))</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>   如果<span class="math inline">\(range\)</span>函数只传了一个参数，那么就返回从<span class="math inline">\(0\)</span>到<span class="math inline">\(i-1\)</span>间的序列： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>   <span class="math inline">\(range\)</span>经常与<span class="math inline">\(for\)</span>结合，以达到迭代<span class="math inline">\(list\)</span>的一部分的目的。这里有一种特殊情况：当<code>&lt;name&gt;='_'</code>时，整个序列会被重复<span class="math inline">\(i\)</span>次： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Go Bears!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br></pre></td></tr></table></figure></p>
<h4 id="c序列解包">  <span class="math inline">\(c.\)</span>序列解包</h4>
<p>  当某个<span class="math inline">\(list\)</span>的内部仍然为<span class="math inline">\(list\)</span>，但内部的<span class="math inline">\(list\)</span>长度固定时，我们可以在调用<span class="math inline">\(for\)</span>循环时使用多个<code>&lt;name&gt;</code>，以打开内部的<span class="math inline">\(list\)</span>，读取其中元素。下举一例：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs=[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> pairs:</span><br><span class="line">    <span class="keyword">if</span>(x==y):</span><br><span class="line">        same_count+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>same_count</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>  这一操作与我们在将多个名称绑定到多个值的赋值语句中看到的模式相同。</p>
<h2 id="三-对序列的基本处理">三、对序列的基本处理</h2>
<h3 id="1列表解析listcomprehension">1.列表解析<span class="math inline">\(List\;Comprehension\)</span></h3>
<p>  有时我们要对序列中的所有元素执行一个统一的操作，并输出处理后的序列。这时我们可以用<strong>列表解析</strong>的方法：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#改变列表元素的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odds=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x+<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> odds]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将列表元素归到其他结构里面</span></span><br><span class="line">&gt;&gt;&gt;s=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;t=[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[[s[i]+t[i]]<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">&gt;&gt;&gt;[[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>   这里的<span class="math inline">\(for\)</span>并不是<span class="math inline">\(for\)</span>语句的一部分，而是列表解析的一部分。</p>
<p>  同时，我们也可以<strong>只解析序列符合要求的部分</strong>，即原序列的<strong>子集</strong>，下举一例：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> odds <span class="keyword">if</span> <span class="number">25</span> % x == <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure></p>
<p>  列表解析的一般形式为： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&lt;<span class="built_in">map</span> expression&gt; <span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;sequence expression&gt; <span class="keyword">if</span> &lt;<span class="built_in">filter</span> expression&gt;]</span><br></pre></td></tr></table></figure>
  当要表达不同分支时，可如下书写列表解析： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&lt;<span class="built_in">map</span> expression&gt; <span class="keyword">if</span> &lt;expression&gt; <span class="keyword">else</span> &lt;<span class="built_in">map</span> expression&gt; <span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;seq&gt;]</span><br></pre></td></tr></table></figure></p>
<h3 id="2数据合并">2.数据合并</h3>
<p>  数据合并，顾名思义，就是<strong>将序列中的所有数据最终合并成一个数据</strong>。常见的<span class="math inline">\(min\)</span>、<span class="math inline">\(max\)</span>、<span class="math inline">\(sum\)</span>函数都属于数据合并。</p>
<h3 id="3利用高阶函数抽象序列基本操作">3.利用高阶函数抽象序列基本操作</h3>
<p>  上述序列操作可通过高阶函数、以函数为参数的手段来抽象出更普适的模式：</p>
<ul>
<li><p>对序列全体元素的映射： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_to_all</span>(<span class="params">map_f,s</span>):</span><br><span class="line">    <span class="keyword">return</span> [map_f(i) <span class="keyword">for</span> i <span class="keyword">in</span> s]</span><br></pre></td></tr></table></figure></p></li>
<li><p>筛选元素： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">keep_if</span>(<span class="params">filter_f,s</span>):</span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> s <span class="keyword">if</span> filter_f(i)]</span><br></pre></td></tr></table></figure></p></li>
<li><p>数据合并： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reduce</span>(<span class="params">reduce_f,s,init</span>):</span><br><span class="line">    reduced=init</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        reduced=reduce_f(reduced,i)</span><br><span class="line">    <span class="keyword">return</span> reduced</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="4序列基本处理的应用">4.序列基本处理的应用</h3>
<p>  通过使用上述序列基本处理手段，我们可以利用序列处理很多问题。</p>
<p>  <span class="math inline">\(e.g.\)</span>求出<span class="math inline">\(1\sim 1000\)</span>内的所有完全数。</p>
<p>  <span class="math inline">\(solve\)</span>：先利用列表解析写出求某个数因数的函数：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>]+[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n) <span class="keyword">if</span> n%i==<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divisors(<span class="number">12</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>   求出所有因数后，我们将所有因数合并为<span class="math inline">\(sum\)</span>，继续利用列表解析筛选：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">perfect</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>]+[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1000</span>) <span class="keyword">if</span> <span class="built_in">sum</span>(div(i))==i]</span><br><span class="line">&gt;&gt;&gt;[<span class="number">6</span>, <span class="number">28</span>, <span class="number">496</span>]</span><br></pre></td></tr></table></figure></p>
<p>  同时我们的<span class="math inline">\(div\)</span>函数可以复用以解决以下问题：</p>
<p>  <span class="math inline">\(e.g.\)</span>给定矩形面积，求矩形的最小周长。</p>
<p>  <span class="math inline">\(solve\)</span>：矩形的边长只可能是<span class="math inline">\(div(area)\)</span>中的某个数，于是可写出如下程序：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">width</span>(<span class="params">area,hei</span>):</span><br><span class="line">    <span class="keyword">assert</span> area%hei==<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> area//hei</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perimeter</span>(<span class="params">hei,width</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*hei+<span class="number">2</span>*width</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">min_per</span>(<span class="params">area</span>):</span><br><span class="line">    hei=div(area):</span><br><span class="line">    per=[perimeter(h,width(area,h)) <span class="keyword">for</span> h <span class="keyword">in</span> hei]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(per)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>area=<span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>width(area,<span class="number">5</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>perimeter(<span class="number">10</span>, <span class="number">8</span>)</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min_per(area)</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[minimum_perimeter(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">12</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure></p>
<p>  这些操作并不是一定需要序列来实现，但是序列上述基本操作的存在极大地降低了实现的难度。<strong>将问题序列化</strong>不失为一种解题策略。</p>
<h2 id="四-序列抽象">四、序列抽象</h2>
<p>  序列抽象分为以下部分(前两点前文已提及)：</p>
<h3 id="1序列长度">1.序列长度</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(digits)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="2序列选择">2.序列选择</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits[<span class="number">3</span>]</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="3判断是否为序列成员">3.判断是否为序列成员</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="keyword">in</span> digits</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1828</span> <span class="keyword">not</span> <span class="keyword">in</span> digits</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="4剪切序列片段">4.剪切序列片段</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits[<span class="number">1</span>:]</span><br><span class="line">[<span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<h2 id="五-string">五、<span class="math inline">\(string\)</span></h2>
<h2 id="六-trees">六、<span class="math inline">\(Trees\)</span></h2>
<h3 id="1引入闭包性质">1.引入——闭包性质</h3>
<p>  在<span class="math inline">\(list\)</span>中，我们可以使用<span class="math inline">\(list\)</span>作为<span class="math inline">\(list\)</span>的元素，这种数据的组合方式被称为<strong>数据的闭包性质</strong>。</p>
<p>  在任何组合方式中，闭包性质都是组合的关键，因为<strong>它允许我们创造一种组合方式的等级结构</strong>——一种组合由与它相同的子组合构成，而子组合又由更小的子组合构成...如下即为<span class="math inline">\(list\)</span>的等级结构示意图： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">one_two = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    nested = [[<span class="number">1</span>, <span class="number">2</span>], [],</span><br><span class="line">    [[<span class="number">3</span>, <span class="literal">False</span>, <span class="literal">None</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="keyword">lambda</span>: <span class="number">5</span>]]]</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/2.3.%E5%BA%8F%E5%88%97/image-1.png"></p>
<p>  这种嵌套结构会引入复杂性，让我们能更好地处理复杂的数据。<span class="math inline">\(Trees\)</span>和之后的数据结构都是这样的嵌套结构</p>
<h3 id="2树的概念">2.树的概念</h3>
<p>  树是由树根与树枝序列组成的。树的每根树枝也是一棵树。没有树枝的节点被称为叶子结点。每棵树的树根被称作根节点。</p>
<h3 id="3树的代码实现">3.树的代码实现</h3>
<h4 id="a树的相关概念的实现">  <span class="math inline">\(a.\)</span>树的相关概念的实现</h4>
<p>  树这种数据抽象形式的实现由<span class="math inline">\(constructor\)</span><code>tree</code>与<span class="math inline">\(selector\)</span><code>branches，root</code>构成：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">root_label,branches=[]</span>):<span class="comment">#将branches强制转化为list结构</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch),<span class="string">&#x27;branches must be trees&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [root_label]+<span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">branches</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_tree</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(tree)!=<span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(tree)&lt;<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(tree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> branches(tree)</span><br></pre></td></tr></table></figure></p>
<p>  树可以由嵌套表达式构造，如下所示： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = tree(<span class="number">3</span>, [tree(<span class="number">1</span>), tree(<span class="number">2</span>, [tree(<span class="number">1</span>), tree(<span class="number">1</span>)])])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">[<span class="number">3</span>, [<span class="number">1</span>], [<span class="number">2</span>, [<span class="number">1</span>], [<span class="number">1</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label(t)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>branches(t)</span><br><span class="line">[[<span class="number">1</span>], [<span class="number">2</span>, [<span class="number">1</span>], [<span class="number">1</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label(branches(t)[<span class="number">1</span>])</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_leaf(t)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_leaf(branches(t)[<span class="number">0</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h4 id="b树形递归的使用">  <span class="math inline">\(b.\)</span>树形递归的使用</h4>
<p>  由于树本身的层次性，利用树形递归也可得出树的一些性质。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_leaves</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        branches_count=[count_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(branch_counts)</span><br></pre></td></tr></table></figure>   可以发现我们对树结构的处理是在<span class="math inline">\(list\)</span>的层面上处理，当我们需要读取具体的结果时才利用数据合并的操作<span class="math inline">\(return\)</span>一个整数。</p>
<h4 id="c限制树的树枝数">  <span class="math inline">\(c.\)</span>限制树的树枝数</h4>
<p>  为限制树的树枝数，以构建二叉树为例，当树枝长度超过<span class="math inline">\(2\)</span>时，我们就<strong>将树的第一个元素保持不变，而将其余元素作为右分支的子树。</strong>即可：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">right_binarize</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">        <span class="keyword">return</span> tree</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tree)&gt;<span class="number">2</span>:</span><br><span class="line">        tree=[tree[<span class="number">0</span>],tree[<span class="number">1</span>:]]</span><br><span class="line">    <span class="keyword">return</span> [right_binarize(b) <span class="keyword">for</span> b <span class="keyword">in</span> tree]</span><br></pre></td></tr></table></figure>
  注意该函数的目标是对整棵树进行右分支重建，因此是<code>for b in tree</code>。</p>
<h4 id="d树的列表化处理">  <span class="math inline">\(d.\)</span>树的列表化处理</h4>
<p>  当我们要对树的某一层节点执行一些操作时，可以考虑如下思路：</p>
<ol type="1">
<li>将所有节点装进一个<span class="math inline">\(list\)</span>中</li>
<li>利用序列操作对<span class="math inline">\(list\)</span>进行处理</li>
<li>将<span class="math inline">\(list\)</span>回带到树上</li>
</ol>
<p>  这种<strong>将一种序列类型转化为其他类型的序列</strong>从而简化操作的方法值得学习。</p>
<p>  <span class="math inline">\(e.g.\)</span>Write a function
reverse_other that mutates the tree such that labels on every other
(odd-depth) level are reversed. For example, Tree(1,[Tree(2, [Tree(4)]),
Tree(3)]) becomes Tree(1,[Tree(3, [Tree(4)]), Tree(2)]). Notice that the
nodes themselves are not reversed; only the labels are.
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_other</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">t,index</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t.is_leaf():</span><br><span class="line">            <span class="keyword">if</span> index%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                treelist=[]</span><br><span class="line">                <span class="keyword">for</span> b <span class="keyword">in</span> t.branches:</span><br><span class="line">                    treelist.append(b.label)</span><br><span class="line">                treelist.reverse()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t.branches)):</span><br><span class="line">                    t.branches[i].label=treelist[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> t.branches:</span><br><span class="line">                helper(b,index+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    helper(t,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="3树的应用">3.树的应用</h3>
<p>  利用树形递归求解的问题都可以转化到树结构上。以之前的<span class="math inline">\(Fib\)</span>数列和数的分解为例：</p>
<h4 id="afib数列">  <span class="math inline">\(a.\)</span><span class="math inline">\(Fib\)</span>数列</h4>
<p>  <span class="math inline">\(Fib\)</span>数列的树结构搭建如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_tree</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left,right=fib_tree(n-<span class="number">1</span>),fib_tree(n-<span class="number">2</span>)</span><br><span class="line">        fib_n=label(left)+label(right)<span class="comment">#根节点为左右根节点的和</span></span><br><span class="line">        <span class="keyword">return</span> tree(fib_n,[left,right])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib_tree(<span class="number">5</span>)</span><br><span class="line">[<span class="number">5</span>, [<span class="number">2</span>, [<span class="number">1</span>], [<span class="number">1</span>, [<span class="number">0</span>], [<span class="number">1</span>]]], [<span class="number">3</span>, [<span class="number">1</span>, [<span class="number">0</span>], [<span class="number">1</span>]], [<span class="number">2</span>, [<span class="number">1</span>], [<span class="number">1</span>, [<span class="number">0</span>], [<span class="number">1</span>]]]]]</span><br></pre></td></tr></table></figure>   这样，每棵树的根节点就表示对应的<span class="math inline">\(Fib\)</span>数列的值了。</p>
<h4 id="b分解树">  <span class="math inline">\(b.\)</span>分解树</h4>
<p>  在先前的分解数字中，我们将数字分解分为两种情况：</p>
<ul>
<li>选一个<span class="math inline">\(m\)</span>，然后对<span class="math inline">\(n-m\)</span>执行相同操作</li>
<li>不选<span class="math inline">\(m\)</span>，此时序列中最大值变为<span class="math inline">\(m-1\)</span>，然后继续执行相同操作</li>
</ul>
<p>  这两种情况分别对应根节点的两个树枝：</p>
<ul>
<li>左树枝：所有至少用一个<span class="math inline">\(m\)</span>的分解<span class="math inline">\(n\)</span>的方法</li>
<li>右树枝：最大为<span class="math inline">\(m-1\)</span>的分解<span class="math inline">\(n\)</span>的方法</li>
<li>根节点：<span class="math inline">\(m\)</span></li>
</ul>
<p>  于是可以写出对应的树的构建： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition_tree</span>(<span class="params">n,m</span>):</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> n&lt;<span class="number">0</span> <span class="keyword">or</span> m&lt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left=partition_tree(n-m,m)</span><br><span class="line">        right=partition_tree(n,m-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> tree(m,[left,right])</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>partition_tree(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">[<span class="number">2</span>, [<span class="literal">True</span>], [<span class="number">1</span>, [<span class="number">1</span>, [<span class="literal">True</span>], [<span class="literal">False</span>]], [<span class="literal">False</span>]]]</span><br></pre></td></tr></table></figure></p>
<p>  若要打印该树，可以将树的根节点转化为<span class="math inline">\(string\)</span>类型，然后递归打印：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_parts</span>(<span class="params">tree,partition=[]</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">        <span class="keyword">if</span> label(tree):<span class="comment">#如果不是空节点</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>.join(partition))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left,right=branches(tree)//序列解包</span><br><span class="line">        m=<span class="built_in">str</span>(label(tree))</span><br><span class="line">        print_parts(left,partition+m)</span><br><span class="line">        print_parts(right,partition+m)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_parts(partition_tree(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"><span class="number">4</span> + <span class="number">2</span></span><br><span class="line"><span class="number">4</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">3</span> + <span class="number">3</span></span><br><span class="line"><span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"><span class="number">3</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">2</span> + <span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="number">2</span> + <span class="number">2</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">2</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="七-linkedlists">七、<span class="math inline">\(Linked\;lists\)</span></h2>
<h3 id="1链表的概念">1.链表的概念</h3>
<p>  如下所示的序列结构就是链表： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">four = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="string">&#x27;empty&#x27;</span>]]]]</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/2.3.%E5%BA%8F%E5%88%97/image-2.png"></p>
<p>  链表表示若干个<span class="math inline">\(pair\)</span>，第一个<span class="math inline">\(pair\)</span>包括第一个元素和一个子链表，以此类推；最后一个<span class="math inline">\(pair\)</span>包含最后一个元素和空链表<code>empty</code>。可以看出链表具有<strong>递归的结构</strong>。</p>
<h3 id="2链表的操作">2.链表的操作</h3>
<h4 id="a链表的基本元素">  <span class="math inline">\(a.\)</span>链表的基本元素</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">first</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rest</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="b链表的长度与元素访问">  <span class="math inline">\(b.\)</span>链表的长度与元素访问</h4>
<p>  作为序列的一种形式，序列抽象的操作在链表中亦可实现：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">len_link</span>(<span class="params">s</span>):</span><br><span class="line">    length=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> s!=empty:</span><br><span class="line">        s,length=rest(s),length+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getitem_link</span>(<span class="params">s,i</span>):</span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">        s,i=rest(s),i-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> first(s)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len_link(four)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getitem_link(four, <span class="number">1</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h4 id="c链表的序列基本操作">  <span class="math inline">\(c.\)</span>链表的“序列基本操作”</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extend_link</span>(<span class="params">s,t</span>):</span><br><span class="line">    <span class="comment">#Return a list with the elements of s followed by those of t.</span></span><br><span class="line">    <span class="keyword">assert</span> is_link(s) <span class="keyword">and</span> is_link(t)</span><br><span class="line">    <span class="keyword">if</span> s==empty:</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> link(first(s),extend_link(rest(s),t))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extend_link(four, four)</span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="string">&#x27;empty&#x27;</span>]]]]]]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_to_all_link</span>(<span class="params">f,s</span>):</span><br><span class="line">    <span class="keyword">assert</span> is_link(s)</span><br><span class="line">    <span class="keyword">if</span> s==empty:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> link(f(first(s)),apply_to_all_link(f,rest(s)))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apply_to_all_link(<span class="keyword">lambda</span> x: x*x, four)</span><br><span class="line">[<span class="number">1</span>, [<span class="number">4</span>, [<span class="number">9</span>, [<span class="number">16</span>, <span class="string">&#x27;empty&#x27;</span>]]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keep_if_link</span>(<span class="params">f,s</span>):</span><br><span class="line">    <span class="comment">#Return a list with elements of s for which f(e) is true.</span></span><br><span class="line">    <span class="keyword">assert</span> is_link(s)</span><br><span class="line">    <span class="keyword">if</span> s==empty:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        kept=keep_if_link(f,rest(s))</span><br><span class="line">        <span class="keyword">if</span> f(first(s)):</span><br><span class="line">            <span class="keyword">return</span> link(first(s)+kept)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> kept</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keep_if_link(<span class="keyword">lambda</span> x: x%<span class="number">2</span> == <span class="number">0</span>, four)</span><br><span class="line">[<span class="number">2</span>, [<span class="number">4</span>, <span class="string">&#x27;empty&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">join_link</span>(<span class="params">s,separator</span>):</span><br><span class="line">    <span class="comment">#Return a string of all elements in s separated by separator.</span></span><br><span class="line">    <span class="keyword">if</span> s==empty:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> rest(s)==empty:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(first(s))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(first(s))+separator+join_link(rest(s),separator)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join_link(four, <span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="string">&#x27;1, 2, 3, 4&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="3链表的应用">3.链表的应用</h3>
<p>  链表在递增构造序列方面非常有用，因为链表允许动态添加元素、而不必一开始知道序列全部内容</p>
<p>  以先前的数的分解为例，可以用列表如下实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">n,m</span>):</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> link(empty,empty)</span><br><span class="line">    <span class="keyword">elif</span> n&lt;<span class="number">0</span> <span class="keyword">or</span> m&lt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> empty</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        using_m=partition(n-m,m)</span><br><span class="line">        with_m = apply_to_all_link(<span class="keyword">lambda</span> s: link(m, s), using_m)</span><br><span class="line">        <span class="comment"># creat a list that starts with m</span></span><br><span class="line">        without_m = partitions(n, m-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> extend_link(with_m, without_m)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>2.5.面向对象编程</title>
    <url>/2024/05/31/2.5.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="25面向对象编程"><span class="math inline">\(2.5\)</span>面向对象编程</h1>
<h2 id="一-面向对象编程概述">一、面向对象编程概述</h2>
<p>  在前文的讲述中，对象具有如下的特点：</p>
<ul>
<li>对象间<strong>可以建立抽象屏障</strong></li>
<li>对象<strong>具有无法被全局环境访问的局部状态</strong></li>
<li><span class="math inline">\(\cdots\)</span></li>
</ul>
<p>  <span class="math inline">\(Python\)</span>的对象系统可以利用面向对象编程(<span class="math inline">\(object-oriented\;programme\)</span>)语言来表述。</p>
<p>  对象系统为多个独立代理(<span class="math inline">\(agent\)</span>)在计算机内部的互动提供了新的隐喻方法。每个对象都将局部状态和行为通过抽象的方式进行绑定，从而将两者的复杂性进行抽象。对象间互相交流，而它们交流的结果得出了有用的结论。对象间<strong>不仅传递信息，而且和其它相同类型的对象共享行为、继承相同类型对象的特性</strong>。</p>
<h2 id="二-类class">二、类(<span class="math inline">\(class\)</span>)</h2>
<h3 id="1类的概念">1.类的概念</h3>
<p>  类是作为所有属于该类的对象的模版(<span class="math inline">\(template\)</span>)。每个对象都是类的一个实例(<span class="math inline">\(instance\)</span>)。</p>
<p>  类的声明具体说明了<strong>类的对象间共享的属性与方法</strong>。以之前的银行账户<span class="math inline">\(account\)</span>为例，可以如下声明一个类：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=Account(<span class="string">&#x27;Kirk&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="2类的子概念">2.类的子概念</h3>
<p>  类的属性(<span class="math inline">\(attribute\)</span>)是一个<strong>与对象相关联的“名字-值”对</strong>，通过“点标记”(<span class="math inline">\(dot-notation\)</span>)能访问类的属性。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.holder</span><br><span class="line"><span class="string">&#x27;Kirk&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.balance</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>   类的方法(<span class="math inline">\(method\)</span>)是<strong>作用于对象及其计算的函数</strong>。方法的返回值与副作用取决于对象的属性、并且能改变对象的一些属性。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.deposit(<span class="number">15</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3类的声明">3.类的声明</h3>
<h4 id="a初始化声明">  <span class="math inline">\(a.\)</span>初始化声明</h4>
<p>  一个声明类的语句有以下的结构： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>&lt;name&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></p>
<p>  一个类为了具体声明实例对象的属性，会<strong>内置一个初始化方法<code>__init__</code>，这称为类的构建(<span class="math inline">\(constructor\)</span>)</strong>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>  <span class="math inline">\(p.s.\)</span>在<span class="math inline">\(Python\)</span>中，方法名以双下划线 __
开头和结尾的形式被称为特殊方法(<span class="math inline">\(special\;methods)\)</span>。<code>__init__</code>是其中一种，它用于初始化对象的状态。当你创建一个新的实例时，<span class="math inline">\(Python\)</span>会自动调用这个方法来初始化对象的属性。</p>
</blockquote>
<p>  这里的参数<code>account_holder</code>是局部名称。但<strong>通过点标记，<code>account_holder</code>被绑定到了赋值语句上</strong>，因为此时<code>account_holder</code>作为<code>self</code>的属性被存储了。</p>
<p>  具体化<span class="math inline">\(Account\)</span>类后，我们就可以创建一个具体的类的实例：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Account(<span class="string">&#x27;Kirk&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>  这个对类的调用创建了一个新的<strong>对象</strong>，这个对象是类的一个<strong>实例(<span class="math inline">\(instance\)</span>)</strong>。<code>__init__</code>的第一个参数<code>self</code>与这个对象绑定了，传入的是第二个参数的值。这样之后我们就可以访问实例的属性了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.balance</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.holder</span><br><span class="line"><span class="string">&#x27;Kirk&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>  每个独立声明的类的实例都有自己的独特身份(<span class="math inline">\(identity\)</span>)，例如以下语句所展示的：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Account(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.balance = <span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[acc.balance <span class="keyword">for</span> acc <span class="keyword">in</span> (a, b)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">200</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> <span class="keyword">not</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h4 id="b方法的声明">  <span class="math inline">\(b.\)</span>方法的声明</h4>
<p>  在<code>class</code>语句内部使用<code>def</code>语句即可声明类的方法：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            self.balance = self.balance + amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">if</span> amount &gt; self.balance:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">            self.balance = self.balance - amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br></pre></td></tr></table></figure></p>
<p>  虽然方法的定义与普通函数的定义没有差别，但它们执行后产生的影响却不一样。在<code>class</code>语句下定义的<code>def</code>语句<strong>作为属性在类中局部绑定</strong>。例如下面对<span class="math inline">\(Account\)</span>方法的调用： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account = Account(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.deposit(<span class="number">100</span>)</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.withdraw(<span class="number">90</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.withdraw(<span class="number">90</span>)</span><br><span class="line"><span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.holder</span><br><span class="line"><span class="string">&#x27;Spock&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>  每个方法的<strong>第一个参数都是<code>self</code>，表示调用该方法的对象</strong>。当一个方法通过点标记被调用后，对象执行了两个功能：</p>
<ul>
<li><strong>决定对应的方法具体是什么</strong>。例如示例中的<code>withdraw</code>，这里的<code>withdraw</code>是类中的局部名称。</li>
<li><strong>作为方法的特殊参数</strong>。</li>
</ul>
<h2 id="三-信息传递与点表达式">三、信息传递与点表达式</h2>
<h3 id="1类中的信息传递模式">1.类中的信息传递模式</h3>
<p>  在类中，对象通过点标记接受信息，但这些信息不再是分派字典中的字符串<code>key</code>了，而是类局部下的名称。同时类也有局部状态的值，我们可以运用点标记来访问与操作它们、而不需要<code>nonlocal</code>语句。</p>
<h3 id="2类的属性的实现">2.类的属性的实现</h3>
<p>  类的属性可以通过简单的赋值语句实现，例如下面对<span class="math inline">\(Account\)</span>类的<code>interest</code>属性的赋值：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        interest = <span class="number">0.02</span>            <span class="comment"># A class attribute</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="comment"># Additional methods would be defined here</span></span><br></pre></td></tr></table></figure></p>
<p>  这个属性可以<strong>被所有该类的实例获取</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account = Account(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account = Account(<span class="string">&#x27;Kirk&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.02</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.02</span></span><br></pre></td></tr></table></figure></p>
<p>  同样地，<strong>当类的属性被改变了，所有该类的实例的这一属性都会改变</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.interest = <span class="number">0.04</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2点表达式">2.点表达式</h3>
<p>  点表达式是形如以下的语句： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;expression&gt;.&lt;name&gt;</span><br></pre></td></tr></table></figure>
  一个点表达式通过一个对象和一个属性的名字(通过<code>&lt;expression&gt;</code>表达式得出)来访问对象的属性、并返回该属性的值。</p>
<p>  同时，通过内置函数<code>getattr</code>也可用字符串访问对象的属性，像分派字典里的那样：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(spock_account, <span class="string">&#x27;balance&#x27;</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>  <code>getattr</code>函数还可以测试对象中有无某种属性：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(spock_account, <span class="string">&#x27;deposit&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3方法与函数的差异">3.方法与函数的差异</h3>
<p>  当某个对象调用了一个方法时，这个对象会直接作为该方法第一个特殊参数。这样方法的特殊参数<code>self</code>与对象就得到了绑定。</p>
<p>  为了实现这种自动绑定，<span class="math inline">\(python\)</span>对方法与函数进行了区分。利用<code>type</code>函数运行如下程序：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(spock_account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;method&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="四-类的属性">四、类的属性</h2>
<h3 id="1类的属性的概念">1.类的属性的概念</h3>
<p>  有的类中的属性会被所有属于该类的对象共享，这种属性是与类直接连接的、并不是与某个单独的类的实例相连。</p>
<h3 id="3类的属性的访问">3.类的属性的访问</h3>
<p>  类的属性的访问也可通过点表达式实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;expression&gt;.&lt;name&gt;</span><br></pre></td></tr></table></figure></p>
<p>  访问类的属性遵循以下过程：</p>
<ul>
<li>计算<code>&lt;expression&gt;</code>，然后得到对应的对象。</li>
<li><code>&lt;name&gt;</code>随后对应到该对象的属性，如果该对象对应属性存在，就返回该属性。</li>
<li>如果不存在，<code>&lt;name&gt;</code>就会去类中寻找对应属性，并读取对应属性。</li>
<li>如果这个属性是方法，就返回对应函数；否则返回对应值。</li>
</ul>
<p>  在这一流程中，实例自己的属性先于类的属性被查找，这与局部环境对全局环境具有优先级相类似</p>
<h3 id="4类的属性的赋值规则">4.类的属性的赋值规则</h3>
<p>  在类的赋值语句中，如果对象是类的话，赋值语句就会设置一个类的属性；如果对象是实例的话，赋值语句就会设置一个实例的属性。<strong>对实例属性的改变不会影响类的属性</strong>。</p>
<p>  下面的例子中，我们对实例的属性重新赋值： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest = <span class="number">0.08</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.08</span></span><br></pre></td></tr></table></figure>
  但是，类的属性依然不变： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br></pre></td></tr></table></figure></p>
<p>  <strong>改变类的属性后，该实例的属性也不会被影响</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.interest = <span class="number">0.05</span>  <span class="comment"># changing the class attribute</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest     <span class="comment"># changes instances without like-named instance attributes</span></span><br><span class="line"><span class="number">0.05</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest     <span class="comment"># but the existing instance attribute is unaffected</span></span><br><span class="line"><span class="number">0.08</span></span><br></pre></td></tr></table></figure></p>
<h2 id="五-继承">五、继承</h2>
<h3 id="1继承的概念">1.继承的概念</h3>
<p>  在面向对象的编程中，两个类可能有相似的属性，但一个是另一个的特殊例子。例如，我们想实现一个跟先前的<span class="math inline">\(Account\)</span>不同的<span class="math inline">\(CheckingAccount\)</span>，该类的特殊如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch = CheckingAccount(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.interest     <span class="comment"># Lower interest rate for checking accounts</span></span><br><span class="line"><span class="number">0.01</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.deposit(<span class="number">20</span>)  <span class="comment"># Deposits are the same</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.withdraw(<span class="number">5</span>)  <span class="comment"># withdrawals decrease balance by an extra charge</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(CheckingAccount\)</span>是<span class="math inline">\(Account\)</span>的特殊化。在<span class="math inline">\(OOP\)</span>术语中，<strong>普遍的类<span class="math inline">\(Account\)</span>是<span class="math inline">\(CheckingAccount\)</span>的基准类，而<span class="math inline">\(CheckingAccount\)</span>是<span class="math inline">\(Account\)</span>的子类</strong>。</p>
<p>  子类<strong>会继承基准类的属性，但会覆盖原有的一些属性，包括一些方法</strong>。在继承中，我们只具体说明子类与基准类的差别，剩余的就默认与基准类一致。</p>
<p>  继承在我们的对象隐喻中也有着重要作用，它<strong>揭示了对象间的<code>is-a</code>关系</strong>。例如<span class="math inline">\(CheckingAccount\)</span><code>is-a</code><span class="math inline">\(Account\)</span>的一种特殊形式，那么继承的操作就顺理成章了。而如果两者只是单纯的<code>has-a</code>关系，那么两者不应有继承关系。</p>
<h3 id="2继承操作的实现">2.继承操作的实现</h3>
<p>  首先我们给出基准类的实现作为基础： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A bank account that has a non-negative balance.&quot;&quot;&quot;</span></span><br><span class="line">        interest = <span class="number">0.02</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Increase the account balance by amount and return the new balance.&quot;&quot;&quot;</span></span><br><span class="line">            self.balance = self.balance + amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Decrease the account balance by amount and return the new balance.&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> amount &gt; self.balance:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">            self.balance = self.balance - amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br></pre></td></tr></table></figure></p>
<p>  相应地对<span class="math inline">\(CheckingAccount\)</span>的实现如下，我们通过<code>&lt;name&gt; + &lt;value&gt;/def</code>的形式定义<span class="math inline">\(CheckingAccount\)</span>独有的属性：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">CheckingAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A bank account that charges for withdrawals.&quot;&quot;&quot;</span></span><br><span class="line">        withdraw_charge = <span class="number">1</span></span><br><span class="line">        interest = <span class="number">0.01</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">return</span> Account.withdraw(self, amount + self.withdraw_charge)</span><br></pre></td></tr></table></figure></p>
<p>  下面是该子类对应属性的输出结果： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking = CheckingAccount(<span class="string">&#x27;Sam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.deposit(<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.withdraw(<span class="number">5</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.interest</span><br><span class="line"><span class="number">0.01</span></span><br></pre></td></tr></table></figure></p>
<p>  这里，我们还可以得出在子类中查找<code>&lt;name&gt;</code>的流程： *
如果这个名称<strong>在子类中，就输出对应属性的值</strong>。 *
否则，<strong>在基准类中找这个名称</strong>。</p>
<p>  例如该例中的<code>deposit</code>属性，由于只在基准类中得到定义，因此子类属性的执行与基准类属性的执行相一致。</p>
<p>  <strong>即使子类覆盖了基准类的属性，子类依然可以访问基准类的属性。</strong>例如实现子类的<code>withdraw</code>函数的过程中调用了基准类的<code>withdraw</code>。</p>
<p>  注意到我们调用的是<code>self.withdraw_charge</code>而非<code>CheckingAccount.withdraw_charge</code>，因为我们无法确定此时的<code>self</code>一定是<code>CheckingAccount</code>，这样确保了万无一失。</p>
<h3 id="3接口">3.接口</h3>
<p>  一个对象接口(<span class="math inline">\(object\;interface\)</span>)是<strong>一些被共享的属性的集合</strong>。例如，对于所有的<code>account</code>，都会有<code>deposit</code>与<code>withdraw</code>方法和<code>balance</code>属性。<span class="math inline">\(Account\)</span>类和<span class="math inline">\(CheckingAccount\)</span>类都实现了这一接口。而继承通过这一方式促进了名称的共享。</p>
<h2 id="六-多重继承">六、多重继承</h2>
<h3 id="1多重继承的概念与实现">1.多重继承的概念与实现</h3>
<p>  <span class="math inline">\(python\)</span>支持一个继承不同基准类的子类的实现。</p>
<p>  假设我们已知一个继承<span class="math inline">\(Account\)</span>的<span class="math inline">\(SavingAccount\)</span>，它会在每次<code>deposit</code>时收取一定费用：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">SavingsAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">        deposit_charge = <span class="number">2</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">return</span> Account.deposit(self, amount - self.deposit_charge)</span><br></pre></td></tr></table></figure>   这是，如果我们要实现一个基于<span class="math inline">\(SavingAccount\)</span>与<span class="math inline">\(CheckingAccount\)</span>的新<code>account</code><span class="math inline">\(AsSeenOnTVAccount\)</span>，它同时实现<code>check</code>与<code>save</code>功能，那么我们可以通过<strong>继承两个类</strong>来实现这一个类：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">AsSeenOnTVAccount</span>(CheckingAccount, SavingsAccount):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">            self.balance = <span class="number">1</span>           <span class="comment"># A free dollar!</span></span><br></pre></td></tr></table></figure>
  这样，只需要初始化，该子类的其它部分可借助继承的类来实现：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal = AsSeenOnTVAccount(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.balance</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.deposit(<span class="number">20</span>)            <span class="comment"># $2 fee from SavingsAccount.deposit</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.withdraw(<span class="number">5</span>)            <span class="comment"># $1 fee from CheckingAccount.withdraw</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.deposit_charge</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.withdraw_charge</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2多重继承的顺序结构">2.多重继承的顺序结构</h3>
<p>  在多重继承中，假如某个名为<code>&lt;name&gt;</code>的属性在两个继承类中都有，程序抉择的顺序结构如下：</p>
<p><img src="/2024/05/31/2.5.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-4.png"></p>
<p>  对于这种“钻石型”的继承结构，<span class="math inline">\(python\)</span>会采用“<strong>从下往上、从左往右</strong>”的查找顺序，在各个类中查找该属性，直到找到为止。</p>
<h2 id="七-对对象的总结">七、对对象的总结</h2>
<p>  像这节介绍的类、方法、继承、点表达式等特殊语法，让我们能够更好地形象化我们对程序的隐喻。</p>
<p>  在编写程序时，我们希望我们的对象系统推动程序的不同方面关注不同的问题。每个对象封装、解决问题的一个状态，并且每个类的声明实现程序总体逻辑的一部分。而抽象屏障让问题的不同方面的界限更加的鲜明。</p>
<p>  面向对象编程很好地契合了分为独立的模块化系统、每个系统互相交互的程序设计需求。例如我们对社交网络等生活中事物的模拟，当我们想在程序中实现这些模型时，我们可以把<strong>系统中的对象模块化为程序中的对象，同时用类表明它们的类别与联系</strong>。</p>
<p>  同时，对象并不是唯一的实现抽象的方式。<strong>对于输入输出式的抽象，函数抽象显得更为自然</strong>。认识到什么时候该用对象抽象的方式、什么时候该用函数抽象的方式，是编程中关键的问题。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>2.4.可变数据</title>
    <url>/2024/05/31/2.4.%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="24可变数据"><span class="math inline">\(2.4\)</span>可变数据</h1>
<p>  在模块化程序设计中的一个重要技术是<strong>合并随时间变化的数据</strong>，这样，合并后的数据就可以表示一个独立的对象、不被程序的其他部分限制。<strong>将状态加入数据中</strong>是“面向对象编程”的核心要素。</p>
<h2 id="一-对象objection及其相关概念">一、对象(<span class="math inline">\(objection\)</span>)及其相关概念</h2>
<p>  对象包含<strong>数据的值(<span class="math inline">\(value\)</span>)与数据行为(<span class="math inline">\(behaviour\)</span>)</strong>。</p>
<p>  以<span class="math inline">\(python\)</span>库中的<code>date</code>为例：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br></pre></td></tr></table></figure>
  在这里，<code>date</code>函数与<code>class</code>被绑定在一起。<code>class</code>是一类数值的总称，单独的<code>date</code>是<code>class</code>中的一个例子。</p>
<p>  我们可以如下对<code>date</code>赋值与对<code>date</code>进行运算，像普通数据一样：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues = date(<span class="number">2014</span>, <span class="number">5</span>, <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(date(<span class="number">2014</span>, <span class="number">5</span>, <span class="number">19</span>) - tues)</span><br><span class="line"><span class="number">6</span> days, <span class="number">0</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure></p>
<p>  同时，对象具有<strong>属性</strong>(attribute)，属性即是<strong>对象不同部分的数值</strong>。可以通过如下方式访问其属性：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;expression&gt;.&lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues.year</span><br><span class="line"><span class="number">2014</span></span><br></pre></td></tr></table></figure></p>
<p>  对象还具有<strong>方法</strong>(method)，方法就是<strong>一个内置的函数</strong>，当调用方法时，<strong>对象会自己执行、输出对应的结果</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues.strftime(<span class="string">&#x27;%A, %B %d&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Tuesday, May 13&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>  不仅<code>data</code>，<span class="math inline">\(python\)</span>中的其他值(如<code>string,numbers...</code>)都是对象，因为他们都有<strong>属性和对应的行为</strong>。</p>
<h2 id="三-序列对象">三、序列对象</h2>
<h3 id="1可改变对象">1.可改变对象</h3>
<h4 id="a概念与性质">  <span class="math inline">\(a.\)</span>概念与性质</h4>
<p>  <strong>可改变对象</strong>(<span class="math inline">\(mutable\;objects\)</span>)用于<strong>表示随时间变化的量</strong>。例如，我们可以改变<span class="math inline">\(list\)</span>内的内容，利用<span class="math inline">\(list\)</span>自带的方法。而<span class="math inline">\(number\)</span>是不可改变对象。</p>
<p>  下面这个例子展示了<span class="math inline">\(list\)</span>的可改变性： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chinese = [<span class="string">&#x27;coin&#x27;</span>, <span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;myriad&#x27;</span>]</span><br><span class="line">suits = chinese</span><br><span class="line">suits.pop()</span><br><span class="line">suits.remove(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">suits.append(<span class="string">&#x27;cup&#x27;</span>)</span><br><span class="line">suits.extend([<span class="string">&#x27;sword&#x27;</span>, <span class="string">&#x27;club&#x27;</span>])</span><br><span class="line">suits[<span class="number">2</span>] = <span class="string">&#x27;spade&#x27;</span></span><br><span class="line">suits[<span class="number">0</span>:<span class="number">2</span>] = [<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese  <span class="comment"># This name co-refers with &quot;suits&quot; to the same changing list</span></span><br><span class="line">[<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>]</span><br></pre></td></tr></table></figure>
  由于我们一直在改变一个<span class="math inline">\(list\)</span>而非创造一个新<span class="math inline">\(list\)</span>，与原<span class="math inline">\(list\)</span>绑定的<code>chinese</code>也随之改变，因为<strong>它们是同一个对象</strong>。因此，<strong>对于可改变对象，对某个名字(<span class="math inline">\(name\)</span>)使用的方法不改变另一个名字的值，当且仅当它们不共享同一个对象</strong>。</p>
<blockquote>
<p>  <span class="math inline">\(p.s.\)</span>这里的“共享”<strong>并不仅仅是相同</strong>，当一个变量的某一部分用可改变对象赋值时，改变可改变对象也会导致这一变量改变：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nest = <span class="built_in">list</span>(suits)  <span class="comment"># Bind &quot;nest&quot; to a second list with the same elements</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nest[<span class="number">0</span>] = suits     <span class="comment"># Create a nested list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits.insert(<span class="number">2</span>, <span class="string">&#x27;Joker&#x27;</span>)  <span class="comment"># Insert an element at index 2, shifting the rest</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nest</span><br><span class="line">[[<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;Joker&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>], <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>  需要注意，<strong>经过序列解析后得到的新序列不与先前序列共享一个对象</strong>。</p>
<h4 id="bis运算">  <span class="math inline">\(b.\)</span><span class="math inline">\(is\)</span>运算</h4>
<p>  由上述论证，我们定义表达式<span class="math inline">\(is\)</span>为<strong>两个名字是否同属一个对象</strong>，如下例：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">suits = [<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>]</span><br><span class="line">nest = <span class="built_in">list</span>(suits)</span><br><span class="line">nest[<span class="number">0</span>] = suits</span><br><span class="line">suits.insert(<span class="number">2</span>, <span class="string">&#x27;Joker&#x27;</span>)</span><br><span class="line">joke = nest[<span class="number">0</span>].pop(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits <span class="keyword">is</span> nest[<span class="number">0</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits <span class="keyword">is</span> [<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>]</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits == [<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>]</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>   此处的<span class="math inline">\(list\)</span>是新创建的<span class="math inline">\(list\)</span>,因此是新的对象。</p>
<h3 id="2元组与字典">2.元组与字典</h3>
<h4 id="a元组tuple">  <span class="math inline">\(a.\)</span>元组(<span class="math inline">\(Tuple\)</span>)</h4>
<p>  下面的几种序列形式都属于元组： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>, <span class="number">2</span> + <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&quot;the&quot;</span>, <span class="number">1</span>, (<span class="string">&quot;and&quot;</span>, <span class="string">&quot;only&quot;</span>))</span><br><span class="line">(<span class="string">&#x27;the&#x27;</span>, <span class="number">1</span>, (<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;only&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>( (<span class="number">10</span>, <span class="number">20</span>) )</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>  元组的查询操作如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>code = (<span class="string">&quot;up&quot;</span>, <span class="string">&quot;up&quot;</span>, <span class="string">&quot;down&quot;</span>, <span class="string">&quot;down&quot;</span>) + (<span class="string">&quot;left&quot;</span>, <span class="string">&quot;right&quot;</span>) * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(code)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code[<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;down&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code.count(<span class="string">&quot;down&quot;</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code.index(<span class="string">&quot;left&quot;</span>)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
  由于<strong>元组是不可改变对象，因此<span class="math inline">\(list\)</span>诸如<code>pop,insert</code>等方法对元组都不适用</strong>。</p>
<p>  虽然元组是不可改变对象，但当调用元组内部的可改变对象时，它依然是可改变的：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nest = (<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line">nest[<span class="number">2</span>].pop()</span><br></pre></td></tr></table></figure></p>
<h4 id="b字典dictionary">  <span class="math inline">\(b.\)</span>字典(<span class="math inline">\(dictionary\)</span>)</h4>
<p>  字典是一个<strong>储存键值对的容器</strong>。字典的作用是<strong>提供一种抽象，用于存储和检索那些不是通过连续整数而是通过描述性键进行索引的值</strong>。</p>
<p>  下面的几种序列形式都是字典： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numerals = &#123;<span class="string">&#x27;I&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>  字典的查询等操作如下，由于字典是可改变对象，可以对字典进行插入、删改等操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numerals[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numerals[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numerals[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numerals</span><br><span class="line">&#123;<span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>   需要注意，字典内元素有如下性质：</p>
<ul>
<li>字典的键<strong>不能是或包含可变的值</strong>。</li>
<li>对于给定的键，<strong>最多只能有一个值</strong>。</li>
</ul>
<p>  字典中的元素都可通过可迭代的对象属性<code>keys</code>、<code>values</code>、<code>items</code>来访问，并可用<span class="math inline">\(sum\)</span>等函数进行数据合并：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(numerals.values())</span><br><span class="line"><span class="number">66</span></span><br></pre></td></tr></table></figure></p>
<p>  一系列键值对可以直接转化为字典类型： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="number">3</span>, <span class="number">9</span>), (<span class="number">4</span>, <span class="number">16</span>), (<span class="number">5</span>, <span class="number">25</span>)])</span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure>
  字典也有类似列表解析的操作： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四-局部状态localstate">四、局部状态(<span class="math inline">\(local\;state\)</span>)</h2>
<h3 id="1局部状态的概念">1.局部状态的概念</h3>
<p>  列表与字典等可改变对象具有的这种性质被称为<strong>局部状态</strong>：在程序的执行过程中，它们的一些特定的内容会发生改变。“状态”一词说明对象的状态会在包含它的过程中发生改变。</p>
<p>  函数也具有局部状态。我们假设一个函数<code>withdraw</code>来模拟从银行取钱的过程。假设我们的银行账户有<span class="math inline">\(100\)</span>元，我们希望通过引用<code>withdraw</code>得到下列序列：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>withdraw(<span class="number">25</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>withdraw(<span class="number">25</span>)</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>withdraw(<span class="number">60</span>)</span><br><span class="line"><span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>withdraw(<span class="number">15</span>)</span><br><span class="line"><span class="number">35</span></span><br></pre></td></tr></table></figure>
  表达式<code>withdraw</code>被调用两次，返回不同的结果，因此这个函数是非纯函数：引用该函数不仅返回一个值、还对函数本身有副作用。</p>
<p>  为了实现<code>withdraw</code>，它还需创建一个初始的银行账户，我们用高阶函数<code>make_withdraw</code>来实现这一功能，让<code>withdraw</code>作为返回的函数：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_withdraw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span>(amount&gt;balance):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Not enough&#x27;</span></span><br><span class="line">        balance=balance-amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd=make_withdraw(<span class="number">20</span>)</span><br><span class="line">wd(<span class="number">5</span>)</span><br><span class="line">wd(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>   对该函数的框架分析如下：</p>
<ul>
<li>第一个定义的函数将<code>make_withdraw</code>与全局框架绑定。</li>
<li>第二个定义的函数是局部定义的，将<code>withdraw</code>与局部框架绑定。</li>
<li>每次调用<code>wd</code>，都会<strong>创造出一个新的局部框架</strong>。</li>
</ul>
<p>  而对于<code>balance</code>,在执行<code>nonlocal</code>语句后，<strong>任何<code>balance</code>在左侧的赋值语句都不会将<code>balance</code>与当前框架绑定。相反地，它会去寻找<code>balance</code>已经被定义的框架，并把<code>balance</code>与该框架绑定。</strong>而当<code>balance</code>还没被赋过一个值，<code>nonlocal</code>语句便会报错。</p>
<p>  在先前对嵌套函数的学习中，我们知道一个局部定义的函数可以调用局部框架以外的变量，并不需要<code>nonlocal</code>语句。但<strong>只有<code>nonlocal</code>可以让局部函数改变名称绑定的框架</strong>。</p>
<h3 id="2python的语言特性">2.<span class="math inline">\(python\)</span>的语言特性</h3>
<p>  上面说到的<code>nonlocal</code>语句是<span class="math inline">\(python\)</span>高阶函数与词法范围的特性。事实上，<code>nonlocal</code>语句经常是其它编程语言的默认行为。</p>
<p>  <span class="math inline">\(python\)</span>语句还有一个限制：<strong>在函数体内部，所有名字(<span class="math inline">\(name\)</span>)的实例必须处于同一框架</strong>。因此，在<span class="math inline">\(python\)</span>中，一个局部函数不能在非局部框架中查询一个名字的值、然后将其绑定到局部框架中，否则一个名字就属于两个不同的框架了。这个限制允许<span class="math inline">\(Python\)</span>在执行函数体之前预先计算包含每个名称的框架。</p>
<p>  下面这个例子说明了<span class="math inline">\(python\)</span>的这一特性： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_withdraw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">            balance = balance - amount</span><br><span class="line">            <span class="keyword">return</span> balance</span><br><span class="line">        <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd = make_withdraw(<span class="number">20</span>)</span><br><span class="line">wd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;UnboundLocalError: local variable <span class="string">&#x27;balance&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure></p>
<p>  在<code>withdraw</code>中，原本处于<code>make_withdraw</code>框架中的<code>balance</code>在局部框架中被赋值，违反了<span class="math inline">\(python\)</span>的限制。</p>
<h3 id="3nonlocal的好处">3.<code>nonlocal</code>的好处</h3>
<p>  <code>nonlocal</code>语句是我们<strong>将程序视为相互交互而彼此独立的集合</strong>的重要步骤。</p>
<p>  特别地，<code>nonlocal</code>语句让我们<strong>能够维护那些属于某个函数的局部框架、但随着调用不断更新的状态。</strong>像上面的与<code>withdraw</code>联系的<code>balance</code>在对<code>withdraw</code>的多次调用中得到共享。但是，<strong>这个<code>balance</code>与<code>withdraw</code>的联系对函数的其它部分是不可访问的、仅对<code>wd</code>生效。</strong>当我们再次调用<code>make_withdraw</code>后，它会创建一个独立的框架，与一个跟新的<code>balance</code>的独特的联系。</p>
<p>  下面这个对原来例子的拓展很好地说明了这个问题： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_withdraw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">         <span class="keyword">nonlocal</span> balance</span><br><span class="line">         <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">        balance = balance - amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd = make_withdraw(<span class="number">20</span>)</span><br><span class="line">wd2 = make_withdraw(<span class="number">7</span>)</span><br><span class="line">wd2(<span class="number">6</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="number">1</span></span><br><span class="line">wd(<span class="number">8</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="number">12</span></span><br></pre></td></tr></table></figure>
  通过这个方式，<strong>每个<code>withdraw</code>的实例(<code>instance</code>)都维护了自己独有的<code>balance</code>值，并且这个值对其它函数而言是不可访问的。</strong>这样，我们就创建了一个完全独立的<span class="math inline">\(bank\;account\)</span>对象。</p>
<h3 id="4关于相等same的思考">4.关于相等(<span class="math inline">\(same\)</span>)的思考</h3>
<p>  对于一个函数，以上面的<code>make_withdraw</code>为例，<code>wd</code>与<code>wd2</code>绑定的都是同一个函数<code>make_withdraw</code>，但是两者是否相等呢？由上述讨论知两者并不相等。但对于以下例子，两者就变成完全相等的了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_withdraw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">        balance = balance - amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd = make_withdraw(<span class="number">12</span>)</span><br><span class="line">wd2 = wd</span><br><span class="line">wd2(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="number">11</span></span><br><span class="line">wd(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>
  这时，<code>make_withdraw</code>的一个实例被两个不同的名字<code>wd</code>和<code>wd2</code>所表示，这是很不寻常的。而分析这个问题的关键在于<strong>只有调用函数才可以引入新的框架，并且赋值语句只会改变现有框架中的绑定关系</strong>。</p>
<p>  这引发了对“相等”的讨论。在先前对<code>rational number</code>的定义中，只要分子分母相等的数就是相等的；但如今，<code>rational number</code>又有了与其所在框架相关的属性——<code>identity</code>。而对于上面<span class="math inline">\(account\)</span>的例子，<code>wd2</code>与<code>wd</code>的值并不相同，但它们是同一个<span class="math inline">\(account\)</span>。这一差异让程序设计变得更为复杂。</p>
<h2 id="五-对象的具体实现以列表与字典为例">五、对象的具体实现——以列表与字典为例</h2>
<h3 id="1列表的实现">1.列表的实现</h3>
<p>  我们将用一个以链表作为局部状态的函数代表可变列表，先考虑下面这些基本的设计：</p>
<ul>
<li><strong>具有与框架相关的属性——<code>identity</code></strong>，像普通的可变列表一样。</li>
<li>不能用<code>None</code>表示空列表，因为两个不同的空列表不是相等的值，但<code>None is None</code>。而<code>empty</code>可以实现<code>identity</code>属性。</li>
</ul>
<p>  既然是用函数实现，那么应该用什么作为函数的参数呢？该问题的答案揭示了编程中的一般模式：</p>
<h4 id="a分派函数dispatchfunction">  <span class="math inline">\(a.\)</span>分派函数(<span class="math inline">\(dispatch\;function\)</span>)</h4>
<p>  分派函数的<strong>第一个参数是<code>message</code>——一个字符串，用于指挥这个函数该调用哪个方法</strong>；其余参数是各个方法需要的参数。</p>
<p>  分派函数实际上是<strong>多个函数的集成体</strong>：<code>message</code>参数决定了函数的行为，其余参数则在这个行为中被调用:
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mutable_link</span>():</span><br><span class="line">    contents=empty</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">message,value=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> contents</span><br><span class="line">        <span class="keyword">if</span> messages==<span class="string">&#x27;len&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> len_link(contents)</span><br><span class="line">        <span class="keyword">elif</span> messages==<span class="string">&#x27;getitem&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> getitem_link(contents,value)</span><br><span class="line">        <span class="keyword">elif</span> messages==<span class="string">&#x27;push_first&#x27;</span>:</span><br><span class="line">            contents=link(value,contens)</span><br><span class="line">        <span class="keyword">elif</span> message==<span class="string">&#x27;pop_first&#x27;</span>:</span><br><span class="line">            f=first(contents)</span><br><span class="line">            contents=rest(contens)</span><br><span class="line">            <span class="keyword">return</span> f</span><br><span class="line">        <span class="keyword">elif</span> message==<span class="string">&#x27;str&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> join_link(contents,<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> dispatch</span><br></pre></td></tr></table></figure></p>
<p>  我们还可以创建一个将<span class="math inline">\(python\)</span>内置的序列数据类型表示为<code>mutable_list</code>类型的函数：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">to_mutable_link</span>(<span class="params">source</span>):</span><br><span class="line">    s=multible_link()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reverse(source):</span><br><span class="line">        s(<span class="string">&#x27;push_first&#x27;</span>,i)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = to_mutable_link(suits)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(s)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s(<span class="string">&#x27;str&#x27;</span>))</span><br><span class="line">heart, diamond, spade, club</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s(<span class="string">&#x27;pop_first&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;heart&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s(<span class="string">&#x27;str&#x27;</span>))</span><br><span class="line">diamond, spade, club</span><br></pre></td></tr></table></figure>
  这样，<code>mutable list</code>的封装就完成了。这种<strong>通过在一个函数内封装对某个数据值的所有操作的方法被称作信息传递原则(<span class="math inline">\(message\;passing\)</span>)。一个运用信息传递原则的函数会定义分派函数、并通过传递<code>message</code>来组织计算</strong>。</p>
<h3 id="2字典的实现">2.字典的实现</h3>
<p>  利用上面的逻辑，我们也可以实现字典的封装： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dictionart</span>():</span><br><span class="line">    records=[]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getitem</span>(<span class="params">key</span>):</span><br><span class="line">        matches=[r <span class="keyword">for</span> r <span class="keyword">in</span> records <span class="keyword">if</span> r[<span class="number">0</span>]==key]:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span>(matches)==<span class="number">1</span>):</span><br><span class="line">            key,value=matches[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setitem</span>(<span class="params">key,value</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> records</span><br><span class="line">        non_matches=[r <span class="keyword">for</span> r <span class="keyword">in</span> records <span class="keyword">if</span> r[<span class="number">0</span>]!=key]</span><br><span class="line">        records=non_matches+[[key,value]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">message,key=<span class="literal">None</span>,value=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> message==<span class="string">&#x27;getitem&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> getitem(key)</span><br><span class="line">        <span class="keyword">elif</span> message==<span class="string">&#x27;setitem&#x27;</span>:</span><br><span class="line">            setitem(key,value)</span><br><span class="line">    <span class="keyword">return</span> dispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dictionary()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d(<span class="string">&#x27;setitem&#x27;</span>, <span class="number">3</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d(<span class="string">&#x27;setitem&#x27;</span>, <span class="number">4</span>, <span class="number">16</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d(<span class="string">&#x27;getitem&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d(<span class="string">&#x27;getitem&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<h2 id="六-分派字典dispatchdictionary">六、分派字典(<span class="math inline">\(dispatch\;dictionary\)</span>)</h2>
<h3 id="1分派字典的概念">1.分派字典的概念</h3>
<p>  分派函数是抽象数据传递接口的一种通用方法，而我们可以<strong>用字典这种数据类型来实现分派函数的分派功能</strong>。</p>
<h3 id="2分派字典的实现">2.分派字典的实现</h3>
<p>  以先前的<span class="math inline">\(account\)</span>为例，我们创建一个可变数据类型<code>account</code>，它由<span class="math inline">\(constructor\)</span><code>account</code>与<span class="math inline">\(selector\)</span><code>check_balance</code>组成：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">account</span>(<span class="params">initial_balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">amount</span>):</span><br><span class="line">        dispatch[<span class="string">&#x27;balance&#x27;</span>]+=amount</span><br><span class="line">        <span class="keyword">return</span> dispatch[<span class="string">&#x27;balance&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        <span class="keyword">if</span> amount&gt;dispatch[<span class="string">&#x27;balance&#x27;</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">        dispatch[<span class="string">&#x27;balance&#x27;</span>]-=amount</span><br><span class="line">        <span class="keyword">return</span> dispatch[<span class="string">&#x27;balance&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    dispatch=&#123;<span class="string">&#x27;deposit&#x27;</span>:deposit,<span class="string">&#x27;withdraw&#x27;</span>:withdraw,<span class="string">&#x27;balance&#x27;</span>:initial_balance&#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">account,amount</span>):</span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">&#x27;withdraw&#x27;</span>](amount)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">account,amount</span>):</span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">&#x27;deposit&#x27;</span>](amount)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_balance</span>(<span class="params">account</span>):</span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">&#x27;balance&#x27;</span>]</span><br><span class="line"></span><br><span class="line">a=account(<span class="number">20</span>)</span><br><span class="line">deposit(a,<span class="number">5</span>)</span><br><span class="line">withdraw(a,<span class="number">17</span>)</span><br><span class="line">check_balance(a)</span><br><span class="line">&gt;&gt;&gt;<span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>  在这里，我们<strong>通过把<code>balance</code>存储在字典中而非直接存储在<code>account</code>框架里，避免了使用<code>nonlocal</code>语句</strong>。</p>
<h2 id="七-约束传递propagatingconstraints">七、约束传递(<span class="math inline">\(propagating\;constraints\)</span>)</h2>
<h3 id="1新的抽象系统基于约束的系统constraint-basedsystem">1.新的抽象系统——基于约束的系统(<span class="math inline">\(constraint-based\;system\)</span>)</h3>
<p>  可改变数据<strong>允许我们模拟随时改变的系统</strong>，同时也为我们提供了新的抽象方法。下面介绍利用<code>nonlocal</code>赋值、<span class="math inline">\(list\)</span>、字典搭建的基于约束器的系统。这是声明式编程(<span class="math inline">\(declarative\;programming\)</span>)的重要部分。</p>
<p>  在这个系统中，我们将<strong>程序表达为约束(<span class="math inline">\(constraint\)</span>)</strong>，确定待解决问题的结构，但将解决问题的细节进行抽象。</p>
<p>  这个系统的引入是基于计算机程序的特性——<strong>单向计算性</strong>(<span class="math inline">\(one-directional\;computations\)</span>)。在计算机程序中，我们将问题抽象为一个系统，模拟系统中各个数量的关系，在系统中传入给定的参数，然后计算出想要的答案。但很多事物，如下面的公式，并不是单向的：</p>
<p><span class="math display">\[pV=nRT\]</span></p>
<p>  在这个公式中，给出任意四个量，显然可以求出第五个量的值。但在计算机程序中，一个设计好用来求解<span class="math inline">\(p\)</span>的程序<strong>由于参数被固定了，并不能用于求解<span class="math inline">\(T\)</span>或其他量</strong>，即使我们已知其中四个量。</p>
<p>  于是我们构想一个模拟这种线性关系的模型。我们先定义<strong>一些初始的约束器</strong>，例如<strong>加法器</strong><code>adder(a,b,c)</code>，它强制(<span class="math inline">\(enforce\)</span>)了数学的加法关系<code>a+b=c</code>。</p>
<p>  我们再定义一种合并的方法，使得初始的约束器能被合并以表达更复杂的关系。我们<strong>构建一个网络(<span class="math inline">\(network\)</span>)，在这个网络中，约束器被连接器(<span class="math inline">\(connector\)</span>)连接在一起</strong>。连接器<strong>是一个连接一个或多个限制的对象，它自身会携带一个值</strong>。例如摄氏度与华氏度的换算<span class="math inline">\(9\times
c=5\times(f-32)\)</span>可表示为如下网络：</p>
<p><img src="/2024/05/31/2.4.%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE/image-3.png"></p>
<p>  基于这个网络的计算流程如下：</p>
<ul>
<li>当一个连接器被赋值，它<strong>会唤醒所有与它相连的约束器，告诉它们自己获得了一个值。</strong></li>
<li>每个约束器<strong>检测(<span class="math inline">\(poll\)</span>)自己的连接器，看自己是否有足够多的信息来决定连接器的值。</strong></li>
<li>如果<strong>能决定，约束器就重设连接器的值，然后连接器接着执行唤醒操作。</strong></li>
</ul>
<p>  对于温度换算的例子，该网络执行如下操作：</p>
<ul>
<li>先在<span class="math inline">\(w\)</span>、<span class="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>这些放常数的盒子(<span class="math inline">\(constant\;box\)</span>)里放入常数。</li>
<li>连接器唤醒加法器<code>adder</code>和乘法器<code>multiplier</code></li>
<li>由于<span class="math inline">\(celsius\)</span>的输入，最左侧乘法器将连接器<span class="math inline">\(u\)</span>的值重设，同时<span class="math inline">\(u\)</span>唤醒右侧的乘法器；最右侧同理。</li>
</ul>
<h3 id="2约束系统的使用">2.约束系统的使用</h3>
<h4 id="a连接器的创建与连接">  <span class="math inline">\(a.\)</span>连接器的创建与连接</h4>
<p>  为创建两个表示温度的连接器，我们调用<code>connector</code><span class="math inline">\(constructor\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;celsius=connector(<span class="string">&#x27;Celsius&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;fahrenheit=connector(<span class="string">&#x27;Fahrenheit&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>  然后我们把这些连接器组装到如上图的网络中。这里的<code>converter</code>函数用于组装该系统的诸多连接器与约束器：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">converter</span>(<span class="params">c,f</span>):</span><br><span class="line">    u,v,w,x,y=[connector()<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">    <span class="comment">#apply a new connector for each variables</span></span><br><span class="line">    multiplier(c,w,u)</span><br><span class="line">    multiplier(v,x,u)</span><br><span class="line">    adder(v,y,f)</span><br><span class="line">    constant(w,<span class="number">9</span>)</span><br><span class="line">    constant(x,<span class="number">5</span>)</span><br><span class="line">    constant(y,<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">converter(celsius,fahrenheit)</span><br></pre></td></tr></table></figure> ####   <span class="math inline">\(b.\)</span>连接器与限制器的协调
  我们用之前介绍的<span class="math inline">\(message\;passing\)</span>系统来协调连接器与约束器。这里，约束器是不持有局部状态的字典，它们对<code>message</code>的回应是会改变连接器值的非纯函数。</p>
<p>  而连接器是<strong>持有当前值、并回应接收到的<code>message</code>从而改变当前值的字典</strong>。约束器不会立即改变连接器的值，而是发送信息，这样连接器就可以根据收到的信息来唤醒其他约束器。通过这一流程，连接器不仅表示当前值、而且还封装了一系列行为。</p>
<p>  向连接器发送信号，以<code>set_val</code>为例，的方法如下：(这里的<code>user</code>是我们，发送信号的人)
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;celsius[<span class="string">&#x27;set_val&#x27;</span>](<span class="string">&#x27;user&#x27;</span>,<span class="number">25</span>)</span><br><span class="line">celsius=<span class="number">25</span></span><br><span class="line">fahrenheit=<span class="number">77.0</span></span><br></pre></td></tr></table></figure></p>
<p>  在<code>set_val</code>被执行后，不仅<span class="math inline">\(celsius\)</span>的值变成了<span class="math inline">\(25\)</span>，它的值通过网络传递导致了<span class="math inline">\(fahrenheit\)</span>的改变。这个改变被打印出来，因为<span class="math inline">\(constructor\)</span><code>converter</code>将两个名称绑定在同一网络里。</p>
<p>  那假如我们对其中一个名称输入一个与原结果相矛盾的值呢？
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fahrenheit[<span class="string">&#x27;set_val&#x27;</span>](<span class="string">&#x27;user&#x27;</span>, <span class="number">212</span>)</span><br><span class="line">Contradiction detected: <span class="number">77.0</span> vs <span class="number">212</span></span><br></pre></td></tr></table></figure></p>
<p>  此时连接器报错了：它的值是<span class="math inline">\(77.0\)</span>，但有人想把它变成<span class="math inline">\(212\)</span>。如果我们想让这个网络采纳这个新值，就要<strong>让<span class="math inline">\(celsius\)</span>忘记它的旧值</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>celsius[<span class="string">&#x27;forget&#x27;</span>](<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line">Celsius <span class="keyword">is</span> forgotten</span><br><span class="line">Fahrenheit <span class="keyword">is</span> forgotten</span><br></pre></td></tr></table></figure></p>
<p>  在接受到<code>forget</code>的指令后，<strong>不仅<span class="math inline">\(celsius\)</span>撤回了原先的值，该指令通过网络传递给<span class="math inline">\(fahrenheit\)</span>，<span class="math inline">\(fahrenheit\)</span>也忘记了原先的值</strong>。此时再对<span class="math inline">\(fahrenheit\)</span>进行赋值就可成立：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fahrenheit[<span class="string">&#x27;set_val&#x27;</span>](<span class="string">&#x27;user&#x27;</span>, <span class="number">212</span>)</span><br><span class="line">Fahrenheit=<span class="number">212</span></span><br><span class="line">Celsius=<span class="number">100.0</span></span><br></pre></td></tr></table></figure></p>
<p>  在这整个过程中体现出的系统的<strong>非方向性是约束系统的显著特征</strong>。</p>
<h3 id="3约束系统的实现">3.约束系统的实现</h3>
<p>  我们想让连接器对如下<code>message</code>做出回应：</p>
<ul>
<li><code>connector['set_val'](source, value)</code>：为连接器赋值。</li>
<li><code>connector['has_val']()</code>：返回是否有值。</li>
<li><code>connector['val']</code>：输出连接器当前值。</li>
<li><code>connector['forget'](source)</code>：告诉连接器<code>source</code>让它忘记当前值。</li>
<li><code>connector['connect'](source)</code>：让连接器与<code>source</code>相连</li>
</ul>
<p>  约束器也是字典，它接受连接器传来的两种信息：</p>
<ul>
<li><code>constraint['new_val']()</code>：表明与约束器相连的某个连接器有一个新值。</li>
<li><code>constraint['forget']()</code>：表明与约束器相连的某个连接器忘记了它的值。</li>
</ul>
<p>  当约束器收到<code>message</code>后，会将它们传给其他的连接器。</p>
<p>  下面展示一般三元约束(<span class="math inline">\(generic\;ternary\)</span>)的实现。在三元约束系统中，我们用三个连接器和三个从加法器<code>adder</code>创建的函数来创建约束：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_tenery_constraint</span>(<span class="params">a,b,c,ab,ca,cb</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_value</span>():</span><br><span class="line">        av,bv,cv=[connector[<span class="string">&#x27;has_val&#x27;</span>]<span class="keyword">for</span> connector <span class="keyword">in</span> (a,b,c)]</span><br><span class="line">        <span class="keyword">if</span> av <span class="keyword">and</span> bv:</span><br><span class="line">            c[<span class="string">&#x27;set_val&#x27;</span>](constraint,ab(a[<span class="string">&#x27;val&#x27;</span>],b[<span class="string">&#x27;val&#x27;</span>]))</span><br><span class="line">        <span class="keyword">elif</span> bv <span class="keyword">and</span> cv:</span><br><span class="line">            a[<span class="string">&#x27;set_val&#x27;</span>](constraint,bc(b[<span class="string">&#x27;val&#x27;</span>],c[<span class="string">&#x27;val&#x27;</span>]))</span><br><span class="line">        <span class="keyword">elif</span> av <span class="keyword">and</span> cv:</span><br><span class="line">            b[<span class="string">&#x27;set_val&#x27;</span>](constraint,ac(a[<span class="string">&#x27;val&#x27;</span>],c[<span class="string">&#x27;val&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forget_value</span>():</span><br><span class="line">        <span class="keyword">for</span> connector <span class="keyword">in</span> (a,b,c):</span><br><span class="line">            connector[<span class="string">&#x27;forget&#x27;</span>](constraint)</span><br><span class="line">    </span><br><span class="line">    constraint=[<span class="string">&#x27;new_val&#x27;</span>:new_value,<span class="string">&#x27;forget&#x27;</span>:forget_value]</span><br><span class="line">    <span class="keyword">for</span> connector <span class="keyword">in</span>(a,b,c):</span><br><span class="line">        connectot[<span class="string">&#x27;connect&#x27;</span>](constraint)</span><br><span class="line">    <span class="keyword">return</span> constraint</span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(constraint\)</span>既是分派字典、又是<span class="math inline">\(constraint\)</span>对象本身，它负责回应连接器传来的信息。函数的实现逻辑如下：</p>
<ul>
<li><span class="math inline">\(constraint\)</span>的<code>new_value</code>局部函数在约束器被告知它的连通器获得了一个新值时会被调用。当其<strong>检测到两个值时，它就会告知对应连接器：把值设置成两个值约束后的值</strong>。</li>
<li>当约束器<strong>被告知它的连通器忘记了某个值时，它要求所有与它相连的连接器忘掉它们的值</strong>。</li>
</ul>
<p>  乘法器的实现与加法器类似： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul,truediv</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">muitiplier</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="keyword">return</span> make_tenery_constraint(a,b,c,mul,truediv,truediv)</span><br></pre></td></tr></table></figure></p>
<p>  常数也是一种约束器，但<strong>它不会发送任何信息，因为它只有一个刚创建时创建的连接器</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">constant</span>(<span class="params">connector,value</span>):</span><br><span class="line">    constraint=&#123;&#125;</span><br><span class="line">    connector[<span class="string">&#x27;set_val&#x27;</span>](constraint,value)</span><br><span class="line">    <span class="keyword">return</span> constraint</span><br></pre></td></tr></table></figure></p>
<h3 id="4连接器的实现">4.连接器的实现</h3>
<p>  连接器是一个不仅包含自身值、还包含回应函数的字典。一个连接器需要跟踪给它赋予当前值的<code>informant</code>(<code>source</code>)与和它相连的<code>constraint</code>。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connector</span>(<span class="params">name=<span class="literal">None</span></span>):</span><br><span class="line">    informant=<span class="literal">None</span></span><br><span class="line">    constraint=[]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_value</span>(<span class="params">source,value</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> informant</span><br><span class="line">        val=connect[<span class="string">&#x27;val&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            informant,connector[<span class="string">&#x27;val&#x27;</span>]=source,value</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(name,<span class="string">&#x27;=&#x27;</span>,value)</span><br><span class="line">            inform_all_except(source,<span class="string">&#x27;new_val&#x27;</span>,constraints)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> val!=value:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Contradiction detected:&#x27;</span>,val,<span class="string">&#x27;vs&#x27;</span>,value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forger_value</span>(<span class="params">source</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> informant</span><br><span class="line">        <span class="keyword">if</span> informant==source:</span><br><span class="line">            informant,connector[<span class="string">&#x27;val&#x27;</span>]=<span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(name,<span class="string">&#x27;is forgotten&#x27;</span>)</span><br><span class="line">            inform_all_except(source,<span class="string">&#x27;forget&#x27;</span>,constraints)</span><br><span class="line"></span><br><span class="line">    connector=&#123;<span class="string">&#x27;val&#x27;</span>:<span class="literal">None</span>,</span><br><span class="line">               <span class="string">&#x27;set_val&#x27;</span>:set_value,</span><br><span class="line">               <span class="string">&#x27;forget&#x27;</span>:forget_value,</span><br><span class="line">               <span class="string">&#x27;has_val&#x27;</span>:<span class="keyword">lambda</span>:connector[<span class="string">&#x27;val&#x27;</span>]<span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>,</span><br><span class="line">               <span class="string">&#x27;connect&#x27;</span>:<span class="keyword">lambda</span> source:constraints.append(source)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> connector</span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(connector\)</span>同样既是分派字典又是<span class="math inline">\(connector\)</span>对象本身，字典的其中四项代表方法函数，最后一项返回<span class="math inline">\(connector\)</span>的值。函数的实现逻辑如下：</p>
<ul>
<li>当<strong>收到设置连接器当前值的请求</strong>时，<code>set_value</code>被调用。</li>
<li>当此时的连接器没有值时，它<strong>会设置一个值，并将请求设置值的源约束器<code>source</code>作为<code>informant</code></strong>。然后连接器就会<strong>告知除源约束器外的所有与它相连的约束器</strong>。</li>
<li>当连接器被告知要忘记当前值时，它<strong>调用<code>forget_value</code>，接着告知除源约束器外的所有与它相连的约束器</strong>。</li>
</ul>
<p>  告知函数可如下实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inform_all_except</span>(<span class="params">source,message,constraints</span>):</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> constraints:</span><br><span class="line">        <span class="keyword">if</span> c!=source:</span><br><span class="line">            c[message]()</span><br></pre></td></tr></table></figure></p>
<h3 id="5约束系统的性质">5.约束系统的性质</h3>
<p>  约束系统中的约束器与连接器都是<strong>通过传递<code>message</code>来操作的对象</strong>。当某个连接器的值被改变时，传递的<code>message</code><strong>不仅改变了连接器的值，还确认了值的正确性、将值的效果传递给其他对象</strong>。这使得程序更为完善</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>2.9.迭代对象</title>
    <url>/2024/05/31/2.9.%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="29迭代对象"><span class="math inline">\(2.9\)</span>迭代对象</h1>
<p>  对象可以将其他对象作为属性，当一个类中的某个对象的属性是该类的某个成员时，它就是迭代对象(<span class="math inline">\(recursive\;object\)</span>)。</p>
<h3 id="1链表类">1.链表类</h3>
<h4 id="a链表类定义">  <span class="math inline">\(a.\)</span>链表类定义</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Link</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A linked list with a first element and the rest.&quot;&quot;&quot;</span></span><br><span class="line">        empty = ()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first, rest=empty</span>):</span><br><span class="line">            <span class="keyword">assert</span> rest <span class="keyword">is</span> Link.empty <span class="keyword">or</span> <span class="built_in">isinstance</span>(rest, Link)</span><br><span class="line">            <span class="comment"># if rest is an empty list or is a link instance</span></span><br><span class="line">            self.first = first</span><br><span class="line">            self.rest = rest</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> self.first</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.rest[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">len</span>(self.rest)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="b字符串表示">  <span class="math inline">\(b.\)</span>字符串表示</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">link_expression</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a string that would evaluate to s.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line">            rest = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rest = <span class="string">&#x27;, &#x27;</span> + link_expression(s.rest)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Link(&#123;0&#125;&#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(s.first, rest)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>link_expression(s)</span><br><span class="line"><span class="string">&#x27;Link(3, Link(4, Link(5)))&#x27;</span></span><br></pre></td></tr></table></figure>
<p>  将这个字符串表示函数与<code>__repr__</code>方法绑定，可以在显示链表实例时自动调用：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Link.__repr__ = link_expression</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>)))</span><br></pre></td></tr></table></figure></p>
<h4 id="c链表的映射-筛选与字符插入">  <span class="math inline">\(c.\)</span>链表的映射、筛选与字符插入</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">map_link</span>(<span class="params">f, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Link(f(s.first), map_link(f, s.rest))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_link(square, s)</span><br><span class="line">Link(<span class="number">9</span>, Link(<span class="number">16</span>, Link(<span class="number">25</span>)))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">filter_link</span>(<span class="params">f, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            filtered = filter_link(f, s.rest)</span><br><span class="line">            <span class="keyword">if</span> f(s.first):</span><br><span class="line">                <span class="keyword">return</span> Link(s.first, filtered)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> filtered</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odd = <span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_link(square, filter_link(odd, s))</span><br><span class="line">Link(<span class="number">9</span>, Link(<span class="number">25</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[square(x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="keyword">if</span> odd(x)]</span><br><span class="line">[<span class="number">9</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">join_link</span>(<span class="params">s, separator</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> s.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(s.first)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(s.first) + separator + join_link(s.rest, separator)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join_link(s, <span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="string">&#x27;3, 4, 5&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="d链表的一些其它迭代操作">  <span class="math inline">\(d.\)</span>链表的一些其它迭代操作</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">extend_link</span>(<span class="params">s, t</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> t</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Link(s.first, extend_link(s.rest, t))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extend_link(s, s)</span><br><span class="line">Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>, Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>))))))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Link.__add__ = extend_link</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s + s</span><br><span class="line">Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>, Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>))))))</span><br></pre></td></tr></table></figure>
<h3 id="2树类">2.树类</h3>
<h4 id="a树类定义">  <span class="math inline">\(a.\)</span>树类定义</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Tree</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, label, branches=(<span class="params"></span>)</span>):</span><br><span class="line">            self.label = label</span><br><span class="line">            <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(branch, Tree)</span><br><span class="line">            self.branches = branches</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">if</span> self.branches:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Tree(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.label, <span class="built_in">repr</span>(self.branches))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Tree(&#123;0&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">repr</span>(self.label))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> self.branches</span><br></pre></td></tr></table></figure>
<h3 id="3set">3.<span class="math inline">\(set\)</span></h3>
<h4 id="a概念">  <span class="math inline">\(a.\)</span>概念</h4>
<p>  <span class="math inline">\(set\)</span>是<span class="math inline">\(python\)</span>内置的容器，<span class="math inline">\(set\)</span>内部的元素会自动去重与排序。</p>
<h4 id="b基本操作">  <span class="math inline">\(b.\)</span>基本操作</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.union(&#123;<span class="number">1</span>, <span class="number">5</span>&#125;)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.intersection(&#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;)</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4set的实现">4.<span class="math inline">\(set\)</span>的实现</h3>
<h4 id="a链表实现非排序set">  <span class="math inline">\(a.\)</span>链表实现非排序<span class="math inline">\(set\)</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">is</span> Link.empty</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return True if and only if set s contains v.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> empty(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> s.first == v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.rest, v)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Link(<span class="number">4</span>, Link(<span class="number">1</span>, Link(<span class="number">5</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(s, <span class="number">2</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(s, <span class="number">5</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">adjoin_set</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a set containing all elements of s and element v.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> set_contains(s, v):</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Link(v, s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = adjoin_set(s, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">Link(<span class="number">2</span>, Link(<span class="number">4</span>, Link(<span class="number">1</span>, Link(<span class="number">5</span>))))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">intersect_set</span>(<span class="params">set1, set2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a set containing all elements common to set1 and set2.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> keep_if_link(set1, <span class="keyword">lambda</span> v: set_contains(set2, v))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>intersect_set(t, apply_to_all_link(s, square))</span><br><span class="line">Link(<span class="number">4</span>, Link(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">union_set</span>(<span class="params">set1, set2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a set containing all elements either in set1 or set2.&quot;&quot;&quot;</span></span><br><span class="line">        set1_not_set2 = keep_if_link(set1, <span class="keyword">lambda</span> v: <span class="keyword">not</span> set_contains(set2, v))</span><br><span class="line">        <span class="keyword">return</span> extend_link(set1_not_set2, set2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>union_set(t, s)</span><br><span class="line">Link(<span class="number">2</span>, Link(<span class="number">4</span>, Link(<span class="number">1</span>, Link(<span class="number">5</span>))))</span><br></pre></td></tr></table></figure>
<h4 id="b排序对时间复杂度的影响">  <span class="math inline">\(b.\)</span>排序对时间复杂度的影响</h4>
<p>  对于查询操作，非排序元素的时间复杂度为<span class="math inline">\(O(n)\)</span>；而对于排序元素，查询最小元素为<span class="math inline">\(1\)</span>，最大元素为<span class="math inline">\(n\)</span>，平均复杂度为<span class="math inline">\(O({n\over 2})=O(n)\)</span>，虽然同阶但较小。</p>
<p>  对于合并操作，非排序元素的时间复杂度是<span class="math inline">\(O(n,m)\)</span>；而对于排序元素，可以利用双指针算法实现<span class="math inline">\(O(m+n)\)</span>的复杂度。</p>
<h4 id="c列表实现排序set">  <span class="math inline">\(c.\)</span>列表实现排序<span class="math inline">\(set\)</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="keyword">if</span> empty(s) <span class="keyword">or</span> s.first &gt; v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> s.first == v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.rest, v)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = Link(<span class="number">1</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(u, <span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(u, <span class="number">4</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">intersect_set</span>(<span class="params">set1, set2</span>):</span><br><span class="line">        <span class="keyword">if</span> empty(set1) <span class="keyword">or</span> empty(set2):</span><br><span class="line">            <span class="keyword">return</span> Link.empty</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            e1, e2 = set1.first, set2.first</span><br><span class="line">            <span class="keyword">if</span> e1 == e2:</span><br><span class="line">                <span class="keyword">return</span> Link(e1, intersect_set(set1.rest, set2.rest))</span><br><span class="line">            <span class="keyword">elif</span> e1 &lt; e2:</span><br><span class="line">                <span class="keyword">return</span> intersect_set(set1.rest, set2)</span><br><span class="line">            <span class="keyword">elif</span> e2 &lt; e1:</span><br><span class="line">                <span class="keyword">return</span> intersect_set(set1, set2.rest)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>intersect_set(s, s.rest)</span><br><span class="line">Link(<span class="number">4</span>, Link(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h4 id="d二叉查找树树实现set">  <span class="math inline">\(d.\)</span>二叉查找树树实现<span class="math inline">\(set\)</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> s.entry == v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> s.entry &lt; v:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.right, v)</span><br><span class="line">        <span class="keyword">elif</span> s.entry &gt; v:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.left, v)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">adjoin_set</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> Tree(v)</span><br><span class="line">        <span class="keyword">elif</span> s.entry == v:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">elif</span> s.entry &lt; v:</span><br><span class="line">            <span class="keyword">return</span> Tree(s.entry, s.left, adjoin_set(s.right, v))</span><br><span class="line">        <span class="keyword">elif</span> s.entry &gt; v:</span><br><span class="line">            <span class="keyword">return</span> Tree(s.entry, adjoin_set(s.left, v), s.right)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>adjoin_set(adjoin_set(adjoin_set(<span class="literal">None</span>, <span class="number">2</span>), <span class="number">3</span>), <span class="number">1</span>)</span><br><span class="line">Tree(<span class="number">2</span>, Tree(<span class="number">1</span>), Tree(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>2.7.对象抽象</title>
    <url>/2024/05/31/2.7.%E5%AF%B9%E8%B1%A1%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="27对象抽象"><span class="math inline">\(2.7\)</span>对象抽象</h1>
<h2 id="一-思想概述">一、思想概述</h2>
<p>  对象系统(<span class="math inline">\(object\;system\)</span>)可以实现对抽象数据的不同表达的共存。</p>
<p>  为实现这样的对象系统，我们需要<strong>找到一个普遍函数(<span class="math inline">\(generic\;function\)</span>)，这个函数可以接受某个值的各种表达</strong>，下面将介绍实现这一操作的方法。</p>
<h2 id="二-前置知识">二、前置知识</h2>
<h3 id="1字符串转换">1.字符串转换</h3>
<p>  为更高效地表达数据，我们希望在<span class="math inline">\(python\)</span>的交互式对话中自动显示表达式的字符串表示。</p>
<p>  <span class="math inline">\(python\)</span>规定，每个对象都会产生两种不同的字符串表示：<strong>一种是人类可以阅读(<span class="math inline">\(human-interpretable\)</span>)的文本，一种是<span class="math inline">\(python\)</span>可理解(<span class="math inline">\(python-interpretable\)</span>)的表达式</strong>。字符串的构造函数<code>str</code>返回一个人类可读的字符串。(在可能的情况下)而<code>repr</code>函数返回结果等价的<code>python</code>表达式：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">12e12</span></span><br><span class="line"><span class="number">12000000000000.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(<span class="number">12e12</span>))</span><br><span class="line"><span class="number">12000000000000.0</span></span><br></pre></td></tr></table></figure></p>
<p>  当传入的表达式没有初始值时，<code>repr</code>会返回如下语句：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(<span class="built_in">min</span>)</span><br><span class="line"><span class="string">&#x27;&lt;built-in function min&gt;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>  <code>str</code>的<span class="math inline">\(constructor\)</span>与<code>repr</code>语句经常重合，但前者返回一个人类更易读的文本：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues = date(<span class="number">2011</span>, <span class="number">9</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(tues)</span><br><span class="line"><span class="string">&#x27;datetime.date(2011, 9, 12)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(tues)</span><br><span class="line"><span class="string">&#x27;2011-09-12&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>  对象系统为我们提供了能用于所有数据类型的方法：<code>__repr__</code>与<code>__str__</code>，这让我们可以以点表达式编写程序：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues.__repr__()</span><br><span class="line"><span class="string">&#x27;datetime.date(2011, 9, 12)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues.__str__()</span><br><span class="line"><span class="string">&#x27;2011-09-12&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2特殊方法">2.特殊方法</h3>
<p>  在<span class="math inline">\(python\)</span>中，特殊方法(<span class="math inline">\(special\;method\)</span>)在特定情况被<span class="math inline">\(python\)</span>编译器调用，例如：</p>
<ul>
<li><code>__init__</code>方法会在某个对象被创建后自动调用。</li>
<li><code>__str__</code>方法在打印结果时自动调用。</li>
<li><code>__repr</code>方法在交互式程序展示值(<code>value</code>)时自动调用。</li>
</ul>
<p>  <span class="math inline">\(python\)</span>中还有一些类似的特殊方法。</p>
<h4 id="a__bool__方法">  <span class="math inline">\(a.\)</span><code>__bool__</code>方法</h4>
<p>  一般的<code>bool</code>会默认<span class="math inline">\(0\)</span>为<code>false</code>，其他值为<code>true</code>。对于对象而言，<span class="math inline">\(python\)</span>中默认所有对象都有<code>true</code>值。但<strong>我们可以利用<code>__bool__</code>方法来覆盖这一默认值</strong>。例如我们将值为<span class="math inline">\(0\)</span>的<span class="math inline">\(Account\)</span>为<code>false</code>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;Account.__bool__=<span class="keyword">lambda</span> self:self.balance!= <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>  则对于下面的对象，它会输出<code>false</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(Account(<span class="string">&#x27;Jack&#x27;</span>))</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="keyword">not</span> Account(<span class="string">&#x27;Jack&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Jack has nothing&#x27;</span>)</span><br><span class="line">Jack has nothing</span><br></pre></td></tr></table></figure></p>
<h4 id="b序列操作">  <span class="math inline">\(b.\)</span>序列操作</h4>
<p>  序列中的方法主要如下：</p>
<ul>
<li><p><code>__len__</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Go Bears!&#x27;</span>.__len__()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>__getitem__</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Go Bears!&#x27;</span>[<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Go Bears!&#x27;</span>.__getitem__(<span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="3可调用的对象">3.可调用的对象</h3>
<p>  <strong>通过<code>__call__</code>方法，我们可以让定义的对象像函数一样被调用</strong>，进而实现类似高阶函数的功能。</p>
<p>  考虑下面的高阶函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">make_adder</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">adder</span>(<span class="params">k</span>):</span><br><span class="line">            <span class="keyword">return</span> n + k</span><br><span class="line">        <span class="keyword">return</span> adder</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_three = make_adder(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_three(<span class="number">4</span>)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>  我们可以定义一个<code>Adder</code>类实现类似操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Adder</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">            self.n = n</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, k</span>):</span><br><span class="line">            <span class="keyword">return</span> self.n + k</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_three_obj = Adder(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_three_obj(<span class="number">4</span>)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>  这样，我们就让类和对象表现得像函数一样，这进一步模糊了函数与数据的界限。</p>
<h2 id="三-多重表示multiplerepresentations">三、多重表示<span class="math inline">\(multiple\;representations\)</span></h2>
<p>  在编程中，对于程序中的某个数据对象，可能存在多种表达方式。例如复数(<span class="math inline">\(complex\;number\)</span>)，既可以用“实部+虚部”来表示，又可以用“模长+辐角主值”来表示。这使我们希望设计出<strong>能处理多重表示(<span class="math inline">\(multiple\;representations\)</span>)的系统</strong>。</p>
<p>  下面即以复数系统说明这一功能的实现。</p>
<h3 id="1对两种表示的初始化">1.对两种表示的初始化</h3>
<p>  我们<strong>从最高层次的抽象着手搭建系统，然后慢慢将其中的功能具体化</strong>。所有的复数都属于<span class="math inline">\(Number\)</span>，而数字可以相加与相乘，于是我们可以定义一个基准类<code>Number</code>与方法<code>__add__</code>、<code>__mul__</code>，这里的<code>__add__</code>、<code>__mul__</code>是通过<code>add</code>、<code>mul</code>等更具体的方法实现的：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">            <span class="keyword">return</span> self.add(other)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self,other</span>):</span><br><span class="line">            <span class="keyword">return</span> self.mul(other)</span><br></pre></td></tr></table></figure></p>
<p>  然后考虑在复数中实现<code>add</code>与<code>mul</code>方法，对<code>add</code>我们用复数的标准形式来计算；对于<code>mul</code>我们用复数的辐角形式来计算：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Complex</span>(<span class="title class_ inherited__">Number</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,other</span>):</span><br><span class="line">            <span class="keyword">return</span> ComplexRI(self.real+other.real,self.imag+other.imag)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self,other</span>):</span><br><span class="line">            magnitude=self.magnitude*other.magnitude</span><br><span class="line">            <span class="keyword">return</span> ComplexMA(magnitude,self.angle+other.angle)</span><br></pre></td></tr></table></figure></p>
<p>  这种实现方式假设了复数的两种类表示。</p>
<h3 id="2接口">2.接口</h3>
<p>  <strong>对象的属性作为信息传递(<span class="math inline">\(message\;passing\)</span>)的一种，允许不同的数据类型对相同信息做出不同反应</strong>。这种<strong>在不同的类中引发相似操作的共享信息组(<span class="math inline">\(shared\;set\;of\;messages\)</span>)</strong>
是有力的抽象方式。而<strong>接口(<span class="math inline">\(interface\)</span>)是一系列共享的属性名称与各自行为的详细说明</strong>。对于复数系统，接口需要实现四个属性：<code>real</code>，<code>imag</code>，<code>magnitude</code>，<code>angle</code>。</p>
<p>  为了保证复数算法(<span class="math inline">\(arithmic\)</span>)的正确性，这些属性必须具有一致性。这就是说，<code>(magnitude,angle)</code>表示的复数与<code>(real,imag)</code>表示的复数必须是同一个复数。</p>
<h3 id="3properties">3.<span class="math inline">\(properties\)</span></h3>
<p>  让多个属性维系一个固定的关系是一个新的问题，我们可以通过<strong>只存储某种属性、在需要其他属性时单独计算</strong>的方式解决这个问题。</p>
<p>  <span class="math inline">\(python\)</span>中的<code>@property</code>装饰符允许我们在不调用表达式语法的情况下调用函数，通过零参数的方法计算属性。以复数系统为例，我们存储复数的标准形式：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> atan2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">ComplexRI</span>(<span class="title class_ inherited__">Complex</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, real, imag</span>):</span><br><span class="line">            self.real = real</span><br><span class="line">            self.imag = imag</span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">magnitude</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> (self.real**<span class="number">2</span>+self.imag**<span class="number">2</span>)**<span class="number">0.5</span></span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">angle</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> atan2(self.imag, self.real)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;ComplexRI(&#123;0:g&#125;, &#123;1:g&#125;)&#x27;</span>.<span class="built_in">format</span>(self.real, self.imag)</span><br></pre></td></tr></table></figure></p>
<p>  这样我们就可以通过点表达式直接访问除标准形式外的属性了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri = ComplexRI(<span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri.real</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri.magnitude</span><br><span class="line"><span class="number">13.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri.real = <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri.real</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri.magnitude</span><br><span class="line"><span class="number">15.0</span></span><br></pre></td></tr></table></figure></p>
<p>  同样地，我们也可以存储辐角形式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sin, cos, pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">ComplexMA</span>(<span class="title class_ inherited__">Complex</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, magnitude, angle</span>):</span><br><span class="line">            self.magnitude = magnitude</span><br><span class="line">            self.angle = angle</span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">real</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> self.magnitude * cos(self.angle)</span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">imag</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> self.magnitude * sin(self.angle)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;ComplexMA(&#123;0:g&#125;, &#123;1:g&#125; * pi)&#x27;</span>.<span class="built_in">format</span>(self.magnitude, self.angle/pi)</span><br></pre></td></tr></table></figure></p>
<p>  并得到以下的输出结果： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ma = ComplexMA(<span class="number">2</span>, pi/<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ma.imag</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ma.angle = pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ma.real</span><br><span class="line">-<span class="number">2.0</span></span><br></pre></td></tr></table></figure></p>
<p>  通过接口方式对多重表示进行编码有优良的性质：<strong>每种表达的类都可以独自定义，它们只需要在共享的属性名称、这些属性的行为条件(<span class="math inline">\(behaviour\;condition\)</span>)上达成一致即可</strong>。当另一个编程者想再加入一个表达时，他只需要再创建一个具有相同属性的类即可。</p>
<h2 id="四-通用函数">四、通用函数</h2>
<h3 id="1概念amp引入">1.概念&amp;引入</h3>
<p>  <strong>通用函数(<span class="math inline">\(generic\;function\)</span>)是一种函数方法，它可以被用于不同类型的变量。</strong>
先前的<code>Complex.add</code>是通用函数，因为它的<code>other</code>变量既可以接受<code>ComplexRI</code>型，也可以接受<code>ComplexMA</code>型。</p>
<p>  这种灵活性的实现是基于
<strong><code>ComeplexRI</code>与<code>ComplexMA</code>共享一个接口</strong>的事实。除了利用接口和信息传递来实现通用函数，还有两种不同方法：类型分派与类型强制。</p>
<p>  现在，我们想将原来的复数系统拓展到实数域，在先前章节中我们已经实现了实数类：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> gcd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Rational</span>(<span class="title class_ inherited__">Number</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,numer,denom</span>):</span><br><span class="line">            g = gcd(numer,denom)</span><br><span class="line">            self.numer=numer // g</span><br><span class="line">            self.denom=denom // g</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Rational(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,other</span>):</span><br><span class="line">            nx,dx=self.numer, self.denom</span><br><span class="line">            ny,dy=other.numer, other.denom</span><br><span class="line">            <span class="keyword">return</span> Rational(nx*dy+ny*dx,dx*dy)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self,other</span>):</span><br><span class="line">            numer=self.numer*other.numer</span><br><span class="line">            denom=self.denom*other.denom</span><br><span class="line">            <span class="keyword">return</span> Rational(numer,denom)</span><br></pre></td></tr></table></figure></p>
<p>  我们希望实现一个通用函数<code>__add__</code>实现所有数的加法，同时将实数与复数的概念分离。</p>
<h3 id="2类型分派">2.类型分派</h3>
<p>  一个实现跨类(<span class="math inline">\(cross-type\)</span>)操作的方法是基于参数的数据类型选择适当的行为。而<strong>类型分派(<span class="math inline">\(type\;dispatch\)</span>)正是为了实现一个检查参数数据类型的函数</strong>。</p>
<p>  <span class="math inline">\(python\)</span>内置的<code>isinstance</code>函数可以实现这一功能。它<strong>接收一个对象和一个类，返回这个对象属于该类或属于该类的继承类的真假</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = ComplexRI(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, ComplexRI)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, Complex)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, ComplexMA)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>  可以利用<code>isinstance</code>函数实现对某个数是不是实数的判断：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">is_real</span>(<span class="params">c</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return whether c is a real number with no imaginary part.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(c, ComplexRI):</span><br><span class="line">            <span class="keyword">return</span> c.imag == <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(c, ComplexMA):</span><br><span class="line">            <span class="keyword">return</span> c.angle % pi == <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_real(ComplexRI(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_real(ComplexMA(<span class="number">2</span>, pi))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<p>  当然，我们也可以通过别的方式实现类型分派。我们可以<strong>给每一种数据类型添加一个属性<code>.type_tag</code></strong>，调用该属性会<strong>返回该数据类型的字符串表示</strong>。这样，我们就可以直接比较两个参数的<code>type_tag</code>了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Rational.type_tag = <span class="string">&#x27;rat&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Complex.type_tag = <span class="string">&#x27;com&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Rational(<span class="number">2</span>, <span class="number">5</span>).type_tag == Rational(<span class="number">1</span>, <span class="number">2</span>).type_tag</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ComplexRI(<span class="number">1</span>, <span class="number">1</span>).type_tag == ComplexMA(<span class="number">2</span>, pi/<span class="number">2</span>).type_tag</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Rational(<span class="number">2</span>, <span class="number">5</span>).type_tag == ComplexRI(<span class="number">1</span>, <span class="number">1</span>).type_tag</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>  处理完类型分派问题，我们编写接受实数与复数进行计算的函数操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add_complex_and_rational</span>(<span class="params">c, r</span>):</span><br><span class="line">        <span class="keyword">return</span> ComplexRI(c.real + r.numer/r.denom, c.imag)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">mul_complex_and_rational</span>(<span class="params">c, r</span>):</span><br><span class="line">        r_magnitude, r_angle = r.numer/r.denom, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> r_magnitude &lt; <span class="number">0</span>:</span><br><span class="line">            r_magnitude, r_angle = -r_magnitude, pi</span><br><span class="line">        <span class="keyword">return</span> ComplexMA(c.magnitude * r_magnitude, c.angle + r_angle)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add_rational_and_complex</span>(<span class="params">r, c</span>):</span><br><span class="line">        <span class="keyword">return</span> add_complex_and_rational(c, r)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">mul_rational_and_complex</span>(<span class="params">r, c</span>):</span><br><span class="line">        <span class="keyword">return</span> mul_complex_and_rational(c, r)</span><br></pre></td></tr></table></figure></p>
<p>  利用类型分派，我们可以根据传入参数的类型选择适当的函数操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">if</span> self.type_tag == other.type_tag:</span><br><span class="line">                <span class="keyword">return</span> self.add(other)</span><br><span class="line">            <span class="keyword">elif</span> (self.type_tag, other.type_tag) <span class="keyword">in</span> self.adders:</span><br><span class="line">                <span class="keyword">return</span> self.cross_apply(other, self.adders)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">if</span> self.type_tag == other.type_tag:</span><br><span class="line">                <span class="keyword">return</span> self.mul(other)</span><br><span class="line">            <span class="keyword">elif</span> (self.type_tag, other.type_tag) <span class="keyword">in</span> self.multipliers:</span><br><span class="line">                <span class="keyword">return</span> self.cross_apply(other, self.multipliers)</span><br><span class="line">        <span class="comment"># to tackle cross-type requirement</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">cross_apply</span>(<span class="params">self, other, cross_fns</span>):</span><br><span class="line">            cross_fn = cross_fns[(self.type_tag, other.type_tag)]</span><br><span class="line">            <span class="keyword">return</span> cross_fn(self, other)</span><br><span class="line">        <span class="comment"># dispatch dictionary</span></span><br><span class="line">        adders = &#123;(<span class="string">&quot;com&quot;</span>, <span class="string">&quot;rat&quot;</span>): add_complex_and_rational,</span><br><span class="line">                  (<span class="string">&quot;rat&quot;</span>, <span class="string">&quot;com&quot;</span>): add_rational_and_complex&#125;</span><br><span class="line">        multipliers = &#123;(<span class="string">&quot;com&quot;</span>, <span class="string">&quot;rat&quot;</span>): mul_complex_and_rational,</span><br><span class="line">                       (<span class="string">&quot;rat&quot;</span>, <span class="string">&quot;com&quot;</span>): mul_rational_and_complex&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;ComplexRI(<span class="number">1.5</span>,<span class="number">0</span>)+Rational(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">ComplexRI(<span class="number">3</span>,<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt;Rational(-<span class="number">1</span>,<span class="number">2</span>)*ComplexMA(<span class="number">4</span>,pi/<span class="number">2</span>)</span><br><span class="line">ComplexMA(<span class="number">2</span>,<span class="number">1.5</span>*pi)</span><br></pre></td></tr></table></figure></p>
<p>  在新定义的<code>Number</code>类中，所有跨类型函数都作为<code>adders</code>与<code>multipliers</code>的索引。</p>
<p>  在这种基于字典的实现方式是可拓展的，当我们要定义一个<code>Number</code>的新子类时，只需<strong>给它定义一个<code>type_tag</code>，然后把对应的跨类型操作加进<code>Number.adders</code>和<code>Number.multiplier</code>中，同时也可以在子类中定义自己的<code>adders</code>和<code>multipliers</code></strong>
。</p>
<h3 id="3类型强制">3.类型强制</h3>
<p>  在对两种完全不相同的数据类型进行操作时，直接实现跨类型函数是最佳选择。但有时，我们可以利用<strong>类型系统中隐性的附加结构</strong>得到更优解法。</p>
<p>  通常，<strong>不同的数据类型并不是完全独立的，一种数据类型可能是另一种数据类型的子类型</strong>，例如实数就可以被看作虚部为<span class="math inline">\(0\)</span>的复数。这样，我们就可以只用<code>Complex.add</code>与<code>Complex.mul</code>来实现实数虚数的运算了。像这样转换类型的做法被称作<strong>类型强制(<span class="math inline">\(type\;coercion\)</span>)</strong>。</p>
<p>  可以通过以下函数实现类型强制： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">rational_to_complex</span>(<span class="params">r</span>):</span><br><span class="line">        <span class="keyword">return</span> ComplexRI(r.numer/r.denom,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>  包含类型强制的<code>Number</code>类实现如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">            x,y=self.coerce(other)</span><br><span class="line">            <span class="keyword">return</span> x.add(y)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">            x,y=self.coerce(other)</span><br><span class="line">            <span class="keyword">return</span> x.mul(y)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">coerce</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">if</span> self.type_tag==other.type_tag:</span><br><span class="line">                <span class="keyword">return</span> self,other</span><br><span class="line">            <span class="keyword">elif</span> (self.type_tag, other.type_tag) <span class="keyword">in</span> self.coercions:</span><br><span class="line">                <span class="keyword">return</span> (self.coerce_to(other.type_tag), other)</span><br><span class="line">            <span class="keyword">elif</span> (other.type_tag, self.type_tag) <span class="keyword">in</span> self.coercions:</span><br><span class="line">                <span class="keyword">return</span> (self, other.coerce_to(self.type_tag))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">coerce_to</span>(<span class="params">self, other_tag</span>):</span><br><span class="line">            coercion_fn=self.coercions[(self.type_tag, other_tag)]</span><br><span class="line">            <span class="keyword">return</span> coercion_fn(self)</span><br><span class="line">        coercions=&#123;(<span class="string">&#x27;rat&#x27;</span>, <span class="string">&#x27;com&#x27;</span>): rational_to_complex&#125;</span><br></pre></td></tr></table></figure></p>
<p>  类型强制的方法相对于类型分派有新的优势：虽然需要一个<code>coerce_to</code>函数实现类型转换，但<strong>我们只需要写这一个函数，就可以将其他所有的函数归进一个统一的范式中</strong>。这是基于以下思想：类型间的转换<strong>只与类型本身有关、与类型的具体操作无关</strong>。</p>
<p>  类型强制给我们带来了启发：对于两种数据类型，我们可以<strong>设法找到一种中间类型(即前文说的“隐性的附加结构”)，将两种数据类型转换成这个类型</strong>。例如我们可以将矩形和菱形都转化为平行四边形。类似的，不同的中间类型可以转换为新的中间类型<span class="math inline">\(\cdots\)</span>通过这样的链式强制(<span class="math inline">\(chaining\;coercion\)</span>)，我们可以减少程序中需要的<code>coerce</code>函数数量。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>3.2.scheme语言介绍</title>
    <url>/2024/05/31/3.2.scheme%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="32scheme语言介绍"><span class="math inline">\(3.2\;scheme\)</span>语言介绍</h1>
<h3 id="1基本表达式">1.基本表达式</h3>
<h4 id="a数字">  <span class="math inline">\(a.\)</span>数字</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; 1234    ; integer</span><br><span class="line">1234</span><br><span class="line">scm&gt; 123.4   ; real number</span><br><span class="line">123.4</span><br></pre></td></tr></table></figure>
<h4 id="b标志symbol">  <span class="math inline">\(b.\)</span>标志<span class="math inline">\(symbol\)</span></h4>
<p>  标志是<span class="math inline">\(scheme\)</span>语言特有的类型。在<span class="math inline">\(scheme\)</span>语言中，标志本身可以作为一个值，而在<span class="math inline">\(python\)</span>中的“标志”只是作为表达式的名称存在。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; quotient      ; A name bound to a built-in procedure</span><br><span class="line">#[quotient]</span><br><span class="line">scm&gt; &#x27;quotient     ; An expression that evaluates to a symbol</span><br><span class="line">quotient</span><br><span class="line">scm&gt; &#x27;hello-world!</span><br><span class="line">hello-world!</span><br></pre></td></tr></table></figure></p>
<h4 id="c布尔值">  <span class="math inline">\(c.\)</span>布尔值</h4>
<p>  在<span class="math inline">\(scheme\)</span>语言中，除了<code>#f</code>外的所有值都是<span class="math inline">\(true\)</span>，这和<span class="math inline">\(python\)</span>的零值为<span class="math inline">\(false\)</span>不同。<span class="math inline">\(scheme\)</span>用<code>#t</code>表示<span class="math inline">\(true\)</span>，用<code>#f</code>表示<span class="math inline">\(false\)</span>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; #t</span><br><span class="line">#t</span><br><span class="line">scm&gt; #f</span><br><span class="line">#f</span><br></pre></td></tr></table></figure></p>
<h3 id="2调用表达式">2.调用表达式</h3>
<p>  与<span class="math inline">\(Python\)</span>类似，<span class="math inline">\(Scheme\)</span>调用表达式中的操作符位于所有操作数之前。与
<span class="math inline">\(Python\)</span>不同，操作符包含在括号内，且操作数用空格而不是逗号分隔，计算的具体流程如下：</p>
<ol type="1">
<li>计算操作符，决定运算规则。</li>
<li>从左到右考虑操作数。</li>
<li>将运算规则作用于操作数上。</li>
</ol>
<p>  这也是<span class="math inline">\(scheme\)</span>语句一般地执行方法。但之后讲解的规则与这个不同，被称作“特殊规则”。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (+ 1 2)</span><br><span class="line">3</span><br><span class="line">scm&gt; (- 10 (/ 6 2))</span><br><span class="line">7</span><br><span class="line">scm&gt; (modulo 35 4)</span><br><span class="line">3</span><br><span class="line">scm&gt; (even? (quotient 45 2))</span><br><span class="line">#t</span><br></pre></td></tr></table></figure></p>
<h3 id="3控制结构">3.控制结构</h3>
<h4 id="aif语句">  <span class="math inline">\(a.\)</span><code>if</code>语句</h4>
<p>  <span class="math inline">\(scheme\)</span>中的<code>if</code>语句结构如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if &lt;predicate&gt; &lt;if-true&gt; [if-false])</span><br></pre></td></tr></table></figure></p>
<p>  该结构的<code>&lt;if-true&gt;</code>部分与<code>[if-false]</code>部分只能接受一个表达式，与<span class="math inline">\(python\)</span>不同。该结构的一个运行实例如下：</p>
<p><img src="/2024/05/31/3.2.scheme%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/image.png"></p>
<p>  <span class="math inline">\(scheme\)</span>中没有<code>elif</code>语句，实现该功能只能通过<code>if</code>的嵌套：</p>
<p><img src="/2024/05/31/3.2.scheme%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/image-1.png"></p>
<h4 id="bcond表达式">  <span class="math inline">\(b.\)</span><code>cond</code>表达式</h4>
<p>  <code>cond</code>表达式类似<code>switch</code>语句，其结构如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(cond</span><br><span class="line">    (&lt;p1&gt; &lt;e1&gt;)</span><br><span class="line">    (&lt;p2&gt; &lt;e2&gt;)</span><br><span class="line">    ...</span><br><span class="line">    (&lt;pn&gt; &lt;en&gt;)</span><br><span class="line">    [(else &lt;else-expression&gt;)])</span><br></pre></td></tr></table></figure>
  每个从句中的第一个表达式就相当于<code>&lt;predicate&gt;</code>，当<code>&lt;predicate&gt;</code>为真，就执行后面的语句并终止程序。该表达式的一个具体实例如下：</p>
<p><img src="/2024/05/31/3.2.scheme%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/image-2.png"></p>
<h3 id="4数据结构">4.数据结构</h3>
<h4 id="a链表">  <span class="math inline">\(a.\)</span>链表</h4>
<p>  <span class="math inline">\(scheme\)</span>中的链表是通过一系列<span class="math inline">\(pair\)</span>构建的，它通过<span class="math inline">\(constructor\)</span><code>cons</code>创建。</p>
<p>  链表的<span class="math inline">\(rest\)</span>元素，即<code>cdr</code>操作，是别的链表或<code>nil</code>，空链表：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (cons 1 (cons 2 (cons 3 nil)))</span><br><span class="line">(1 2 3)</span><br></pre></td></tr></table></figure></p>
<p>  可以通过<code>car</code>与<code>cdr</code>语句获取链表中的元素值：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (define a (cons 1 (cons 2 (cons 3 nil))))  ; Assign the list to the name a</span><br><span class="line">a</span><br><span class="line">scm&gt; a</span><br><span class="line">(1 2 3)</span><br><span class="line">scm&gt; (car a)</span><br><span class="line">1</span><br><span class="line">scm&gt; (cdr a)</span><br><span class="line">(2 3)</span><br><span class="line">scm&gt; (car (cdr (cdr a)))</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>  如果在<span class="math inline">\(pair\)</span>中不传入另一个<span class="math inline">\(pair\)</span>或<code>nil</code>作为<code>cons</code>的第二个参数，程序会报错：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (cons 1 2)</span><br><span class="line">Error</span><br></pre></td></tr></table></figure></p>
<h4 id="b列表">  <span class="math inline">\(b.\)</span>列表</h4>
<p>  创建列表的方法有很多种，可以直接用<code>list</code>创建：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (list 1 2 3)</span><br><span class="line">(1 2 3)</span><br><span class="line">scm&gt; (list 1 (list 2 3) 4)</span><br><span class="line">(1 (2 3) 4)</span><br><span class="line">scm&gt; (list (cons 1 (cons 2 nil)) 3 4)</span><br><span class="line">((1 2) 3 4)</span><br></pre></td></tr></table></figure></p>
<p>  注意<code>cons</code>函数只能接受两个参数，如果要在一个链表里面插入多个元素，可以采用多个<code>cons</code>嵌套的方法：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (interleave first second)</span><br><span class="line">  &#x27;YOUR-CODE-HERE</span><br><span class="line">  (cond</span><br><span class="line">  ((null? first) second)</span><br><span class="line">  ((null? second) first)</span><br><span class="line">  (else (cons (car first)</span><br><span class="line">    (cons (car second)</span><br><span class="line">      (interleave (cdr first) (cdr second))))))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>  还可以通过单引号语句创建，语句中的<code>'</code>不会被读入：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; &#x27;(1 2 3)</span><br><span class="line">(1 2 3)</span><br><span class="line">scm&gt; &#x27;(cons 1 2)           ; Argument to quote is not evaluated</span><br><span class="line">(cons 1 2)</span><br><span class="line">scm&gt; &#x27;(1 (2 3 4))</span><br><span class="line">(1 (2 3 4))</span><br></pre></td></tr></table></figure></p>
<p>  列表有与<span class="math inline">\(python\)</span>类似的操作：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (null? nil)                ; Checks if a value is the empty list</span><br><span class="line">True</span><br><span class="line">scm&gt; (append &#x27;(1 2 3) &#x27;(4 5 6)) ; Concatenates two lists</span><br><span class="line">(1 2 3 4 5 6)</span><br><span class="line">scm&gt; (length &#x27;(1 2 3 4 5))      ; Returns the number of elements in a list</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<h3 id="5定义语句">5.定义语句</h3>
<p>  定义语句用于定义变量与函数。定义语句的结构如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define &lt;name&gt; &lt;expression&gt;)</span><br></pre></td></tr></table></figure>
  该语句通过以下流程实现： 1. 计算<code>&lt;expression&gt;</code>的值 2.
将值与<code>name</code>绑定 3. 返回<code>name</code></p>
<p>  只有在调用<code>define</code>时<code>&lt;body&gt;</code>才会被执行。</p>
<h3 id="6lambdas">6.<span class="math inline">\(lambdas\)</span></h3>
<p>  <span class="math inline">\(scheme\)</span>中的<span class="math inline">\(lambda\)</span>语句如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(lambda (&lt;param1&gt; &lt;param2&gt; ...) &lt;body&gt;)</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(lambda\)</span>的具体实例如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (lambda (x y) (+ x y))        ; Returns a lambda function, but doesn&#x27;t assign it to a name</span><br><span class="line">(lambda (x y) (+ x y))</span><br><span class="line">scm&gt; ((lambda (x y) (+ x y)) 3 4)  ; Create and call a lambda function in one line</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 3.Interpreting Computer Programs</category>
      </categories>
  </entry>
  <entry>
    <title>3.5.包含抽象的语言的解释器</title>
    <url>/2024/05/31/3.5.%E5%8C%85%E5%90%AB%E6%8A%BD%E8%B1%A1%E7%9A%84%E8%AF%AD%E8%A8%80%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
    <content><![CDATA[<h1 id="35包含抽象的语言的解释器interpretersforlanguageswithabstraction"><span class="math inline">\(3.5\)</span>包含抽象的语言的解释器(<span class="math inline">\(Interpreters\;for\;Languages\;with\;Abstraction\)</span>)</h1>
<p>  先前<code>Calcualtor</code>的实现并未给出定义新操作、给变量命名、表达计算的一般方法等的实现。下面给出描述性的实现方法：</p>
<h3 id="1结构">1.结构</h3>
<p>  一个<span class="math inline">\(scheme\)</span>解释器和先前的计算器解释器有很多相似的结构：</p>
<ul>
<li><strong>分析器</strong>通过计算器解释(<span class="math inline">\(evaluator\;interpretation\)</span>)来<strong>产生一个表达式</strong>。</li>
<li><strong>计算函数侦测表达式的形式</strong>；对于<strong>调用表达式，它会调用一个函数用于处理某些参数</strong>。</li>
</ul>
<p>  两者的计算器(<span class="math inline">\(evaluator\)</span>)的区别存在于特殊的形式(<span class="math inline">\(special\;form\)</span>)，用户定义函数(<span class="math inline">\(user-defined\;function\)</span>)和实现计算所需的环境模型(<span class="math inline">\(the\;environment\;model\;of\;computation\)</span>)。</p>
<h4 id="a解析parsing">  <span class="math inline">\(a.\)</span>解析(<span class="math inline">\(Parsing\)</span>)</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; read_line(&quot;(car &#x27;(1 . 2))&quot;)</span><br><span class="line">Pair(&#x27;car&#x27;, Pair(Pair(&#x27;quote&#x27;, Pair(Pair(1, 2), nil)), nil))</span><br></pre></td></tr></table></figure>
<h4 id="b计算evaluation">  <span class="math inline">\(b.\)</span>计算(<span class="math inline">\(evaluation\)</span>)</h4>
<p>  <span class="math inline">\(Scheme\)</span>每次计算一个表达式。每个<strong>通过<code>scheme_read</code>返回的表达式</strong>都<strong>传递给<code>scheme_eval</code>函数</strong>，它会在当前环境<code>env</code>中计算表达式<code>expr</code>。</p>
<p>  <code>scheme_eval</code>函数会计算<span class="math inline">\(Scheme\)</span>中的不同表达式类型：初始型(<span class="math inline">\(primitive\)</span>)，特殊型(<span class="math inline">\(special\;form\)</span>)和调用表达式(<span class="math inline">\(call\;expression\)</span>)。每种形式都有它们对应的计算法则：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scheme_eval</span>(<span class="params">expr, env</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Evaluate Scheme expression expr in environment env.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> scheme_symbolp(expr):</span><br><span class="line">            <span class="keyword">return</span> env[expr]</span><br><span class="line">        <span class="keyword">elif</span> scheme_atomp(expr):</span><br><span class="line">            <span class="keyword">return</span> expr</span><br><span class="line">        first, rest = expr.first, expr.second</span><br><span class="line">        <span class="keyword">if</span> first == <span class="string">&quot;lambda&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> do_lambda_form(rest, env)</span><br><span class="line">        <span class="keyword">elif</span> first == <span class="string">&quot;define&quot;</span>:</span><br><span class="line">            do_define_form(rest, env)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            procedure = scheme_eval(first, env)</span><br><span class="line">            args = rest.<span class="built_in">map</span>(<span class="keyword">lambda</span> operand: scheme_eval(operand, env))</span><br><span class="line">            <span class="keyword">return</span> scheme_apply(procedure, args, env)</span><br></pre></td></tr></table></figure></p>
<h4 id="c过程调用procedureapplication">  <span class="math inline">\(c.\)</span>过程调用(<span class="math inline">\(Procedure\;application\)</span>)</h4>
<p>  过程调用通过<code>scheme_apply</code>实现。它比起先前的<code>calc_apply</code>更具普遍性。它接受两类参数：<code>PrimitiveProcedure</code>或<code>LambdaProcedure</code>。</p>
<p>  <code>PrimitiveProcedure</code>是在<span class="math inline">\(python\)</span>中实现的，它有一个<code>fn</code>的实例属性(<span class="math inline">\(instance\;attribute\)</span>)，<strong>每当过程被调用，这个函数就被调用</strong>。</p>
<p>  <code>LambdaProcedure</code>是在<span class="math inline">\(scheme\)</span>中实现的。它有一个<code>body</code>属性，这是一个<span class="math inline">\(scheme\)</span>表达式，<strong>每当过程被调用它就被调用</strong>。为了将该过程用于一系列参数，<code>body</code>表达式<strong>会在一个新环境里被调用</strong>。为了搭建环境，<strong>一个新的框架被加入进环境中，在这个框架中，过程的形式参数(<span class="math inline">\(formal\;parameters\)</span>)与变量(<span class="math inline">\(argument\)</span>)绑定</strong>。<code>body</code><strong>通过<code>scheme_eval</code>计算</strong>。</p>
<h4 id="d递归调用与计算evalapplyrecursion">  <span class="math inline">\(d.\)</span>递归调用与计算(<span class="math inline">\(Eval/apply\;recursion\)</span>)</h4>
<p>  实现计算过程的<code>scheme_eval</code>和<code>scheme_apply</code>是<strong>相互递归</strong>的(<span class="math inline">\(mutually\;recursive\)</span>)。<strong>每当一个调用表达式被计算，计算函数都需要被调用</strong>。而<strong>应用函数使用计算函数将操作元表达式作为参数，并计算用户定义的过程这一部分(<span class="math inline">\(user-defined\;procedures\)</span>)</strong>。这一相互递归的过程是由下面这个过程决定的：计算函数是通过(<span class="math inline">\(in\;terms\;of\)</span>)应用函数定义的，而应用函数又是通过计算函数定义的。</p>
<p>  递归的循环<strong>以语言原语(<span class="math inline">\(language\;primitive\)</span>)结束</strong>。计算函数<strong>有一个用于计算基本表达式的基本情况</strong>。一些特殊形式(<span class="math inline">\(special\;form\)</span>)也是不需要递归调用的基本情况。</p>
<p>  这种<strong>处理表达式形式(<span class="math inline">\(expression\;form\)</span>)</strong> 的<span class="math inline">\(eval\)</span>函数与<strong>处理函数及其参数</strong>的<span class="math inline">\(apply\)</span>函数相互递归调用的结构组成了计算过程的核心。</p>
<h3 id="2环境">2.环境</h3>
<h4 id="a基本结构">  <span class="math inline">\(a.\)</span>基本结构</h4>
<p>  我们希望实现一个<code>Frame</code>类来构建环境。<strong>每个<code>Frame</code>的实例都代表一个环境</strong>，在这个实例中，<strong>标记(<span class="math inline">\(symbol\)</span>)与值(<span class="math inline">\(value\)</span>)相绑定</strong>。</p>
<p>  <code>Frame</code>实例由<strong>一个<code>binding</code>字典和<code>parant</code>框架</strong>构成。对于<span class="math inline">\(Global\)</span>框架，<code>parent=None</code>。</p>
<h4 id="bbinding和define">  <span class="math inline">\(b.\)</span><code>binding</code>和<code>define</code></h4>
<p>  <code>binding</code>并不是直接访问的，它通过两个<code>Frame</code>方法访问：<code>lookup</code>和<code>define</code>。<code>lookup</code>过程会在<strong>我们的环境模型中执行<span class="math inline">\(lookup\)</span>过程</strong>。然后<strong>符号与当前<code>frame</code>的<code>binding</code>相匹配</strong>。如果它<strong>找到了，它相关联的值就被返回</strong>；否则，<code>lookup</code>过程会<strong>在<code>parent frame</code>继续该过程</strong>。而<code>define</code>方法<strong>在当前<code>frame</code>中将标记与值相绑定</strong>。</p>
<p>  考虑下面的程序： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (factorial n)</span><br><span class="line">  (if (= n 0) 1 (* n (factorial (- n 1)))))</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(factorial 5)</span><br><span class="line">120</span><br></pre></td></tr></table></figure></p>
<p>  定义这样一个函数有以下步骤：</p>
<ol type="1">
<li><strong>检查表达式的格式(<span class="math inline">\(format\)</span>)</strong>，确保<strong>它是一个完备的<span class="math inline">\(Scheme\)</span>列表，至少有两个元素与关键字<span class="math inline">\(define\)</span></strong>。</li>
<li><strong>分析第一个元素</strong>。在本例中，寻找函数名称<span class="math inline">\(factorial\)</span>和形式参数<span class="math inline">\(list(n)\)</span>。</li>
<li><strong>用提供的形式参数创造一个<code>LambdaProcedure</code>，<code>body</code>和<code>parent</code>环境</strong>。</li>
<li><strong>在当前环境的第一个<code>frame</code>中，将<span class="math inline">\(factorial\)</span>标志与这个函数绑定</strong>。</li>
</ol>
<p>  第二个输入是一个调用表达式。传给<code>scheme_apply</code>的过程是与<span class="math inline">\(factorial\)</span>相绑定的<code>LambdaProcedure</code>。<strong>为了应用这一过程，一个新的框架创建了，扩展了原来的父框架</strong>。在这个框架中，标志<span class="math inline">\(n\)</span>与值<span class="math inline">\(5\)</span>绑定。然后，<span class="math inline">\(factorial\)</span>的<code>body</code>部分在这个环境中被计算，它的值也被返回。</p>
<h3 id="3作为程序的数据">3.作为程序的数据</h3>
<p>  我们可以从模拟(<span class="math inline">\(analogy\)</span>)的角度来看待程序。对程序含义的操作观点(<span class="math inline">\(optional\;view\)</span>)认为：<strong>程序是对一个抽象机器的描述</strong>。以先前的函数为例：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (factorial n)</span><br><span class="line">  (if (= n 0) 1 (* n (factorial (- n 1)))))</span><br></pre></td></tr></table></figure></p>
<p>  我们可以将这个程序看作对一个机器的描述，这个机器包括减法、乘法、相等性测试、双向开关和另一个<span class="math inline">\(factorial\)</span>机器(由于一个机器内部可以嵌套另一个机器，这个机器是<strong>无限的</strong>)：</p>
<p><img src="/2024/05/31/3.5.%E5%8C%85%E5%90%AB%E6%8A%BD%E8%B1%A1%E7%9A%84%E8%AF%AD%E8%A8%80%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/image-3.png"></p>
<p>  相似地，我们可以将<span class="math inline">\(Scheme\)</span>解释器视为一个特别的机器，<strong>它将一个对机器的描述作为输入。对于这个输入，解释器配置好自己来模拟这个描述的机器</strong>。</p>
<p>  从这个角度，我们的<span class="math inline">\(Scheme\)</span>解释器是一种具有普遍性的机器。<strong>当其它机器在<span class="math inline">\(Scheme\)</span>程序中被描述时，解释器会模拟这些机器。它扮演着被编程语言操纵的数据对象和编程语言本身之间的桥梁</strong>。对于用户的输入，解释器将其视为一个简单的句子，并通过一系列完备规则操作它们。</p>
<p>  计算作为执行过程一部分的表达式是一个有活力的编程语言所具的特点。在程序的执行过程中创建并计算表达式的能力是一个有力的工具。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 3.Interpreting Computer Programs</category>
      </categories>
  </entry>
  <entry>
    <title>3.4.带有组合的语言的解释器</title>
    <url>/2024/05/31/3.4.%E5%B8%A6%E6%9C%89%E7%BB%84%E5%90%88%E7%9A%84%E8%AF%AD%E8%A8%80%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
    <content><![CDATA[<h1 id="34带有组合的语言的解释器interpretersforlanguageswithcombination">3.4
带有组合的语言的解释器(<span class="math inline">\(Interpreters\;for\;Languages\;with\;Combination\)</span>)</h1>
<h2 id="一-概述">一、概述</h2>
<p>  在程序中，我们不仅可以定义一个新语言，还可以通过<strong>构建解释器(<span class="math inline">\(interpreter\)</span>)</strong>
来实现这些语言。而<strong>编程语言的解释器就是一个函数，这个函数在用在表达式或语言上时，可以表现出相应的行为来执行它们</strong>。</p>
<p>  <span class="math inline">\(scheme\)</span>语言计算器(<span class="math inline">\(Scheme-Syntax\;Calculator\)</span>)是用于加减乘除操作的表达式语言。它使用<span class="math inline">\(scheme\)</span>的句法规则与<span class="math inline">\(operator\)</span>行为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (+ 1 2 3 4)</span><br><span class="line">10</span><br><span class="line">&gt; (+)</span><br><span class="line">0</span><br><span class="line">&gt; (* 1 2 3 4)</span><br><span class="line">24</span><br><span class="line">&gt; (*)</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">&gt; (- 10 1 2 3)</span><br><span class="line">4</span><br><span class="line">&gt; (- 3)</span><br><span class="line">-3</span><br><span class="line">&gt; (/ 15 12)</span><br><span class="line">1.25</span><br><span class="line">&gt; (/ 30 5 2)</span><br><span class="line">3</span><br><span class="line">&gt; (/ 10)</span><br><span class="line">0.1</span><br></pre></td></tr></table></figure></p>
<p>  调用表达式(<span class="math inline">\(call\;expression\)</span>)的计算方法是<strong>计算它的子表达式，然后将运算符用于计算后的结果</strong>：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (- 100 (* 7 (+ 8 (/ -12 -3))))</span><br><span class="line">16.0</span><br></pre></td></tr></table></figure></p>
<h2 id="二-表达式树expressiontrees">二、表达式树<span class="math inline">\(Expression\;Trees\)</span></h2>
<p>  一个<strong>最原始的表达式是一个单独的数字或字符串</strong>，其数据类型为<code>int</code>或<code>float</code>或<code>operator symbol</code>.而<strong>一个调用表达式是一个<span class="math inline">\(scheme\;list\)</span></strong>，表达式的<strong>第一个元素是操作符<span class="math inline">\(operator\)</span></strong>，后面<strong>是<span class="math inline">\(0\)</span>或者更多的操作元表达式(<span class="math inline">\(operand\;expression\)</span>)</strong>。<strong>所有的组合表达式都是调用表达式</strong>。</p>
<h3 id="1pair">1.<code>Pair</code></h3>
<p>  <code>List</code>是嵌套的<code>Pair</code>，反之则不然。因此有必要定义一个单独的<code>Pair</code>型。</p>
<p>  在<span class="math inline">\(scheme\)</span>中，<code>Pair</code>类是用<span class="math inline">\(python\)</span>表示的<span class="math inline">\(scheme\)</span>值，它们有<code>repr</code>的<span class="math inline">\(python\)</span>表达式和<code>str</code>的<span class="math inline">\(scheme\)</span>表达式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Pair(1, Pair(2, nil))</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">Pair(1, Pair(2, nil))</span><br><span class="line">&gt;&gt;&gt; print(s)</span><br><span class="line">(1 2)</span><br></pre></td></tr></table></figure></p>
<p>  它们实现了长度、元素选择等基本的<span class="math inline">\(python\)</span>序列接口，其中的<code>map</code>方法会<strong>返回一个映射后的<span class="math inline">\(scheme\)</span>列表</strong>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x+<span class="number">4</span>))</span><br><span class="line">(<span class="number">5</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="2嵌套列表">2.嵌套列表</h3>
<p>  嵌套<code>Pair</code>能够表达<code>List</code>，而<code>List</code>自身也可以通过嵌套得到新的<code>List</code>。因此，<code>Pair</code>足够表示所有的<code>List</code>型数据，也因此足够表示所有的<span class="math inline">\(Scheme\)</span>表达式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; expr = Pair(&#x27;+&#x27;, Pair(Pair(&#x27;*&#x27;, Pair(3, Pair(4, nil))), Pair(5, nil)))</span><br><span class="line">&gt;&gt;&gt; print(expr)</span><br><span class="line">(+ (* 3 4) 5)</span><br><span class="line">&gt;&gt;&gt; print(expr.second.first)</span><br><span class="line">(* 3 4)</span><br><span class="line">&gt;&gt;&gt; expr.second.first.second.first</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
  上述例子说明了<strong>所有的计算表达式都是嵌套的<span class="math inline">\(Scheme\)</span><code>List</code></strong>。我们的计算器解释器将会<strong>读入这些嵌套的<span class="math inline">\(Scheme\)</span><code>List</code>，将它们转化为用嵌套<code>Pair</code>实例代表的表达式树，然后通过计算表达式树来产生值</strong>。</p>
<h2 id="三-对表达式的语法分析">三、对表达式的语法分析</h2>
<h3 id="1概述">1.概述</h3>
<p>  语法分析(<span class="math inline">\(parsing\)</span>)是<strong>从原始文本输入产生表达式</strong>的过程。</p>
<p>  语法翻译器由两部分构成：<strong>词法分析器(<span class="math inline">\(lexical\;analyzer\)</span>)</strong>
和<strong>句法分析器(<span class="math inline">\(syntactic\;analyzer\)</span>)</strong>。首先，词法分析器<strong>将输入文本分成标记(<span class="math inline">\(tokens\)</span>)</strong>。标记是<strong>最小的句法单元</strong>，如<code>name</code>、<code>symbol</code>类型。然后，句法分析器<strong>通过标记序列(<span class="math inline">\(tokens\;sequence\)</span>)搭建表达式树</strong>，消耗掉词法分析器产生的标记序列。</p>
<h3 id="2词法分析">2.词法分析</h3>
<p>  <strong>将字符串解释为标记序列</strong>的部分称为标记器(<span class="math inline">\(tokenizer\)</span>)或词法分析器。在我们的实现中，标记器是<code>tokenize_line</code>函数。</p>
<p>  <span class="math inline">\(scheme\)</span>的标记间由空格、逗号、点等符号相隔。<strong>标记器一个字符一个字符地分析句子，验证其中符号(<span class="math inline">\(symbol\)</span>)与数字(<span class="math inline">\(numeral\)</span>)的格式</strong>。下面是一个标记器的分析结果：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokenize_line(<span class="string">&#x27;(+ 1 (* 2.3 45))&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="number">2.3</span>, <span class="number">45</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;)&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<p>  词法分析是一个迭代的过程，它可以独立地用于一个输入程序的每一行。</p>
<h3 id="3句法分析">3.句法分析</h3>
<p>  将<strong>标记序列转化为表达式树</strong>的部分被称为句法分析器。句法分析是一个树形递归(<span class="math inline">\(tree-recursive\)</span>)的过程，它不仅要考虑行内表达式，还要考虑扩张到多个行的表达式。</p>
<p>  句法分析是通过<code>scheme_read</code>函数实现的。它是树形递归的，因为<strong>分析一个标记序列经常需要将它的一些子列分析进一个子表达式中，子表达式本身充当较大表达式树的分支</strong>。递归生成了<strong>计算器使用的层次结构(<span class="math inline">\(hierarchical\;structure\)</span>)</strong>。</p>
<p>  <code>scheme_read</code>函数希望它的<code>src</code>输入是一个允许访问标记序列的<span class="math inline">\(Buffer\)</span>实例。<span class="math inline">\(Buffer\)</span>会<strong>将扩展到很多行的标记收集为一个单独的对象</strong>，这个对象可以被进行句法分析：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = [<span class="string">&#x27;(+ 1&#x27;</span>, <span class="string">&#x27;   (* 2.3 45))&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expression = scheme_read(Buffer(tokenize_lines(lines)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expression</span><br><span class="line">Pair(<span class="string">&#x27;+&#x27;</span>, Pair(<span class="number">1</span>, Pair(Pair(<span class="string">&#x27;*&#x27;</span>, Pair(<span class="number">2.3</span>, Pair(<span class="number">45</span>, nil))), nil)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(expression)</span><br><span class="line">(+ <span class="number">1</span> (* <span class="number">2.3</span> <span class="number">45</span>))</span><br></pre></td></tr></table></figure></p>
<p>  <code>scheme_read</code>函数先检查众多基础的情况，包括空的输入(<span class="math inline">\(empty\;input\)</span>)(这会导致<span class="math inline">\(end-of-file\)</span>错误，即<code>EOFError</code>)和基本表达式。<strong>只要<code>(</code>标记了列表的开头，<code>read_tail</code>就被递归地调用</strong>。</p>
<p>  <code>read_tail</code>函数也从同样的<code>src</code>中读取，但它希望<strong>在<code>List</code>的开头被调用</strong>。它的基本情况(<span class="math inline">\(base\;cases\)</span>)是一个<strong>空输入(<code>EOF</code>)或者一个结束括号(<code>)</code>)终止列表</strong>。它的递归调用会<strong>先使用<code>scheme_read</code>读取<code>List</code>中的第一个元素，再用<code>read_tail</code>读入<code>List</code>中的剩余元素，然后返回一个用<code>Pair</code>表示的列表</strong>。</p>
<p>  提供信息的句法错误大大提高了解释器的可用性，它引发的<code>SyntaxError</code>异常包括了所遇到问题的声明。</p>
<h2 id="四-计算器的计算">四、计算器的计算</h2>
<h3 id="1计算器表达式的转换">1.计算器表达式的转换</h3>
<p>  对于计算器，<strong>唯一的两个合法的句法形式是数字(<span class="math inline">\(numbers\)</span>)和调用表达式(<span class="math inline">\(call\;expressions\)</span>)</strong>，即经过良好组织的<span class="math inline">\(scheme\)</span><code>List</code>，它们是以<code>Pair</code>形式存在的。数字自己就可以计算出一个值，它们可以直接被<code>calc_eval</code>返回。而<strong>调用表达式需要对其应用函数(<span class="math inline">\(function\;application\)</span>)才可返回值</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_eval</span>(<span class="params">exp</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Evaluate a Calculator expression.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># number type</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(exp) <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>):</span><br><span class="line">            <span class="keyword">return</span> simplify(exp)</span><br><span class="line">        <span class="comment"># list type as pair instance</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(exp, Pair):</span><br><span class="line">            arguments = exp.second.<span class="built_in">map</span>(calc_eval)</span><br><span class="line">            <span class="keyword">return</span> simplify(calc_apply(exp.first, arguments))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(exp + <span class="string">&#x27; is not a number or call expression&#x27;</span>)</span><br></pre></td></tr></table></figure>   这里，当传入的参数为<span class="math inline">\(call\;expression\)</span>时，<code>argument</code>对<code>Pair</code>除了第一个元素外的所有元素<strong>调用<code>calc_eval</code>函数，并通过<code>map</code>操作将结果映射到原来的<code>Pair</code>中</strong>，最后对只有两个元素的<code>Pair</code>进行最后的化简。</p>
<p>  <code>calc_eval</code>的结构是根<strong>据类型分派的典型例子：根据表达式形式分派</strong>。</p>
<p>  这里引入一个新的概念：不需要多余计算步骤的原始表达式叫作“自我计算式”(<span class="math inline">\(self-evaluating\)</span>)，除了数字，字符串、布尔值都是自我计算式。</p>
<h3 id="2计算器的计算">2.计算器的计算</h3>
<p>  可以通过如下程序实现表达式的计算，其中的每一个条件语句分别作用于一个操作符：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_apply</span>(<span class="params">operator, args</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Apply the named operator to a list of args.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(operator, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="built_in">str</span>(operator) + <span class="string">&#x27; is not a symbol&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> operator == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> reduce(add, args, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> operator == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> TypeError(operator + <span class="string">&#x27; requires at least 1 argument&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(args) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -args.first</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> reduce(sub, args.second, args.first)</span><br><span class="line">        <span class="keyword">elif</span> operator == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> reduce(mul, args, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> operator == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> TypeError(operator + <span class="string">&#x27; requires at least 1 argument&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(args) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>/args.first</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> reduce(truediv, args.second, args.first)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(operator + <span class="string">&#x27; is an unknown operator&#x27;</span>)</span><br></pre></td></tr></table></figure>
  <code>calc_apply</code>函数可以直接调用，但传入的参数<strong>必须是值的列表</strong>而不是操作数表达式(<span class="math inline">\(a\;list\;of\;operand\;expressions\)</span>)：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_apply(<span class="string">&#x27;+&#x27;</span>, as_scheme_list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_apply(<span class="string">&#x27;-&#x27;</span>, as_scheme_list(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_apply(<span class="string">&#x27;*&#x27;</span>, nil)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_apply(<span class="string">&#x27;*&#x27;</span>, as_scheme_list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_apply(<span class="string">&#x27;/&#x27;</span>, as_scheme_list(<span class="number">40</span>, <span class="number">5</span>))</span><br><span class="line"><span class="number">8.0</span></span><br></pre></td></tr></table></figure></p>
<p>  先前的<code>calc_eval</code>的作用是<strong>先计算操作数子表达式的值，然后决定合适的<code>calc_apply</code>调用</strong>。因此，<code>calc_eval</code><strong>可以接受嵌套表达式</strong>作为参数：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(exp)</span><br><span class="line">(+ (* <span class="number">3</span> <span class="number">4</span>) <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_eval(exp)</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3读取-计算-打印流程">3.“读取-计算-打印”流程</h3>
<h4 id="a解释器的一般范式">  <span class="math inline">\(a.\)</span>解释器的一般范式</h4>
<p>  与解释器交互的一般流程是
<strong>“读取-计算-打印”流程</strong>，即：先读入表达式，再计算表达式，最后打印计算出的值。</p>
<p>  下面展示这一流程的一般实现。<code>read_eval_print_loop</code>函数先将用户的输入<span class="math inline">\(buffer\)</span>化，然后用特定语言函数(<span class="math inline">\(language-specific\)</span>)构建表达式，最后打印通过<code>calc_eval</code>计算出的结果：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_eval_print_loop</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run a read-eval-print loop for calculator.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            src = buffer_input()</span><br><span class="line">            <span class="keyword">while</span> src.more_on_line:</span><br><span class="line">                expression = scheme_read(src)</span><br><span class="line">                <span class="built_in">print</span>(calc_eval(expression))</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; (* <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; (+)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt; (+ <span class="number">2</span> (/ <span class="number">4</span> <span class="number">8</span>))</span><br><span class="line"><span class="number">2.5</span></span><br><span class="line">&gt; (+ <span class="number">2</span> <span class="number">2</span>) (* <span class="number">3</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">&gt; (+ <span class="number">1</span></span><br><span class="line">     (- <span class="number">23</span>)</span><br><span class="line">     (* <span class="number">4</span> <span class="number">2.5</span>))</span><br><span class="line">-<span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<h4 id="b优化">  <span class="math inline">\(b.\)</span>优化</h4>
<p>  上述交互接口包含所有接口必须的要素，但是缺少终止与错误处理机制。我们可以通过将错误报告给用户对其进行优化：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_eval_print_loop</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run a read-eval-print loop for calculator.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                src = buffer_input()</span><br><span class="line">                <span class="keyword">while</span> src.more_on_line:</span><br><span class="line">                    expression = scheme_read(src)</span><br><span class="line">                    <span class="built_in">print</span>(calc_eval(expression))</span><br><span class="line">            <span class="keyword">except</span> (SyntaxError, TypeError, ValueError, ZeroDivisionError) <span class="keyword">as</span> err:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">type</span>(err).__name__ + <span class="string">&#x27;:&#x27;</span>, err)</span><br><span class="line">            <span class="keyword">except</span> (KeyboardInterrupt, EOFError):  <span class="comment"># &lt;Control&gt;-D, etc.</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Calculation completed.&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure>   这一流程实现报告用户的错误，但不退出流程：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; )</span><br><span class="line">SyntaxError: unexpected token: )</span><br><span class="line">&gt; <span class="number">2.3</span><span class="number">.4</span></span><br><span class="line">ValueError: invalid numeral: <span class="number">2.3</span><span class="number">.4</span></span><br><span class="line">&gt; +</span><br><span class="line">TypeError: + <span class="keyword">is</span> <span class="keyword">not</span> a number <span class="keyword">or</span> call expression</span><br><span class="line">&gt; (/ <span class="number">5</span>)</span><br><span class="line">TypeError: / requires exactly <span class="number">2</span> arguments</span><br><span class="line">&gt; (/ <span class="number">1</span> <span class="number">0</span>)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure></p>
<h2 id="五-总结">五、总结</h2>
<p>  当我们将我们的解释器用于新的语言时，我们会发现<code>read_eval_print_loop</code><strong>被解析函数、计算函数、错误输出语句参数化</strong>了。除了这些差别，所有的<span class="math inline">\(REPLs\)</span>都可以用相同的框架实现。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 3.Interpreting Computer Programs</category>
      </categories>
  </entry>
  <entry>
    <title>4.1.接口</title>
    <url>/2024/05/31/4.1.interface/</url>
    <content><![CDATA[<h1 id="41接口"><span class="math inline">\(4.1\)</span>接口</h1>
<h3 id="1上位词-下位词">1.上位词、下位词</h3>
<p>  在日常语言中，词语、对象之间具有逻辑上的层次性，例如：狗(<span class="math inline">\(dog\)</span>)是贵宾犬、哈士奇等的上位词(<span class="math inline">\(hypernym\)</span>)，而贵宾犬、哈士奇等是狗的下位词(<span class="math inline">\(hyponyms\)</span>)。</p>
<p>  上位词与下位词描述的是一种<span class="math inline">\(is-a\)</span>的层次关系：</p>
<ul>
<li>贵宾犬<span class="math inline">\(is-a\)</span>狗</li>
<li>狗<span class="math inline">\(is-a\)</span>动物</li>
</ul>
<p><img src="/2024/05/31/4.1.interface/image.png"></p>
<p>  同样地，我们前面讲解的<span class="math inline">\(SLList\)</span>与<span class="math inline">\(AList\)</span>也是链表的下位词。在<span class="math inline">\(Java\)</span>中，<span class="math inline">\(SLList\)</span>是<span class="math inline">\(List61B\)</span>的子类(<span class="math inline">\(subclass\)</span>)，<span class="math inline">\(List61B\)</span>是<span class="math inline">\(SLList\)</span>的主类(<span class="math inline">\(superclass\)</span>)。</p>
<p><img src="/2024/05/31/4.1.interface/image-1.png"></p>
<h3 id="2接口">2.接口</h3>
<p>  在<span class="math inline">\(Java\)</span>中，为了表达上述的层次结构，我们会进行以下操作：</p>
<ul>
<li>为通用列表(<span class="math inline">\(hypernym\)</span>)定义一个类型——我们将选择名称<span class="math inline">\(List61B\)</span>。</li>
<li>指定<span class="math inline">\(SLList\)</span>与<span class="math inline">\(ALList\)</span>是<span class="math inline">\(List61B\)</span>的下位词。</li>
</ul>
<p>  这里的<span class="math inline">\(List61B\)</span>被称为接口(<span class="math inline">\(interface\)</span>)。它本质上是一个契约(<span class="math inline">\(contract\)</span>)，记录了一个链表必须能够做的方法，但它不提供任何方法的实现。下面是<span class="math inline">\(List61B\)</span>的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List61B</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> add <span class="title function_">Last</span><span class="params">(Item y)</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item x, <span class="type">int</span> position)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <span class="math inline">\(AList\)</span>等可以如下定义：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">List61B</span>&lt;Item&gt;&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这里的<code>implements List61B&lt;Item&gt;</code>实际上是一种承诺(<span class="math inline">\(promise\)</span>)，保证<span class="math inline">\(AList\)</span>实现了接口要求实现的方法。</p>
<h3 id="3覆盖">3.覆盖</h3>
<p>  在实现接口所需的方法时，在方法前面涵盖一个<code>@Override</code>的标记是很有用的：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">    insert(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4接口的继承">4.接口的继承</h3>
<p>  接口的继承(<span class="math inline">\(inheritance\)</span>)指代了一种关系，即子类继承了主类的所有的方法与行为。在我们定义的<span class="math inline">\(List61B\)</span>中，接口继承了所有的方法签名(<span class="math inline">\(signature\)</span>)，但不包括实现。</p>
<h3 id="5groe">5.<span class="math inline">\(GRoE\)</span></h3>
<p>  在定义了<span class="math inline">\(is-a\)</span>关系后，我们就可以实现以下语句了：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLList&lt;String&gt; someList = <span class="keyword">new</span> <span class="title class_">List61B</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure></p>
<p>  这是因为<span class="math inline">\(SLList\)</span><span class="math inline">\(is-a\)</span><span class="math inline">\(List61B\)</span>，这说明<span class="math inline">\(SLList\)</span>可以放进<span class="math inline">\(List61B\)</span>的内存盒子中，因此可以这么写。但反过来则不对。</p>
<h3 id="5实现的继承">5.实现的继承</h3>
<p>  之前对接口的讲解中，我们说<span class="math inline">\(List61B\)</span>中只有标识<span class="math inline">\(List61B\)</span>做什么(<span class="math inline">\(what\)</span>)的方法名称(<span class="math inline">\(method\;header\)</span>)。接下来我们在<span class="math inline">\(List61B\)</span>中实现具体的方法。</p>
<p>  如果我们在<span class="math inline">\(List61B\)</span>中加入如下方法： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  那么，所有对<span class="math inline">\(List61B\)</span>的实现(<span class="math inline">\(implements\)</span>)都可以使用这个方法。</p>
<p>  但是，该方法中的<span class="math inline">\(get(i)\)</span>函数对<span class="math inline">\(SLList\)</span>来说效率过低，于是我们可以在<span class="math inline">\(SLList\)</span>子类中覆盖这一方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">        System.out.print(p.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样，在对<span class="math inline">\(SLList\)</span>调用<span class="math inline">\(print()\)</span>时，<span class="math inline">\(SLList\)</span>就会使用覆盖后的方法了。</p>
<h3 id="6动态方法选择">6.动态方法选择</h3>
<p>  我们知道，<span class="math inline">\(Java\)</span>中的每一个变量都有一个类型：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List61B&lt;String&gt; lst = new SLList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p>
<p>  在上面实例化的声明中，<span class="math inline">\(lst\)</span>的类型是<span class="math inline">\(List61B\)</span>，这叫作静态类型(<span class="math inline">\(static\;type\)</span>)。</p>
<p>  然而，对象自己也有类型。<span class="math inline">\(lst\)</span>指向的对象具有<span class="math inline">\(SLList\)</span>类型，同时它也是<span class="math inline">\(List61B\)</span>类型，这是由于两者的<span class="math inline">\(is-a\)</span>关系。我们称它的<span class="math inline">\(List61B\)</span>类型为动态类型(<span class="math inline">\(dynamic\;type\)</span>)。</p>
<blockquote>
<p>  Aside: the name “dynamic type” is actually quite semantic in its
origin! Should lst be reassigned to point to an object of another type,
say a AList object, lst’s dynamic type would now be AList and not
SLList! It’s dynamic because it changes based on the type of the object
it’s currently referring to.</p>
</blockquote>
<p>  考虑下面的例子： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">peek</span><span class="params">(List61B&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(list.getLast());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">peek</span><span class="params">(SLList&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(list.getFirst());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SLList&lt;String&gt; SP = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;String&gt;();</span><br><span class="line">List61B&lt;String&gt; LP = SP;</span><br><span class="line">SP.addLast(<span class="string">&quot;elk&quot;</span>);</span><br><span class="line">SP.addLast(<span class="string">&quot;are&quot;</span>);</span><br><span class="line">SP.addLast(<span class="string">&quot;cool&quot;</span>);</span><br><span class="line">peek(SP);</span><br><span class="line">peek(LP);</span><br></pre></td></tr></table></figure></p>
<p>  第一个<span class="math inline">\(peek\)</span>调用的是第一个，而第二个<span class="math inline">\(peek\)</span>调用的是第二个。<span class="math inline">\(Java\)</span>在相同名称的方法间选择时，会检查与静态变量类型相同的方法，然后调用它。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>4.inheritance &amp; inplements</category>
      </categories>
  </entry>
  <entry>
    <title>4.2.扩展</title>
    <url>/2024/05/31/4.2.extends/</url>
    <content><![CDATA[<h1 id="42扩展"><span class="math inline">\(4.2\)</span>扩展</h1>
<h3 id="1扩展的引入">1.扩展的引入</h3>
<p>  假设我们想实现<span class="math inline">\(RotatingSLList\)</span>，它具有和<span class="math inline">\(SLList\)</span>完全相同的方法，但增添了一个方法<code>rotateRight</code>，这个方法将链表的最后一个元素添加到链表前端。</p>
<p>  为了继承<span class="math inline">\(SLList\)</span>的方法，我们可以使用<span class="math inline">\(extend\)</span>关键词： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RotatingSLList</span>&lt;Item&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;Item&gt;</span><br></pre></td></tr></table></figure></p>
<p>  这里，<span class="math inline">\(RotatingSLList\)</span>和<span class="math inline">\(SLList\)</span>间也是<span class="math inline">\(is-a\)</span>关系，<span class="math inline">\(extends\)</span>关键词允许我们保留<span class="math inline">\(SLList\)</span>的原始功能，同时允许我们进行修改并添加其他的功能(<span class="math inline">\(functionality\)</span>)。</p>
<p><img src="/2024/05/31/4.2.extends/image-2.png"></p>
<p>  使用<span class="math inline">\(extends\)</span>语句后，我们便可以借助<span class="math inline">\(SLList\)</span>中的方法来实现<code>rotateRight</code>：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotateRight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Item</span> <span class="variable">x</span> <span class="operator">=</span> removeLast();</span><br><span class="line">    addFirst(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  在<span class="math inline">\(extend\)</span>关键词下，子类继承了父类的大部分成员：</p>
<ul>
<li>所有的实例和静态变量</li>
<li>所有的方法</li>
<li>所有的嵌套类</li>
</ul>
<p>  当我们要覆盖所继承的方法时，使用<code>@Override</code>即可。例如下面<span class="math inline">\(VengefulSLList\)</span>的实现：它的<code>removeLast</code>方法在删去末尾元素后会将其添加到前端：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VengefulSLList</span>&lt;Item&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;Item&gt; &#123;</span><br><span class="line">    SLList&lt;Item&gt; deletedItems;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> &#123;</span><br><span class="line">        deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Item</span> <span class="variable">x</span> <span class="operator">=</span> <span class="built_in">super</span>.removeLast();</span><br><span class="line">        deletedItems.addLast(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Prints deleted items. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLostItems</span><span class="params">()</span> &#123;</span><br><span class="line">        deletedItems.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2关于构造方法的继承">2.关于构造方法的继承</h3>
<p>  虽然子类会继承父类的大部分成员，但是子类无法继承父类的构造方法(<span class="math inline">\(constructor\)</span>)。同时，<span class="math inline">\(Java\)</span>要求所有的构造函数必须从对一个主类(<span class="math inline">\(superclass\)</span>)的构造方式的调用开始。</p>
<p>  以下面的两个类为例： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Human &#123;...&#125;</span><br><span class="line">public class TA extends Human &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>  由<span class="math inline">\(extends\)</span>语句，<span class="math inline">\(TA\)</span>会继承<span class="math inline">\(Human\)</span>的属性与行为。</p>
<p>  如果我们运行下面的代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TA</span> <span class="variable">Christine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TA</span>();</span><br></pre></td></tr></table></figure></p>
<p>  那么首先，一个<span class="math inline">\(Human\)</span>要先被创建，这样<span class="math inline">\(Human\)</span>才能把自己的特性传递给<span class="math inline">\(TA\)</span>，如果没有创建<span class="math inline">\(Human\)</span>就创建<span class="math inline">\(TA\)</span>显然是错误的。</p>
<p>  因此，在创建一个子类时，我们可以直接先用<span class="math inline">\(super\)</span>关键词，调用主类的构造方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  或者，如果我们不这么做，<span class="math inline">\(Java\)</span>会自动调用主类的无参数(<span class="math inline">\(non-argument\)</span>)构造方法。</p>
<p>  但有时候，如果不直接调用父类的构造方法，<span class="math inline">\(Java\)</span>的自动调用的方法可能不是我们想要的。例如我们有一个包含一个参数的单参数构造方法，<span class="math inline">\(Java\)</span>自动调用的无参数构造方法会让我们传入的参数无效！这时，我们就必须直接调用我们需要的构造方式：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(x);</span><br><span class="line">    deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3对象类">3.对象类</h3>
<p>  <span class="math inline">\(Java\)</span>中的所有类都是对象类(<span class="math inline">\(object\;class\)</span>)的子类(<span class="math inline">\(descendant\)</span>)，或者对象类的<span class="math inline">\(extends\)</span>。不管一个类有没有显性的<span class="math inline">\(extends\)</span>关键词，它都隐性地继承了对象类。以前面为例：</p>
<ul>
<li><span class="math inline">\(VengefulSLList\)</span>是<span class="math inline">\(SLList\)</span>的显式<span class="math inline">\(extends\)</span>。</li>
<li><span class="math inline">\(SLList\)</span>隐性继承了对象类。</li>
</ul>
<p>  对象类提供了很多所有对象都应遵循的操作，如<code>.equal(Object obj)</code>、<code>.hashCode()</code>等。</p>
<h3 id="4封装">4.封装</h3>
<p>  我们可以通过阶层抽象(抽象屏障)来减小程序的复杂性(<span class="math inline">\(complexity\)</span>)，以及“为准备修改而编程”的概念。这是围绕着程序应该被建造为模块化的、可内部改变(<span class="math inline">\(interchangeable\)</span>)的片段，它们可以互相交换、并且不会破坏原有的系统。同时，把他人不需要的信息隐藏起来也是减小程序复杂性的重要手段。</p>
<p>  封装的根源即存在于将信息对外隐藏的概念。在计算机科学中，一个模块可以被定义为一系列方法，它们作为一个整体工作来解决问题。当这个模块的实现细节都被隐藏起来、只能通过接口与其进行交互，这样的模块就是已封装的(<span class="math inline">\(encapsulated\)</span>)。</p>
<p>  在理想状态下，用户不应观察到它们所使用的数据结构的内部工作原理。而<span class="math inline">\(Java\)</span>的<span class="math inline">\(private\)</span>关键词就很好地建立了抽象屏障。</p>
<h3 id="5类型错误-编译时类型">5.类型错误、编译时类型</h3>
<p>  我们考虑下面的程序： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    VengefulSLList&lt;Integer&gt; vsl = <span class="keyword">new</span> <span class="title class_">VengefulSLList</span>&lt;Integer&gt;(<span class="number">9</span>);</span><br><span class="line">    SLList&lt;Integer&gt; sl = vsl;</span><br><span class="line"></span><br><span class="line">    sl.addLast(<span class="number">50</span>);</span><br><span class="line">    sl.removeLast();</span><br><span class="line"></span><br><span class="line">    sl.printLostItems();</span><br><span class="line">    VengefulSLList&lt;Integer&gt; vsl2 = sl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VengefulSLList&lt;Integer&gt; vsl = <span class="keyword">new</span> <span class="title class_">VengefulSLList</span>&lt;Integer&gt;(<span class="number">9</span>);</span><br><span class="line">SLList&lt;Integer&gt; sl = vsl;</span><br></pre></td></tr></table></figure>
<p>  程序的前两行没有问题，因为<span class="math inline">\(VengefulSLList\)</span><span class="math inline">\(is-a\)</span><span class="math inline">\(SLList\)</span>，我们可以把<span class="math inline">\(VengefulSLList\)</span>放入<span class="math inline">\(SLList\)</span>的内存盒子中。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sl.addLast(<span class="number">50</span>);</span><br><span class="line">sl.removeLast();</span><br></pre></td></tr></table></figure></p>
<p>  这两行也没有问题，根据前面的讲解，第一个<code>addLast</code>会调用<span class="math inline">\(SLList\)</span>的方法，而第二个<code>removeLast</code>会调用<span class="math inline">\(VengefulSLList\)</span>的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sl.printLostItems();</span><br></pre></td></tr></table></figure>
<p>  但是这一行程序无法编译，因为<span class="math inline">\(SLList\)</span>及其主类都没有<code>printLostItems</code>这一方法，即使<span class="math inline">\(sl\)</span>的运行类型是<span class="math inline">\(VengefulSLList\)</span>依然不行。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VengefulSLList&lt;Integer&gt; vsl2 = sl;</span><br></pre></td></tr></table></figure></p>
<p>  同样地，这一行程序也会编译错误。因为<span class="math inline">\(SLList\)</span>并不<span class="math inline">\(is-a\;\)</span><span class="math inline">\(VengefulSLList\)</span>。</p>
<p>  这两例说明，编译器只支持编译时(<span class="math inline">\(compile-time\)</span>)的类型所包含的方法。</p>
<p>  除了表达式，对方法的调用也会有编译时类型，即该方法声明时的类型。例如下面的程序：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">frank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poodle</span>(<span class="string">&quot;Frank&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Poodle</span> <span class="variable">frankJr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poodle</span>(<span class="string">&quot;Frank Jr.&quot;</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Dog</span> <span class="variable">largerDog</span> <span class="operator">=</span> maxDog(frank, frankJr);</span><br><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> maxDog(frank, frankJr); </span><br><span class="line"><span class="comment">//does not compile! RHS has compile-time type Dog</span></span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> maxDog(frank, frankJr); </span><br><span class="line"><span class="comment">//does not compile! RHS has compile-time type Dog</span></span><br></pre></td></tr></table></figure></p>
<p>  该行代码也会编译错误，因为<code>maxDog</code>的编译时类型为<span class="math inline">\(Dog\)</span>。</p>
<h3 id="6类型铸造casting">6.类型铸造<span class="math inline">\(casting\)</span></h3>
<p>  在<span class="math inline">\(Java\)</span>中，我们可以告诉编译器某个表达式有特定的编译时类型，这样可以实现类型的“转换”。</p>
<p>  例如，我们可以对上面的代码进行如下更改： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> (Poodle) maxDog(frank, frankJr); </span><br><span class="line"><span class="comment">// compiles! Right hand side has compile-time type Poodle after casting</span></span><br></pre></td></tr></table></figure></p>
<p>  但是，对两个毫不相干的类进行类型铸造，会导致<code>ClassCastException</code>的错误。</p>
<h3 id="7高阶函数">7.高阶函数</h3>
<p>  在<span class="math inline">\(Java\)</span>中，我们可以利用接口实现高阶函数。</p>
<p>  先在接口中定义一个函数： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  然后我们写一个类来实现接口中指定的函数： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TenX</span> <span class="keyword">implements</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">    <span class="comment">/* Returns ten times the argument. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  然后，我们就可以写出高阶函数的表达式了： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">do_twice</span><span class="params">(IntUnaryFunction f, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(f.apply(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  在调用时，我们创造一个新的<span class="math inline">\(tenX\)</span>实例，然后传入参数<span class="math inline">\(x\)</span>即可： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(do_twice(<span class="keyword">new</span> <span class="title class_">TenX</span>(), <span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>  函数式接口允许我们以优雅的方式传递函数，我们可以通过接口定义函数的签名与行为，然后通过实现接口的类来提供具体的函数。</p>
<h3 id="8summarcopy-by-origin-text">8.summar(copy by origin text)</h3>
<p>  VengefulSLList extends SLList means VengefulSLList "is-an" SLList,
and inherits all of SLList's members:</p>
<ul>
<li>Variables, methods nested classes</li>
<li>Not constructors Subclass constructors must invoke superclass
constructor first. The super keyword can be used to invoke overridden
superclass methods and constructors.</li>
</ul>
<p>  Invocation of overridden methods follows two simple rules:</p>
<ul>
<li>Compiler plays it safe and only allows us to do things according to
the static type.</li>
<li>For overridden methods (not overloaded methods), the actual method
invoked is based on the dynamic type of the invoking expression</li>
<li>Can use casting to overrule compiler type checking.</li>
</ul>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>4.inheritance &amp; inplements</category>
      </categories>
  </entry>
  <entry>
    <title>4.2.隐性序列</title>
    <url>/2024/05/31/4.2.%E9%9A%90%E6%80%A7%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="42隐性序列implicitsequences"><span class="math inline">\(4.2\)</span>隐性序列<span class="math inline">\(Implicit\;Sequences\)</span></h1>
<h2 id="一-概述">一、概述</h2>
<h3 id="1懒惰计算">1.懒惰计算</h3>
<p>  一个序列可以在不直接存储在电脑内存的情况下被代表(<span class="math inline">\(represent\)</span>)。这就是说，我们可以创建一个对象，它<strong>能够访问序列型数据集(<span class="math inline">\(sequential\;dataset\)</span>)的所有元素，并且不用预先计算存储所有的元素</strong>。作为替代，我们<strong>只在需要访问某元素的时候进行计算</strong>。</p>
<p>  一个简单的例子是序列类型<span class="math inline">\(range\)</span>。在<span class="math inline">\(range\)</span>中，当一个元素被要求计算出来时，<span class="math inline">\(range\)</span>才会着手计算它。因此，我们可以在不消耗大量内存的情况下表示很大区间范围的整数。只有<span class="math inline">\(range\)</span>的结尾作为<span class="math inline">\(range\)</span>对象的一部分被存储了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">range</span>(<span class="number">10000</span>, <span class="number">1000000000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="number">45006230</span>]</span><br><span class="line"><span class="number">45016230</span></span><br></pre></td></tr></table></figure></p>
<p>  在这个例子中，<code>r[45006230]</code>是通过第一个元素<span class="math inline">\(10000\)</span>加上索引(<span class="math inline">\(index\)</span>)<span class="math inline">\(45006230\)</span>计算出来的。这种<strong>在需要某个值的时候才计算它的行为</strong>被称作懒惰计算(<span class="math inline">\(lazy\;computation\)</span>)。</p>
<h3 id="2迭代器">2.迭代器</h3>
<p>  迭代器(iterator)是一个对象，它为底层的序列型数据集提供循序存取。迭代器抽象有两个组成部分：</p>
<ul>
<li><strong>在序列元素中检索下一个元素<span class="math inline">\(next\)</span></strong> 的机制。</li>
<li><strong>发出结束信号</strong>：已经到达序列结束处、没有其他元素存在的信号的机制。</li>
</ul>
<p>  迭代器的有用之处基于底层的一系列信息(<span class="math inline">\(series\;of\;data\)</span>)可能不会在内存中直接被表示。而迭代器提供了一个<strong>依次考虑一系列值的机制</strong>，而<strong>其他未被考虑的值不需要同时存储在内存中，而是在迭代器访问到它的时候才被计算</strong>。</p>
<p>  <span class="math inline">\(range\)</span>之所以可以对元素进行懒惰计算，是因为<strong>序列内部的元素形式是统一的，并且任意一个值都可以容易地通过头元素与尾元素计算出来</strong>。而迭代器将懒惰计算的适用类型扩大了，因为这些序列类型不需要自己提供一种计算任意值的方法。相反，它们<strong>只需要能依次计算出下一个元素<span class="math inline">\(next\)</span>即可</strong>。</p>
<h2 id="二-python的迭代器">二、<span class="math inline">\(python\)</span>的迭代器</h2>
<h3 id="1迭代器的功能与性质">1.迭代器的功能与性质</h3>
<p>  <span class="math inline">\(python\)</span>迭代器包含<code>__next__</code>信息：询问迭代器序列的下一个元素是什么。对<code>__next__</code>的调用<strong>会导致迭代器的改变</strong>：它<strong>更新当前迭代器的位置</strong>。<span class="math inline">\(python\)</span>在迭代器到达序列末端时会产生<code>StopIteration</code>的异常(<span class="math inline">\(exception\)</span>)。</p>
<p>  下面的$ LetterIter$迭代了一系列字母： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LetterIter</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;An iterator over letters of the alphabet in ASCII order.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="string">&#x27;a&#x27;</span>, end=<span class="string">&#x27;e&#x27;</span></span>):</span><br><span class="line">            self.next_letter = start</span><br><span class="line">            self.end = end</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">if</span> self.next_letter == self.end:</span><br><span class="line">                <span class="keyword">raise</span> StopIteration</span><br><span class="line">            letter = self.next_letter</span><br><span class="line">            self.next_letter = <span class="built_in">chr</span>(<span class="built_in">ord</span>(letter)+<span class="number">1</span>)<span class="comment">#iterate to the next number</span></span><br><span class="line">            <span class="keyword">return</span> letter</span><br></pre></td></tr></table></figure>
  通过这个类，我们可以用<code>__next__</code>方法或<code>next</code>函数来访问字母：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letter_iter = LetterIter()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letter_iter.__next__()</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letter_iter.__next__()</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(letter_iter)</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letter_iter.__next__()</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letter_iter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">12</span>, <span class="keyword">in</span> <span class="built_in">next</span></span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<p>  迭代器是<strong>可改变的(<span class="math inline">\(mutable\)</span>)</strong>。当迭代器到达序列的末尾时，它就被耗尽了。<span class="math inline">\(LetterIter\)</span><strong>只能被迭代一次，当它的<code>__next__</code>方法产生<code>StopIteration</code>的异常后，从这以后的所有迭代都会产生这个异常</strong>。一般地，<strong>迭代器不会重置</strong>。<strong>当一个新的实例被创建时，一个新的迭代器也被创建了</strong>。</p>
<p>  迭代器也可以通过实现<strong>一个不产生异常的<code>__next__</code>方法</strong>来表示无限序列，例如下面表示正整数序列的迭代器：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Positives</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">            self.next_positive = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">            result = self.next_positive</span><br><span class="line">            self.next_positive += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Positives()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(p)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(p)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(p)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2可迭代性">2.可迭代性</h3>
<p>  一个对象<strong>是可迭代的(<span class="math inline">\(iterable\)</span>)，当它的<code>iter</code>方法被调用</strong>。可迭代值代表数据集合，并且它们提供了产生一个或多个迭代器的固定表达。</p>
<p>  以下面这个代表一系列有序字母序列的类为例。每次当其<code>__iter__</code>方法被调用，<strong>一个新的<span class="math inline">\(LetterIter\)</span>实例就被创建，这允许了对序列内容的有序访问</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Letters</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="string">&#x27;a&#x27;</span>, end=<span class="string">&#x27;e&#x27;</span></span>):</span><br><span class="line">            self.start = start</span><br><span class="line">            self.end = end</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> LetterIter(self.start, self.end)</span><br></pre></td></tr></table></figure></p>
<p>  在下面的表达式中，两个源自同一个可迭代序列的迭代器<strong>独立地</strong>产生各自的单词序列：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b_to_k = Letters(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first_iterator = b_to_k.__iter__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(first_iterator)</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(first_iterator)</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second_iterator = <span class="built_in">iter</span>(b_to_k)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second_iterator.__next__()</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first_iterator.__next__()</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first_iterator.__next__()</span><br><span class="line"><span class="string">&#x27;e&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second_iterator.__next__()</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second_iterator.__next__()</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3for语句">3.<span class="math inline">\(for\)</span>语句</h3>
<p>  <span class="math inline">\(for\)</span>语句对迭代器进行操作。可迭代对象可以作为<span class="math inline">\(for\)</span>语句<code>&lt;expression&gt;</code>结构的值：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></p>
<p>  为了执行<span class="math inline">\(for\)</span>语句，<span class="math inline">\(python\)</span>会<strong>计算<code>&lt;expression&gt;</code>，它提供一个可迭代的值</strong>。然后，<strong><code>__iter__</code>方法在该值上调用</strong>，直到异常被提出。这个过程中，<span class="math inline">\(python\)</span><strong>将迭代器产生的结果与<code>&lt;name&gt;</code>绑定，然后执行<code>&lt;suite&gt;</code></strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> counts:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>  通过先前对迭代器的讲解，我们可以用<span class="math inline">\(while\)</span>语句实现该<span class="math inline">\(for\)</span>语句： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items = counts.__iter__()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = items.__next__()</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="三-生成器与yield语句">三、生成器与<code>yield</code>语句</h2>
<h3 id="1引入">1.引入</h3>
<p>  当我们在处理复杂序列、并且需要在计算过程中保存<code>__next__</code>的位置时，单独依靠迭代器显得难以为继。生成器(<span class="math inline">\(genarator\)</span>)允许我们利用<span class="math inline">\(python\)</span>的特性定义更为复杂的迭代器。</p>
<h3 id="2生成器与yield语句的声明与执行">2.生成器与<code>yield</code>语句的声明与执行</h3>
<p>  生成器是由被称为生成器函数(<span class="math inline">\(genarator\;function\)</span>)的特殊类函数(<span class="math inline">\(class\;of\;function\)</span>)返回的迭代器。生成器函数与一般函数的区别在于：生成器函数<strong>通过<code>yield</code>语句返回元素而不是<code>return</code>语句</strong>。</p>
<p>  生成器并不用对象的属性来跟踪序列的过程。相反，他<strong>控制生成器函数的执行过程</strong>，这个函数会<strong>在生成器调用<code>__next__</code>方法后一直运行直到下个<code>yield</code>被执行</strong>。<span class="math inline">\(Letter\)</span>迭代器可以利用生成器更加紧凑地实现：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">letters_generator</span>():</span><br><span class="line">        current = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> current &lt;= <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">yield</span> current</span><br><span class="line">            current = <span class="built_in">chr</span>(<span class="built_in">ord</span>(current)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> letter <span class="keyword">in</span> letters_generator():</span><br><span class="line">        <span class="built_in">print</span>(letter)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure></p>
<p>  尽管我们没有直接地定义<code>__iter__</code>与<code>__next__</code>方法，程序中的<code>yield</code>语句表明我们在定义一个生成器函数。<strong>当被调用，生成器函数不会返回一个特定的生成值(<span class="math inline">\(yielded\;value\)</span>)，而是一个生成器(迭代器的一种)，生成器自己会返回生成值</strong>。生成器对象有<code>__iter__</code>和<code>__next__</code>方法。</p>
<p>  第一次<code>__next__</code>被调用时，程序执行<code>&lt;body&gt;</code>内语句，即<code>letters_generator</code>，直到<strong>遇到<code>yield</code>语句。然后，它暂停执行并返回<span class="math inline">\(current\)</span>的值</strong>。<code>yield</code>语句并不会破坏新创建的环境，<strong>它会保存这个环境留着之后计算使用</strong>。<strong>当<code>__next__</code>被再次调用时，程序从之前停下来的地方开始执行</strong>。在对<code>__next__</code>的后续调用中，<code>letters_generator</code>作用域中的<span class="math inline">\(current\)</span>值和其他绑定名称被保存下来：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = letters_generator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(letters)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;generator&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<h3 id="3利用yield语句创建可迭代对象">3.利用<code>yield</code>语句创建可迭代对象</h3>
<p>  在<span class="math inline">\(python\)</span>中，迭代器只会对底层序列的元素进行一次传递，<strong>当这次传递结束后，再次调用<code>__next__</code>方法，迭代器将一直产生<code>StopIteration</code>异常</strong>。而许多程序需要<strong>多次迭代</strong>元素，例如我们想要枚举一个列表的所有<span class="math inline">\(pair\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">all_pairs</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="keyword">for</span> item1 <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">for</span> item2 <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">yield</span> (item1, item2)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(all_pairs([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure></p>
<p>  序列本身<strong>不是迭代器，而是可迭代对象</strong>。当<strong>序列的<code>__iter__</code>方法被调用后，序列会返回一个新的迭代器实例</strong>。如果一个可迭代对象<strong>在每次调用<code>__iter__</code>后都会返回一个新的新的迭代器实例，它就可以被多次迭代</strong>。</p>
<p>  可以通过实现一个可迭代接口来定义新的可迭代类，例如下面<span class="math inline">\(LettersWithYield\)</span>类就在每次调用<code>__iter__</code>后返回一个新的迭代器：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#create an iterable object</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LettersWithYield</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="string">&#x27;a&#x27;</span>, end=<span class="string">&#x27;e&#x27;</span></span>):</span><br><span class="line">            self.start = start</span><br><span class="line">            self.end = end</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">            next_letter = self.start</span><br><span class="line">            <span class="keyword">while</span> next_letter &lt; self.end:</span><br><span class="line">                <span class="keyword">yield</span> next_letter</span><br><span class="line">                next_letter = <span class="built_in">chr</span>(<span class="built_in">ord</span>(next_letter)+<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>  该类的<code>__iter__</code>方法是一个生成器函数，它<strong>返回一个生成器对象，这个生成器对象生成从<code>a</code>到<code>d</code>的序列后停下</strong>。每次我们调用这个方法，一个新的生成器会开始对序列型数据的新的传递：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = LettersWithYield()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(all_pairs(letters))[:<span class="number">5</span>]</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)]</span><br></pre></td></tr></table></figure></p>
<h2 id="四-流">四、流</h2>
<h3 id="1流的概念">1.流的概念</h3>
<p>  流(<span class="math inline">\(stream\)</span>)提供了隐性表示序列型数据的另一种方法。流是<strong>懒惰计算的递归列表(<span class="math inline">\(recusive\;list\)</span>)</strong>，与链表结构类似。但与链表不同，<strong>流的<span class="math inline">\(rest\)</span>部分只有在被调用的时候才会被计算</strong>。</p>
<h3 id="2流的实现与调用">2.流的实现与调用</h3>
<p>  为了实现懒惰计算的操作，流会<strong>存储一个计算<span class="math inline">\(rest\)</span>部分的函数</strong>。当这个函数被调用时，<strong>它的返回值作为流的属性<code>_rest</code>存储在流的一部分</strong>，名称前面的下划线说明<strong>它不应该被直接访问</strong>。而<strong>可访问的<code>rest</code>属性是一个返回流的<span class="math inline">\(rest\)</span>部分的属性方法</strong>。流的基本设计如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A lazily computed recursive list.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">empty</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Stream.empty&#x27;</span></span><br><span class="line">        empty = empty()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first, compute_rest=<span class="keyword">lambda</span>: empty</span>):</span><br><span class="line">            <span class="keyword">assert</span> <span class="built_in">callable</span>(compute_rest), <span class="string">&#x27;compute_rest must be callable.&#x27;</span></span><br><span class="line">            self.first = first</span><br><span class="line">            self._compute_rest = compute_rest</span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">rest</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Return the rest of the stream, computing it if necessary.&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> self._compute_rest <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self._rest = self._compute_rest()</span><br><span class="line">                self._compute_rest = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> self._rest</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Stream(&#123;0&#125;, &lt;...&gt;)&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">repr</span>(self.first))</span><br></pre></td></tr></table></figure></p>
<p>  流可以像链表一样利用嵌套表达式创建。为了实现懒惰计算，我们采用匿名函数的方法：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = Stream(<span class="number">1</span>, <span class="keyword">lambda</span>: Stream(<span class="number">2</span>+<span class="number">3</span>, <span class="keyword">lambda</span>: Stream(<span class="number">9</span>)))</span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(lambda\)</span>表达式返回<strong>计算流剩余部分的方法</strong>。可以通过下面的操作访问流中的元素：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.first</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.first</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.rest.first</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rest.first</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.rest</span><br><span class="line">Rlist(<span class="number">5</span>, Rlist(<span class="number">9</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rest</span><br><span class="line">Stream(<span class="number">5</span>, &lt;...&gt;)</span><br><span class="line"><span class="comment">#the fact that it will return the empty stream are undiscovered</span></span><br></pre></td></tr></table></figure></p>
<p>  当一个<span class="math inline">\(stream\)</span>实例被创建时，<code>self._rest</code>是<span class="math inline">\(None\)</span>，这表明实例的<span class="math inline">\(rest\)</span>部分尚未被计算；<strong>当<code>rest</code>属性通过点表达式被访问后，<code>rest</code>的属性方法被调用，触发了<code>self._rest = self._compute_rest()</code>的计算</strong>。</p>
<p>  <code>compute_rest</code>函数的关键属性是：它<strong>不接受参数，并且返回<span class="math inline">\(stream\)</span>或<span class="math inline">\(stream.empty\)</span></strong>。</p>
<p>  懒惰计算允许我们用流表示无限的序列型数据集。例如，可以用以下语句表示正整数集：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">integer_stream</span>(<span class="params">first</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute_rest</span>():</span><br><span class="line">        <span class="keyword">return</span> integer_stream(first+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> Stream(first, compute_rest)</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>positives = integer_stream(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>positives</span><br><span class="line">Stream(<span class="number">1</span>, &lt;...&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>positives.first</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3利用流实现序列基本操作">3.利用流实现序列基本操作</h3>
<p>  上述<strong>利用高阶函数改变<span class="math inline">\(compute_rest\)</span>函数</strong>的方法可以用于其他序列操作：</p>
<h4 id="amap映射">  <span class="math inline">\(a.\)</span><span class="math inline">\(map\)</span>映射</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">map_stream</span>(<span class="params">fn, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Stream.empty:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">compute_rest</span>():</span><br><span class="line">            <span class="keyword">return</span> map_stream(fn, s.rest)</span><br><span class="line">        <span class="keyword">return</span> Stream(fn(s.first), compute_rest)</span><br></pre></td></tr></table></figure>
<h4 id="b筛选指定元素">  <span class="math inline">\(b.\)</span>筛选指定元素</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">filter_stream</span>(<span class="params">fn, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Stream.empty:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">compute_rest</span>():</span><br><span class="line">            <span class="keyword">return</span> filter_stream(fn, s.rest)</span><br><span class="line">        <span class="keyword">if</span> fn(s.first):</span><br><span class="line">            <span class="keyword">return</span> Stream(s.first, compute_rest)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> compute_rest()</span><br></pre></td></tr></table></figure>
<h4 id="c筛选前k个元素">  <span class="math inline">\(c.\)</span>筛选前<span class="math inline">\(k\)</span>个元素</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">first_k_as_list</span>(<span class="params">s, k</span>):</span><br><span class="line">        first_k = []</span><br><span class="line">        <span class="keyword">while</span> s <span class="keyword">is</span> <span class="keyword">not</span> Stream.empty <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            first_k.append(s.first)</span><br><span class="line">            s, k = s.rest, k-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> first_k</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = integer_stream(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Stream(<span class="number">3</span>, &lt;...&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = map_stream(<span class="keyword">lambda</span> x: x*x, s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">Stream(<span class="number">9</span>, &lt;...&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first_k_as_list(m, <span class="number">5</span>)</span><br><span class="line">[<span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>]</span><br></pre></td></tr></table></figure>
<p>  正如链表提供的简单的数据抽象的实现，流也提供了一个简单的函数化递归数据结构，通过高阶函数实现懒惰计算。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 4.Data Processing</category>
      </categories>
  </entry>
  <entry>
    <title>4.3.子类多态性</title>
    <url>/2024/05/31/4.3.subtype%20polymorphism/</url>
    <content><![CDATA[<h1 id="43子类多态性"><span class="math inline">\(4.3\)</span>子类多态性</h1>
<h3 id="1多态性的概念">1.多态性的概念</h3>
<p>  在前面，我们学习了如何运用继承来重复利用已有的代码。继承也可以用于设计具有多态性的通用数据结构与方法。</p>
<p>  在<span class="math inline">\(Java\)</span>中，多态性(<span class="math inline">\(polymorphism\)</span>)代指对象具有不同形式的类型(<span class="math inline">\(types\)</span>)的性质；在面向对象编程中，多态性代指对象具有的不同身份：自己类中的一个实例、主类的一个实例...</p>
<p>  考虑下面的问题：我们要实现一个比较函数，用于比较两个对象的大小。我们可以用高阶函数实现：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_larger</span>(<span class="params">x, y, compare, stringify</span>):</span><br><span class="line">    <span class="keyword">if</span> compare(x, y):</span><br><span class="line">        <span class="keyword">return</span> stringify(x)</span><br><span class="line">    <span class="keyword">return</span> stringify(y)</span><br></pre></td></tr></table></figure></p>
<p>  还可以用子类多态性实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_larger</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> x.largerThan(y):</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">return</span> y.<span class="built_in">str</span>()</span><br></pre></td></tr></table></figure></p>
<p>  高阶函数给出的是普适的方法，对任何对象都适用。而在子类多态性的方法中，需要对象自己做出决定，执行相应的方法，<code>x.largerThan</code>方法是由<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>来决定的。</p>
<h3 id="2子类多态性的应用">2.子类多态性的应用</h3>
<p>  假设我们想要实现一个普适的<code>max</code>函数，这个函数接受任意类型的数组，并返回数组中的最大元素。</p>
<p>  一个简单的想法是用<code>&gt;</code>比较： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">max</span><span class="params">(Object[] items)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (items[i] &gt; items[maxDex]) &#123;</span><br><span class="line">            maxDex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items[maxDex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  我们默认<code>&gt;</code>可以比较任意类型的对象，但是实际上不行。因为<code>&gt;</code>只能用于确定类型的对象。</p>
<p>  于是问题转为实现能比较任意类型对象的<code>&gt;</code>。我们可以为此创建一个方法接口<code>compareTo</code>，来确保每个对象都可以调用该方法来比较大小:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样，我们对每个子类逐一实现对应的<span class="math inline">\(implements\)</span>即可。以<span class="math inline">\(Dog\)</span>类为例： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">        <span class="comment">// notice that compartTo takes in any object,we need to cast o.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - d.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  实现<code>compareTo</code>后，便可自然地实现<code>max</code>了：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> OurComparable <span class="title function_">max</span><span class="params">(OurComparable[] items)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> items[i].compareTo(items[maxDex]);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxDex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items[maxDex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  利用继承，我们优雅地实现了通用的<code>max</code>函数。</p>
<h3 id="3comparable接口">3.<code>comparable</code>接口</h3>
<p>  <span class="math inline">\(Java\)</span>中已有的<code>comparable</code>接口可以更好地实现<code>max</code>，它的形式如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  与<span class="math inline">\(OurComparable\)</span>相比，该接口接受一个通用类型，这使得我们不需要使用类型铸造，同时即使一个类没有继承接口，它也可以调用<code>max</code>。这样，我们的<span class="math inline">\(Dog\)</span>类可以如此实现： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog d)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - d.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  通过内置(<span class="math inline">\(built-in\)</span>)的接口，我们得以利用已有的库(<span class="math inline">\(libraries\)</span>)和<span class="math inline">\(Comparable\)</span>接口。</p>
<h3 id="4comparator接口">4.<code>comparator</code>接口</h3>
<p>  考虑下面的问题：假如我们不想让<span class="math inline">\(Dog\)</span>以<span class="math inline">\(size\)</span>排列，该怎么写<code>max</code>呢？</p>
<p>  <span class="math inline">\(Java\)</span>的内置接口<code>comparator</code>内部如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这说明<code>comparator</code>需要子类实现<code>compare</code>方法，它和<code>compareTo</code>的规则相似。我们可以如下实现<span class="math inline">\(Dog\)</span>的<code>compare</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog uddaDog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - uddaDog.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NameComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Dog&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Dog a, Dog b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.name.compareTo(b.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//declared it as static,for it doesn&#x27;t use any other methods  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Dog&gt; <span class="title function_">getNameComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NameComparator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(Dog\)</span>类通过<code>Comparator</code>的内部接口实现了继承的层次性：我们可以在<span class="math inline">\(Dog\)</span>内部定义自己需要的比较方法：<code>NameComparator</code>、<code>SizeComparator</code>...</p>
<h3 id="5接口的功能">5.接口的功能</h3>
<p>  <span class="math inline">\(Java\)</span>中的接口为我们提供了函数回调(<span class="math inline">\(callback\)</span>)的能力。有时，一个函数需要其他还未实现的函数的帮助，如<code>max</code>需要<code>compareTo</code>。而回调函数就是辅助函数(<span class="math inline">\(helper\;function\)</span>)，如<code>compareTo</code>。在<span class="math inline">\(Java\)</span>中，我们把需要的函数封装在接口内。</p>
<blockquote>
<p>  A Comparable says, "I want to compare myself to another object". It
is imbedded within the object itself, and it defines the natural
ordering of a type. A Comparator, on the other hand, is more like a
third party machine that compares two objects to each other. Since
there's only room for one compareTo method, if we want multiple ways to
compare, we must turn to Comparator.</p>
</blockquote>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>4.inheritance &amp; inplements</category>
      </categories>
  </entry>
  <entry>
    <title>4.3.声明式编程</title>
    <url>/2024/05/31/4.3.%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="43声明式编程declarativeprogramming"><span class="math inline">\(4.3\)</span>声明式编程(<span class="math inline">\(declarative\;programming\)</span>)</h1>
<h2 id="一-概述">一、概述</h2>
<p>  除了流(<span class="math inline">\(streams\)</span>)，数据的值也经常存储在一个叫作数据库(<span class="math inline">\(database\)</span>)的仓库里。</p>
<p>  数据库由存入其中的数据和检索、转换这些数据的接口组成。每个存储在数据库中的值称作记录(<span class="math inline">\(record\)</span>)，有着相似结构的记录被归类为表格(<span class="math inline">\(tables\)</span>)。可以通过询问语言中的询问语句(<span class="math inline">\(queries\)</span>)来检索、转换记录。目前最普遍的询问语言被称作<span class="math inline">\(Structure\;Query\;Language(SQL)\)</span>。</p>
<p>  <span class="math inline">\(SQL\)</span>是声明式编程语言的一种。在这种语言中，声明并不直接描述计算，而是描述计算想要得到的结果。而设计和运行一个计算过程来得到这个结果是询问解释器(<span class="math inline">\(query\;interpreter\)</span>)的工作。这种语言经常将过程性的细节(<span class="math inline">\(procedural\;details\)</span>)抽象，而专注于结果的形式(<span class="math inline">\(form\)</span>)。</p>
<h2 id="二-sql">二、<span class="math inline">\(SQL\)</span></h2>
<h3 id="1表格">1.表格</h3>
<p>  表格(<span class="math inline">\(table\)</span>)具有固定数量的命名列(<span class="math inline">\(named\;column\)</span>)和类型列(<span class="math inline">\(typed\;column\)</span>)。表的每一行表示一个数据记录，行中的每一列表示一个值。例如下面这个关于城市的表格：</p>
<p><img src="/2024/05/31/4.3.%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B/image.png"></p>
<p>  一个只有一行的表格可以通过<span class="math inline">\(select\)</span>语句创建。该行的每个值间用逗号隔开，列名称跟在关键词<span class="math inline">\(as\)</span>后面。所有的<span class="math inline">\(SQL\)</span>语句都以分号结尾： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select 38 as latitude, 122 as longitude, &quot;Berkeley&quot; as name;</span><br><span class="line">38|122|Berkeley</span><br></pre></td></tr></table></figure></p>
<p>  多行的表格可以通过<span class="math inline">\(union\)</span>语句创建： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select 38 as latitude, 122 as longitude, &quot;Berkeley&quot; as name union</span><br><span class="line">   ...&gt; select 42,             71,               &quot;Cambridge&quot;        union</span><br><span class="line">   ...&gt; select 45,             93,               &quot;Minneapolis&quot;;</span><br><span class="line">38|122|Berkeley</span><br><span class="line">42|71|Cambridge</span><br><span class="line">45|93|Minneapolis</span><br></pre></td></tr></table></figure></p>
<p>  可以通过<span class="math inline">\(create\;table\)</span>语句来给表格命名：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table cities as</span><br><span class="line">   ...&gt;    select 38 as latitude, 122 as longitude, &quot;Berkeley&quot; as name union</span><br><span class="line">   ...&gt;    select 42,             71,               &quot;Cambridge&quot;        union</span><br><span class="line">   ...&gt;    select 45,             93,               &quot;Minneapolis&quot;;</span><br></pre></td></tr></table></figure></p>
<p>  当一个表格被命名后，可以通过<span class="math inline">\(from\)</span>语句调用这个名字。表格中的所有列可以通过<code>select *</code>形式访问：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select * from cities;</span><br><span class="line">38|122|Berkeley</span><br><span class="line">42|71|Cambridge</span><br><span class="line">45|93|Minneapolis</span><br></pre></td></tr></table></figure></p>
<h3 id="2select语句">2.<span class="math inline">\(select\)</span>语句</h3>
<p>  <span class="math inline">\(select\)</span>语句通过列举(<span class="math inline">\(listing\)</span>)某一行的值，或者(更普遍地)从一个已存在的表格中，利用<span class="math inline">\(from\)</span>句式投射(<span class="math inline">\(project\)</span>)来定义一个表格。该语句的一般格式如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select [column description] from [existing table name]</span><br></pre></td></tr></table></figure>   这里的<span class="math inline">\(column\;expression\)</span>表示对原来表格的列的操作，如加减乘除等。</p>
<p>  例如，我们可以用如下方法来创造一个两列的表格，这个表格描述了每个城市到<span class="math inline">\(Berkeley\)</span>的距离： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select name, 60*abs(latitude-38) from cities;</span><br><span class="line">Berkeley|0</span><br><span class="line">Cambridge|240</span><br><span class="line">Minneapolis|420</span><br></pre></td></tr></table></figure></p>
<p>  为了方便后续被其它<span class="math inline">\(select\)</span>语句所引用，在定义表格时给每一个列一个名字往往是必须的：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table distances as</span><br><span class="line">   ...&gt;   select name, 60*abs(latitude-38) as distance from cities;</span><br><span class="line">sqlite&gt; select distance/5, name from distances;</span><br><span class="line">0|Berkeley</span><br><span class="line">48|Cambridge</span><br><span class="line">84|Minneapolis</span><br></pre></td></tr></table></figure></p>
<h4 id="awhere语句">  <span class="math inline">\(a.\)</span><span class="math inline">\(Where\)</span>语句</h4>
<p>  <span class="math inline">\(select\)</span>语句也可以穿插一个表示过滤元素(<span class="math inline">\(filering\)</span>)的<span class="math inline">\(where\)</span>语句。这个表达式将不符合<span class="math inline">\(where\)</span>语句的行给筛序掉。只有符合筛选条件的行才会被用于构成一个新的表格：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table cold as</span><br><span class="line">   ...&gt;   select name from cities where latitude &gt; 43;</span><br><span class="line">sqlite&gt; select name, &quot;is cold!&quot; from cold;</span><br><span class="line">Minneapolis|is cold!</span><br></pre></td></tr></table></figure></p>
<h4 id="b顺序语句">  <span class="math inline">\(b.\)</span>顺序语句</h4>
<p>  顺序语句(<span class="math inline">\(order\;clause\)</span>)包括一个排序表达式，所有未被过滤的行都会按照这个语句进行排序：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select distance, name from distances order by -distance;</span><br><span class="line">84|Minneapolis</span><br><span class="line">48|Cambridge</span><br><span class="line">0|Berkeley</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(select\)</span>的这些特性功能使得<span class="math inline">\(select\)</span>能够表示很多种类的行输入表格到输出表格的映射。</p>
<h3 id="3合并">3.合并</h3>
<h4 id="a合并的基本操作">  <span class="math inline">\(a.\)</span>合并的基本操作</h4>
<p>  众多数据可以通过合并(<span class="math inline">\(joining\)</span>)表格变成一个，这是数据库系统中一个基础的操作。</p>
<p>  当表格被合并后，对于输入表格的每一个行，合并后的表格都会包括一个新的行。如果有两个表格进行合并操作，它们分别有<span class="math inline">\(m\)</span>行与<span class="math inline">\(n\)</span>行，那么合并后的表格就会有<span class="math inline">\(m\times n\)</span>行。在<span class="math inline">\(SQL\)</span>语言中，合并两个表格是通过<span class="math inline">\(from\)</span>语句加上逗号隔开的表格名称实现的：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table temps as</span><br><span class="line">   ...&gt;   select &quot;Berkeley&quot; as city, 68 as temp union</span><br><span class="line">   ...&gt;   select &quot;Chicago&quot;         , 59         union</span><br><span class="line">   ...&gt;   select &quot;Minneapolis&quot;     , 55;</span><br><span class="line"></span><br><span class="line">sqlite&gt; select * from cities, temps;</span><br><span class="line">38|122|Berkeley|Berkeley|68</span><br><span class="line">38|122|Berkeley|Chicago|59</span><br><span class="line">38|122|Berkeley|Minneapolis|55</span><br><span class="line">42|71|Cambridge|Berkeley|68</span><br><span class="line">42|71|Cambridge|Chicago|59</span><br><span class="line">42|71|Cambridge|Minneapolis|55</span><br><span class="line">45|93|Minneapolis|Berkeley|68</span><br><span class="line">45|93|Minneapolis|Chicago|59</span><br><span class="line">45|93|Minneapolis|Minneapolis|55</span><br></pre></td></tr></table></figure></p>
<h4 id="b不同表格的关系">  <span class="math inline">\(b.\)</span>不同表格的关系</h4>
<p>  同样地，合并也可以通过<span class="math inline">\(where\)</span>语句，表示两个表格间的关系。例如，我们希望将数据收集到一个表中，以获得每个城市自己的<span class="math inline">\(temp\)</span>和<span class="math inline">\(lati\)</span>。可以通过以下语句实现这个想法：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select name, latitude, temp from cities, temps where name = city;</span><br><span class="line">Berkeley|38|68</span><br><span class="line">Minneapolis|45|55</span><br></pre></td></tr></table></figure></p>
<h4 id="c消除歧义">  <span class="math inline">\(c.\)</span>消除歧义</h4>
<p>  为了消除名称相同的表格间的歧义，<span class="math inline">\(SQL\)</span>允许我们使用关键字<span class="math inline">\(as\)</span>为<span class="math inline">\(form\)</span>语句提供别名，并利用点表达式来引用特定的表中的列。在下面计算不同城市温差的例子中，<span class="math inline">\(where\)</span>语句的字母顺序约束确保了每个对在结果中只出现一次：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select a.city, b.city, a.temp - b.temp</span><br><span class="line">   ...&gt;        from temps as a, temps as b where a.city &lt; b.city;</span><br><span class="line">Berkeley|Chicago|10</span><br><span class="line">Berkeley|Minneapolis|15</span><br><span class="line">Chicago|Minneapolis|5</span><br></pre></td></tr></table></figure></p>
<h2 id="三-sql解释器">三、<span class="math inline">\(SQL\)</span>解释器</h2>
<h3 id="1概括">1.概括</h3>
<p>  为了创建一个<span class="math inline">\(SQL\)</span>解释器，我们需要创造一个对表格的表示、对<span class="math inline">\(SQL\)</span>语句的分析器，和对分析后语句的计算器。</p>
<p>  在这个实现中，每个表格有自己的一个类，并且表格中的每行都由该类的一个实例来代表。一行的每一列都有一个属性，并且表格是列的序列。</p>
<h3 id="2table的创建">2.<span class="math inline">\(table\)</span>的创建</h3>
<p>  在<span class="math inline">\(python\)</span>中，可以用<span class="math inline">\(namedtuple\)</span>函数实现表格的类，它会返回一个新的<span class="math inline">\(tuple\)</span>子类，这个子类会为元组中的每个元素给予名称。例如，先前的<span class="math inline">\(cities\)</span>表格可以用如下<span class="math inline">\(python\)</span>语句实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">CitiesRow = namedtuple(<span class="string">&quot;Row&quot;</span>, [<span class="string">&quot;latitude&quot;</span>, <span class="string">&quot;longitude&quot;</span>, <span class="string">&quot;name&quot;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cities = [CitiesRow(<span class="number">38</span>, <span class="number">122</span>, <span class="string">&quot;Berkeley&quot;</span>),</span><br><span class="line">              CitiesRow(<span class="number">42</span>,  <span class="number">71</span>, <span class="string">&quot;Cambridge&quot;</span>),</span><br><span class="line">              CitiesRow(<span class="number">43</span>,  <span class="number">93</span>, <span class="string">&quot;Minneapolis&quot;</span>)]</span><br></pre></td></tr></table></figure></p>
<h3 id="3select的实现">3.<span class="math inline">\(select\)</span>的实现</h3>
<p>  可以通过序列操作来实现<span class="math inline">\(select\)</span>语句，例如先前生成的<span class="math inline">\(cities\)</span>的<span class="math inline">\(distances\)</span>的表格： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table distances as</span><br><span class="line">   ...&gt;   select name, 60*abs(latitude-38) as distance from cities;</span><br><span class="line">sqlite&gt; select distance/5, name from distances;</span><br><span class="line">0|Berkeley</span><br><span class="line">48|Cambridge</span><br><span class="line">84|Minneapolis</span><br></pre></td></tr></table></figure></p>
<p>  这个表格是由<span class="math inline">\(cities\)</span>的<span class="math inline">\(name\)</span>列和<span class="math inline">\(latitude\)</span>列生成的。该过程可以通过对输入表格的行用一个函数映射(<span class="math inline">\(mapping\;a\;function\)</span>)、然后返回一个新的行来实现：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>DistancesRow = namedtuple(<span class="string">&quot;Row&quot;</span>, [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;distance&quot;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">cities_row</span>):</span><br><span class="line">        latitude, longitude, name = cities_row</span><br><span class="line">        <span class="keyword">return</span> DistancesRow(name, <span class="number">60</span>*<span class="built_in">abs</span>(latitude-<span class="number">38</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>distances = <span class="built_in">list</span>(<span class="built_in">map</span>(select, cities))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> distances:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">Row(name=<span class="string">&#x27;Berkeley&#x27;</span>, distance=<span class="number">0</span>)</span><br><span class="line">Row(name=<span class="string">&#x27;Cambridge&#x27;</span>, distance=<span class="number">240</span>)</span><br><span class="line">Row(name=<span class="string">&#x27;Minneapolis&#x27;</span>, distance=<span class="number">300</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="4解释器的整体实现">4.解释器的整体实现</h3>
<p>  <span class="math inline">\(SQL\)</span>解释器的设计将上述方法普遍化了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Select</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;select [columns] from [tables] where [condition] order by [order].&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, columns, tables, condition, order</span>):</span><br><span class="line">            self.columns = columns</span><br><span class="line">            self.tables = tables</span><br><span class="line">            self.condition = condition</span><br><span class="line">            self.order = order</span><br><span class="line">            self.make_row = create_make_row(self.columns)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, env</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Join, filter, sort, and map rows from tables to columns.&quot;&quot;&quot;</span></span><br><span class="line">            from_rows = join(self.tables, env)</span><br><span class="line">            filtered_rows = <span class="built_in">filter</span>(self.<span class="built_in">filter</span>, from_rows)</span><br><span class="line">            ordered_rows = self.sort(filtered_rows)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>(self.make_row, ordered_rows)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">self, row</span>):</span><br><span class="line">            <span class="keyword">if</span> self.condition:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">eval</span>(self.condition, row)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">self, rows</span>):</span><br><span class="line">            <span class="keyword">if</span> self.order:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sorted</span>(rows, key=<span class="keyword">lambda</span> r: <span class="built_in">eval</span>(self.order, r))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> rows</span><br></pre></td></tr></table></figure></p>
<p>  <code>execute</code>方法将输入的表格进行合并、过滤和排序。最后输出行调用的函数<code>make_row</code>是一个高阶函数，它为生成的表格创建了一个新的类，并且定义了如何从一个输入行(<span class="math inline">\(input\;row\)</span>)到一个输出行(<span class="math inline">\(output\;row\)</span>)： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_make_row</span>(<span class="params">description</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a function from an input environment (dict) to an output row.</span></span><br><span class="line"><span class="string">        description -- a comma-separated list of [expression] as [column name]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#seperate the string by commas and space</span></span><br><span class="line">        columns = description.split(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">        expressions, names = [], []</span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> columns:</span><br><span class="line">        <span class="comment">#if an &#x27;as&#x27; is contained in the coloum,then divide it into expression and column name</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot; as &quot;</span> <span class="keyword">in</span> column:</span><br><span class="line">                expression, name = column.split(<span class="string">&quot; as &quot;</span>)</span><br><span class="line">         <span class="comment">#else,view expression and name as the same</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                expression, name = column, column</span><br><span class="line">            expressions.append(expression)</span><br><span class="line">            names.append(name)</span><br><span class="line">        row = namedtuple(<span class="string">&quot;Row&quot;</span>, names)</span><br><span class="line">        <span class="comment">#the lambda function output a named tuple,its value is received by calculating the expression in the current environment</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> env: row(*[<span class="built_in">eval</span>(e, env) <span class="keyword">for</span> e <span class="keyword">in</span> expressions])</span><br></pre></td></tr></table></figure></p>
<p>  最后，我们需要定义<span class="math inline">\(join\)</span>函数。在提供<code>env</code>，包括由名字键(<span class="math inline">\(keyed\;by\;name\)</span>)控制的现有表格(以行列表的形式存在)，的情况下，<span class="math inline">\(join\)</span>函数通过<span class="math inline">\(python\)</span>的<span class="math inline">\(product\)</span>函数，将这些行列表进行合并。对被合并的输出行，它用<code>make_env</code>函数映射，来得出对应字段的计算值：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">tables, env</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return an iterator over dictionaries from names to values in a row.</span></span><br><span class="line"><span class="string">        tables -- a comma-separate sequences of table names</span></span><br><span class="line"><span class="string">        env    -- a dictionary from global names to tables</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        names = tables.split(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">        joined_rows = product(*[env[name] <span class="keyword">for</span> name <span class="keyword">in</span> names])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> rows: make_env(rows, names), joined_rows)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">make_env</span>(<span class="params">rows, names</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create an environment of names bound to values.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#transform a tuple into a dictionary</span></span><br><span class="line">        env = <span class="built_in">dict</span>(<span class="built_in">zip</span>(names, rows))</span><br><span class="line">        <span class="comment"># add the name and its value into the dictionary</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> row._fields:</span><br><span class="line">                env[name] = <span class="built_in">getattr</span>(row, name)</span><br><span class="line">        <span class="keyword">return</span> env</span><br></pre></td></tr></table></figure></p>
<p>  上述的<span class="math inline">\(SQL\)</span>解释器能够实现大部分<span class="math inline">\(SQL\)</span>语句： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select name, 60*abs(latitude-38) as distance</span><br><span class="line">   ...&gt;        from cities where name != &quot;Berkeley&quot; order by -longitude;</span><br><span class="line">Minneapolis|420</span><br><span class="line">Cambridge|240</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>env = &#123;<span class="string">&quot;cities&quot;</span>: cities&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select = Select(<span class="string">&quot;name, 60*abs(latitude-38) as distance&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;cities&quot;</span>, <span class="string">&quot;name != &#x27;Berkeley&#x27;&quot;</span>, <span class="string">&quot;-longitude&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> select.execute(env):</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">Row(name=<span class="string">&#x27;Minneapolis&#x27;</span>, distance=<span class="number">300</span>)</span><br><span class="line">Row(name=<span class="string">&#x27;Cambridge&#x27;</span>, distance=<span class="number">240</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select cities.name as name, distance, longitude</span><br><span class="line">   ...&gt;        from cities, distances where cities.name = distances.name;</span><br><span class="line">Cambridge|240|71</span><br><span class="line">Minneapolis|420|93</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>env[<span class="string">&quot;distances&quot;</span>] = <span class="built_in">list</span>(select.execute(env))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joined = Select(<span class="string">&quot;cities.name as name, distance, longitude&quot;</span>, <span class="string">&quot;cities, distances&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;cities.name == distances.name&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> joined.execute(env):</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">Row(name=<span class="string">&#x27;Cambridge&#x27;</span>, distance=<span class="number">240</span>, longitude=<span class="number">71</span>)</span><br><span class="line">Row(name=<span class="string">&#x27;Minneapolis&#x27;</span>, distance=<span class="number">300</span>, longitude=<span class="number">93</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="四-递归select语句">四、递归<span class="math inline">\(select\)</span>语句</h2>
<h3 id="1with语句">1.<span class="math inline">\(with\)</span>语句</h3>
<p>  <span class="math inline">\(with\)</span>语句的格式如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with [tables] select [columns] from [names] where [condition] order by [order]</span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(tables\)</span>部分是一个用逗号分隔开的列表，列表内是对表格的描述：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[table name]([column names]) as ([select statement])</span><br></pre></td></tr></table></figure></p>
<p>  任何<span class="math inline">\(select\)</span>语句都可以用于描述表格。</p>
<p>  下面的例子展示了<span class="math inline">\(with\)</span>语句的使用： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; with</span><br><span class="line">   ...&gt;   states(city, state) as (</span><br><span class="line">   ...&gt;     select &quot;Berkeley&quot;,  &quot;California&quot;    union</span><br><span class="line">   ...&gt;     select &quot;Boston&quot;,    &quot;Massachusetts&quot; union</span><br><span class="line">   ...&gt;     select &quot;Cambridge&quot;, &quot;Massachusetts&quot; union</span><br><span class="line">   ...&gt;     select &quot;Chicago&quot;,   &quot;Illinois&quot;      union</span><br><span class="line">   ...&gt;     select &quot;Pasadena&quot;,  &quot;California&quot;</span><br><span class="line">   ...&gt;   )</span><br><span class="line">   ...&gt; select a.city, b.city, a.state from states as a, states as b</span><br><span class="line">   ...&gt;        where a.state = b.state and a.city &lt; b.city;</span><br><span class="line">Berkeley|Pasadena|California</span><br><span class="line">Boston|Cambridge|Massachusetts</span><br></pre></td></tr></table></figure></p>
<p>  在<span class="math inline">\(with\)</span>语句中定义的表格可以包含一个简单的递归结构，通过其他的输出行来得出当前输出行。例如下面定义一个<span class="math inline">\(5\)</span>到<span class="math inline">\(15\)</span>间整数的表格： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; with</span><br><span class="line">   ...&gt;   ints(n) as (</span><br><span class="line">   ...&gt;     select 5 union</span><br><span class="line">   ...&gt;     select n+1 from ints where n &lt; 15</span><br><span class="line">   ...&gt;   )</span><br><span class="line">   ...&gt; select n, n*n from ints where n % 2 = 1;</span><br><span class="line">5|25</span><br><span class="line">7|49</span><br><span class="line">9|81</span><br><span class="line">11|121</span><br><span class="line">13|169</span><br><span class="line">15|225</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(with\)</span>语句还可以定义多重表格，表格间用逗号隔开。例如下面求解勾股数的表格：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; with</span><br><span class="line">   ...&gt;   ints(n) as (</span><br><span class="line">   ...&gt;     select 1 union </span><br><span class="line">            select n+1 from ints where n &lt; 20</span><br><span class="line">   ...&gt;   ),</span><br><span class="line">   ...&gt;   squares(x, xx) as (</span><br><span class="line">   ...&gt;     select n, n*n from ints</span><br><span class="line">   ...&gt;   ),</span><br><span class="line">   ...&gt;   sum_of_squares(a, b, sum) as (</span><br><span class="line">   ...&gt;     select a.x, b.x, a.xx + b.xx</span><br><span class="line">   ...&gt;            from squares as a, squares as b where a.x &lt; b.x</span><br><span class="line">   ...&gt;   )</span><br><span class="line">   ...&gt; select a, b, x from squares, sum_of_squares where sum = xx;</span><br><span class="line">3|4|5</span><br><span class="line">6|8|10</span><br><span class="line">5|12|13</span><br><span class="line">9|12|15</span><br><span class="line">8|15|17</span><br><span class="line">12|16|20</span><br></pre></td></tr></table></figure></p>
<p>  设计递归询问需要确保每个输入行都有足够的信息来计算结果行。例如下面求解斐波那契数的表格：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; with</span><br><span class="line">   ...&gt;   fib(previous, current) as (</span><br><span class="line">   ...&gt;     select 0, 1 union</span><br><span class="line">   ...&gt;     select current, previous+current from fib</span><br><span class="line">   ...&gt;     where current &lt;= 100</span><br><span class="line">   ...&gt;   )</span><br><span class="line">   ...&gt; select previous from fib;</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">55</span><br><span class="line">89</span><br></pre></td></tr></table></figure></p>
<h3 id="2搭建字符串">2.搭建字符串</h3>
<p>  两个字符串可以通过<code>||</code>操作符合并成一个更长的字符串：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; with wall(n) as (</span><br><span class="line">  ....&gt;   select 99 union select 98 union select 97</span><br><span class="line">  ....&gt; )</span><br><span class="line">  ....&gt; select n || &quot; bottles&quot; from wall;</span><br><span class="line">99 bottles</span><br><span class="line">98 bottles</span><br><span class="line">97 bottles</span><br></pre></td></tr></table></figure></p>
<p>  这个操作可以用来通过短语来构建句子。例如，构建英语句子的一个方式是用主语、动词和宾语进行组合：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table nouns as</span><br><span class="line">  ....&gt;   select &quot;the dog&quot; as phrase union</span><br><span class="line">  ....&gt;   select &quot;the cat&quot;           union</span><br><span class="line">  ....&gt;   select &quot;the bird&quot;;</span><br><span class="line">sqlite&gt; select subject.phrase || &quot; chased &quot; || object.phrase</span><br><span class="line">  ....&gt;        from nouns as subject, nouns as object</span><br><span class="line">  ....&gt;        where subject.phrase != object.phrase;</span><br><span class="line">the bird chased the cat</span><br><span class="line">the bird chased the dog</span><br><span class="line">the cat chased the bird</span><br><span class="line">the cat chased the dog</span><br><span class="line">the dog chased the bird</span><br><span class="line">the dog chased the cat</span><br></pre></td></tr></table></figure></p>
<h2 id="五-归并与分组">五、归并与分组</h2>
<h3 id="1归并操作">1.归并操作</h3>
<p>  <span class="math inline">\(select\)</span>语句可以实现如<span class="math inline">\(max\)</span>、<span class="math inline">\(min\)</span>、<span class="math inline">\(count\)</span>、<span class="math inline">\(sum\)</span>等归并操作，它们分别返回行的最大最小值、行的数量和行内值的和：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table animals as</span><br><span class="line">  ....&gt;   select &quot;dog&quot; as name, 4 as legs, 20 as weight union</span><br><span class="line">  ....&gt;   select &quot;cat&quot;        , 4        , 10           union</span><br><span class="line">  ....&gt;   select &quot;ferret&quot;     , 4        , 10           union</span><br><span class="line">  ....&gt;   select &quot;t-rex&quot;      , 2        , 12000        union</span><br><span class="line">  ....&gt;   select &quot;penguin&quot;    , 2        , 10           union</span><br><span class="line">  ....&gt;   select &quot;bird&quot;       , 2        , 6;</span><br><span class="line">sqlite&gt; select max(legs) from animals;</span><br><span class="line">4</span><br><span class="line">sqlite&gt; select sum(weight) from animals;</span><br><span class="line">12056</span><br><span class="line">sqlite&gt; select min(legs), max(weight) from animals where name &lt;&gt; &quot;t-rex&quot;;</span><br><span class="line">2|20</span><br></pre></td></tr></table></figure></p>
<p>  <code>count(*)</code>语句用于计算对应量的行的数量：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select count(legs) from animals;</span><br><span class="line">6</span><br><span class="line">sqlite&gt; select count(*) from animals;</span><br><span class="line">6</span><br><span class="line">sqlite&gt; select count(distinct legs) from animals;</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h3 id="2groupby和having语句">2.<span class="math inline">\(group\;by\)</span>和<span class="math inline">\(having\)</span>语句</h3>
<p>  <span class="math inline">\(group\;by\)</span>和<span class="math inline">\(having\)</span>语句用于将表格的行分割为组的一个子集(<span class="math inline">\(subset\;of\;groups\)</span>)并只从这些子集中挑选一个。任何在<span class="math inline">\(having\)</span>语句中的归并语句都会应用到表格的每一行，而不是一次性用于表格的所有行。例如下面的例子：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select legs, max(weight) from animals group by legs;</span><br><span class="line">2|12000</span><br><span class="line">4|20</span><br><span class="line">sqlite&gt; select weight from animals group by weight having count(*)&gt;1;</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(group\;by\)</span>语句可以接受多个列，并将原来的表格按照这些列分组：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select max(name) from animals group by legs, weight order by name;</span><br><span class="line">bird</span><br><span class="line">dog</span><br><span class="line">ferret</span><br><span class="line">penguin</span><br><span class="line">t-rex</span><br><span class="line">sqlite&gt; select max(name), legs, weight from animals group by legs, weight</span><br><span class="line">  ....&gt;   having max(weight) &lt; 100;</span><br><span class="line">bird|2|6</span><br><span class="line">penguin|2|10</span><br><span class="line">ferret|4|10</span><br><span class="line">dog|4|20</span><br><span class="line">sqlite&gt; select count(*), weight/legs from animals group by weight/legs;</span><br><span class="line">2|2</span><br><span class="line">1|3</span><br><span class="line">2|5</span><br><span class="line">1|6000</span><br><span class="line"></span><br><span class="line">sqlite&gt; select name, legs, max(weight) from animals group by legs;</span><br><span class="line">t-rex|2|12000</span><br><span class="line">dog|4|20</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(having\)</span>语句可以和<span class="math inline">\(where\)</span>语句一样过滤表格元素，还可以包含对归并元素的引用。可以按照如下原则选择两种语句：当过滤条件是对单一的行执行时使用<span class="math inline">\(where\)</span>语句；当过滤条件设计归并操作时使用<span class="math inline">\(having\)</span>语句。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 4.Data Processing</category>
      </categories>
  </entry>
  <entry>
    <title>5.1.自动装箱</title>
    <url>/2024/05/31/5.1.Autoboxing/</url>
    <content><![CDATA[<h1 id="51自动装箱"><span class="math inline">\(5.1\)</span>自动装箱</h1>
<h3 id="1自动装箱与解包">1.自动装箱与解包</h3>
<p>  当我们实例化一个泛型对象时，我们需要指定其具体的类型，例如<code>LinkedListDeque&lt;Integer&gt;</code>。对于<span class="math inline">\(Java\)</span>的<span class="math inline">\(8\)</span>种基本类型，我们使用相应的引用类型，这些引用类型被称为包装类(<span class="math inline">\(wrapper\;classes\)</span>)：</p>
<p><img src="/2024/05/31/5.1.Autoboxing/image.png"></p>
<p>  由引用类型转换到基本类型，我们不需要执行额外的操作。例如，我们可以直接写如下程序：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; L = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">      L.add(<span class="number">5</span>);</span><br><span class="line">      L.add(<span class="number">6</span>);</span><br><span class="line">      <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> L.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  而不必写成如下繁琐的形式： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; L = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">      L.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>));</span><br><span class="line">      L.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Use the Integer.valueOf method to convert to int */</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> L.get(<span class="number">0</span>).valueOf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这是因为<span class="math inline">\(Java\)</span>会自动“装箱”(<span class="math inline">\(autobox\)</span>)与“解包”(<span class="math inline">\(unbox\)</span>)基本类型与引用类型。因此，下面的程序都是正确的：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blah</span><span class="params">(Integer x)</span> &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">blah(x);</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blahPrimitive</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">20</span>);</span><br><span class="line">blahPrimitive(x);</span><br></pre></td></tr></table></figure></p>
<p>  不过需要注意，数组不能自动装箱或解包。</p>
<h3 id="2类型扩展">2.类型扩展</h3>
<p>  当需要的时候，<span class="math inline">\(Java\)</span>会自动扩展一个初始类型的范围，例如：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blahDouble</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">    System.out.println(“<span class="type">double</span>: “ + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">blahDouble(x);</span><br></pre></td></tr></table></figure></p>
<p>  是正确的，但： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blahInt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    System.out.println(“<span class="type">int</span>: “ + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">blahInt(x);</span><br></pre></td></tr></table></figure></p>
<p>  是错误的，因为<span class="math inline">\(int\)</span>的范围小于<span class="math inline">\(double\)</span>，不能扩展到比自己更大的集合中。此时必须使用类型铸造：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">blahInt((<span class="type">int</span>) x);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>5.Generics and Autoboxing</category>
      </categories>
  </entry>
  <entry>
    <title>5.3.泛类的创建</title>
    <url>/2024/05/31/5.3.Creating%20Another%20Generic%20Class/</url>
    <content><![CDATA[<h1 id="53泛类的创建"><span class="math inline">\(5.3\)</span>泛类的创建</h1>
<h3 id="1泛型方法的创建">1.泛型方法的创建</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; V <span class="title function_">get</span><span class="params">(Map61B&lt;K,V&gt; map, K key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> map.containsKey(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//why &lt;K,V&gt;?because the parameters takes two different</span></span><br><span class="line"><span class="comment">//genetic types,so we alse use two. </span></span><br></pre></td></tr></table></figure>
<h3 id="2gt运算符的泛型化">2.<code>&gt;</code>运算符的泛型化</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; K <span class="title function_">maxKey</span><span class="params">(Map61B&lt;K, V&gt; map)</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// the &quot;extends&quot; assure that the object has a &quot;compareTo&quot; method.</span></span><br></pre></td></tr></table></figure>
<p>  此处的<span class="math inline">\(extends\)</span>关键词，可以理解为“<span class="math inline">\(K\)</span>必须是可比的”的声明。<span class="math inline">\(extends\)</span>会对对象施加一个约束、而非赋予它新的能力。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>5.Generics and Autoboxing</category>
      </categories>
  </entry>
  <entry>
    <title>6.2.异常引发</title>
    <url>/2024/05/31/6.2.Throwing%20Exceptions/</url>
    <content><![CDATA[<h1 id="62异常引发"><span class="math inline">\(6.2\)</span>异常引发</h1>
<h3 id="1throw语句">1.<span class="math inline">\(throw\)</span>语句</h3>
<p>  考虑下面这个实现<span class="math inline">\(ArraySet\)</span>的程序： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// the next item to be added will be at position size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns true if this map contains a mapping for the specified key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (items[i].equals(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Associates the specified value with the specified key in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the number of key-value mappings in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这个程序有一个小问题：当我们向<span class="math inline">\(ArraySet\)</span>中加入<span class="math inline">\(null\)</span>时，会产生<code>NullPointerException</code>的错误。这是因为：在<code>contains</code>方法中，由于加入了<span class="math inline">\(null\)</span>，调用<span class="math inline">\(items[i]\)</span>时会产生这种错误。</p>
<p>  我们可以选择抛出自己的异常(<span class="math inline">\(exceptions\)</span>)。在<span class="math inline">\(python\)</span>中我们使用<span class="math inline">\(raise\)</span>语句，而在<span class="math inline">\(Java\)</span>中，我们可以用如下语句声明错误：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionObject</span>(parameter1, ...)</span><br></pre></td></tr></table></figure></p>
<p>  于是，我们可以如下编写我们的异常抛弃(<span class="math inline">\(throwing\;exception\)</span>)语句：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">   Throws an IllegalArgumentException if the key is null. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;can&#x27;t add null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  虽然不管有没有<span class="math inline">\(throw\)</span>语句，程序都会在该处中断。但是，通过<span class="math inline">\(throw\)</span>语句，我们对程序有了更高的掌控力：我们可以自己决定程序应该在何处中断。同时，我们也可以将<span class="math inline">\(Java\)</span>中的报错更改为更具体的语句。</p>
<h3 id="2catch语句">2.<span class="math inline">\(catch\)</span>语句</h3>
<p>  利用先前的<span class="math inline">\(throw\)</span>，我们可以将<span class="math inline">\(Java\)</span>中的隐性错误(<span class="math inline">\(implicit\;exceptions\)</span>)显式化，例如：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ayyy lmao&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;For no reason.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ java Alien</span><br><span class="line">ayyy lmao</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.RuntimeException: For no reason.</span><br><span class="line">at Alien.main(Alien.java:<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>  这里，我们发现了构造方法<code>new</code>，这看起来和类的实例化非常相似——事实上就是如此。<span class="math inline">\(RuntimeException\)</span>也是一个普通的<span class="math inline">\(Java\)</span>实例。</p>
<p>  因此，我们可以<span class="math inline">\(catch\)</span>每个异常实例，如下面的例子：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="string">&quot;Retriever&quot;</span>, <span class="number">80</span>);</span><br><span class="line">d.becomeAngry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    d.receivePat();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Tried to pat: &quot;</span> + e);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure></p>
<p>  其对应输出可能为： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java ExceptionDemo</span><br><span class="line">Tried to pat: java.lang.RuntimeException: grrr... snarl snarl</span><br><span class="line">Lucy is a displeased Retriever weighing <span class="number">80.0</span> standard lb units.</span><br></pre></td></tr></table></figure></p>
<p>  可以看到，我们在<span class="math inline">\(catch\)</span>到<code>RuntimeException</code>后，依然执行到了最后一行。</p>
<p>  我们还可以用<span class="math inline">\(catch\)</span>语句来执行修正措施：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="string">&quot;Retriever&quot;</span>, <span class="number">80</span>);</span><br><span class="line">d.becomeAngry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    d.receivePat();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">    <span class="string">&quot;Tried to pat: &quot;</span> + e);</span><br><span class="line">    d.eatTreat(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line">d.receivePat();</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure></p>
<p>  在这个程序中，我们在发现异常时用<span class="math inline">\(treat\)</span>来慰抚<span class="math inline">\(Dog\)</span>，这样，程序的异常就解决了：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java ExceptionDemo</span><br><span class="line">Tried to pat: java.lang.RuntimeException: grrr... snarl snarl</span><br><span class="line">Lucy munches the banana</span><br><span class="line"></span><br><span class="line">Lucy enjoys the pat.</span><br><span class="line"></span><br><span class="line">Lucy is a happy Retriever weighing <span class="number">80.0</span> standard lb units.</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>  In the real world, this corrective action might be extending an
antenna on a robot when an exception is thrown by an operation expecting
a ready antenna. Or perhaps we simply want to write the error to a log
file for later analysis.</p>
</blockquote>
<h3 id="3异常处理的哲学">3.异常处理的哲学</h3>
<p>  异常处理使得我们在概念上将错误处理(<span class="math inline">\(error\;handling\)</span>)与剩余部分的程序分离开来。例如，考虑下面的程序：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func readFile: &#123;</span><br><span class="line">    open the file;</span><br><span class="line">    determine its size;</span><br><span class="line">    allocate that much memory;</span><br><span class="line">    read the file into memory;</span><br><span class="line">    close the file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  如果不进行异常处理，我们可能会对程序进行如下改写：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func readFile: &#123;</span><br><span class="line">    open the file;</span><br><span class="line">    <span class="keyword">if</span> (theFileIsOpen) &#123;</span><br><span class="line">        determine its size;</span><br><span class="line">        <span class="keyword">if</span> (gotTheFileLength) &#123;</span><br><span class="line">            allocate that much memory;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;fileLengthError&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span> (gotEnoughMemory) &#123;</span><br><span class="line">                read the file into memory;</span><br><span class="line">            <span class="keyword">if</span> (readFailed) &#123;</span><br><span class="line">                <span class="keyword">return</span> error(<span class="string">&quot;readError&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;memoryError&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> error(<span class="string">&quot;fileOpenError&quot;</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样的代码十分冗杂。我们可以用异常处理如下书写： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func readFile: &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        open the file;</span><br><span class="line">        determine its size;</span><br><span class="line">        allocate that much memory;</span><br><span class="line">        read the file into memory;</span><br><span class="line">        close the file;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (fileOpenFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (sizeDeterminationFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (memoryAllocationFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (readFailed) &#123;</span><br><span class="line">        doSomething;    </span><br><span class="line">    &#125; <span class="keyword">catch</span> (fileCloseFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  异常处理的方法让代码十分整洁：首先，程序先尝试执行所需的操作；然后，程序开始捕捉所有的错误。</p>
<blockquote>
<p>  Good code feels like a story; it has a certain beauty to its
construction. That clarity makes it easier to both write and maintain
over time.</p>
</blockquote>
<h3 id="4未被捕捉的异常">4.未被捕捉的异常</h3>
<p>  当一个异常被引发时，它会向下历经如下的栈：</p>
<p><img src="/2024/05/31/6.2.Throwing%20Exceptions/image.png"></p>
<p>  如果三个方法都没有捕捉到异常，程序就会中断，<span class="math inline">\(Java\)</span>会给用户发送信息，并打印堆栈跟踪的信息：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException in thread “main”: </span><br><span class="line">at ArrayRingBuffer.peek:<span class="number">63</span> </span><br><span class="line">at GuitarString.sample:<span class="number">48</span> </span><br><span class="line">at GuitarHeroLite.java:<span class="number">110</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>6.Exception &amp; Iterator &amp; Iterables &amp; Object Methods</category>
      </categories>
  </entry>
  <entry>
    <title>6.3.迭代</title>
    <url>/2024/05/31/6.3.Iteration/</url>
    <content><![CDATA[<h1 id="63迭代"><span class="math inline">\(6.3\)</span>迭代</h1>
<h3 id="1增强型for循环">1.增强型<span class="math inline">\(for\)</span>循环</h3>
<p>  我们知道，可以用以下<span class="math inline">\(for\)</span>语句实现对数组元素的遍历：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (String city : s) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这与下面的程序等价： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">Iterator&lt;String&gt; seer = s.iterator();</span><br><span class="line"><span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> seer.next();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这个程序的关键在于被称作迭代器(<span class="math inline">\(iterator\)</span>)的对象。我们可以使用如下方法返回一个迭代器对象：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>  例如，我们可以通过如下语句实现对<span class="math inline">\(List\)</span>的迭代遍历： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; friends = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">...</span><br><span class="line">Iterator&lt;Integer&gt; seer = friends.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">System.out.println(seer.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这个迭代器有三个关键方法：</p>
<ol type="1">
<li>获得迭代器对象：<code>Iterator&lt;Integer&gt; seer = friends.iterator();</code>。</li>
<li>检测是否有对象剩余：<code>seer.hasNext()</code>。</li>
<li>返回当前对象、并使迭代器前进一个对象：<code>seer.next()</code>。</li>
</ol>
<h3 id="2迭代器的实现">2.迭代器的实现</h3>
<h4 id="a迭代器要素">  <span class="math inline">\(a.\)</span>迭代器要素</h4>
<p>  首先，我们考虑编译器需要知道哪些可迭代对象的信息。首先，<code>iterator()</code>被调用了，于是我们需要知道：</p>
<ul>
<li>该接口具有<code>iterator()</code>方法。</li>
</ul>
<p>  其次，<span class="math inline">\(seer\)</span>的<code>.next()</code>与<code>.hasNext()</code>方法被调用了，于是：
*
迭代器接口是否有<code>.next()</code>与<code>.hasNext()</code>方法。</p>
<h4 id="b迭代器的实现">  <span class="math inline">\(b.\)</span>迭代器的实现</h4>
<ol type="1">
<li><p>我们的<span class="math inline">\(List\)</span>接口需要扩展迭代器接口，继承迭代器的抽象方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>编译器检查迭代器接口是否具有<code>.next()</code>与<code>.hasNext()</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>  特定的类需要实现自己的迭代器方法与行为。例如，我们想给<span class="math inline">\(ArrarMap\)</span>添加一个迭代器。可以先如下实现迭代器接口所需方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ArraySetIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> wizPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySetIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        wizPos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wizPos &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">returnItem</span> <span class="operator">=</span> items[wizPos];</span><br><span class="line">        wizPos += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> returnItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样，我们就可以利用<span class="math inline">\(ArraySetIterator\)</span>来实现对<span class="math inline">\(ArrayMap\)</span>的迭代： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArraySet&lt;Integer&gt; aset = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">aset.add(<span class="number">5</span>);</span><br><span class="line">aset.add(<span class="number">23</span>);</span><br><span class="line">aset.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iter = aset.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="c增强型for循环的实现">  <span class="math inline">\(c.\)</span>增强型<span class="math inline">\(for\)</span>循环的实现</h4>
<p>  为了实现增强型<span class="math inline">\(for\)</span>循环，我们需要让<span class="math inline">\(ArrayMap\)</span>类实现可迭代接口。可迭代接口的关键方法是<code>iterator</code>，我们只需要如下实现：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArraySetIterator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样以后，我们就可以使用增强型<span class="math inline">\(for\)</span>循环了： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArraySet&lt;Integer&gt; aset = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : aset) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="d关键概念辨析">  <span class="math inline">\(d.\)</span>关键概念辨析</h4>
<ul>
<li><p>可迭代对象(<span class="math inline">\(iterable\)</span>)：使得一个类可以被迭代的接口，需要方法<code>iterator()</code>。</p></li>
<li><p>迭代器(<span class="math inline">\(iterator\)</span>)：定义某些方法的接口，这些方法用于实现真正的迭代。</p></li>
</ul>
<blockquote>
<p>   You can think of an Iterator as a machine that you put onto an
iterable that facilitates the iteration. Any iterable is the object on
which the iterator is performing.</p>
</blockquote>
<h3 id="3可迭代arrayset的完整实现">3.可迭代<span class="math inline">\(ArraySet\)</span>的完整实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// the next item to be added will be at position size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns true if this map contains a mapping for the specified key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (items[i].equals(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">       Throws an IllegalArgumentException if the key is null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;can&#x27;t add null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the number of key-value mappings in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** returns an iterator (a.k.a. seer) into ME */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArraySetIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ArraySetIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> wizPos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ArraySetIterator</span><span class="params">()</span> &#123;</span><br><span class="line">            wizPos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> wizPos &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">returnItem</span> <span class="operator">=</span> items[wizPos];</span><br><span class="line">            wizPos += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> returnItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArraySet&lt;Integer&gt; aset = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">        aset.add(<span class="number">5</span>);</span><br><span class="line">        aset.add(<span class="number">23</span>);</span><br><span class="line">        aset.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//iteration</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : aset) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>6.Exception &amp; Iterator &amp; Iterables &amp; Object Methods</category>
      </categories>
  </entry>
  <entry>
    <title>6.4.对象方法</title>
    <url>/2024/05/31/6.4.Object%20Methods/</url>
    <content><![CDATA[<h1 id="64对象方法"><span class="math inline">\(6.4\)</span>对象方法</h1>
<h3 id="1对象方法概述">1.对象方法概述</h3>
<p>  所有的类都继承了<span class="math inline">\(Object\)</span>类。它们继承的方法如下：</p>
<ul>
<li>String toString()</li>
<li>boolean equals(Object obj)</li>
<li>Class &lt;?&gt; getClass()</li>
<li>int hashCode()</li>
<li>protected Objectclone()</li>
<li>protected void finalize()</li>
<li>void notify()</li>
<li>void notifyAll()</li>
<li>void wait()</li>
<li>void wait(long timeout)</li>
<li>void wait(long timeout, int nanos)</li>
</ul>
<p>  下面我们重点讨论前两个。</p>
<h3 id="2tostring">2.<code>toString()</code></h3>
<p>  <code>toString</code>方法返回一个对象的字符串表示。对于特定的类，我们可以覆盖对象原有的方法。考虑下面的问题：</p>
<p>  Exercise 6.4.1: Write the toString() method so that when we print
an ArraySet, it prints the elements separated by commas inside of curly
braces. i.e {1, 2, 3, 4}. Remember, the toString() method should return
a string: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* hmmm */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(solution\)</span>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">returnString</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">        returnString += keys[i];</span><br><span class="line">        returnString += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    returnString += <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> returnString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这种写法看似简洁优雅，但每次使用<code>+=</code>运算符后，都需要创建一个新的字符串，这样的时间复杂度为<span class="math inline">\(O(n^2)\)</span>。为了优化该方法，<span class="math inline">\(Java\)</span>内置了<code>StringBuilder</code>方法。这个方法创造一个<span class="math inline">\(String\)</span>的可变对象，我们可以向对象内添加其它<span class="math inline">\(String\)</span>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">returnSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            returnSB.append(items[i].toString());</span><br><span class="line">            returnSB.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        returnSB.append(items[size - <span class="number">1</span>]);</span><br><span class="line">        returnSB.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnSB.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3equals">3.<code>equals()</code></h3>
<h4 id="aequals的实现">  <span class="math inline">\(a.\)</span><code>equals()</code>的实现</h4>
<p>  在<span class="math inline">\(Java\)</span>中，<code>==</code>检查两个对象在内存中的是否为同一个对象。由之前<span class="math inline">\(pass-by-value\)</span>原则，<code>==</code>会检查两个盒子放的是不是同一个东西：</p>
<ul>
<li>对于基本类型的变量，这表示比较它们的值是否相等。</li>
<li>对于对象(<span class="math inline">\(objects\)</span>)，这表示比较两个对象的地址或指针是否相等。</li>
</ul>
<p>  而<code>equals()</code>方法在比较对象时，只会比较两者的值是否相等，这便是我们实现它的目的。我们可以如下实现<span class="math inline">\(ArraySet\)</span>的<code>equals()</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == other) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (other == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (other.getClass() != <span class="built_in">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArraySet&lt;T&gt; o = (ArraySet&lt;T&gt;) other;</span><br><span class="line">        <span class="keyword">if</span> (o.size() != <span class="built_in">this</span>.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (T item : <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!o.contains(item)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>   在上面的<code>equals()</code>方法中，我们加入了对<span class="math inline">\(null\)</span>与跨类对象的比较的判断。我们也通过预先判断<code>==</code>的情况优化了方法。</p>
<h4 id="bequals方法的规则">  <span class="math inline">\(b.\)</span><code>equals()</code>方法的规则</h4>
<p>  <code>equals()</code>方法要符合以下规则：</p>
<ol type="1">
<li>反身性(<span class="math inline">\(reflexive\)</span>)：<code>x.equals(x) == true</code>。</li>
<li>对称性(<span class="math inline">\(symmetric\)</span>)：<code>x.equals(y) == true</code>当且仅当<code>y.equals(x) == true</code>。</li>
<li>传递性(<span class="math inline">\(transitive\)</span>)：<code>x.equals(y), y.equals(z) == true</code>，则<code>x.equals(z) == true</code>。</li>
<li><code>x.equals(null) == false</code>，不论<span class="math inline">\(x\)</span>是什么。</li>
<li><code>equals()</code>方法的参数必须是<span class="math inline">\(object\)</span>型的，这样才能覆盖原有的<code>.equals()</code>方法。</li>
</ol>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>6.Exception &amp; Iterator &amp; Iterables &amp; Object Methods</category>
      </categories>
  </entry>
  <entry>
    <title>8.2.渐进分析介绍</title>
    <url>/2024/05/31/8.2.Asymptotics%20I/</url>
    <content><![CDATA[<h1 id="82渐进分析介绍"><span class="math inline">\(8.2\)</span>
渐进分析介绍</h1>
<h3 id="1简化的分析流程">1.简化的分析流程</h3>
<blockquote>
<p>We can do the following steps to simplify our analysis: * Only
consider the worst case. * Pick a representative operation (aka: cost
model) * Ignore lower order terms * Ignore multiplicative constants.</p>
</blockquote>
<h3 id="2big-theta">2.<span class="math inline">\(Big-Theta\)</span></h3>
<p>  当对于任一比<span class="math inline">\(N_0\)</span>大的<span class="math inline">\(N\)</span>，存在<span class="math inline">\(k_1\)</span>、<span class="math inline">\(k_2\)</span>使得<span class="math inline">\(k_1·f(N)\leq R(N)\leq
k_2·f(N)\)</span>，那么：<span class="math inline">\(R(N)\in
\Theta(f(N))\)</span>。</p>
<p>  我们可以用<span class="math inline">\(\Theta\)</span>来衡量程序的增长阶数，通过确定增长函数的上界和下界，我们相当于“确定”了增长函数。</p>
<h3 id="3big-o">3.<span class="math inline">\(Big-O\)</span></h3>
<p>  <span class="math inline">\(O\)</span>可以看作是增长函数的“不等关系”，即“大于等于”。例如，我们可以说<span class="math inline">\(R(N)\in O(f(n^2))\)</span>。</p>
<p>  一般地，如果对于任一比<span class="math inline">\(N_0\)</span>大的<span class="math inline">\(N\)</span>，存在<span class="math inline">\(k_1\)</span>使得<span class="math inline">\(R(N)\leq k_1·f(N)\)</span>，有：<span class="math inline">\(R(n)\in O(f(n))\)</span>。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>8.Effecient Programming</category>
      </categories>
  </entry>
  <entry>
    <title>8.4.摊还分析</title>
    <url>/2024/05/31/8.4.Omega,Amortized%20Analysis/</url>
    <content><![CDATA[<h1 id="84摊还分析"><span class="math inline">\(8.4\)</span>摊还分析</h1>
<h3 id="1big-omega">1.<span class="math inline">\(Big-Omega\)</span></h3>
<p>  与<span class="math inline">\(O\)</span>相同，<span class="math inline">\(\Omega\)</span>描述的也是不等关系：如果对于任一比<span class="math inline">\(N_0\)</span>大的<span class="math inline">\(N\)</span>，存在<span class="math inline">\(k_1\)</span>使得<span class="math inline">\(R(N)\geq k_1·f(N)\)</span>，有：<span class="math inline">\(R(n)\in \Omega(f(n))\)</span>。</p>
<p>  关于<span class="math inline">\(\Omega\)</span>有以下两个结论：</p>
<ul>
<li><span class="math inline">\(R(n)=O(f(n)),R(n)=\Omega(f(n))\Rightarrow
R(n)=\Theta(f(n))\)</span>。</li>
<li>它用于分析算法的基本复杂度。例如，对于重复查找问题(<span class="math inline">\(duplicate-finding\)</span>)，有<span class="math inline">\(R(n)=\Omega(n)\)</span>，这说明该问题的时间复杂度最小不得超过<span class="math inline">\(n\)</span>(因为每个元素至少要遍历一次)。</li>
</ul>
<p><img src="/2024/05/31/8.4.Omega,Amortized%20Analysis/image.png"></p>
<h3 id="2摊还分析">2.摊还分析</h3>
<h4 id="a摊还分析的引入">  <span class="math inline">\(a.\)</span>摊还分析的引入</h4>
<p>  考虑下面的问题：</p>
<p>  <span class="math inline">\(e.g.\)</span>There are two choices to
feed Grigometh:</p>
<ul>
<li><p>Choice 1: Every day, Grigometh eats 3 bushels of hay from your
urn.</p></li>
<li><p>Choice 2:Grigometh eats exponentially more hay over time, but
comes exponentially less frequently. Specifically:</p>
<ul>
<li>On day 1, he eats 1 bushel of hay (total 1)</li>
<li>On day 2, he eats 2 additional bushels of hay (total 3)</li>
<li>On day 4, he eats 4 additional bushels of hay (total 7)</li>
<li>On day 8, he eats 8 additional bushels of hay (total 15)</li>
</ul></li>
</ul>
<p>  选择<span class="math inline">\(1\)</span>每次只用放置常数个干草，然而事实上，选择<span class="math inline">\(2\)</span>需要的干草数量更少，因为：</p>
<ul>
<li>On day 1, the average hay per day is 1.</li>
<li>On day 2, the average hay per day is 1.5.</li>
<li>On day 3, the average hay per day is 1.75.</li>
<li>On day 4, the average hay per day is 1.875.</li>
</ul>
<p>  这里我们采用的方法是将所有天数干草的总和“均摊”到每一天。可以看到，选择<span class="math inline">\(2\)</span>的每日干草消耗量实际上是常数。我们将选择<span class="math inline">\(2\)</span>的情况称为均摊常数。</p>
<h4 id="b摊还分析的流程">  <span class="math inline">\(b.\)</span>摊还分析的流程</h4>
<p>  更为严谨的摊还分析流程如下：</p>
<ol type="1">
<li>选择一个耗费模型(<span class="math inline">\(cost\;model\)</span>)。</li>
<li>计算第<span class="math inline">\(i\)</span>次操作后的平均耗费。</li>
<li>证明平均耗费以常数为边界(<span class="math inline">\(bound\)</span>)。</li>
</ol>
<p>  以我们的数组扩容为例，对于数组扩容，我们每次需要执行的操作如下：</p>
<ul>
<li>x.add(0) performs 1 write operation. No resizing. Total: 1
operation</li>
<li>x.add(1) resizes and copies the existing array (1 read, 1 write),
and then writes the new element. Total: 3 operations</li>
<li>x.add(2) resizes and copies the existing array (2 reads, 2 writes),
and then writes the new element. Total: 5 operations</li>
<li>x.add(3) does not resize, and only writes the new element. Total: 1
operations</li>
<li>x.add(4) resizes and copies the existing array (4 reads, 4 writes),
and then writes the new element. Total: 9 operations</li>
</ul>
<p>  我们可以列出如下的表格：</p>
<p><img src="/2024/05/31/8.4.Omega,Amortized%20Analysis/image-1.png"></p>
<p>  我们接着引入“势能”(<span class="math inline">\(potential\)</span>)的概念。对于每个操作<span class="math inline">\(i\)</span>，令<span class="math inline">\(c_i\)</span>为该操作的真实时间耗费，令<span class="math inline">\(a_i\)</span>为任一摊还时间消耗。对于常数时间消耗，<span class="math inline">\(a_i\)</span>也必须是常数。</p>
<p>  我们令<span class="math inline">\(\Phi_i\)</span>为操作<span class="math inline">\(i\)</span>的势能，用于表示摊还消耗和真实消耗间的累积差距(<span class="math inline">\(difference\)</span>)，则：<span class="math inline">\(\Phi_i=\Phi_{i-1}+a_i-c_i\)</span>。</p>
<p>  <span class="math inline">\(a_i\)</span>可以是任一我们选择的数。如果对于我们选择的<span class="math inline">\(a_i\)</span>，<span class="math inline">\(\Phi_i\)</span>永远是非负的，那么我们预测的摊还消耗就是实际消耗的上界。如果<span class="math inline">\(a_i\)</span>为一个永远不变的常数，那么实际消耗就是以常数时间为上界，这即说明该函数的平均时间消耗为常数！</p>
<p>  对于数组扩容，可以列出以下表格：</p>
<p><img src="/2024/05/31/8.4.Omega,Amortized%20Analysis/image-2.png"></p>
<p>  可以看出，势能一直是非负的。这样，我们就可以宣称：数组扩容的操作的摊还时间是常数。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>8.Effecient Programming</category>
      </categories>
  </entry>
  <entry>
    <title>9.1.并查集介绍</title>
    <url>/2024/05/31/9.1.Introduction%20to%20Disjoint%20Sets/</url>
    <content><![CDATA[<h1 id="91并查集介绍"><span class="math inline">\(9.1\)</span>并查集介绍</h1>
<h3 id="1并查集的接口">1.并查集的接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="comment">/** connects two items P and Q */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** checks to see if two items are connected */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>9.Disjoint sets</category>
      </categories>
  </entry>
  <entry>
    <title>9.2.快速查找</title>
    <url>/2024/05/31/9.2.Quick%20Find/</url>
    <content><![CDATA[<h1 id="92快速查找"><span class="math inline">\(9.2\)</span>快速查找</h1>
<h3 id="1并查集的构造">1.并查集的构造</h3>
<p>  直观上，我们可以通过<span class="math inline">\(ListOfSet\)</span>来表示并查集，例如<code>[&#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;, &#123;4&#125;, &#123;5&#125;, &#123;6&#125;]</code>。但是，这种形式的并查集难以合并。</p>
<p>  我们考虑只用一个数组来实现并查集的合并操作，该数组按如下方式构造：</p>
<ul>
<li>数组的下标值代表元素本身。</li>
<li>数组下标对应的值代表元素所属集合的序号。</li>
</ul>
<p>  例如，我们可以如下表示<code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code>：</p>
<p><img src="/2024/05/31/9.2.Quick%20Find/image.png"></p>
<p>  集合的序号并不重要，只需要确保相同的集合的值相同即可。</p>
<h3 id="2connect操作">2.<code>connect</code>操作</h3>
<p>  有了上面的构造，我们可以通过更改数组对应下标的值来实现合并。例如，假如我们想将<span class="math inline">\(2\)</span>与<span class="math inline">\(3\)</span>合并：</p>
<p><img src="/2024/05/31/9.2.Quick%20Find/image-1.png"></p>
<h3 id="3isconnected操作">3.<code>isConnected</code>操作</h3>
<p>  为了检查<code>isConnected(x, y)</code>，我们只需要检查它们对应集合的序号是否相等即可。这只需要常数时间。</p>
<h3 id="4总结与代码实现">4.总结与代码实现</h3>
<p><img src="/2024/05/31/9.2.Quick%20Find/image-2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFindDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickFindDS</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="comment">// initialize the parent</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> id[p];</span><br><span class="line">        <span class="type">int</span> <span class="variable">qid</span> <span class="operator">=</span> id[q];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pid) &#123;</span><br><span class="line">                id[i] = qid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id[p] == id[q];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>9.Disjoint sets</category>
      </categories>
  </entry>
  <entry>
    <title>9.3.快速合并</title>
    <url>/2024/05/31/9.3.Quick%20Union/</url>
    <content><![CDATA[<h1 id="93快速合并"><span class="math inline">\(9.3\)</span>快速合并</h1>
<h3 id="1根节点的引入">1.根节点的引入</h3>
<p>  假如我们想让<code>connect</code>操作快一些，由于先前用<span class="math inline">\(id[x]\)</span>代指所属集合的操作仍是通过遍历序列实现的，时间复杂度为线性，我们希望用一个元素代指整个集合，这样合并操作只需要合并两个元素即可。</p>
<p>  对序列中的每个元素，我们给它分派(<span class="math inline">\(assign\)</span>)一个值，这个值是它的父亲(<span class="math inline">\(parent\)</span>)的索引；如果某个元素没有索引，那么它就是根节点，我们给它分派一个负数的值。下面的图示展示了<code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code>的对应表示：</p>
<p><img src="/2024/05/31/9.3.Quick%20Union/image-3.png"></p>
<p>  为了实现快速合并，我们引入一个辅助函数<code>find(int item)</code>，它返回某个元素对应的根节点。</p>
<h3 id="2connectx-y">2.<code>connect(x, y)</code></h3>
<p>  为了合并两元素，我们找到两个元素对应的根节点，然后让其中一个根节点作为另一个的儿子(<span class="math inline">\(child\)</span>)。例如<code>connect(5, 2)</code>需要进行如下操作：</p>
<ol type="1">
<li><code>find(5)</code> <span class="math inline">\(\rightarrow
3\)</span></li>
<li><code>find(2)</code> <span class="math inline">\(\rightarrow
0\)</span></li>
<li>设置<code>parent[3] = 0</code></li>
</ol>
<p><img src="/2024/05/31/9.3.Quick%20Union/image-4.png"></p>
<h3 id="3isconnectedx-y">3.<code>isConnected(x, y)</code></h3>
<p>  如果两个元素同属一个集合，那么它们的根节点应该相同。只需检查<code>find(x) == find(y)</code>即可。</p>
<h3 id="4总结与代码实现">4.总结与代码实现</h3>
<p><img src="/2024/05/31/9.3.Quick%20Union/image-6.png"></p>
<p>  看起来快速合并的运行时间比快速查询长！但是<span class="math inline">\(O(n)\)</span>代表的是快速合并的上界。当我们的树比较平衡时，快速查询的时间复杂度会非常优秀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickUnionDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickUnionDS</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i += <span class="number">1</span>) &#123;</span><br><span class="line">            parent[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[p] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> find(q);</span><br><span class="line">        parent[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>9.Disjoint sets</category>
      </categories>
  </entry>
  <entry>
    <title>1.3.C Intro</title>
    <url>/2024/05/22/1-3-C-Intro/</url>
    <content><![CDATA[<h1 id="13c-intro"><span class="math inline">\(1.3.\)</span>C Intro</h1>
<h3 id="1c-compilation">1.C compilation</h3>
<p><img src="/2024/05/22/1-3-C-Intro/image.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-1.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-2.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-3.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-4.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-5.png"></p>
<h3 id="2some-c-grammar">2.Some C grammar</h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-6.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-7.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-8.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-9.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-10.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-11.png"></p>
<h3 id="3c-pointer">3.C pointer</h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-12.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-13.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-14.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-15.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-16.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-17.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-18.png"></p>
<h3 id="4pointer-operation">4.Pointer operation</h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-19.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-20.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-21.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-22.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-23.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-24.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-25.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-26.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-27.png"></p>
<blockquote>
<p>Why? * <em>Address validity</em>: The pointer is used to store the
memory address and point at the specified data. If we cast an integer to
a pointer, the integer may <strong>not be an valid memory
address</strong>, and visit this address will lead to program crash. *
<em>Type system protection</em>: Cast ignores the protection of the type
system. An important function of the type system is to ensure that the
operations in your code are safe. For example, converting an integer to
a pointer and accessing it, skipping the type system check, might result
in accessing an incorrect data type.</p>
</blockquote>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-28.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-29.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-30.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-31.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-32.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-33.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-34.png"></p>
<h3 id="5c-string">5.C string</h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-35.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-36.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-37.png"></p>
<h3 id="6c-structures">6.C structures</h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-38.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-39.png"></p>
<h3 id="7error-types">7.Error types</h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-40.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-41.png"></p>
<h3 id="8c-array">8.C array</h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-42.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-43.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-44.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-45.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-46.png"></p>
<h3 id="9endianness">9.Endianness</h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-47.png"></p>
<h3 id="10c-memory-management">10.C memory management</h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-48.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-49.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-50.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-51.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-52.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-53.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-54.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-55.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-56.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-57.png"></p>
<blockquote>
<p>For example, the following program is right: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void functionB(int *ptr) &#123;</span><br><span class="line">    printf(&quot;Value: %d\n&quot;, *ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void functionA() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    functionB(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Because
the local variable is stored on the stack during the run of
<code>functionB</code>, it's safe to pass its pointer to the
function.</p>
<p>However, this program is wrong: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* function() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    return &amp;x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void example() &#123;</span><br><span class="line">    int *p = function(); </span><br><span class="line">    printf(&quot;Value: %d\n&quot;, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> After the function is
returned, <strong>the stack frame where <code>x</code> is located is
released</strong>, and <strong>the memory address pointed to by pointer
<code>p</code> may be overwritten by other data</strong>. This can lead
to undefined behavior</p>
</blockquote>
<p><img src="/2024/05/22/1-3-C-Intro/image-58.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-59.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-60.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-61.png"></p>
<blockquote>
<p>Static string constants are typically <strong>stored in read-only
memory</strong>, and modifying these is an undifined behavior in C.</p>
</blockquote>
<p><img src="/2024/05/22/1-3-C-Intro/image-62.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-63.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-64.png"></p>
<blockquote>
<p>The main reason for placing 4 bytes of data on multiples of 4 is to
<strong>optimize the processor's memory access efficiency</strong>.
Suppose a processor has a 4-byte memory bus width. When accessing 4-byte
aligned data, the processor <strong>can retrieve the entire data in one
memory read operation</strong>. If the data is not aligned (for example,
an int spanning two memory addresses) , the processor may <strong>need
to perform two memory reads and then merge the two reads</strong>. This
can cause performance degradation.</p>
</blockquote>
<figure>
<img src="/2024/05/22/1-3-C-Intro/image-65.png" alt="Alt text">
<figcaption aria-hidden="true">Alt text</figcaption>
</figure>
<blockquote>
<p>Let's take an example to illustrate the alignment process:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Example &#123; </span><br><span class="line">	char a; </span><br><span class="line">	int b; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> The <code>a</code> requires 1 byte, and alignment requires
1 byte, so it can be placed at the starting address of the
struction.</p>
<p>The <code>b</code> requires 4 bytes, and alignement requires 4 bytes,
so <strong>it must be placed on a multiple of 4 address.</strong> To
satisfy <code>b</code>'s alignment requirements, the compiler
<strong>inserts three padding bytes after <code>a</code></strong>,
making <code>b</code>'s address a multiple of 4.</p>
</blockquote>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-66.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-67.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-68.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-69.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-70.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-71.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-72.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-73.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-74.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-75.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-76.png"></p>
<hr>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 1.Intro</category>
      </categories>
  </entry>
  <entry>
    <title>1.2.Number Representation</title>
    <url>/2024/05/19/1-2-Number-Representation/</url>
    <content><![CDATA[<h1 id="12number-representation"><span class="math inline">\(1.2.\)</span>Number Representation</h1>
<h3 id="1binary-representation">1.Binary representation</h3>
<p><img src="/2024/05/19/1-2-Number-Representation/image.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-1.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-2.png"></p>
<ul>
<li>We move -1 to the right by one, -2 to the right, etc. Then the two
0s overlap:</li>
</ul>
<p><img src="/2024/05/19/1-2-Number-Representation/image-3.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-4.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-5.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-6.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-7.png"></p>
<h3 id="2bias-encoding">2.Bias encoding</h3>
<p><img src="/2024/05/19/1-2-Number-Representation/image-8.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-9.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-10.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-11.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-12.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-13.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-14.png"></p>
<ul>
<li>Because the biased number are all <strong>start at 0</strong>,
<strong>the MSB doesn't represent the sign anymore</strong>. So in
floating point, we can compare two biased number directly as if they
were unsigned number.</li>
</ul>
<h3 id="3iec-standard-prefixes">3.IEC standard prefixes</h3>
<p><img src="/2024/05/19/1-2-Number-Representation/image-15.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-16.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-17.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 1.Intro</category>
      </categories>
  </entry>
  <entry>
    <title>1.1.Great Indea Intro</title>
    <url>/2024/05/18/1-1-Great-Idea-Intro/</url>
    <content><![CDATA[<h3 id="1cs61c-intro">1.CS61C intro</h3>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-4.png"></p>
<ul>
<li>The hareware is composed of <strong>a gazillion computers in
parallel</strong>.</li>
<li>The computers are consisted of <strong>parallel computers within the
processing unit</strong>.</li>
<li>We get parallelism all the way down the stack.</li>
</ul>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-5.png"></p>
<h3 id="2abstraction">2.Abstraction</h3>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image.png"></p>
<ul>
<li>Each level of abstraction is only influenced by <strong>the level
above or below by one</strong>.</li>
<li>We can change out the architecture and keep the same machine
language to make program run faster.</li>
</ul>
<h3 id="3moores-law">3.Moore's law</h3>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-1.png"></p>
<ul>
<li><em>Moore's law</em>: Over time, the number of transistors that's
actual switches keeps growing exponentially.</li>
<li>However, we hit a brick wall that getting more performance is no
longer a matter of improving processes and adding transistors, but
<strong>exploiting parallelsome</strong>.</li>
</ul>
<h3 id="4localitymemory-hierarchy">4.Locality/Memory Hierarchy</h3>
<ul>
<li>It's about <strong>how far away is a piece of data</strong>.</li>
</ul>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-2.png"></p>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-3.png"></p>
<h3 id="5parallelism">5.Parallelism</h3>
<ul>
<li>We do lots of things at once, even within the most processor.</li>
<li>On the program, we spilt things up.</li>
</ul>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-6.png"></p>
<ul>
<li>However, there's a limit called <em>Amdahl's Law</em>: The amount
you can speed up something by parallelization depends on <strong>the
amount that's actually parallelizable</strong>. If the problem isn't
parallelizable, then it will fail.</li>
</ul>
<h3 id="6dependability-viaredundancy">6.Dependability via
redundancy</h3>
<ul>
<li>To deal with failures, we use <em>redundancy</em> so that a failing
piece doesn't make the whole thing fail:</li>
</ul>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-7.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 1.Intro</category>
      </categories>
  </entry>
  <entry>
    <title>10.11.编译器实现笔记</title>
    <url>/2024/05/04/10-11-%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1011编译器实现笔记"><span class="math inline">\(10.11.\)</span>编译器实现笔记</h1>
<h3 id="1symbol-table实现">1.<code>Symbol Table</code>实现</h3>
<p>  为了方便读取单一字符，我们选择<strong>利用<code>tokenizer</code>生成的代码</strong>来构建我们的<code>Symbol Table</code>.</p>
<h4 id="a准备工作">  <span class="math inline">\(a.\)</span>准备工作</h4>
<ol type="1">
<li>虽然理论上应该对于每一个子程序，我们都应该实时地产生一个对应的<code>subroutineMap</code>，但是由于较难实现，我选择遍历整个程序后，将每个子程序对应的<code>subroutineMap</code>用一个新的<span class="math inline">\(Map\)</span>来存储：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for convenience, we store the symbolTable of each subroutine into a map.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Map&lt;String, Integer&gt;&gt; mapOfSubVar = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Map&lt;String, String&gt;&gt; mapOfSubVarType = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Map&lt;String, String&gt;&gt; mapOfSubVarKind = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; subroutineVar = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; typeOfSubroutineVar = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; kindOfSubroutineVar = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>  同时，这要求我们记录下当前遍历的子程序的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">currentStringName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>由于对每个<code>class</code>，我们都要生成一个新的<code>Symbol Table</code>，
因此我们在生成对应的<code>Symbol Table</code>前先要对储存表格的<span class="math inline">\(Map\)</span>进行初始化：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startClass</span><span class="params">()</span> &#123;</span><br><span class="line">    classVar.clear();</span><br><span class="line">    typeOfClassVar.clear();</span><br><span class="line">    kindOfClassVar.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>在后续生成VM代码的过程中，我们需要每个变量对应的序号，因此我们需要设置变量对其进行存储：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//use to return the kind index</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">classNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">argNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">localNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//and for subroutine, we store their argNum and localNum</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; subroutineArgNum = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; subroutineLCLNum = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="b类变量处理">  <span class="math inline">\(b.\)</span>类变量处理</h4>
<p>  类中定义的变量遵循以下结构：</p>
<p><span class="math display">\[kind+type+name(,name);\]</span></p>
<p>  由于该结构具有普适性，我们可以用<strong>递归</strong>的方法读取并处理我们读入的<em>token</em>：</p>
<ol type="1">
<li>处理一定存在的<span class="math inline">\(kind+type+name\)</span>.</li>
<li>判断是否有<span class="math inline">\(,name\)</span>部分，如果有的话进行处理.</li>
<li>递归执行上述步骤，直至下一个传入变量不是<code>local</code>变量.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dealClassVar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Tokenizer.getNextString().equals(<span class="string">&quot;field&quot;</span>) || Tokenizer.getNextString().equals(<span class="string">&quot;static&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// get the kind</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classVarKind</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        <span class="comment">// get the type</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classVarType</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        <span class="comment">// get the name</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classVarName</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        <span class="comment">// add to correspond kind</span></span><br><span class="line">        <span class="keyword">if</span> (classVarKind.equals(<span class="string">&quot;static&quot;</span>)) &#123;</span><br><span class="line">            classVar.put(classVarName, classNum++);</span><br><span class="line">            typeOfClassVar.put(classVarName, classVarType);</span><br><span class="line">            kindOfClassVar.put(classVarName, <span class="string">&quot;this&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (classVarKind.equals(<span class="string">&quot;field&quot;</span>)) &#123;</span><br><span class="line">            classVar.put(classVarName, classNum++);</span><br><span class="line">            typeOfClassVar.put(classVarName, classVarType);</span><br><span class="line">            kindOfClassVar.put(classVarName, <span class="string">&quot;this&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if there&#x27;s a &#x27;,&#x27;, there remains some vars</span></span><br><span class="line">        <span class="keyword">while</span> (Tokenizer.getNextString().equals(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            Tokenizer.stringAdvance();</span><br><span class="line">            <span class="type">String</span> <span class="variable">nextName</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">            <span class="comment">// after the operation, there will be &#x27;,&#x27; or &#x27;;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (classVarKind.equals(<span class="string">&quot;static&quot;</span>)) &#123;</span><br><span class="line">                classVar.put(nextName, classNum++);</span><br><span class="line">                typeOfClassVar.put(nextName, classVarType);</span><br><span class="line">                kindOfClassVar.put(nextName, <span class="string">&quot;this&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (classVarKind.equals(<span class="string">&quot;field&quot;</span>)) &#123;</span><br><span class="line">                classVar.put(nextName, classNum++);</span><br><span class="line">                typeOfClassVar.put(nextName, classVarType);</span><br><span class="line">                kindOfClassVar.put(nextName, <span class="string">&quot;this&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// then we meets &#x27;;&#x27;, we skip it</span></span><br><span class="line">        Tokenizer.stringAdvance();</span><br><span class="line">        <span class="comment">// we continuously deal with rest classVar recursively</span></span><br><span class="line">        <span class="keyword">if</span> (Tokenizer.getNextString().equals(<span class="string">&quot;field&quot;</span>) || Tokenizer.getNextString().equals(<span class="string">&quot;static&quot;</span>)) &#123;</span><br><span class="line">            dealClassVar();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// finally, update the current string</span></span><br><span class="line">        currentStringName.setLength(<span class="number">0</span>);</span><br><span class="line">        currentStringName.append(Tokenizer.stringAdvance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="c子程序变量">  <span class="math inline">\(c.\)</span>子程序变量</h4>
<p>  子程序变量结构与类变量相似，这里略过。需要注意：子程序中包含参数变量，这也需要我们纳入考虑的范畴：</p>
<ul>
<li><p>对参数的处理： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dealFuncArgVar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//the function features: Dec + type + funcName + ( + args + )</span></span><br><span class="line">    <span class="comment">//so we need to ignore the irrelevant elements</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">subroutineType</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">    currentSubroutineName.setLength(<span class="number">0</span>);</span><br><span class="line">    currentSubroutineName.append(className + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    currentSubroutineName.append(Tokenizer.stringAdvance());</span><br><span class="line">    Tokenizer.stringAdvance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//we continue read the arguments until we meet &quot;)&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (!Tokenizer.getNextString().equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// type + name</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        subroutineVar.put(name, argNum++);</span><br><span class="line">        typeOfSubroutineVar.put(name, type);</span><br><span class="line">        kindOfSubroutineVar.put(name, <span class="string">&quot;argument&quot;</span>);</span><br><span class="line">        <span class="comment">//if there&#x27;s a &#x27;,&#x27;, then we have more args</span></span><br><span class="line">        <span class="keyword">while</span> (Tokenizer.getNextString().equals(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//ignore the &#x27;,&#x27;</span></span><br><span class="line">            Tokenizer.stringAdvance();</span><br><span class="line">            type = Tokenizer.stringAdvance();</span><br><span class="line">            name = Tokenizer.stringAdvance();</span><br><span class="line">            subroutineVar.put(name, argNum++);</span><br><span class="line">            typeOfSubroutineVar.put(name, type);</span><br><span class="line">            kindOfSubroutineVar.put(name, <span class="string">&quot;argument&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//we ignore the &quot;)&quot;</span></span><br><span class="line">    Tokenizer.stringAdvance();</span><br><span class="line">    <span class="comment">//then we ignore the &quot;&#123;&quot;</span></span><br><span class="line">    Tokenizer.stringAdvance();</span><br><span class="line">    currentStringName.setLength(<span class="number">0</span>);</span><br><span class="line">    currentStringName.append(Tokenizer.stringAdvance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p>对程序体内部变量的处理：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dealFuncLCLVar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;var&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//var + type + name</span></span><br><span class="line">        <span class="comment">//we skip var first</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line"></span><br><span class="line">        subroutineVar.put(name, localNum++);</span><br><span class="line">        typeOfSubroutineVar.put(name, type);</span><br><span class="line">        kindOfSubroutineVar.put(name, <span class="string">&quot;local&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//deal with &quot;,&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (Tokenizer.getNextString().equals(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            Tokenizer.stringAdvance();</span><br><span class="line">            name = Tokenizer.stringAdvance();</span><br><span class="line">            subroutineVar.put(name, localNum++);</span><br><span class="line">            typeOfSubroutineVar.put(name, type);</span><br><span class="line">            kindOfSubroutineVar.put(name, <span class="string">&quot;local&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//we meet a &quot;;&quot;</span></span><br><span class="line">    Tokenizer.stringAdvance();</span><br><span class="line">    currentStringName.setLength(<span class="number">0</span>);</span><br><span class="line">    currentStringName.append(Tokenizer.stringAdvance());</span><br><span class="line">    <span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;var&quot;</span>)) dealFuncLCLVar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="dsymbol-table最终构建">  <span class="math inline">\(d.\)</span><code>Symbol Table</code>最终构建</h4>
<p>  有了上述方法的铺垫， 我们只需要在遇到对应的<span class="math inline">\(token\)</span>时调用对应的方法即可。我们利用<code>private static String currentStringName</code>来记录当前读入的<span class="math inline">\(token\)</span>，如果遇到了声明类或子程序的关键字，就跳转到对应的变量处理程序中：</p>
<ol type="1">
<li>当遇到<code>class</code>关键字，我们在忽略掉<span class="math inline">\(class+className+{\)</span>后着手处理类变量：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if we meet &quot;class&quot;, then we call dealClass</span></span><br><span class="line"><span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;class&quot;</span>)) &#123;</span><br><span class="line">    startClass();</span><br><span class="line"></span><br><span class="line">    className = Tokenizer.stringAdvance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ignore the &#x27;&#123;&#x27;</span></span><br><span class="line">    Tokenizer.stringAdvance();</span><br><span class="line"></span><br><span class="line">    dealClassVar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!currentStringName.toString().equals(<span class="string">&quot;class&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>当遇到<code>funcDec</code>关键词，我们只处理<code>varDec</code>部分，并将得到的<span class="math inline">\(Map\)</span>存入对应子程序的<span class="math inline">\(Map\)</span>中：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;method&quot;</span>)</span><br><span class="line">        || currentStringName.toString().equals(<span class="string">&quot;function&quot;</span>)</span><br><span class="line">        || currentStringName.toString().equals(<span class="string">&quot;constructor&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//deal with the arguments first</span></span><br><span class="line">    startSubroutine();</span><br><span class="line">    <span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;method&quot;</span>)) startMethod();</span><br><span class="line">    dealFuncArgVar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//after the argument comes the body of func</span></span><br><span class="line">    <span class="comment">//we only care about varDec</span></span><br><span class="line">    <span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;var&quot;</span>)) dealFuncLCLVar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//we copy the current ArrayList and deliver the copyList</span></span><br><span class="line">    Map&lt;String, Integer&gt; copyVar = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(subroutineVar);</span><br><span class="line">    Map&lt;String, String&gt; copyType = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(typeOfSubroutineVar);</span><br><span class="line">    Map&lt;String, String&gt; copyKind = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(kindOfSubroutineVar);</span><br><span class="line"></span><br><span class="line">    mapOfSubVar.put(currentSubroutineName.toString(), copyVar);</span><br><span class="line">    mapOfSubVarType.put(currentSubroutineName.toString(), copyType);</span><br><span class="line">    mapOfSubVarKind.put(currentSubroutineName.toString(), copyKind);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//store the index of arg and lcl</span></span><br><span class="line">    subroutineLCLNum.put(currentSubroutineName.toString(), localNum);</span><br><span class="line">    subroutineArgNum.put(currentSubroutineName.toString(), argNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="d供其他类使用的函数">  <span class="math inline">\(d.\)</span>供其他类使用的函数</h4>
<p>  对于给定的输入，返回该输入在<span class="math inline">\(Map\)</span>中对应的值即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">varCount</span><span class="params">(String <span class="keyword">var</span>, String subroutine)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subroutine != <span class="literal">null</span> &amp;&amp; mapOfSubVar.get(subroutine).containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> mapOfSubVar.get(subroutine).get(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (classVar.containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> classVar.get(<span class="keyword">var</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The variable is undefined&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">varType</span><span class="params">(String <span class="keyword">var</span>, String subroutine)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subroutine != <span class="literal">null</span> &amp;&amp; mapOfSubVarType.get(subroutine).containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> mapOfSubVarType.get(subroutine).get(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (typeOfClassVar.containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> typeOfClassVar.get(<span class="keyword">var</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The variable is undefined&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">varKind</span><span class="params">(String <span class="keyword">var</span>, String subroutine)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subroutine != <span class="literal">null</span> &amp;&amp; mapOfSubVarKind.get(subroutine).containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> mapOfSubVarKind.get(subroutine).get(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (kindOfClassVar.containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> kindOfClassVar.get(<span class="keyword">var</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The variable is undefined.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if it&#x27;s a classVar, then subroutine is null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">kindCount</span><span class="params">(String kindName, String subroutine)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subroutine.equals(<span class="string">&quot;Output.printInt&quot;</span>)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (kindName.equals(<span class="string">&quot;argument&quot;</span>)) <span class="keyword">return</span> subroutineArgNum.get(subroutine);</span><br><span class="line">        <span class="keyword">if</span> (kindName.equals(<span class="string">&quot;local&quot;</span>)) <span class="keyword">return</span> subroutineLCLNum.get(subroutine);</span><br><span class="line">        <span class="keyword">if</span> (kindName.equals(<span class="string">&quot;field&quot;</span>) || kindName.equals(<span class="string">&quot;static&quot;</span>)) <span class="keyword">return</span> classNum;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The kind is out of range.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2vmwriter实现">2.<code>VMWriter</code>实现</h3>
<p>  为满足<code>CompileEngine</code>VM代码的生成，我们在<code>VMWriter</code>中设计以下函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writePush</span><span class="params">(String segment, <span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writePop</span><span class="params">(String segment, <span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeOp</span><span class="params">(String command)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeUnaryOp</span><span class="params">(String command)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeCall</span><span class="params">(String name, <span class="type">int</span> argNum)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeFunctionDec</span><span class="params">(String name, <span class="type">int</span> lclNum)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeFunctionCall</span><span class="params">(String name, <span class="type">int</span> argNum)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeReturn</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">writeString</span><span class="params">(String string)</span></span><br></pre></td></tr></table></figure>
<h3 id="3compileengine实现">3.<code>CompileEngine</code>实现</h3>
<p>  在<code>CompileEngine</code>中我们希望读入完整的表达式以生成对应的VM代码，因此我们选择直接读入源程序，然后根据读入行的关键字判断其表达式类型。</p>
<h4 id="a准备工作">  <span class="math inline">\(a.\)</span>准备工作</h4>
<p>  为了防止<code>if</code>和<code>while</code>的<span class="math inline">\(label\)</span>重复，我们可以定义<code>private static int ifLabelCount, whileLabelCount</code>。</p>
<p>  同时，由于在调用函数时需要知道函数的返回值类型，我们也要在编译过程中存储我们遇到的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; funcType</span><br></pre></td></tr></table></figure>
<h4 id="b表达式计算">  <span class="math inline">\(b.\)</span>表达式计算</h4>
<p>  我们知道，<code>Jack</code>中的表达式有以下性质： 1.
当没有括号时，从左到右依次计算。 2. 有括号时，优先计算括号内式子。</p>
<p>  因此，我们<strong>从左往右</strong>处理输入的表达式，并<strong>优先考虑是否有括号，如果遇到括号优先处理括号内语句</strong>。</p>
<blockquote>
<p><span class="math inline">\(p.s.\)</span>:由于我们先计算内侧括号、再计算外侧括号，一个自然的想法是<strong>找到最内侧的括号对，处理完其内部表达式后将其抹去，向外延展</strong>。但是这样不满足性质一，因而会导致失败。</p>
</blockquote>
<p>  我们可以利用<strong>栈</strong>来进行括号对的匹配，然后计算对应下标表达式的值。</p>
<p>  在<code>Jack</code>语法一章中，我们知道表达式具有如下结构：</p>
<p><span class="math display">\[expression=term(op\;term)\]</span></p>
<p>  我们可以继续沿用该结构，<strong>利用<code>op</code>将原表达式拆分成一个个子表达式，然后分别递归计算</strong>。但是，我们并不能确定<span class="math inline">\(term\)</span>的个数，因此我们对上面的结构进行改动：</p>
<p><span class="math display">\[expression=term(op\;expression)\]</span></p>
<p>  该结构的变量个数是确定的，我们只需分别递归计算即可：</p>
<blockquote>
<p><span class="math inline">\(p.s\)</span>这里有一个比较棘手的问题：对于<span class="math inline">\(unary\;op\)</span>的处理。在<code>-(1+2)</code>这个表达式中，第一个<code>-</code>并不起到拆分的作用。注意到我们是以<span class="math inline">\(term\)</span>为基本处理单元的，而<strong>在<span class="math inline">\(term\)</span>中<span class="math inline">\(unary\;op\)</span>只能在第一个位置</strong>。因此，我们在从左往右计算前<strong>先判断第一个元素是否为<span class="math inline">\(op\)</span>，如果是，我们对其进行计算，然后在计算完第一个<span class="math inline">\(term\)</span>后记录该表达式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if the first character belongs unary op //then we skip it </span></span><br><span class="line"><span class="type">String</span> <span class="variable">unaryOp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; </span><br><span class="line"><span class="keyword">if</span> (isOp(line.charAt(<span class="number">0</span>))) &#123; </span><br><span class="line">	unaryOp = Character.toString(line.charAt(<span class="number">0</span>)); </span><br><span class="line">	line = line.substring(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!unaryOp.isEmpty()) expression.add(VMWriter.writeUnaryOp(unaryOp));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileExpression</span><span class="params">(String line)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; expression = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the first character belongs unary op</span></span><br><span class="line">    <span class="comment">//then we skip it</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">unaryOp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isOp(line.charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">        unaryOp = Character.toString(line.charAt(<span class="number">0</span>));</span><br><span class="line">        line = line.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!containOP(line)) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; term = compileTerm(line);</span><br><span class="line">        expression.addAll(term);</span><br><span class="line">        <span class="keyword">if</span> (!unaryOp.isEmpty())</span><br><span class="line">            expression.add(VMWriter.writeUnaryOp(unaryOp));</span><br><span class="line">        <span class="keyword">return</span> expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if we meet (, deal with it first</span></span><br><span class="line">    <span class="keyword">if</span> (line.charAt(<span class="number">0</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.charAt(i) == <span class="string">&#x27;(&#x27;</span>) stack.push(i);</span><br><span class="line">            <span class="keyword">if</span> (line.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) stack.pop();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    rightIndex = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">termExp</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, rightIndex + <span class="number">1</span>);</span><br><span class="line">        expression.addAll(compileTerm(termExp));</span><br><span class="line">        <span class="keyword">if</span> (!unaryOp.isEmpty()) expression.add(VMWriter.writeUnaryOp(unaryOp));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the ) is not the last, then after it comes an op</span></span><br><span class="line">        <span class="comment">//it&#x27;s defined by the Jack grammar</span></span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; line.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            expression.addAll(compileExpression(line.substring(rightIndex + <span class="number">2</span>)));</span><br><span class="line">            expression.add(VMWriter.writeOp(Character.toString(line.charAt(rightIndex + <span class="number">1</span>))));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//we deal with the next op</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">opIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">curOp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOp(line.charAt(i))) &#123;</span><br><span class="line">            opIndex = i;</span><br><span class="line">            curOp = Character.toString(line.charAt(i));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">termExp1</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, opIndex);</span><br><span class="line">    <span class="type">String</span> <span class="variable">termExp2</span> <span class="operator">=</span> line.substring(opIndex + <span class="number">1</span>);</span><br><span class="line">    expression.addAll(compileTerm(termExp1));</span><br><span class="line">    <span class="keyword">if</span> (!unaryOp.isEmpty())</span><br><span class="line">        expression.add(VMWriter.writeUnaryOp(unaryOp));</span><br><span class="line">    <span class="keyword">if</span> (!termExp2.isEmpty())</span><br><span class="line">        expression.addAll(compileExpression(termExp2));</span><br><span class="line">    expression.add(VMWriter.writeOp(curOp));</span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  对于<span class="math inline">\(term\)</span>的处理较为简单，只需注意对函数的判断方式即可：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileTerm</span><span class="params">(String line)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; term = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line.matches(<span class="string">&quot;-?\\d+&quot;</span>)) &#123;</span><br><span class="line">        term.add(VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, Integer.parseInt(line)));</span><br><span class="line">        <span class="keyword">return</span> term;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line.contains(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//if the first is &quot;(&quot;, then it&#x27;s (expression)</span></span><br><span class="line">        <span class="keyword">if</span> (line.charAt(<span class="number">0</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            term.addAll(compileExpression(line.substring(<span class="number">1</span>, line.length() - <span class="number">1</span>)));</span><br><span class="line">            <span class="keyword">return</span> term;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//else, it&#x27;s a functionCall</span></span><br><span class="line">            ArrayList&lt;String&gt; functionCall = compileSubroutineCall(line);</span><br><span class="line">            term.addAll(functionCall);</span><br><span class="line">            <span class="keyword">return</span> term;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if line contains &#x27;[&#x27;, it must be an array</span></span><br><span class="line">    <span class="keyword">if</span> (line.contains(<span class="string">&quot;[&quot;</span>)) &#123;</span><br><span class="line">        term.addAll(compileArray(line));</span><br><span class="line">        <span class="keyword">return</span> term;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if it&#x27;s a stringConstant, we use string method to append char by char</span></span><br><span class="line">    <span class="keyword">if</span> (line.charAt(<span class="number">0</span>) == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> line.substring(<span class="number">1</span>, line.length() - <span class="number">1</span>);</span><br><span class="line">        term.addAll(VMWriter.writeString(string));</span><br><span class="line">        <span class="keyword">return</span> term;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//else, it&#x27;s a variable</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        term.add(VMWriter.writePush(SymbolTable.varKind(line, curSubroutine.toString()), SymbolTable.varCount(line, curSubroutine.toString())));</span><br><span class="line">        <span class="keyword">return</span> term;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="creturn语句">  <span class="math inline">\(c.\)</span><code>return</code>语句</h4>
<p>  根据<code>return</code>变量进行分类处理即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileReturnStatement</span><span class="params">(String line)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; returnStatement = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract the return value from the line</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">returnVal</span> <span class="operator">=</span> line.substring(<span class="number">6</span>, line.indexOf(<span class="string">&quot;;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!returnVal.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isKeywordConstant(returnVal)) &#123;</span><br><span class="line">            <span class="comment">// Handle keyword constants</span></span><br><span class="line">            <span class="keyword">if</span> (returnVal.equals(<span class="string">&quot;this&quot;</span>)) &#123;</span><br><span class="line">                returnStatement.add(VMWriter.writePush(<span class="string">&quot;pointer&quot;</span>, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (returnVal.equals(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line">                returnStatement.add(VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, <span class="number">0</span>));</span><br><span class="line">                returnStatement.add(<span class="string">&quot;not&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (returnVal.equals(<span class="string">&quot;false&quot;</span>) || returnVal.equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                returnStatement.add(VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnVal.matches(<span class="string">&quot;-?\\d+&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// Handle integer constants</span></span><br><span class="line">            returnStatement.add(VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, Integer.parseInt(returnVal)));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnVal.charAt(<span class="number">0</span>) == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// Handle string constants</span></span><br><span class="line">            returnVal = returnVal.substring(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> returnVal.substring(<span class="number">0</span>, returnVal.length() - <span class="number">1</span>);</span><br><span class="line">            returnStatement.addAll(VMWriter.writeString(string));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Handle variable return values</span></span><br><span class="line">            returnStatement.add(VMWriter.writePush(SymbolTable.varKind(returnVal, curSubroutine.toString()), SymbolTable.varCount(returnVal, curSubroutine.toString())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If no return value, push 0</span></span><br><span class="line">        returnStatement.add(VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add return command</span></span><br><span class="line">    returnStatement.add(<span class="string">&quot;return&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnStatement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="ddo语句">  <span class="math inline">\(d.\)</span><code>do</code>语句</h4>
<p>  <code>do</code>语句只需处理被调用的函数即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileDoStatement</span><span class="params">(String line)</span> &#123;</span><br><span class="line">	line = line.substring(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> compileSubroutineCall(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="elet语句">  <span class="math inline">\(e.\)</span><code>let</code>语句</h4>
<p>  对<code>let</code>语句的处理需要注意分类的依据：<strong>左侧的表达式是否为数组</strong>，如果左侧为数组，我们需要加入以下的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop temp 0</span><br><span class="line">pop pointer 1</span><br><span class="line">push temp 0</span><br><span class="line">pop that 0</span><br></pre></td></tr></table></figure>
<p>  否则左侧表达式只能是一个普通的变量，我们将其<code>pop</code>即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileLetStatement</span><span class="params">(String line)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; letstatement = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        line = line.substring(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;=&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> line.substring(line.indexOf(<span class="string">&quot;=&quot;</span>) + <span class="number">1</span>, line.indexOf(<span class="string">&quot;;&quot;</span>));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//case 1: array var + expression</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var1.contains(<span class="string">&quot;[&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">exp1</span> <span class="operator">=</span> var1.substring(var1.indexOf(<span class="string">&quot;[&quot;</span>) + <span class="number">1</span>, var1.indexOf(<span class="string">&quot;]&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> var1.substring(<span class="number">0</span>, var1.indexOf(<span class="string">&quot;[&quot;</span>));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            ArrayList&lt;String&gt; expression1 = compileExpression(exp1);</span><br><span class="line"></span><br><span class="line">            letstatement.addAll(expression1);</span><br><span class="line"></span><br><span class="line">            letstatement.add(VMWriter.writePush(SymbolTable.varKind(name1, curSubroutine.toString()), SymbolTable.varCount(name1, curSubroutine.toString())));</span><br><span class="line"></span><br><span class="line">            letstatement.add(<span class="string">&quot;add&quot;</span>);</span><br><span class="line"></span><br><span class="line">            letstatement.addAll(compileExpression(var2));</span><br><span class="line"></span><br><span class="line">            letstatement.add(VMWriter.writePop(<span class="string">&quot;temp&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            letstatement.add(VMWriter.writePop(<span class="string">&quot;pointer&quot;</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            letstatement.add(VMWriter.writePush(<span class="string">&quot;temp&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            letstatement.add(VMWriter.writePop(<span class="string">&quot;that&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> letstatement;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="e函数体模块设计ampif-while处理手段">  <span class="math inline">\(e.\)</span>函数体模块设计&amp;<code>if, while</code>处理手段</h4>
<p>  在处理<code>if</code>语句时，我们需要在处理<code>if</code>花括号括起的部分后添加<code>IF_ENDLabelindex</code>。因此，我们自然地想到引入<code>compileSubroutineBody</code>函数对函数体模块进行整体地编译(而非一条语句一条语句地离散处理)，它接受的参数是<strong>多条语句构成的函数体<code>ArrayList&lt;String&gt;</code></strong>。</p>
<p>  那么如何实现<code>if</code>语句呢？一个自然地想法如下：</p>
<ol type="1">
<li>设计一个函数<code>compileIfStatement()</code>，它接受一个<code>ArrayList&lt;String&gt;</code>，返回编译后的<code>ArrayList&lt;String&gt;</code>。</li>
<li>传入<code>if</code>语句对应的子程序，然后输出结果。</li>
</ol>
<p>  但是，当我们得到输出结果并往下继续处理时，那些属于<code>if</code>子程序的代码会<strong>被重复处理</strong>。这并不是我们想要的结果。笔者曾试过处理完<code>if</code>的子程序后将其删去，但最终失败了。因此笔者想到了下面的方法：</p>
<ol type="1">
<li>我们依然对<code>if</code>对应的子程序进行读取。</li>
<li>但我们并不将其作为参数传入<code>compileIfStatement</code>，而是<strong>记录下该子程序的行数</strong><code>ifIndex</code>。</li>
<li>同时，在<code>compileSubroutineBody</code>中，我们实时更新当前的代码行数<code>currentIndex</code>。</li>
<li>我们通过记录的<code>currentIndex</code>和<code>ifIndex</code><strong>计算出应该添加<span class="math inline">\(label\)</span>的行数</strong>，然后<strong>当<code>currentIndex</code>的值与其相等时添加<span class="math inline">\(label\)</span></strong>。</li>
</ol>
<p>  同时，我们依然保留<code>compileIfStatement</code>这个方法，只是该方法仅用来编译<code>if(expression)</code>语句。</p>
<blockquote>
<p>如果遇到<code>else</code>语句，直接忽略即可。</p>
</blockquote>
<blockquote>
<p>另：我们不能直接用类中定义的<code>static int ifLabelCount</code>作为标记的序号，因为当存在嵌套条件循环时，由于不管遇到哪个<code>if</code>该值都会增加1，这会导致<strong>同一个<code>if</code>的前后标记序号不一致</strong>。对此，我们<strong>用一个<span class="math inline">\(Map\)</span>来存储特定<code>lineIndex</code>对应的标记序号</strong>，由于<code>lineIndex</code>是唯一的，我们的前后标记序号将会一致。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileSubroutineBody</span><span class="params">(ArrayList&lt;String&gt; lines)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; subroutinebody = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lineIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ifstatementLineNum</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">whilestatementLineNum</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lineIndex == ifstatementLineNum) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">labelCnt</span> <span class="operator">=</span> loopCount.get(ifstatementLineNum);</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;label IF_FALSE&quot;</span> + Integer.toString(labelCnt));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lineIndex == whilestatementLineNum) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">labelCnt</span> <span class="operator">=</span> loopCount.get(whilestatementLineNum);</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;goto WHILE_EXP&quot;</span> + Integer.toString(labelCnt));</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;label WHILE_END&quot;</span> + Integer.toString(labelCnt));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;else&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            line = line.substring(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;do&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            subroutinebody.addAll(compileDoStatement(line));</span><br><span class="line">            lineIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;let&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            subroutinebody.addAll(compileLetStatement(line));</span><br><span class="line">            lineIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;return&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            subroutinebody.addAll(compileReturnStatement(line));</span><br><span class="line">            lineIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;if&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ifstatement</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;&#123;&quot;</span>)) &#123;</span><br><span class="line">                ifstatement = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;&#123;&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ifstatement = line;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            subroutinebody.addAll(compileIfStatement(ifstatement));</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;if-goto IF_TRUE&quot;</span> + Integer.toString(ifLabelCount));</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;goto IF_FALSE&quot;</span> + Integer.toString(ifLabelCount));</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;label IF_TRUE&quot;</span> + Integer.toString(ifLabelCount));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;&#123;&quot;</span>) &amp;&amp; line.indexOf(<span class="string">&quot;&#123;&quot;</span>) != line.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                ArrayList&lt;String&gt; statement = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                statement.add(line.substring(line.indexOf(<span class="string">&quot;&#123;&quot;</span>) + <span class="number">1</span>));</span><br><span class="line">                subroutinebody.addAll(compileSubroutineBody(statement));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ifstatementLineNum = Operation.selectContent(Operation.subList(lines, lineIndex)).size() + lineIndex++;</span><br><span class="line">            loopCount.put(ifstatementLineNum, ifLabelCount++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;while&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">whilestatement</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;&#123;&quot;</span>)) &#123;</span><br><span class="line">                whilestatement = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;&#123;&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                whilestatement = line;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            subroutinebody.add(<span class="string">&quot;label WHILE_EXP&quot;</span> + Integer.toString(whileLabelCount));</span><br><span class="line">            subroutinebody.addAll(compileWhileStatement(whilestatement));</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;not&quot;</span>);</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;if-goto WHILE_END&quot;</span> + Integer.toString(whileLabelCount));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;&#123;&quot;</span>) &amp;&amp; line.indexOf(<span class="string">&quot;&#123;&quot;</span>) != line.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                ArrayList&lt;String&gt; statement = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                statement.add(line.substring(line.indexOf(<span class="string">&quot;&#123;&quot;</span>) + <span class="number">1</span>));</span><br><span class="line">                subroutinebody.addAll(compileSubroutineBody(statement));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            whilestatementLineNum = Operation.selectContent(Operation.subList(lines, lineIndex)).size() + lineIndex++;</span><br><span class="line">            loopCount.put(whilestatementLineNum, whileLabelCount++);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lineIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subroutinebody;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="f其他杂项的处理">  <span class="math inline">\(f.\)</span>其他杂项的处理</h4>
<p>  在实现了框架的大部分内容后，针对VM代码自身的特定，我们需要额外补充对一些操作的实现：</p>
<ol type="1">
<li>对数组的处理：我们将数组名称所在内存段和内部表达式的值<code>add</code>，然后<code>pop pointer 1</code>，<code>push that 0</code>即可：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileArray</span><span class="params">(String line)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the array consists of varName + [ + expression + ]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">varName</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;[&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">exp</span> <span class="operator">=</span> line.substring(line.indexOf(<span class="string">&quot;[&quot;</span>) + <span class="number">1</span>, line.indexOf(<span class="string">&quot;]&quot;</span>));</span><br><span class="line">    ArrayList&lt;String&gt; expression = compileExpression(exp);</span><br><span class="line"></span><br><span class="line">    array.add(VMWriter.writePush(SymbolTable.varKind(varName, curSubroutine.toString()), SymbolTable.varCount(varName, curSubroutine.toString())));</span><br><span class="line">    array.addAll(expression);</span><br><span class="line">    array.add(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">    array.add(VMWriter.writePop(<span class="string">&quot;pointer&quot;</span>, <span class="number">1</span>));</span><br><span class="line">    array.add(VMWriter.writePush(<span class="string">&quot;that&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>调用函数：将函数所需参数<code>push</code>，然后计算参数个数、调用即可。需要注意判断函数是否为<code>void</code>型，如果是的话需要<code>pop temp 0</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileSubroutineCall</span><span class="params">(String line)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; subroutine = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">argNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we first store the functionName</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">funcName</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;(&quot;</span>));</span><br><span class="line">    line = line.substring(line.indexOf(<span class="string">&quot;(&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!funcName.contains(<span class="string">&quot;.&quot;</span>)) funcName = className + <span class="string">&quot;.&quot;</span> + funcName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then comes the expressionList</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expressionList</span> <span class="operator">=</span> line.substring(line.indexOf(<span class="string">&#x27;(&#x27;</span>) + <span class="number">1</span>, line.indexOf(<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!expressionList.isEmpty()) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; expressions = compileExpressionList(expressionList);</span><br><span class="line">        subroutine.addAll(expressions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!expressionList.isEmpty()) &#123;</span><br><span class="line">        argNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; expressionList.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expressionList.charAt(i) == <span class="string">&#x27;,&#x27;</span>) argNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// finally we call the method</span></span><br><span class="line">    <span class="keyword">if</span> (Tokenizer.funcCollection.contains(funcName)) &#123;</span><br><span class="line">        subroutine.add(VMWriter.writeFunctionCall(funcName, argNum));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : Tokenizer.funcCollection) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.substring(s.indexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>).equals(funcName.substring(funcName.indexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>))) &#123;</span><br><span class="line">                subroutine.add(VMWriter.writeFunctionCall(s, argNum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (funcType.get(funcName).equals(<span class="string">&quot;void&quot;</span>))</span><br><span class="line">        subroutine.add(VMWriter.writePop(<span class="string">&quot;temp&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subroutine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="gcompileengine最终构建">  <span class="math inline">\(g.\)</span>
<code>CompileEngine</code>最终构建</h4>
<ol type="1">
<li><p>预处理。将待编译的一个或多个文件作为参数传入<code>SymbolTable.constructor</code>，以构建每个文件对应的<code>Symbol Table</code>。</p></li>
<li><p>编译时，如果遇到一个函数/方法名，先将其存入<code>funcType</code>中，以在后续调用该函数时能够找到该函数/方法名。</p></li>
<li><p>对<code>constructor</code>，<code>method</code>需要进行各自的预处理。</p></li>
<li><p>我们可以将待编译的代码如下分类：</p>
<ul>
<li>方法/函数的声明。</li>
<li>变量声明。</li>
<li>方法/函数体。</li>
</ul></li>
</ol>
<p>  对每一类，分别编译即可。需要注意，处理函数体时，我们需要读入整个子程序，将其放入<code>ArrayList&lt;String&gt;</code>中作为<code>compileSubroutineBody</code>的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">constructor</span><span class="params">(String[] files)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String filename : files) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> filename.substring(<span class="number">0</span>, filename.length() - <span class="number">5</span>);</span><br><span class="line">        Operation.addToArray(Tokenizer.className, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String filename : files) &#123;</span><br><span class="line">        SymbolTable.constructor(filename);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">vmFile</span> <span class="operator">=</span> filename.substring(<span class="number">0</span>, filename.length() - <span class="number">5</span>) + <span class="string">&quot;.vm&quot;</span>;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filename));</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(vmFile));</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> Operation.modify(reader.readLine());</span><br><span class="line">            <span class="keyword">while</span> (line != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!line.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;class&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        className.setLength(<span class="number">0</span>);</span><br><span class="line">                        className.append(line.substring(<span class="number">5</span>, line.length() - <span class="number">1</span>));</span><br><span class="line">                        line = Operation.modify(reader.readLine());</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (isSubroutineDec(line)) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">subroutineKind</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">subroutineType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">subroutineLength</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">typeLength</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; subroutineDec.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (line.indexOf(subroutineDec[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                                subroutineKind = subroutineDec[i];</span><br><span class="line">                                subroutineLength = subroutineDec[i].length();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        line = line.substring(subroutineLength);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// then comes the type</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; type.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (line.indexOf(type[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                                subroutineType = type[i];</span><br><span class="line">                                typeLength = type[i].length();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        line = line.substring(typeLength);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">subroutine</span> <span class="operator">=</span> className + <span class="string">&quot;.&quot;</span> + line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;(&quot;</span>));</span><br><span class="line">                        curSubroutine.setLength(<span class="number">0</span>);</span><br><span class="line">                        curSubroutine.append(subroutine);</span><br><span class="line">                        funcType.put(curSubroutine.toString(), subroutineType);</span><br><span class="line">                        writer.write(VMWriter.writeFunctionDec(curSubroutine.toString(), SymbolTable.kindCount(<span class="string">&quot;local&quot;</span>, curSubroutine.toString())));</span><br><span class="line">                        writer.newLine();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (subroutineKind.equals(<span class="string">&quot;constructor&quot;</span>)) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">line1</span> <span class="operator">=</span> VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, SymbolTable.kindCount(<span class="string">&quot;field&quot;</span>, <span class="literal">null</span>));</span><br><span class="line">                            <span class="type">String</span> <span class="variable">line2</span> <span class="operator">=</span> VMWriter.writeCall(<span class="string">&quot;Memory.alloc&quot;</span>, <span class="number">1</span>);</span><br><span class="line">                            writer.write(line1);</span><br><span class="line">                            writer.newLine();</span><br><span class="line">                            writer.write(line2);</span><br><span class="line">                            writer.newLine();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (subroutineKind.equals(<span class="string">&quot;method&quot;</span>)) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">line1</span> <span class="operator">=</span> VMWriter.writePush(<span class="string">&quot;argument&quot;</span>, <span class="number">0</span>);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">line2</span> <span class="operator">=</span> VMWriter.writePop(<span class="string">&quot;pointer&quot;</span>, <span class="number">0</span>);</span><br><span class="line">                            writer.write(line1);</span><br><span class="line">                            writer.newLine();</span><br><span class="line">                            writer.write(line2);</span><br><span class="line">                            writer.newLine();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        line = Operation.modify(reader.readLine());</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// case 2: varDec, we just ignore it</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (isVarDec(line)) &#123;</span><br><span class="line">                        <span class="keyword">while</span> (isVarDec(line)) &#123;</span><br><span class="line">                            line = Operation.modify(reader.readLine());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// case 3: subroutineBody</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        ArrayList&lt;String&gt; subroutineCode = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        <span class="keyword">while</span> (line != <span class="literal">null</span> &amp;&amp; !isSubroutineDec(line)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!line.isEmpty()) &#123;</span><br><span class="line">                                System.out.println(line);</span><br><span class="line">                                subroutineCode.add(line);</span><br><span class="line">                            &#125;</span><br><span class="line">                            line = Operation.modify(reader.readLine());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ArrayList&lt;String&gt; subroutineBody = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(compileSubroutineBody(subroutineCode));</span><br><span class="line">                        <span class="keyword">for</span> (String s : subroutineBody) &#123;</span><br><span class="line">                            writer.write(s);</span><br><span class="line">                            writer.newLine();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        line = Operation.modify(reader.readLine());</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                line = Operation.modify(reader.readLine());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            reader.close();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.8.对数组的处理</title>
    <url>/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="108handling-array"><span class="math inline">\(10.8.\)</span>Handling Array</h1>
<h3 id="1array-construction">1.Array construction</h3>
<p>  Assume that the high-level programmer writes
<code>var Array arr</code>.</p>
<ul>
<li>In response to this, the compiler will only <strong>allocate a
<code>local</code> variable</strong> to represent the array and
<strong>initialize this variable to 0</strong>.</li>
<li>This statement <strong>generates no code</strong>. The compiler will
<strong>get a variable called <code>loca1 0</code>, its type
<code>Array</code> and name <code>arr</code></strong>.</li>
</ul>
<p>  When we construct this array by calling the subroutine of the
<code>Array</code> class: <code>let arr = Array.new(5)</code>.</p>
<ul>
<li>The compiler and OS will magically <strong>allocate sufficient space
in the heap</strong> to represent the array.</li>
<li>The base address of the new allocated block is going to be stored in
<code>local 0</code>, regardless of the address may be.</li>
<li>What we have here is <strong>a standard call to a Jack
subroutine</strong>, which we already knew how to handle.</li>
</ul>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image.png"></p>
<h3 id="2array-manipulation">2.Array manipulation</h3>
<h4 id="athis-and-thatreview">  <span class="math inline">\(a.\)</span><code>THIS</code> and <code>THAT</code>
review</h4>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-1.png"></p>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-2.png"></p>
<h5 id="bgenerating-code">  <span class="math inline">\(b.\)</span>Generating code</h5>
<p>  Suppose we want to conduct <code>arr[2] = 17</code>:</p>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-3.png"></p>
<ul>
<li><p>Since the base address of <code>arr</code> is stored in
<code>THAT</code>, we simply <code>push arr</code> then
<code>push index</code>, and <code>add</code> to get
<code>arr + 2</code>.</p></li>
<li><p>Then the <code>THAT</code> pointer will be aligned with the
address we want to manipulate.</p></li>
<li><p>Notice that:</p>
<ol type="1">
<li>We use <strong>only <code>THAT 0</code></strong>, we don't use other
entries from <code>THAT</code> segment.</li>
<li>The VM code you have <strong>operates in a completely symbolic
logical world</strong>. It doesn't know where the array is located in
RAM or which address we are manipulating. In this respect, it's a very
safe code, for it cannot reach out of the VM world, because all the
physical considerations are being implemented by the VM translator, and
VM code itself is completely oblivious of the host platform. This is
very important because we have numerous different computers, we don't
know where this code is going to run, and we <strong>don't have the
luxury of making any assumptions about the underlying hardware
platform</strong>.</li>
</ol></li>
</ul>
<p>  What about <code>arr[exp1] = exp2</code>? As above, we may write
the following code:</p>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-4.png"></p>
<p>  This seems make sense, but when we try to write
<code>a[i] = b[j]</code>, there comes a crush:</p>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-5.png"></p>
<p>  To avoid this, we:</p>
<ol type="1">
<li>First deal with the right hand side and left hand side separately.
Once we complete this, the stack is going to <strong>contain two
addresses</strong>: the address of <code>a[i]</code> and the address of
<code>b[j]</code>:</li>
</ol>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-6.png"></p>
<ol start="2" type="1">
<li>We <strong><code>pop</code> the topmost value</strong> onto
<code>pointer 1</code>, which is <code>b[i]</code> in this example. Once
is done, we are going to get the following state:</li>
</ol>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-7.png"></p>
<ol start="3" type="1">
<li>Now that <code>That 0</code> is aligned with <code>b[j]</code>, we
<strong><code>push</code> the value in <code>b[j]</code> and
<code>pop</code> it into <code>temp 0</code></strong>. This is the
picture of the VM segments after the process:</li>
</ol>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-8.png"></p>
<ol start="4" type="1">
<li>Because we have <strong>safely saved the value of
<code>b[i]</code></strong>, we can <strong>take the address of
<code>a[i]</code> and <code>pop</code> it onto
<code>pointer 1</code></strong></li>
<li>We finally <strong><code>push temp 0</code> onto the stack</strong>
and <strong><code>pop</code> it onto <code>that 0</code></strong>, which
is on the address of <code>a[i]</code>:</li>
</ol>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-9.png"></p>
<p>  The general solution for generating array access code is as
below:</p>
<p>![[Pasted image 20240507234141.png]]</p>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-10.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.7.对对象的处理——操纵对象</title>
    <url>/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="107handling-objects-manipulation"><span class="math inline">\(10.7.\)</span>Handling Objects: Manipulation</h1>
<h3 id="1compiling-method-calls">1.Compiling method calls</h3>
<ul>
<li>In compiler, we are going to translate the OO method calls into
<strong>procedural style language</strong> like VM language or machine
language, they don't understand what an object is.</li>
</ul>
<p>  In order to do this:</p>
<ul>
<li>We can <strong>treat the object as the first, implicit
argument</strong>. We push it onto the stack, because we want it to
<strong>be the first argument on which the method is going to
operate</strong>.</li>
</ul>
<p><img src="/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/image-5.png"></p>
<ol type="1">
<li>We <code>push</code> the object into the stack.</li>
<li>We <code>push</code> enough arguments into the stack.</li>
<li>We <code>call</code> the method.</li>
</ol>
<p>  When we say "put the object onto the stack", we don't care what the
object is, we are only interested in its <em>base address</em>.</p>
<h3 id="2compiling-methods">2.Compiling methods</h3>
<p>  Methods are used to operate on the object which refers to as
<code>THIS</code>. Therefore, each method's code needs to <strong>access
to the object's <code>field</code> variables</strong>.</p>
<p>  In the previous unit, we know that we can access the <span class="math inline">\(ith\)</span> <code>field</code> by
<code>THIS i</code>. However, before we use <code>THIS</code>, we have
to anchor it on the proper address on the RAM first, so we also need
<code>pointer</code>.</p>
<p><img src="/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/image-6.png"></p>
<p>  Let's take the <code>distance</code> method as an example:</p>
<ol type="1">
<li>The method is compiled within a class, so we will <strong>compile
the class variables</strong>, namely <code>x, y, pointCount</code>. This
will end up generating no code.</li>
<li>Both the method declaration and variable declaration generate no
code, either. Instead, the compiler <strong>creates the symbol table of
the subroutine</strong> and <strong>populates it within the
<code>this</code> object as well as the explicit variables that is found
in the parameter list and the variable declaration.</strong></li>
<li>We can anticipate that the method will want to operate on the
current object, so we need to generate code that will <strong>anchor
this on the correct address in memory</strong>. And we know that the
current object address is <code>argument 0</code>, so we do
<code>push argument 0</code> and <code>pop pointer 0</code> to let
<code>THIS</code> pointer to contain the address of the current
object.</li>
</ol>
<p>  When the <code>distance</code> method completes execution and
terminates, control will return to the caller. The compiled code of the
caller is as below:</p>
<p><img src="/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/image-7.png"></p>
<ul>
<li>We know that the method returns a value on the top of stack, so we
remove it and put it into <code>d</code>.</li>
</ul>
<h3 id="3void-methodcompilation">3.<code>void</code> method
compilation</h3>
<p><img src="/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/image-8.png"></p>
<p>  The <code>void</code> doesn't expect to get a return value, while
according to the rules of the game, we must return a value. As a result,
we:</p>
<ol type="1">
<li>To obey the rule, we <strong>generate code at the end of each method
that returns a value</strong>.</li>
<li>Since we have nothing to return, we <code>push constant 0</code>,
which is a dummy value and then <code>return</code>.</li>
</ol>
<p>  But now the compiled code faces a slight problem: the stack
contains uncessary value and we want to get rid of it.</p>
<ol start="3" type="1">
<li>To do this, we simply <code>pop temp 0</code>.</li>
</ol>
<p><img src="/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/image-9.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.6.对对象的处理——构造</title>
    <url>/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<h1 id="106handling-objects-construction"><span class="math inline">\(10.6.\)</span>Handling Objects: Construction</h1>
<p><img src="/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/image.png"></p>
<ul>
<li>What we have here is two completely separate compilation units. We
are facing the challenge of compiling the caller class and the callee
class.</li>
</ul>
<h3 id="1high-level-of-objectconstruction">1.High level of object
construction</h3>
<ul>
<li>When we do <code>var Point p1</code>, the compiler will end up
generating code on <strong>some location in the stack which is going to
be initialized to 0</strong>.</li>
<li>When we call the constructor, the compiled code will end up
<strong>creating the object proper on the heap</strong>.</li>
<li>The two class running together will end up <strong>taking the base
address of the newly created object</strong> and <strong>storing it in
what we assign previously the p1 variable</strong>.</li>
</ul>
<h3 id="2the-callerss-side">2.The callers's side</h3>
<p><img src="/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/image-1.png"></p>
<ul>
<li><p>Whenever the compiler encounters a variable declaration, it
<strong>generates no code whatsover</strong>. The only thing the
compiler does is it <strong>update the relevant symbol table</strong>.
Because we are now compiling code that resides in a certain subroutine,
we will end up <strong>updating the symbol table of the
subroutine</strong>.</p></li>
<li><p><code>Point.new(2, 3)</code> is a call to some subroutine, so we
handle it just like other subroutine. We push the two arguments and
<code>call Point.new</code></p></li>
<li><p>The calling code assumes that when the constructor will execute,
it will end up <strong>allocating some space on the RAM</strong> for the
newly constructed object. It will also take the base address of this
space on the RAM and <strong>return it to the caller</strong>.</p></li>
<li><p>So we <strong><code>pop</code> the topmost value of the stack
into <code>p1</code></strong>, because we want <code>p1</code> to point
at the base address of this object.</p></li>
</ul>
<h3 id="3resulting-impact">3.Resulting impact</h3>
<p><img src="/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/image-2.png"></p>
<ul>
<li>Only when we call the constructors will we actually create the
objects on RAM.</li>
<li>Object construction is a <strong>two-stage affair that happens both
during compile time and run time</strong>.</li>
</ul>
<h3 id="4the-big-picture-ofconstructors">4.The big picture of
constructors</h3>
<p><img src="/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/image-3.png"></p>
<p>  A constructor is typically designed to do at least two things:</p>
<ol type="1">
<li><strong>Arrange some place</strong> on RAM for the new object.</li>
<li><strong>Assign certain values</strong> to the fields of the newly
constructed object.</li>
</ol>
<p>  To do this, the constructor must have access to the object's
fields:</p>
<ul>
<li>We can <strong>manipulate <code>THIS</code> segment</strong> to
manipulate the object that the constructor juct created.</li>
<li>To access <code>THIS</code> segment, we first <strong>anchor it
properly on the right address in the RAM</strong> using
<code>pointer</code> segment.</li>
</ul>
<h3 id="5compiling-constuctor">5.Compiling constuctor</h3>
<ol type="1">
<li>The first thing we meet is the constructor signature. The compiler
will generate no code whatsover. The only thing it will do is <strong>it
will create the subroutine symbol table</strong> and <strong>record in
it two variables <code>ax</code> and <code>ay</code> which are both
arguments </strong></li>
</ol>
<p>  Then comes the question: how much space is needed?</p>
<ol start="2" type="1">
<li>The compiler can <strong>consult the class level symbol
table</strong> and realize that objects of the point class requires two
words only, <code>x</code> and <code>y</code>.</li>
</ol>
<p>  Then how do we find such a free memory block on RAM?</p>
<ol start="3" type="1">
<li><p>The <em>operating system</em> supplies a function called
<code>alloc</code>, if you provide <code>alloc(x)</code> with a certain
argument, it will <strong>find a memory block on the RAM</strong> and
<strong>return the base address of it.</strong> The memory block has two
important properties:</p>
<ol type="1">
<li>It's <code>x</code> words long.</li>
<li>It's free, no one needs it now, so the constructor can safely use
it.</li>
</ol></li>
</ol>
<p><img src="/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/image-4.png"></p>
<ol type="1">
<li>We <code>push 2</code>, because we <strong>need 2 words to store the
arguments</strong>.</li>
<li>We want to push <code>THIS</code> into the stack, we need 1 word, so
we <code>call Memory.alloc 1</code>.</li>
<li>As usual, we anchor <code>THIS</code> at the base address:
<code>pop pointer 0</code>.</li>
</ol>
<blockquote>
<p>If we do <code>pop pointer 0</code>, we are going to align the
virtual segment ot the object we currently constructed on the RAM. We do
this because I know that with very high likelihood the next commands in
the constructor will want to access the fields of the newly created
object.</p>
</blockquote>
<ol start="4" type="1">
<li>Since <code>THIS</code> is anchored on the right endness, to
<code>return</code>, we simply do <code>push pointer 0</code>. And when
the caller of constructor do <code>pop pointer 0</code>, it can
successfully get the address of the newly created object.</li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.5.对对象的处理——底层特性</title>
    <url>/2024/04/22/10-5-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="105handling-objects-low-levelaspects"><span class="math inline">\(10.5.\)</span>Handling Objects: Low-level
Aspects</h1>
<p><img src="/2024/04/22/10-5-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/image.png"></p>
<h3 id="1handling-objects">1.Handling objects</h3>
<p>  Let's review how we handle <code>local</code> and
<code>argument</code> first:</p>
<p><img src="/2024/04/22/10-5-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/image-1.png"></p>
<ul>
<li><p>The first five words in the RAM are used as <strong>pointer that
hold the current value of the stack pointer, namely the base address of
the <code>local</code>, <code>argument</code>, <code>this</code>,
<code>that</code></strong>.</p></li>
<li><p>The VM implementation also allocates a certain area on RAM to
hold the global stack which <strong>keeps the working stack of the
currentlt running VM functions</strong> and all the working stack and
memory segments of the functions that wait to for the current function
to terminate, namely the functions which <strong>are on the calling
chain</strong>.</p></li>
<li><p>The VM implementation recalls the location of these segments of
the stack by <strong>using the two pointers <code>LCL</code> and
<code>ARG</code></strong>. It records the base address of this segment
in the <code>LCL</code>.</p></li>
</ul>
<p>  Then how can we use the same architecture to represent object and
array data?</p>
<ol type="1">
<li>We use a different area altogether on the RAM called
<em><code>heap</code></em>.</li>
<li>On the <code>heap</code>, we recall the data of all the objects and
the arrays that the current program seeks to manipulate.</li>
</ol>
<p><img src="/2024/04/22/10-5-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/image-2.png"></p>
<p>  As opposed to the <code>local</code> and <code>argument</code>
segments which have only one of each to worry about, here you may have
many objects on the heap. So before we access an object using
<code>this</code> segment, we have to tell the system <strong>to which
object are we actually referring</strong>?</p>
<ul>
<li>The implementation of <code>this</code> location is first
<strong>use the pointer <code>this</code> and
<code>that</code></strong>.</li>
<li>Before we use the two segments, we <strong>first have to use the
<code>pointer</code> segment</strong> to <strong>tell the system where
we want to align <code>this</code> and <code>that</code> on the
RAM</strong>.</li>
</ul>
<blockquote>
<p>We had to provide a mechanism to anchor this and that on the
particular object and array the code has to operate on and we are using
this virtual segment pointer for this purpose.</p>
</blockquote>
<p>  Now, suppose we want to access RAM words 8000, 8001, 8002... We can
achieve this by the following VM code:</p>
<p><img src="/2024/04/22/10-5-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/image-3.png"></p>
<ul>
<li>Once we set <code>THIS</code> pointer to a particular address,
<strong><code>THIS</code>can be used as if it's anchored exactly on the
8000th address in RAM</strong>. Given this desired mapping, we can use
command related to <code>THIS</code>.</li>
<li><code>push this 0</code> will <strong>take the value which is
currently located in <code>RAM 8000</code> onto the stack</strong>.</li>
<li><code>pop this 0</code> will <strong>take something off the stack
and put it into <code>RAM 8000</code></strong>.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.4.对控制流的处理</title>
    <url>/2024/04/20/10-4-%E5%AF%B9%E6%8E%A7%E5%88%B6%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="114handling-flow-of-control"><span class="math inline">\(11.4.\)</span>Handling Flow of Control</h1>
<p><img src="/2024/04/20/10-4-%E5%AF%B9%E6%8E%A7%E5%88%B6%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86/image.png"></p>
<ul>
<li>The <code>not</code> operation will <strong>turn the expression into
a boolean value</strong>, thus make out code simpler and tighter.</li>
<li>The compiler generates these labels automatically.</li>
</ul>
<p><img src="/2024/04/20/10-4-%E5%AF%B9%E6%8E%A7%E5%88%B6%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86/image-1.png"></p>
<p>  In a program, we may have multiple <code>if</code> and
<code>while</code>statements, to deal we this, we only have to assure
that <strong>the compiler generates unique labels</strong>.</p>
<p>  Also the <code>if</code> and <code>while</code> statements may be
nested. That is , <strong>the compiler employs a highly recursive
compilation</strong>.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.2.对变量的处理</title>
    <url>/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="112handling-variables"><span class="math inline">\(11.2\)</span>Handling Variables</h1>
<h3 id="1program-compilation">1.Program compilation</h3>
<p>  Remember that the VM language doesn't have symbolic variables, it
only has <code>local</code>, <code>this</code> and so on. In order to
resolve this pseudocode into final executable VM code, we have to
<strong>map these symbolic variables on what is called <em>virtual
memory segments</em></strong>. And to do this, we:</p>
<ul>
<li>need the <strong>variable properties</strong>.</li>
<li>also have to know <strong>the index of the variable of its
kind</strong>(first, second, etc.).</li>
</ul>
<p>  And the properties of variables include:</p>
<ul>
<li><p><em>name</em>: It's an identifier.</p></li>
<li><p><em>type</em>: <code>int</code>, <code>char</code>,
<code>boolean</code> and <strong>all class name</strong>.</p></li>
<li><p><em>kind</em>: There are two kinds of variables, and we view them
separately:</p>
<ul>
<li><em>class level</em>: <code>field</code>, <code>static</code>
variables.</li>
<li><em>subroutine level</em>: <code>argument</code> and
<code>local</code> variables.</li>
</ul></li>
<li><p><em>scope</em>, which is the region of the code in which it is
recognized.</p></li>
</ul>
<h3 id="2symbol-table">2.Symbol table</h3>
<p>  We handle the property of variables using a <em>symbol
table</em>:</p>
<p><img src="/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/image.png"></p>
<ul>
<li>A method is always designed to operate on the current object which
is called <code>this</code>. Therefore, the symbol table of method
<strong>always begins with <code>this</code> entry</strong>, which
represents the properties of current object.</li>
<li><code>this</code> is always treated as <code>argument 0</code></li>
<li>The type of current object is <strong>the name of the class to which
this subroutine belongs</strong>.</li>
</ul>
<p>  The class level symbol table can be reset each time we begin to
compile a new class, for <strong>classes are standalone compilation
unity</strong>. Something similar happens when we compile
subroutines.</p>
<p>  The code writer is going to encounter all sorts of variable
declaration commands, of which in Jack we have three:
<code>local</code>, <code>field</code> and <code>static</code>.</p>
<p>  Then it's going to elucidate all important properties of the
declared variables, and <strong>add the information to the respective
symbol table</strong>. It generates no code whatsoever beyond updating
the symbol tables.</p>
<ul>
<li>If we are defining a <code>field</code> or a <code>static</code>
variable, the code writer will add a new row to the end of the class
level symbol table.</li>
<li>If we are defining <code>local</code> or <code>argument</code>, the
code writer will update the symbol table of the subroutine which is
currently being compiled.</li>
<li>Arguments are being defined as <strong>part of the parameter list of
the method's signature</strong>. When the code writer goes through the
parameter list, it adds the respective lines to the subroutine's symbol
table.</li>
</ul>
<p><img src="/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/image-1.png"></p>
<p>  What about using variables within the context of expressions or
statements. Take <code>let dx = x - other.getX();</code> as an
example:</p>
<ul>
<li><p>For each variable in the code, we <strong>look up this variable
in the subroutine level symbol table</strong>.</p>
<ul>
<li>If we find it there, we know which property we have to use.</li>
<li>If don't, we revert to <strong>looking it up in the class level
symbol table</strong>.</li>
<li>If don't either, we can conclude that the variable is undefined and
throw an error message.</li>
</ul></li>
</ul>
<p>  How can the statements be translated into VM code? Take
<code>let y = y +dy</code> for example:</p>
<ol type="1">
<li>In the process of generating code, the code generator will look up
the respective table.</li>
<li>It finds out that <strong><code>y</code> stands for the second
<code>field</code> of the current object</strong>, so it will be
translated into <code>this 1</code></li>
<li><code>dy</code> stands for the second <code>local</code> variable,
so it will be translated into <code>local 1</code></li>
</ol>
<p><img src="/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/image-2.png"></p>
<p><img src="/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/image-3.png"></p>
<h3 id="3handling-variables-ingeneral">3.Handling variables in
general</h3>
<p>  High level of programming languages vary in terms of:</p>
<ul>
<li>variable types</li>
<li>variable kinds</li>
<li>nested scoping rules</li>
</ul>
<p>  And the symbol table generation and usage we discussed right now
can be easily entended to handle any number of possible variables types
and kinds.</p>
<p>  Some languages, like Java, feature <em>unlimited scoping</em>. this
means that whenever you define a block of code with a pair of curly
brackets, you can define variables within this code which are recognized
only within that block. <code>x</code> in this scope doesn't mean the
same as <code>x</code> in that block.</p>
<p>  To represent the information in our symbol table mechanism, we use
<strong>a linked list of symbol tables</strong>:</p>
<ul>
<li>When start compiling the class, we first create an linked list.</li>
<li>The first symbol table we add to the list is the class level symbol
table.</li>
<li>When we start compiling a method, we create the method symbol table
like before.</li>
<li>Whenever we have another scoping region, we <strong>add another
symbol table to the linked list</strong>.</li>
</ul>
<p><img src="/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/image-4.png"></p>
<p>  When you encounter some variable <code>x</code> in the code we:</p>
<ol type="1">
<li>Look up <code>x</code> in the current scope, which is also the first
table.</li>
<li>If fail, we move to the next symbol table.</li>
<li>We simply go on downstream until we get to the class level symbol
table.</li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.3.对表达式的处理</title>
    <url>/2024/04/20/10-3-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="113handling-expression"><span class="math inline">\(11.3.\)</span>Handling Expression</h1>
<h3 id="1expressions-definitionreview">1.Expressions definition
review</h3>
<p><img src="/2024/04/20/10-3-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/image-5.png"></p>
<h3 id="2parse-tree">2.Parse tree</h3>
<p><img src="/2024/04/20/10-3-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/image-6.png"></p>
<ul>
<li><em>infix</em>: that's sort of ingrained into our brains in
elementary school.</li>
<li><em>prefix</em>: that's what we do when we define functions: we put
the function name and then a list of operands or parameters or
arguments.</li>
<li><em>postfix</em>: that's closely related to the stack machine. Say
we want to do an <code>add</code> operation, we <code>push x</code>,
<code>push y</code> and finally <code>pop</code>, this is exactly
postfix.</li>
</ul>
<h3 id="3generating-code-forexpressions">3.Generating code for
expressions</h3>
<p>  In high level language like Java, we declare expressions in infix,
and the target language, so our compiler has to translate from infix to
postfix. Here are two ways to do this:</p>
<p><img src="/2024/04/20/10-3-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/image-7.png"></p>
<ol type="1">
<li>We generate a parse tree through the infix expression.</li>
<li>The parser takes the source code and produces XML code from it.</li>
<li>We go through every node in the parse tree in a certain order.</li>
</ol>
<p>  To convert the parse tree into the VM code, we use the
<em>deep-first tree traversal algorithm</em>:</p>
<ul>
<li>We go all the way down, and when we hit a terminal leaf, we process
it.</li>
</ul>
<p>  However, the parse tree we have may be gigantic, so it may be
better not to have the side effect. We will use the following code
generation algorithm instead:</p>
<p><img src="/2024/04/20/10-3-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/image-8.png"></p>
<ul>
<li>Whatever is the mapping of <code>x</code> is dictated by the symbol
table which is always in the background of the co-generation
algorithms.</li>
</ul>
<p>  The nice thing about this algorithm is that not only does it
<strong>capture the semantics of the input expression</strong>, it also
<strong>computes the value of this expression</strong>. That is, in the
runtime the value of the expression is going to be placed on the
stack.</p>
<h3 id="4from-parsing-to-codegeneration">4.From parsing to code
generation</h3>
<p>  In the previous project, we develop a Jack Analyzer that generate
static XML code, but in this part, the XML is completely irrelevant now.
Instead, we generate actual executable VM code. And there are some
general guidelines on what has to be done:</p>
<ul>
<li>We have <strong>operator priority</strong> in some operation, such
as mathematics operations (however, Jack doesn't have this). Since the
compiler will ignore it, we ourselves must take this into
consideration.</li>
<li>Once we have parenthesis in Jack, we have to take operator priority
into consideration. We have to make the code write algorithm work in the
proper order as dictated by the parenthesis.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>9.9.分析器实现笔记</title>
    <url>/2024/04/19/9-9-%E5%88%86%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="99分析器实现笔记"><span class="math inline">\(9.9.\)</span>分析器实现笔记</h1>
<h3 id="1分词器">1.分词器</h3>
<p>  实现分词器，容易想到先按照token进行分类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (Character.isDigit(ch))</span><br><span class="line"><span class="keyword">if</span> (isSymbol(ch))</span><br><span class="line"><span class="keyword">for</span> (String keywordName : keyword)</span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure>
<p>  但是，有时关键词会混杂在标识符中，导致分词错误。此时我们在处理完关键词后，可以引入一些<strong>语法模式</strong>，对一些特例<strong>优先处理</strong>，以避免意外情况的出现：</p>
<ol type="1">
<li>类的定义：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (keywordName.equals(<span class="string">&quot;class&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;&#123;&quot;</span>));</span><br><span class="line">    currentClass = classname;</span><br><span class="line">    writer.write(identifierVal(classname));</span><br><span class="line">    writer.newLine();</span><br><span class="line">    token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">    tokenLine.add(identifierVal(classname));</span><br><span class="line">    stringCollection.add(classname);</span><br><span class="line">    line = line.substring(classname.length());</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>变量的声明：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isVarDec(keywordName)) &#123;</span><br><span class="line">    <span class="comment">// The first is type declaration</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (String s : type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line.indexOf(s) == <span class="number">0</span>) &#123;</span><br><span class="line">            tag = <span class="literal">true</span>;</span><br><span class="line">            writer.write(keywordVal(s));</span><br><span class="line">            writer.newLine();</span><br><span class="line">            token.add(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            tokenLine.add(keywordVal(s));</span><br><span class="line">            stringCollection.add(s);</span><br><span class="line">            line = line.substring(s.length());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : className) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.indexOf(s) == <span class="number">0</span>) &#123;</span><br><span class="line">                writer.write(identifierVal(s));</span><br><span class="line">                writer.newLine();</span><br><span class="line">                token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">                tokenLine.add(identifierVal(s));</span><br><span class="line">                stringCollection.add(s);</span><br><span class="line">                line = line.substring(s.length());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then comes the varName</span></span><br><span class="line">    String varName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line.contains(<span class="string">&quot;,&quot;</span>) &amp;&amp; line.indexOf(<span class="string">&quot;,&quot;</span>) &lt; line.indexOf(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">        varName = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        writer.write(identifierVal(varName));</span><br><span class="line">        writer.newLine();</span><br><span class="line">        token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">        tokenLine.add(identifierVal(varName));</span><br><span class="line">        stringCollection.add(varName);</span><br><span class="line">        line = line.substring(varName.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need to consider if there exists a &#x27;,&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> (line.charAt(<span class="number">0</span>) == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">            writer.write(identifierVal(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            writer.newLine();</span><br><span class="line">            token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">            tokenLine.add(identifierVal(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            stringCollection.add(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            line = line.substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;,&quot;</span>) &amp;&amp; line.indexOf(<span class="string">&quot;,&quot;</span>) &lt; line.indexOf(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">                varName = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                varName = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            writer.write(identifierVal(varName));</span><br><span class="line">            writer.newLine();</span><br><span class="line">            token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">            tokenLine.add(identifierVal(varName));</span><br><span class="line">            stringCollection.add(varName);</span><br><span class="line">            line = line.substring(varName.length());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.write(identifierVal(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        writer.newLine();</span><br><span class="line">        token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">        tokenLine.add(identifierVal(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        stringCollection.add(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        line = line.substring(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// No &#x27;,&#x27;, just &#x27;;&#x27;</span></span><br><span class="line">        varName = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        writer.write(identifierVal(varName));</span><br><span class="line">        writer.newLine();</span><br><span class="line">        token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">        tokenLine.add(identifierVal(varName));</span><br><span class="line">        stringCollection.add(varName);</span><br><span class="line">        line = line.substring(varName.length());</span><br><span class="line"></span><br><span class="line">        writer.write(identifierVal(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        writer.newLine();</span><br><span class="line">        token.add(<span class="string">&quot;symbol&quot;</span>);</span><br><span class="line">        tokenLine.add(identifierVal(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        stringCollection.add(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        line = line.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>函数的声明：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSubroutineDec(keywordName)) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (String s : type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line.indexOf(s) == <span class="number">0</span>) &#123;</span><br><span class="line">            tag = <span class="literal">true</span>;</span><br><span class="line">            writer.write(keywordVal(s));</span><br><span class="line">            writer.newLine();</span><br><span class="line">            token.add(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            tokenLine.add(keywordVal(s));</span><br><span class="line">            stringCollection.add(s);</span><br><span class="line">            line = line.substring(s.length());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : className) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.indexOf(s) == <span class="number">0</span>) &#123;</span><br><span class="line">                writer.write(identifierVal(s));</span><br><span class="line">                writer.newLine();</span><br><span class="line">                token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">                tokenLine.add(identifierVal(s));</span><br><span class="line">                stringCollection.add(s);</span><br><span class="line">                line = line.substring(s.length());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">varName</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;(&quot;</span>));</span><br><span class="line">    funcCollection.add(currentClass + <span class="string">&quot;.&quot;</span> + varName);</span><br><span class="line">    writer.write(identifierVal(varName));</span><br><span class="line">    writer.newLine();</span><br><span class="line">    token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">    tokenLine.add(identifierVal(varName));</span><br><span class="line">    stringCollection.add(varName);</span><br><span class="line">    line = line.substring(varName.length());</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2分析器">2.分析器</h3>
<p>  在分析器中，我们使用经分词器处理过的文件来构建最终的.xml文件。由于对一个元素我们可能会生成多行代码，我们选择利用<code>ArrayList&lt;String&gt;</code>来存储每个元素产生的语句。当一个元素中包含了其他子元素时，我们<strong>在调用处理子元素的方法、得到子元素的分析代码后，加入该元素的<code>ArrayList</code>即可</strong>。这样，我们就可以通过<strong>递归</strong>调用来完成对程序的分析</p>
<p>  以<code>class</code>的分析为例，我们可以写出以下的代码框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileClass</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; class_ = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    class_.add(<span class="string">&quot;&lt;class&gt;&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//call method recursively</span></span><br><span class="line">    class_.addAll(compileClassVar());</span><br><span class="line">    class_.addAll(compileSubroutineDec());</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    class_.add(<span class="string">&quot;&lt;/class&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> class_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 9.Syntax Analyze</category>
      </categories>
  </entry>
  <entry>
    <title>9.5.解析器逻辑</title>
    <url>/2024/04/16/9-5-%E8%A7%A3%E6%9E%90%E5%99%A8%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1 id="95parserlogic"><span class="math inline">\(9.5.\)</span>Parser
Logic</h1>
<h3 id="1parsing-logic">1.Parsing logic</h3>
<p>  In order to carry out parsing, we are going to build a
<code>CompilationEngine</code> class which consist of <strong>a set of
methods, one method for every non-terminal rule</strong>.</p>
<p><img src="/2024/04/16/9-5-%E8%A7%A3%E6%9E%90%E5%99%A8%E9%80%BB%E8%BE%91/image.png"></p>
<ul>
<li>The code of each <code>compilexxx</code> method follows the
right-hand side of the rule xxx</li>
<li>Each <code>compilexxx</code> method is responsible for
<strong>advancing</strong> and <strong>handling its own part of the
input</strong>.</li>
</ul>
<p>  To illustrate this, let's focus on one of these methods
<code>compileWhileStatement</code>:</p>
<p><img src="/2024/04/16/9-5-%E8%A7%A3%E6%9E%90%E5%99%A8%E9%80%BB%E8%BE%91/image-1.png"></p>
<ol type="1">
<li><p>We <strong>follow the right-hand side of the rule</strong>, and
parse the input it dictates.</p>
<ul>
<li>In <code>whileStatement</code>, it says we should expect to see the
token <code>while</code>. If we find it in the input, we record the
fact. Then the left parenthesis, and so on and so forth,</li>
<li>At some point we will get a non-terminal rule like
<code>expression</code>, then we go to next step:</li>
</ul></li>
<li><p>If the right-hand side specifies a non-terminal rule
<code>xxx</code>, we call the corresponding method
<code>compilexxx</code></p></li>
<li><p>We do this recursively untile we exhaust the input.</p></li>
</ol>
<p>  And to initialize this process, we:</p>
<ol type="1">
<li>Advance the tokenizer.</li>
<li>Call <code>compileWhileStatement</code>.</li>
</ol>
<h3 id="2parser-design">2.Parser design</h3>
<p>  We also take the <code>compileWhileStatement</code> as an
example:</p>
<ol type="1">
<li>If we look at the grammar, we first see that you should see a
<code>while</code> , so we <strong>call a method
<code>eat('while')</code></strong>, which means you should expect now to
eat the <code>while</code> token.</li>
<li>We do the same thing <code>eat('(')</code>.</li>
<li>We meet a non-terminal rule <code>expression</code>, so we call
<code>compileExpression();</code></li>
<li>And so on and so forth...</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CompilationEngine &#123; </span><br><span class="line">	</span><br><span class="line">	compileWhileStatement() &#123; </span><br><span class="line">		eat(&#x27;while’);</span><br><span class="line">		eat(&#x27;(&#x27;);  </span><br><span class="line">		compileExpression(); </span><br><span class="line">		eat(&#x27;)&#x27;);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  When it comes to <code>eat</code> method:</p>
<ul>
<li>It's a private method.</li>
<li>It says <strong>you should expect to see the given string</strong>,
if not, you should <strong>throw an error</strong>.</li>
<li>Otherwise, simply <strong>advance the input</strong>.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eat(string) &#123;</span><br><span class="line">	if (currentToken &lt;&gt; string) </span><br><span class="line">		error...</span><br><span class="line">	else</span><br><span class="line">		advance...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3some-observationabout-grammars-and-parsing">3.Some observation
about grammars and parsing</h3>
<ul>
<li><p><em>LL grammar</em>: It's a grammar that <strong>can be parsed by
a recursive descent algorithm parser without backtracking</strong>.</p>
<ul>
<li>When you make a decision that what you have is a <code>while</code>
statement, you don't have to kind of retract your progress and find out
a mistake.</li>
</ul></li>
<li><p><em>LL(k) parser</em>: It's an LL parser that needs to look ahead
at most k tokens before you know which rule you are dealing with.</p>
<ul>
<li>The grammar we saw so far is <em>LL1</em>, because <strong>once we
have a particular token in hand like <code>let</code>, we immediately
know which rule we have to invoke</strong>.</li>
<li>There are also things that don't belong to LL1, like English. For
example, when we meet a token word "lift", we still have no idea what we
should do with it. A verb? A noun? We have to look more tokens
downstream to know which rule to use. In this process, we may need to
backtrack and reconsider some of the rules we have to use...</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 9.Syntax Analyze</category>
      </categories>
  </entry>
  <entry>
    <title>9.4.解析树</title>
    <url>/2024/04/16/10-4-%E8%A7%A3%E6%9E%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="94parsetree"><span class="math inline">\(9.4.\)</span>Parse
Tree</h1>
<h3 id="1parse-tree-introduction">1.Parse tree introduction</h3>
<p>  In this part we are going to be specific about the grammatical
structure. Take the sentence "the dog ate my homework" for example,
here's the grammatical structure of it:</p>
<p><img src="/2024/04/16/10-4-%E8%A7%A3%E6%9E%90%E6%A0%91/image.png"></p>
<p>  It's recorded using a <em>parse tree</em>. The tree is a recursive
structure, and the grammatical structure of the inputs are
<strong>recursive</strong>, too.</p>
<ul>
<li>The <code>sentence</code> consists of two lower-level sub parse
tree.</li>
<li>We continue to expanding the tree until get to the boundary of the
tree, called <em>leaves</em> or <em>terminal nodes</em>. In the case of
lexical analysis, they are <strong>the tokens from which the input is
constructed</strong>.</li>
</ul>
<p>  Then let's move to Jack. Take the input
<code>while (count &lt; 100) &#123;let count = count + 1;&#125;</code> for
example:</p>
<p><img src="/2024/04/16/10-4-%E8%A7%A3%E6%9E%90%E6%A0%91/image-1.png"></p>
<blockquote>
<p>The notion of a parse tree is an obstruct artifact that sits
somewhere above all these nice diagrams. And this diagram here is just
one way to describe this parse tree.</p>
</blockquote>
<p>  To motivate this, let's focus on some subset of the prase tree:</p>
<p><img src="/2024/04/16/10-4-%E8%A7%A3%E6%9E%90%E6%A0%91/image-2.png"></p>
<p>  Another way of describing the same parse tree can be <em>XML
format</em>:</p>
<p><img src="/2024/04/16/10-4-%E8%A7%A3%E6%9E%90%E6%A0%91/image-3.png"></p>
<ul>
<li>In XML, we describe the structure of data using <em>markup
tags</em>.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 9.Syntax Analyze</category>
      </categories>
  </entry>
  <entry>
    <title>9.3.语法</title>
    <url>/2024/04/16/10-3-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="93grammars"><span class="math inline">\(9.3.\)</span>Grammars</h1>
<h3 id="1grammar-introduction">1.Grammar introduction</h3>
<p>  In the previous unit, we gain the ability to think about the
program as a set of tokens, but the effect that we have a set of valid
tokens doesn't imply that we have a valid program. <strong>It's not only
the tokens that are important, the order of the tokens is critically
important as well</strong>.</p>
<p>  And the artifact that <strong>defines in what order we can put
tokens together legibly</strong> is referred to as <em>grammar</em>.</p>
<ul>
<li>A grammar is a set of rules, describing how tokens can be combined
to create valid language constructs</li>
</ul>
<p>  Take the English language as an example:</p>
<p><img src="/2024/04/16/10-3-%E8%AF%AD%E6%B3%95/image.png"></p>
<p>  It's just a subset of English language, but is sufficiently rich to
support plenty of inputs. Consider the sentence "The dog ate my
homework":</p>
<ul>
<li>'The' is a det and 'dog' is a noun, so the sentence begins with a
noun phrase.</li>
<li>'ate' is a verb and 'my homework' is once again a noun phrase, so
this subsentence is a verb phrase.</li>
<li>Taken together, we have a noun phrase followed by a verb phrase,
therefore we have a legitimate sentence.</li>
</ul>
<p>  In this example, we notice that grammar is indeed made of a set of
rules. And these rules fall into two broad categories:</p>
<ol type="1">
<li><em>Terminal rule</em>: Its right-hand side consists of constants
only.</li>
<li><em>Non-terminal rule</em>: Its right-hand side consists of names of
other rules, and probably constants.</li>
</ol>
<h3 id="2jack-grammar">2.Jack grammar</h3>
<p>  Let's focus on a subset of Jack language in which we have three
possible statements: <code>if</code>, <code>while</code>,
<code>let</code>:</p>
<p><img src="/2024/04/16/10-3-%E8%AF%AD%E6%B3%95/image-1.png"></p>
<ul>
<li>We use <code>*</code> to indicate 0 or more.</li>
<li>We use <code>|</code> to denote choice.</li>
<li>We use <code>?</code> to denote 0 or 1.</li>
</ul>
<p>  And the process of <strong>determining if a given input conforms to
a grammar</strong> is called <em>prasing</em>.</p>
<p>  Notice that in the process of doing this confirmation, we also
<strong>uncover the entire grammatical structure of the given
input</strong>, because we analyze how the input corresponds to the
various components of the rule.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 9.Syntax Analyze</category>
      </categories>
  </entry>
  <entry>
    <title>9.2.词法分析</title>
    <url>/2024/04/15/9-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="92lexical-analysis"><span class="math inline">\(9.2.\)</span>Lexical Analysis</h1>
<h3 id="1-tokenizing">1. Tokenizing</h3>
<p>  In the previous unit, we observed that the syntax analyzer consist
of two modules: a <em>tokenizer</em> and a <em>parser</em>:</p>
<p><img src="/2024/04/15/9-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image.png"></p>
<p>  And the tokenizer is an application of a more general area of
theory known as <em>lexical analysis</em>. Here's an example of
tokenizing in action:</p>
<p><img src="/2024/04/15/9-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-1.png"></p>
<ul>
<li><p>As far as <em>lexical analysis</em> is concerned, the input is
nothing more than <strong>a stream of characters</strong>.</p></li>
<li><p><em>Tokenizing</em> refers to <strong>grouping the primitive
stream of characters into a stream of meaningful tokens</strong>. It
provides a very simple yet important preliminary processing of the
file.</p></li>
<li><p>A <em>token</em> is <strong>a string of characters that has a
meaning</strong>.</p>
<ul>
<li>Different programming languages have different definitions of token.
For example, <code>x++</code> in C makes a lot of sense, but not in
Jack, for it doesn't have an <code>++</code> operation.</li>
</ul></li>
</ul>
<p>  Once we come up with these stream of tokens, we can <strong>hand it
over to the compiler and completely forget the original input
file</strong>.</p>
<h3 id="2jack-tokenizer">2.Jack tokenizer</h3>
<p>  In Jack, we have 5 kinds of tokens:</p>
<p><img src="/2024/04/15/9-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-2.png"></p>
<p>  And our tokenizer will provide these useful service:</p>
<ol type="1">
<li><p>Handle the compiler's input: It allow us to view the input as a
stream of tokens.</p></li>
<li><p>Allow advancing the input: It allow us to know:</p>
<ul>
<li><strong>If there are more tokens to process</strong>.</li>
<li><strong>What the next token is</strong>.</li>
<li><strong>The value, type of this token</strong>.</li>
</ul></li>
<li><p>Supply the value, type of the current token.</p></li>
</ol>
<p>  Here's an example of a program that use these services:</p>
<p><img src="/2024/04/15/9-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-3.png"></p>
<p>  The <code>TokenizerTest</code> is a program that construct the
tokenizer object. Here's what it does:</p>
<ul>
<li>It goes through the input, and for every token, it <strong>lists the
token to be out of file</strong>.</li>
<li>In the first line, <code>if</code> is surrounded by two
<em>tags</em>, it <strong>describe the type of the token</strong>.</li>
</ul>
<p>  And to conduct these functionalities, we can write this pseudo
code: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tknzr = new JackTokenizer(&quot;Prog.jack&quot;)</span><br><span class="line">tknzr.advance();</span><br><span class="line">while tknzr.hasMoreTokens() &#123;</span><br><span class="line">	tokenclassification=  current token classification</span><br><span class="line">	print &quot;&lt;&quot; + tokenclassification + &quot;&gt;&quot;</span><br><span class="line">	print the current token value</span><br><span class="line">	print &quot;&lt;/&quot; + tokenclassification + &quot;&gt;&quot;</span><br><span class="line">	print newLine</span><br><span class="line">	tknzr.advance();</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li><p>We get the first token, and it becomes the current
token.</p></li>
<li><p>We enter a loop as long as we have more tokens to
process.</p></li>
<li><p>In each line of the program, we have to <strong>output the
classification of the token</strong>, and we have to <strong>do it
twice</strong>.</p></li>
<li><p>We:</p>
<ol type="1">
<li>Print the <strong>opening tag</strong>, then</li>
<li>Print the <strong>value of of the current token</strong>,</li>
<li>Print the <strong>token itself</strong>,</li>
<li>At last print <strong>end tag with token
classification</strong>.</li>
</ol></li>
<li><p>We print a newline, and <code>advance()</code> to get the next
token from the tokenizer, until we consume all the tokens from the input
file.</p></li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 9.Syntax Analyze</category>
      </categories>
  </entry>
  <entry>
    <title>8.3.列表处理</title>
    <url>/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="83listprocessing"><span class="math inline">\(8.3.\)</span>List
Processing</h1>
<h3 id="1list-processing">1.List processing</h3>
<h4 id="acreation">  $a.Creation</h4>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image.png"></p>
<p>  The client process is described as below:</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-1.png"></p>
<ol type="1">
<li>We create a V pointer. We will get the variable containing 0,
because all local variables are initialized to 0.</li>
<li>We invoke the list constructor, and the list constructor is going to
<strong>come back with a block of memory that represents the number 5
and null</strong>.</li>
<li>V is going to <strong>point to the base address</strong> of the
object that was returned by the constructor.</li>
<li>The previous version of V is no longer relevant, and the next
command will do exactly the same.</li>
</ol>
<h4 id="bsequential-access">  <span class="math inline">\(b.\)</span>Sequential access</h4>
<p>  We will use the <code>print</code> method to illustrate the
sequential process:</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-2.png"></p>
<blockquote>
<p>In Object-based Programming, when we call a method on an object, we
are implicitily <strong>passing the object as a parameter to this
method</strong>.</p>
</blockquote>
<p>  In the constructor, we do these things:</p>
<ol type="1">
<li><p>We create <code>current</code>, it's an identifier that exist
outside the world of list. We use a special variable called
<code>this</code> which stands for the current object.</p>
<ul>
<li><code>this</code> is the point from which we are going to
<strong>refer to the object that was passed with</strong>.</li>
</ul></li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-3.png"></p>
<ol start="2" type="1">
<li>The entry point of the list is <code>this</code>, and we set
<code>current</code> to <code>this</code>, then we get two pointers
referring to the head of the list.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-4.png"></p>
<ol start="3" type="1">
<li>Now we enter the loop, we print the <code>data</code> and move
<code>current</code> to <code>next</code>.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-5.png"></p>
<ol start="4" type="1">
<li>At last we <code>return</code>, <code>current</code> no longer
exists and <code>this</code> is reinstated and points to the list as
before.</li>
</ol>
<p>  When the client want to create a list:</p>
<ol type="1">
<li>It all starts by creating a <code>V</code> pointer. We <strong>get
the variable containing value 0</strong> because all local variables are
initialized to 0.</li>
</ol>
<p>  Then we call the constructor, and the list constructor is going to
come back with a block of memory that represents the
<code>(5, null)</code>.</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-6.png"></p>
<ol start="2" type="1">
<li>Once the <code>List.new</code> is called, the previous vesion of
<code>V</code> is no longer relevant. The rest steps are trival.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-7.png"></p>
<h4 id="crecursive-access">  <span class="math inline">\(c.\)</span>Recursive access</h4>
<p>  Let's take the <code>dispose</code> method as an example:</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-8.png"></p>
<ol type="1">
<li>As usual, we first call a variable <code>V</code>. The
<code>dispose</code> method doesn't know what <code>V</code> is, so the
variable <code>this</code> was passed to <code>dispose</code>.</li>
<li>The <code>next</code> isn't null, so we go to the recursive call.
The <code>this</code> now points at the tail of the list.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-9.png"></p>
<ol start="3" type="1">
<li>We finally meet 5, do the <code>deAlloc</code> and
<code>return</code>. Once we do the <code>return</code>, we get
completely out of the recursive method, and <strong>what used to be
called <code>this</code> goes back to be named
<code>V</code></strong>.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-10.png"></p>
<ol start="4" type="1">
<li>Now the <code>V</code> points to nothing, for we basically disposed
everything in this list.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-11.png"></p>
<p>  However, recursion is very inefficient operation and if you do this
with a big list, you will probably get a <code>StackOverflow</code>
error.</p>
<h3 id="4list-representation">4.List representation</h3>
<p>  The following list:</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-12.png"></p>
<p>  is represented in the host RAM like this:</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-13.png"></p>
<p>  Then who makes these work?</p>
<ul>
<li>High-level: the constructor</li>
<li>Low-level: when compiling the constructor, <strong>the compiler
plants calls to OS routines that find, and allocate, available memory
space for the new object</strong>.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 8.High Level Language</category>
      </categories>
  </entry>
  <entry>
    <title>8.2.基于对象的编程</title>
    <url>/2024/04/13/8-2-%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="92object-based-programming"><span class="math inline">\(9.2.\)</span>Object-based Programming</h1>
<h3 id="1object-oriented-programming">1.Object-oriented programming</h3>
<p>  When designing an abstraction, we</p>
<ol type="1">
<li><p>Consider <strong>what kind of data do we want to store
about</strong> and <strong>the objects that this class is supposed to
represent</strong>.</p>
<ul>
<li>In our case, we need to store numerator and denominator.</li>
</ul></li>
<li><p>We store these values into integer type of
<code>field</code>.</p></li>
<li><p><strong>The only way to access field values from outside the
class is through <em>accessor</em> methods</strong>, so we create
accessors to facilitate access.</p></li>
</ol>
<p><img src="/2024/04/13/8-2-%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/image.png"></p>
<ol start="4" type="1">
<li><p>Then we write a <em>constructor</em> to create new objects. We
create the object and <strong>return it to the base
address</strong>.</p>
<ul>
<li><p><code>this</code> is a standard reference to the current object.
It is actually <strong>the base address of the current object in the
host RAM</strong>.</p></li>
<li><p>One of the rules of the game is that a Jack constructor must</p>
<ul>
<li>return the <em>base address</em>.</li>
<li>return <em>an object of the type of the surrounding class</em> or
<em>the class to which this constructor belongs</em>.</li>
<li>In Jack, every subroutine must <strong>always terminate with
<code>return</code> command</strong>.</li>
</ul></li>
</ul></li>
<li><p>We create several methods as we wish, this is quite simple so we
skip this part.</p></li>
<li><p>We create <code>dispose</code> method:</p>
<ul>
<li>The method is implemented using a call to the host operation system.
We call the OS routine <code>deAlloc</code>, which takes an address in
memory and disposes the memory block that begins in this address.</li>
<li>This is important to Jack, because Jack has no garbage collection
services, so it's up to the programmer to do this.</li>
</ul></li>
</ol>
<h3 id="2object-representation">2.Object representation</h3>
<p><img src="/2024/04/13/8-2-%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/image-1.png"></p>
<p>  In client's view:</p>
<ul>
<li>Each fraction is represented by a block that includes all the field
values of the current object.</li>
<li>We have a reference to each of these blocks, which is <strong>the
name of the variable</strong>.</li>
</ul>
<p>  In the host RAM:</p>
<ul>
<li>Some area of it <strong>is designated to represent the the stack of
the currently running application</strong>.</li>
<li>The <code>stack</code> is used to <strong>store
variables</strong>.</li>
<li>We have the <code>heap</code> where we <strong>represent objects and
arrays</strong>.</li>
</ul>
<p> We see that we have a variable <code>a</code> which contains the
number 15087. If we <strong>treat this variable as a pointer and look up
this address in the RAM</strong>, we see that the number after the 2 is
3. This two numbers comprise the memory block that represents our first
object.</p>
<p>  How does this representation is established? The secret is that:
when the compiler is going to compile your constructor, it would</p>
<ol type="1">
<li><strong>Inject some calls to the operating system</strong>.</li>
<li><strong>These calls are going to find available memory and allocate
it to the object that was just constructed</strong>.</li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 8.High Level Language</category>
      </categories>
  </entry>
  <entry>
    <title>7.12.翻译器实现笔记</title>
    <url>/2024/04/13/7-12-%E7%BF%BB%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="712翻译器实现笔记"><span class="math inline">\(7.12.\)</span>翻译器实现笔记</h1>
<h3 id="1localargumentthisthattemp的实现">1.
<code>local,argument,this,that,temp</code>的实现</h3>
<p>  这几个内存段的<code>push</code>实现都遵循<code>*sp=*addr</code>的过程。我们可以将该过程拆分为下面的子过程：</p>
<ul>
<li><code>D=*addr</code>.</li>
<li><code>*sp=D</code>.</li>
<li><code>sp++</code></li>
</ul>
<p>  同时，根据先前的讨论，<code>push</code>操作中的<code>addr</code>可以通过<code>baseAddr+index</code>来计算。<code>index</code>的值很容易获取，假设我们的操作为<code>push local x</code>,
则： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//get index</span><br><span class="line">@x</span><br><span class="line">D=A</span><br></pre></td></tr></table></figure></p>
<p>  但接下来，如果要获取<code>baseAddr</code>，因为此时的D寄存器已经存储了<code>x</code>的序号，
我们会想通过A寄存器获得<code>baseAddr</code>,
然后将<code>baseAddr+index</code>的地址存入A寄存器中： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//get base addr</span><br><span class="line">@LCL</span><br><span class="line">A=M</span><br><span class="line">A=A+D</span><br></pre></td></tr></table></figure></p>
<p>  顺利完成<code>LCL</code>内存段的地址读入后，我们接着用D寄存器读入<code>baseAddr+index</code>对应的数据。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D=A+D</span><br></pre></td></tr></table></figure>
  但是，此时的<code>A</code>储存的已不是原先的<code>baseAddr</code>了，通过这种方式更新<code>D</code>的值是不行的。这时，我们可以考虑<strong>同时更新<code>A</code>与<code>D</code>的值</strong>，这样就可以利用未改变的<code>A</code>成功更新<code>A</code>与<code>D</code>:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@x</span><br><span class="line">D=A</span><br><span class="line">@LCL</span><br><span class="line">A=M //pointer</span><br><span class="line">AD=A+D</span><br></pre></td></tr></table></figure></p>
<p>  然后，我们需要<code>D=*addr</code>，由前面讲解的指针的表示，只需补上<code>D=M</code>语句即可。</p>
<p>  接下来就是较为简单的<code>*sp=D</code>操作了： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+1</span><br></pre></td></tr></table></figure></p>
<h3 id="2loop实现">2.<code>Loop</code>实现</h3>
<p>  对于<code>if-goto</code>语句，我们只需根据栈顶元素是否为<code>0</code>来判断是否需要跳转到所需分支。因为在栈中，我们用<code>0</code>表示<code>false</code>：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">M=M-1</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@LABEL</span><br><span class="line">D;JNE</span><br></pre></td></tr></table></figure></p>
<p>  而对于无条件的<code>goto</code>语句，利用<code>0,JMP</code>即可实现：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@LABEL</span><br><span class="line">0;JMP</span><br></pre></td></tr></table></figure></p>
<h3 id="3function实现">3.<code>function</code>实现</h3>
<p>  在<code>Hack</code>中，我们只需为<code>function</code>创建对应标签即可：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(LABEL)</span><br></pre></td></tr></table></figure></p>
<h3 id="4call实现">4.<code>Call</code>实现</h3>
<p>  我们按照<span class="math inline">\(8.6.\)</span>节所讲逐步实现<code>call</code>功能：</p>
<ol type="1">
<li><p>在栈中放入<code>returnAddress</code>的标签，这标志着我们在调用函数后将返回的地址：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@return_address1</span><br></pre></td></tr></table></figure>   该地址亦是栈指针的初始位置所在之处：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D=A</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
<li><p>然后，我们依次放入<code>LCL</code>, <code>ARG</code>,
<code>THIS</code>,
<code>THAT</code>，以保存调用者(caller)的内存段。</p></li>
</ol>
<p>  对于每一个内存段，我们像普通的<code>push</code>操作一样，将其放入栈指针所指位置，然后移动栈指针：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SP = memorySegment</span><br><span class="line">SP = SP + 1</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@LCL</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+1</span><br><span class="line"></span><br><span class="line">@SRG</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+1</span><br><span class="line"></span><br><span class="line">@THIS</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+1</span><br><span class="line"></span><br><span class="line">@THAT</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+1</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>接下来我们要重定向<code>ARG</code>的位置，我们需要把它定向至<code>ARG[0]</code>的位置，而该位置可以通过计算得出：</li>
</ol>
<p>  假设我们调用的函数为<code>call func x</code>，则在<code>ARG</code>内存段前有4(前四个内存段)+x(<code>LCL</code>需要的位置个数)，对应代码为：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@5+x</span><br><span class="line">D=A</span><br></pre></td></tr></table></figure></p>
<p>  然后我们需要将栈指针移到对应位置，并将<code>ARG</code>的初始位置设置在这里：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">AD=A-D</span><br><span class="line">@ARG</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p>
<ol start="4" type="1">
<li><p>为了能够正确访问<code>LCL</code>的位置，我们将<code>LCL</code>
<code>push</code>到栈指针所在位置： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">D=M</span><br><span class="line">@LCL</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
<li><p>然后，我们<code>goto</code>需要执行的函数以执行函数：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@func</span><br><span class="line">0;JMP</span><br></pre></td></tr></table></figure></p></li>
<li><p>最后我们插入<code>returnAddress</code>的标签，这样当函数被执行完，我们可以回到最初调用它的地方：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(return_address1)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="5return实现">5.<code>return</code>实现</h3>
<p>  我们按照<span class="math inline">\(8.6.\)</span>节所讲逐步实现<code>call</code>功能：</p>
<ol type="1">
<li><p>创建一个临时变量<code>frame</code>，并把<code>LCL</code>的值赋给它。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@LCL</span><br><span class="line">D=M</span><br><span class="line">@frame</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
<li><p>我们将<code>return</code>的值放在栈顶。由于有四个占据主内存的内存段，因此我们需要上移4+1=5个，<code>frame-5</code>即为<code>return</code>的地址：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@5</span><br><span class="line">A=D-A</span><br><span class="line">D=M</span><br><span class="line">@ret</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
</ol>
<blockquote>
<p>为什么此时不考虑每个内存段中的原有元素了呢？因为<strong>在<code>return</code>的过程中，我们需要覆盖所有的已有元素，这要求我们将这些元素当作不存在</strong>。而如果我们考虑这些元素并将<code>ret</code>上移，<strong>在之后的步骤中就无法覆盖一些原有的旧数据和清空调用函数的栈了</strong>。</p>
</blockquote>
<ol start="3" type="1">
<li><p>由于我们需要将待<code>return</code>的值复制到<code>ARG[0]</code>的位置，而该值就在栈顶，我们可以轻易地通过操纵栈指针读取该值：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">M=M-1</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@ARG</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
<li><p>调用者需要能够获取该值，因此栈指针应与<code>ARG</code>相邻：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ARG</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">M=D+1</span><br></pre></td></tr></table></figure></p></li>
<li><p>然后，我们就可以着手覆盖原有的内存段了。我们从先前设置的<code>frame</code>地址往下，依次设置新的内存段地址：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@frame</span><br><span class="line">M=M-1</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@THAT </span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line">@frame</span><br><span class="line">M=M-1</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@THIS </span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line">@frame</span><br><span class="line">M=M-1</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@ARG </span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line">@frame</span><br><span class="line">M=M-1</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@LCL </span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
<li><p>最后，我们回到最初设置的<code>ret</code>位置。由于<code>ret</code>并非标签，要跳转到其地址，我们需要指针操作：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ret</span><br><span class="line">A=M</span><br><span class="line">0;JMP</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="6initial实现">6.<code>Initial</code>实现</h3>
<p>  当我们需要翻译的VM代码是有效的时，我们就需要对我们的硬件系统进行初始化：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@256</span><br><span class="line">D=A</span><br><span class="line">@SP</span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line">call Sys.init// same as other call statements before.</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.11.Hack平台上的VM实现</title>
    <url>/2024/04/11/7-11-Hack%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84VM%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="711vm-implementation-on-the-hackplatform"><span class="math inline">\(7.11.\)</span>VM Implementation on the Hack
Platform</h1>
<h3 id="1program-compilation-andtranslation">1.Program compilation and
translation</h3>
<p><img src="/2024/04/11/7-11-Hack%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84VM%E5%AE%9E%E7%8E%B0/image.png"></p>
<ul>
<li>When we translate from Jack to VM, we lost <em>the notion of
constructors, methods</em>, because everything becomes functions.</li>
<li>When we translate from VM to assembly, we lost <em>the notion of
functions</em>, because we just have a long stream of assembly
commands.</li>
</ul>
<h3 id="2vm-convention">2.VM convention</h3>
<p>  In order to tranlate the VM code into assembly code, we need to
comply to certain conventions:</p>
<ol type="1">
<li><p><em>VM programming convention</em>: One file in any VM program is
expected to be named <code>Main.vm</code>; one VM function in this file
is expected to be named <code>main</code>.</p></li>
<li><p><em>VM implementation convention</em>: When the VM implementation
starts running, or is reset, it starts executing the argument-less OS
function <code>Sys.init</code>.<code>Sys.init</code> then calls
<code>Main.main</code>, and enters an infinite loop.</p></li>
<li><p><em>Hardware platform convention</em>:</p>
<ul>
<li>We request that the code you see here <strong>will be stored in the
target computer's instruction memory beginning in address
<code>0</code></strong>, for our Hack computer is programmed to start
executing the program beginning with address <code>0</code>.</li>
<li>So we first set <code>SP = 256</code>. By doing this, it will
determined that the stack should begin in this address in the whole
stream.</li>
<li>Then we <code>call Sys.init</code>.</li>
</ul></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SP = 256</span><br><span class="line">Call Sys.init</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.10.函数运行实现</title>
    <url>/2024/04/11/7-10-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="710function-call-and-returnimplementation"><span class="math inline">\(7.10.\)</span>Function Call and Return
Implementation</h1>
<h3 id="1the-callers-view">1.The caller's view</h3>
<p>  In the calling function's view:</p>
<ul>
<li>Before calling another function, I must <strong>push as many
arguments as the function expects to get</strong>;</li>
<li>Next, I invoke the function using
<code>call functionName nArgs</code>;</li>
<li>After the called function returns, the argument values that I pushed
before the call have disappeared from the stack, and <strong>a return
value (that always exists) appears at the top of the
stack</strong>;</li>
<li>After the called function returns, <strong>all my memory segments
are exactly the same as they were before the call</strong> (except that
temp is undefined and some values of my static segment may have
changed).</li>
</ul>
<h3 id="2the-callees-view">2.The callee's view</h3>
<p>  In the called function's view:</p>
<ul>
<li>Before I start executing, <strong>my<code>argument</code> segment
has been initialized with the argument values passed by the
caller</strong>.</li>
<li>My <strong><code>local</code> variables segment has been allocated
and initialized to zeros</strong>.</li>
<li>My <code>static</code> segment has been set to <strong>the
<code>static</code> segment of the VM file to which I belong</strong>
(memory segments <code>this</code>, <code>that</code>,
<code>pointer</code>, and <code>temp</code> are undefined upon
entry).</li>
<li>My working stack is empty.</li>
<li>Before returning, I must <strong>push a value onto the
stack</strong>.</li>
</ul>
<h3 id="3handling-call">3.Handling <code>call</code></h3>
<p>  We can implement the VM code by these steps:</p>
<p><img src="/2024/04/11/7-10-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E5%AE%9E%E7%8E%B0/image.png"></p>
<p>  In terms of <code>call</code>, we do these steps:</p>
<ol type="1">
<li><p>Push a label onto the stack, and use the same label when we are
going to return after the called function terminates.
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push returnAddress</span><br></pre></td></tr></table></figure></p></li>
<li><p>Push some label that we generate to <strong>save the memory
segment of the caller</strong>: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push LCL</span><br><span class="line">push ARG</span><br><span class="line">push THIS</span><br><span class="line">push THAT</span><br></pre></td></tr></table></figure></p></li>
<li><p>The <code>argument</code> should <strong>be repositioned for the
called function</strong>, and we should reposition it at the beginning
of the <code>ARG</code> segment:</p>
<ul>
<li>We can calculate the address, because we know how many values we
pushed. Say we push 5 values the we do : <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARG = SP - 5</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Push the <code>local</code> segment to insure that the function
can visit its local variables correctly : <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LCL = SP</span><br></pre></td></tr></table></figure></p></li>
<li><p>We execute the called function by simply writing the command
<code>goto nameOfFunction</code>: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goto functionName</span><br></pre></td></tr></table></figure></p></li>
<li><p>We insert the <code>returnAddress</code> label, so that when the
function has been executed, we can get back to the place we invoke it :
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(returnAddress) //Declares a label for the return-address</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><img src="/2024/04/11/7-10-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E5%AE%9E%E7%8E%B0/image-1.png"></p>
<h3 id="4handling-function">4.Handling <code>function</code></h3>
<p>  The big picture of handling <code>function</code> is that:</p>
<ul>
<li>The first thing translator does is <strong>it takes the function
name and generates a label</strong>, and the label will serve as
<strong>the entry point to the translated assembly code of the
function</strong>.</li>
<li>We simply write some assembly code that <strong>handles the setting
up of the function's execution</strong>.</li>
</ul>
<ol type="1">
<li>We take the function name and generate its label:</li>
<li>Since we know how many local variables we have to create, we do
<code>push 0</code> <code>nVars</code> times. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(functionName)</span><br><span class="line">	//repeat nVars times</span><br><span class="line">	push 0</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4handling-return">4.Handling <code>return</code></h3>
<p>  After setting up, the function can start doing its thing. We need
to generate assembly code that <strong>moves the return value to the
caller, reinstates the caller's state, and finally <code>goto</code> the
return address</strong>.</p>
<ol type="1">
<li>Create some temporary variable (called <code>endFrame</code>) and
assign the value of <code>LCL</code> to it: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">endFrame = LCL</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  If you look at the stack diagram, you will see that
<code>endFrame</code> indeed <strong>points at the end of the frame in
the host RAM</strong>.</p>
<p><img src="/2024/04/11/7-10-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E5%AE%9E%E7%8E%B0/image-2.png"></p>
<ol start="2" type="1">
<li><p>Since we should put the return value at the top of the stack, say
we have 5 values, the <code>endFrame - 5</code> will be the exact return
address.</p>
<ul>
<li>We need to use <code>*</code> to look inside and get the address.
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">retaddr = *(endFrame - 5)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Reposition the return value for the caller.</p>
<ul>
<li>The value should be copied to <code>argument 0</code>, and we
already have a pointer <code>ARG</code> located in the position</li>
<li><code>pop</code> is going to retrieve the return value off the
stack. We take this value and put it in <code>ARG</code>.
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*ARG = pop()</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>The caller expects to see a return value and continue to do its
work, so the stack pointer should <strong>be just after
<code>ARG</code></strong>.<br>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SP = ARG + 1</span><br></pre></td></tr></table></figure></p></li>
<li><p>Then we can begin to recover the various segments that we saved
on the stack before. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">THAT = *(endFrame - 1)</span><br><span class="line">THIS = *(endFrame - 2)</span><br><span class="line">ARG = *(endFrame - 3)</span><br><span class="line">LCL = *(endFrame - 4)</span><br></pre></td></tr></table></figure></p></li>
<li><p>Finally we can jump to the return address we copied before:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goto retAddr</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><img src="/2024/04/11/7-10-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E5%AE%9E%E7%8E%B0/image-3.png"></p>
<ul>
<li>Every thing below <code>SP</code> is recycled. <strong>The next push
is going to override the memory location where <code>SP</code>
shows</strong>.</li>
<li>The caller will see the return value at the top of its working
stack.</li>
<li>The stack pointer will point at the next world in the memory.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.9.函数运行模拟</title>
    <url>/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1 id="79run-time-simulation"><span class="math inline">\(7.9.\)</span>Run-time Simulation</h1>
<h3 id="1run-time-example">1.Run-time example</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	return factorial(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int factorial(int n) &#123;</span><br><span class="line">	if (n == 1) return 1;</span><br><span class="line">	else return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>When compiling the <code>main</code> part, we:</p>
<ul>
<li><code>push 3</code></li>
<li><code>call factorial</code></li>
<li><code>return</code></li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function main</span><br><span class="line">	push 3</span><br><span class="line">	call factorial</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Then we start to compile the function:</p>
<ul>
<li>We declare the function.</li>
<li>We evaluate the condition <code>n==1</code></li>
<li>If the conitional statement returns false, we <code>push n</code>,
and compute <code>factorial(n - 1)</code></li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function factorial(n) </span><br><span class="line">	push n</span><br><span class="line">	push 1</span><br><span class="line">	eq </span><br><span class="line">	if-goto BASECASE</span><br><span class="line">	</span><br><span class="line">	push n</span><br><span class="line">	push n</span><br><span class="line">	pusn 1</span><br><span class="line">	sub</span><br><span class="line">	call factorial</span><br><span class="line">	call mult</span><br><span class="line">	return</span><br><span class="line"></span><br><span class="line">label BASECASE</span><br><span class="line">	push 1</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>
<p>  The pseudo VM code can be translated into these VM codes:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function main 0</span><br><span class="line">	push constant 3</span><br><span class="line">	call factorial 1</span><br><span class="line">	return</span><br><span class="line"></span><br><span class="line">function factorial 0</span><br><span class="line">	push argument 0</span><br><span class="line">	push constant 1</span><br><span class="line">	eq</span><br><span class="line">	if-goto BASECASE</span><br><span class="line"></span><br><span class="line">	push argument 0</span><br><span class="line">	push argument 0</span><br><span class="line">	push constant 1</span><br><span class="line">	sub</span><br><span class="line">	call factorial 1</span><br><span class="line">	call mult 2</span><br><span class="line">	return </span><br><span class="line"></span><br><span class="line">label BASECASE</span><br><span class="line">	push constant 1</span><br><span class="line">	return</span><br></pre></td></tr></table></figure></p>
<p>  Then what happen during the runtime?</p>
<ol type="1">
<li><code>main</code> starts running, and informs that it has 0 local
variable.</li>
<li><code>main</code> pushes, so it starts with an empty stack.</li>
<li><code>push constant 3</code>, then we get a 3 on the stack.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image.png"></p>
<ol start="4" type="1">
<li><code>call factorial 1</code>, the 1 informs that 1 argument was
pushed onto the stack. So we can <strong>refer to the topmost value in
the stack as argument 0</strong>.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-1.png"></p>
<h3 id="2callee-process">2.Callee process</h3>
<p>  Then we begin to deal with the <code>call</code> command.</p>
<ol type="1">
<li>We first <strong>save the frame of <code>main</code> onto the
stack</strong>. Then we jump to execute <code>factorial</code>.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-2.png"></p>
<ul>
<li>The blue dot shows the <em>return address</em> in the given code.
And this is exactly where we want to return to after
<code>factorial</code> finishes.</li>
</ul>
<ol start="2" type="1">
<li>The <code>eq</code> consumes <code>argument 0</code> and
<code>constant 1</code>, so <strong>the overall effect of the first 4
commands on the stack is <code>nil</code></strong>.</li>
<li>We <code>push argument 0</code>, <code>push argument 0</code>,
<code>push constant 1</code>, <code>sub</code>, so we are going to get 3
and 2 on the stack.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-3.png"></p>
<ol start="4" type="1">
<li><code>call factorial 1</code>, we <strong>inform the implementation
that 1 argument has been pushed onto the stack</strong>, we can refer to
it as <code>argument 0</code>.</li>
<li>We want to issue a <code>call</code> command, so the implementation
is going to <strong>save the frame of the current function</strong>, and
the return address is the green dot, we save it, too.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-4.png"></p>
<ol start="6" type="1">
<li>After several calls, we turn to <code>f(1)</code>, and the global
stack now looks like this:</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-5.png"></p>
<ol start="7" type="1">
<li>This time 1 equals 1, we jump to <code>BASECASE</code>,
<code>push constant 1</code> and do a <code>return</code>.</li>
</ol>
<p>  When the inplementation encounters the <code>return</code> command,
it:</p>
<ol type="1">
<li>Gets the return address off the stack.</li>
<li>Copy the return value. In this case, it's <code>argument 0</code>,
so we copy 1 on <code>arg0</code>.</li>
<li>After <code>return</code>, we can recycle the current frame, which
is no more relevant.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-6.png"></p>
<p>  And we do this step again and again:</p>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-7.png"></p>
<p>  During the process, the caller is completely oblivious of all the
drama, it takes part behind the scene.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.8.函数实现前瞻</title>
    <url>/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/</url>
    <content><![CDATA[<h1 id="78function-impletation-preview"><span class="math inline">\(7.8.\)</span>Function Impletation Preview</h1>
<h3 id="1program-execution">1.Program execution</h3>
<ul>
<li><p>When a function enters its execution, we need to create a
<em>state</em> for this function.</p>
<ul>
<li>Give it an <em>empty working stack</em>, its <em>memory
segment</em>.</li>
</ul></li>
<li><p>The working stack and some of the segments should be:</p>
<ul>
<li>Created <strong>when the function starts running</strong>.</li>
<li><strong>Maintained as long as the function is
executing</strong>.</li>
<li><strong>Recycled</strong> when the function retums.</li>
</ul></li>
<li><p>When we call a function, we will have two states: the state of
<em>caller</em> and the state of <em>callee</em>. Once the callee starts
running, <strong>the state of the caller has to be saved
somewhere</strong>. And when the callee terminates, we can
<strong>reinstate the caller state and continue its
execution</strong>.</p></li>
</ul>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image.png"></p>
<h3 id="2function-call-and-return">2.Function call and return</h3>
<p>  However, a <em>calling chain</em> may be several functions deep,
and how can we maintain all the states of these functions?</p>
<p>  To deal with this, we can use the <em>FILO</em> (first in last out)
pattern. The only function to be return is the function which is
currently running, and which is also <strong>the end of the calling
chain</strong>. Once this function returns, the calling chain shortens,
so on and so forth.</p>
<p>  This pattern is similiar to <em>stack</em>, this implies that we
may use a stack in order to save and retrieve all these function
states.</p>
<p>  Take this simple function as example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mult(17, 212)</span><br></pre></td></tr></table></figure>
<p>  In the view of the caller, the effect of the procedure is that
<strong>the function's arguements has been replaced with the function
value</strong>:</p>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image-1.png"></p>
<p> And the details are as follows:</p>
<ul>
<li><p>We push some values in the stack, and nothing happens. And then
we <code>call foo nArgs</code>.</p></li>
<li><p>By the information <code>nArgs</code>, we know where to
<strong>set <code>arg</code> pointer</strong>.</p>
<ul>
<li>From now on, we know what's above the <code>arg</code> is
<strong>the working stack of the caller</strong>, and what's below the
<code>arg</code> are <strong>the arguments to be use by
callee</strong>.</li>
</ul></li>
<li><p>Before we jump to the called function, we have to save the state
of the caller:</p>
<ul>
<li>The working stack is safe, it is already on the stack, so we can
leave it alone.</li>
<li>We have to save the <em>segment</em> and the <em>return
address</em>. Taken together, we call these thing <em>frame</em>.</li>
<li>The VM implementation simply <strong>push these memory segments into
stack</strong>. In this way we save the frame, and will be able to
return to them later on.</li>
</ul></li>
</ul>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image-2.png"></p>
<ul>
<li>Jump to <strong>execute foo</strong>.</li>
</ul>
<p>  After the called function is entered, it:</p>
<ul>
<li><p>Create a <em>local segment</em>.</p></li>
<li><p>Having known that we need n variables, we need to
<strong>initialize them to 0</strong></p>
<ul>
<li>From now on, we can refer to these values as <code>local 0</code>,
<code>local 1</code> and so on.</li>
</ul></li>
</ul>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image-3.png"></p>
<p>  Assume that the called function is running and doing its things, in
this process, it:</p>
<ul>
<li>Grow its working stack, and it now has a working stack of its
own.</li>
</ul>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image-4.png"></p>
<ul>
<li><p>When it is goint to <code>return</code> at some point, we push
the return value <strong>at the bottom of the stack</strong>.</p></li>
<li><p>We pop the topmost value, and <strong>copy it onto
<code>argument 0</code></strong> to replace the pushed arguments with
return value.</p></li>
<li><p>We <strong>restore the segment pointers of the callers</strong>,
take the saved <em>memory segments</em> to the <em>current
segments</em>.</p></li>
<li><p>Then we <strong>clear the stack of the called function</strong>,
and <strong>set the stack pointer for the caller</strong>.</p>
<ul>
<li>The stack pointer should be located after
<code>argument 0</code>.</li>
</ul></li>
<li><p>Finally, we <strong>jump to the return address</strong> in the
caller, and continue executing the caller's code.</p></li>
</ul>
<h3 id="3global-stack">3.Global stack</h3>
<p>  Our previous discussion is only about the caller and callee, but
there are many other pairs of callers and callees in the calling chain,
and we have to maintain their states, too.</p>
<p>  As a result, we get a very large stack called <em>global stack</em>
containing the information of the entire program.</p>
<ul>
<li><p>We refer to some subset of the global stack <em>block</em>. It's
the world of the currently running function, and it contains:</p>
<ul>
<li><em>argument segment</em>. These are the function's arguments.</li>
<li><em>saved information that belongs to caller</em>.</li>
<li><em>local segment</em></li>
<li><em>working stack of its own</em></li>
</ul></li>
</ul>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image-5.png"></p>
<ul>
<li>The global stack contains many more such blocks.</li>
</ul>
<p>  And there are some more observations we can make:</p>
<ul>
<li>We only have to save <code>local</code>, <code>argument</code>,
<code>this</code> and <code>that</code> segments, for the other four
parts don't belong to the world of the function.</li>
<li>We use the stack not only when executing the program, but also
executing all the behind-scene apparatus that is required to service the
program. Everything is saved on the same stack.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.7.函数抽象</title>
    <url>/2024/04/10/7-7-%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="77function-abstraction"><span class="math inline">\(7.7.\)</span>Function: Abstraction</h1>
<h3 id="1function-in-vm-language">1.Function in VM language</h3>
<ul>
<li><p>The VM language features:</p>
<ul>
<li><em>primitive operation</em>(fixed): <code>add</code>,
<code>sub</code></li>
<li><em>abstract operation</em>(extensible): <code>mutiple</code></li>
</ul></li>
</ul>
<p>  When we want to call a function, we:</p>
<ul>
<li>push the required argument onto the stack.</li>
<li>call the function. Then <strong>the result of function will replace
the argument you push earlier</strong>.</li>
</ul>
<p>  Take this simple funtion call <code>sqrt(x-17+x*5)</code> as
example, it can be translated into: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push x</span><br><span class="line">push 17</span><br><span class="line">sub</span><br><span class="line">push x </span><br><span class="line">push 5</span><br><span class="line">call Math.multiply</span><br><span class="line">add </span><br><span class="line">call Math.sqrt</span><br></pre></td></tr></table></figure></p>
<h3 id="2function-definition">2.Function definition</h3>
<p>  Take the previous function as example: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// returns x&quot;y</span><br><span class="line">int mult(int x, int y) &#123;</span><br><span class="line">	int sum = 0;</span><br><span class="line">	int n = 1;</span><br><span class="line">	while !(n&gt;y) &#123;</span><br><span class="line">		sum += x;</span><br><span class="line">		x ++;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  As is discussed before, it's pseudo VM code is as below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mult(x,y)</span><br><span class="line">	push 0</span><br><span class="line">	pop sum</span><br><span class="line">	push 1</span><br><span class="line">	pop n</span><br><span class="line">label LOOP</span><br><span class="line">	push n</span><br><span class="line">	push y</span><br><span class="line">	gt</span><br><span class="line">	if-goto ENDLOOP</span><br><span class="line">	push sum</span><br><span class="line">	push x</span><br><span class="line">	add</span><br><span class="line">	pop sum</span><br><span class="line">	push n</span><br><span class="line">	push 1</span><br><span class="line">	add</span><br><span class="line">	pop n</span><br><span class="line">	goto LOOP</span><br><span class="line">label ENDLOOP</span><br><span class="line">	push sum</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>
<p>  In fact, it can be translated into this VM code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mult 2</span><br><span class="line">	push constant 0 //sum = 0</span><br><span class="line">	pop local 0</span><br><span class="line">	push constant 1 //n = 1</span><br><span class="line">	pop local 1</span><br><span class="line">label LOOP</span><br><span class="line">	push local 1 //if clause</span><br><span class="line">	push argument 1</span><br><span class="line">	gt</span><br><span class="line">	if-goto ENDLOOP</span><br><span class="line">	push local 0 // sum += x</span><br><span class="line">	push argument 0</span><br><span class="line">	add</span><br><span class="line">	pop local 0</span><br><span class="line">	pop local 1 // n ++</span><br><span class="line">	push constant 1</span><br><span class="line">	add</span><br><span class="line">	pop local 1</span><br><span class="line">	goto LOOP</span><br><span class="line">label ENDLOOP</span><br><span class="line">	push local 0 // return sum</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>
<p>  Let's discuss the implementation in detail:</p>
<ol type="1">
<li><p><em>Function declaration</em>:</p>
<ul>
<li><code>Function</code>: function declaration.</li>
<li><code>mult</code>: the name of the function.</li>
<li><code>2</code>: use 2 <em>local variables</em> in the function.</li>
</ul></li>
<li><p><em>Function body</em>:</p>
<ul>
<li>branching.</li>
<li>the variable declared within the body should be stored in
<code>local</code>.</li>
<li>the assignment of variables can be done through
<code>push constant</code> and <code>pop local</code>.</li>
</ul></li>
<li><p><em>Return value</em></p>
<ul>
<li><code>push</code> the to-return value in the stack.</li>
<li><code>return</code> statement at the end of program.</li>
</ul></li>
</ol>
<h3 id="3function-execution">3.Function execution</h3>
<p>  We can execute a function in a <code>Main</code> function:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function main 0</span><br><span class="line">	push constant 3</span><br><span class="line">	push constant 5</span><br><span class="line">	push constant 8</span><br><span class="line">	call mult 2</span><br><span class="line">	add </span><br><span class="line">	return </span><br></pre></td></tr></table></figure></p>
<ul>
<li>the <code>2</code> next to <code>mult</code> indicates that
<strong>the funtion takes in 2 arguments</strong>.</li>
<li>the whole process can be described through these diagrams:</li>
</ul>
<p><img src="/2024/04/10/7-7-%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1/image.png"></p>
<p><img src="/2024/04/10/7-7-%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1/image-1.png"></p>
<p><img src="/2024/04/10/7-7-%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1/image-2.png"></p>
<p>  for each function <code>call</code> during run-time, the
implementation of the <code>call</code> command should :</p>
<ul>
<li><p><strong>Pass parameters</strong> from the calling function to the
called function;</p></li>
<li><p><strong>Determine the return address</strong> within the caller's
code;</p></li>
<li><p><strong>Save the caller's return address, stack and memory
segments</strong>;</p>
<ul>
<li>so that when we return to the <code>main</code>, we will be able to
<strong>recreate the private world of <code>main</code></strong>.</li>
</ul></li>
<li><p>Jump to <strong>execute the called fiunction</strong>:</p></li>
</ul>
<p>  And for each function <code>return</code> during run-time, the
impletation has to:</p>
<ul>
<li><p>Return to the caller <em>the value computed by the called
function</em>;</p>
<ul>
<li>The implementation knows that the topmost value on the stack must be
the return value, so it returns the value.</li>
</ul></li>
<li><p><strong>Recycle the memory resources</strong> used by the called
funetion;</p></li>
<li><p><strong>Reinstate the caller's stack and memory
segments</strong>;</p></li>
<li><p>Jump to the <strong>return address in the caller's
code</strong>.</p></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.6.分支</title>
    <url>/2024/04/10/7-7-%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<h1 id="76branching"><span class="math inline">\(7.6.\)</span>Branching</h1>
<h3 id="1branching-implementation">1.Branching implementation</h3>
<p>  Take the following program as example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//return x * y</span><br><span class="line">int mult (int x, int y) &#123;</span><br><span class="line">	int sum = 0;</span><br><span class="line">	int n = 1;</span><br><span class="line"></span><br><span class="line">	while !(n&gt;y) &#123;</span><br><span class="line">		sum += x;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  This program can be translated into pseudo VM code as below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mult(x,y)</span><br><span class="line">	push 0</span><br><span class="line">	pop sum</span><br><span class="line">	push 1</span><br><span class="line">	pop n</span><br><span class="line">label LOOP</span><br><span class="line">	push n</span><br><span class="line">	push y</span><br><span class="line">	gt</span><br><span class="line">	if-goto ENDLOOP</span><br><span class="line">	push sum</span><br><span class="line">	push x</span><br><span class="line">	add</span><br><span class="line">	pop sum</span><br><span class="line">	push n</span><br><span class="line">	push 1</span><br><span class="line">	add</span><br><span class="line">	pop n</span><br><span class="line">	goto LOOP</span><br><span class="line">label ENDLOOP</span><br><span class="line">	push sum</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>
<p>  Notice that we have three new symbols: <code>label</code>,
<code>if-goto</code>, <code>goto</code>:</p>
<ul>
<li><code>label LABEL</code> declare the label.</li>
<li><code>if-goto LABEL</code>: if the statement is true, then jump to
<code>LABEL</code>.</li>
<li><code>goto LABEL</code>: jump to <code>LABEL</code> with no
condition.</li>
</ul>
<p>  With these three statement, we can translate the branching
expression into VM code.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.5.内存段的实现</title>
    <url>/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="75memory-segment-implementation"><span class="math inline">\(7.5.\)</span>Memory Segment implementation</h1>
<h3 id="1local-implementation">1.<code>local</code> implementation</h3>
<p>  The <code>local</code> segment can be placed <strong>anywhere we
want in the host RAM</strong>, for we just need to <strong>remember the
base address of the block</strong>.</p>
<ul>
<li>We place the <strong>base address of the <code>local</code>
segment</strong> in a pointer called <em>LCL</em>.</li>
<li><em>LCL</em> will refer to <code>RAM 1</code>.</li>
</ul>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image.png"></p>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-1.png"></p>
<p>  Then we can <code>push</code> or <code>pop</code> a value easily.
Say we want to accomplish <code>pop local 2</code>:</p>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-2.png"></p>
<p>  We can do this by putting the stack-top value into
<code>RAM[1015]</code>.</p>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-3.png"></p>
<ul>
<li>How do we know which <code>RAM</code> to add to? We get it by
<code>base addr + index</code></li>
</ul>
<p>  This process can be translated into this VM code: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//get the place to be added</span><br><span class="line">addr = addr + index</span><br><span class="line">//get the value, and put it into correct place</span><br><span class="line">sp--</span><br><span class="line">*addr = *sp</span><br><span class="line">// D = *sp, *addr = D</span><br></pre></td></tr></table></figure></p>
<p>  Notice that 5 is still in <code>RAM[257]</code>, it hasn't been
removed. It's common to have these wasted data in the stack, and it's
not big deal, for <strong>the pointer indicates exactly which part of
the stack are in play, not the data</strong>.</p>
<h3 id="2argumentthisthatimplementation">2.<code>argument,this,that</code>
implementation</h3>
<ul>
<li><p>When translating the high-level code of some method into VM
code:</p>
<ul>
<li>Maps the method's local and argument variables onto the
<code>local</code> and <code>argument</code> segments</li>
<li>Maps the object fields and the array entries that the method is
currently processing onto the <code>this</code> and <code>that</code>
segments</li>
</ul></li>
</ul>
<p>  The process of <code>argument</code>, <code>this</code> and
<code>that</code> is nearly the same as <code>local</code>:</p>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-4.png"></p>
<p>  The process can be translated into this VM code: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//push</span><br><span class="line">addr = segmentPointer + index</span><br><span class="line">*sp = *addr</span><br><span class="line">sp++</span><br><span class="line"></span><br><span class="line">//pop</span><br><span class="line">addr = segmentPointer + index</span><br><span class="line">sp--</span><br><span class="line">*addr = *sp</span><br></pre></td></tr></table></figure></p>
<h3 id="3constant">3.<code>Constant</code></h3>
<ul>
<li><p>When the compiler translates the high-level code of some method
into VM,</p>
<ul>
<li>it translates high-level operations involving constant into VM
operations involving the constant segment.</li>
</ul></li>
<li><p>When we implement <code>constant</code>, we simply <strong>supply
the specified constant</strong>.</p></li>
<li><p>Since we won't store things where a <code>constant</code>
resides, there's no <code>pop</code> in <code>constant</code>.</p></li>
<li><p>The <code>constant</code> segment is a <strong>truly virtual
segment</strong>. So whenever we see a <code>push constant i</code>
command, we simply supply the specified constant
<code>i</code>.</p></li>
</ul>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-5.png"></p>
<h3 id="4static">4.<code>Static</code></h3>
<ul>
<li><p>When translating the high-level code of some method into VM code,
the compiler:</p>
<ul>
<li>Maps the static variables that the method sees onto the
<code>static</code> segment.</li>
</ul></li>
<li><p>The <code>static</code> variables should <strong>be seen by all
the methods in a program</strong>.   To complement this, we store the
variables in a <em>"global space"</em>:</p></li>
<li><p>Have the VM translator translate each VM reference
<code>static i</code>(in file <code>Foo.vm</code>)into an <em>assembly
reference</em> <code>Foo.i</code>.</p>
<ul>
<li><code>Foo</code> is the name of the file, and <code>i</code> is the
index of VM command.</li>
</ul></li>
<li><p>Following assembly, the Hack assembler will map these references
onto <code>RAM[16]</code>,<code>RAM[17]</code>,<code>RAM[18]</code>,
...</p></li>
</ul>
<p>  For example, the statement <code>pop static 5</code> can be
translated into: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Foo.5</span><br><span class="line">M = D</span><br><span class="line">//the register stores this data</span><br><span class="line"></span><br><span class="line">@Foo.2</span><br><span class="line">M = D</span><br></pre></td></tr></table></figure> * The entries of <code>static</code>
segment will end up being mapped onto <code>RAM[16]</code>,
<code>RAM[17]</code>, ... , in the order <strong>in which they appear in
the program</strong> (not their names!!!).</p>
<figure>
<img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-6.png" alt="Alt text">
<figcaption aria-hidden="true">Alt text</figcaption>
</figure>
<blockquote>
<p>Static variables are stored <strong>in a section of memory called the
static data segment</strong>, which is allocated when the program is
loaded and has fixed memory addresses. When we want to retrieve the
value of a static variable, we need to read the value stored <strong>at
the memory location</strong> where the static variable is stored, rather
than directly accessing the value of the static variable itself. This is
why we need to use <code>D=M</code> instead of <code>D=A</code> to get a
<code>static</code> value.</p>
</blockquote>
<h3 id="5temp">5.<code>Temp</code></h3>
<p>  When the compiler translates the Jack program into VM code, it
sometimes has to use temporary variables.</p>
<ul>
<li>We let the 8 place segment called <code>temp</code> to contain and
serve these variables when needed.</li>
<li><code>temp</code> is going to be a <strong>fixed 8-place memory
segment</strong>.</li>
<li>The variables will be mapped on <code>RAM</code> locations 5 to
12.</li>
</ul>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-7.png"></p>
<h3 id="6pointer">6.Pointer</h3>
<ul>
<li><p>When translating a high-level method code into VM code,the
compiler:</p>
<ul>
<li>Has to remember the base addresses of <code>this</code>, which
represents <em>the current object</em>, and <code>that</code>, which
represents <em>the current array of method be processing</em>.</li>
<li>Generates code that <strong>keeps track of the base addresses of the
this and that segments</strong> using the pointer segment.</li>
</ul></li>
<li><p><code>pointer</code> is a fixed memory segment. It has only two
entries, <code>0</code> and <code>1</code>.</p>
<ul>
<li>So we can only <code>push</code> and <code>pop</code> <code>0</code>
and <code>1</code></li>
</ul></li>
<li><p>Accessing <code>pointer 0</code> should result in
<strong>accessing <code>THIS</code></strong>.</p></li>
<li><p>Accessing <code>pointer 1</code> should result in
<strong>accessing <code>THAT</code></strong>.</p></li>
</ul>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-8.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.4.堆栈结构实现</title>
    <url>/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="74implementation-of-stack"><span class="math inline">\(7.4.\)</span>Implementation of Stack</h1>
<h3 id="1pointer-manipulation">1.Pointer manipulation</h3>
<p>  We first introduce <em>pointer notation</em>: <code>*p</code>
represents <strong>the value stores in the address that <code>p</code>
points to</strong>.</p>
<p><img src="/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/image.png"></p>
<p>  In <em>Hack</em>, the pointer statement:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D = *p // D becomes 23</span><br></pre></td></tr></table></figure>
<p>  can be translated into:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@p</span><br><span class="line">A = M</span><br><span class="line">D = M</span><br></pre></td></tr></table></figure>
<ul>
<li><code>A = M</code> points the pointer to the address of register
M.</li>
<li><code>D = M</code> gets the value of the RAM.</li>
</ul>
<p>  The calculation of pointer, such as:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p--</span><br><span class="line">D = *p</span><br></pre></td></tr></table></figure>
<p>  When <code>p--</code>, <code>*p</code> refers to
<code>RAM[256]</code>. After than when we invoke <code>D = *p</code>, it
will get the value stored in <code>RAM[256]</code>, namely 19.</p>
<p>  When we assign a number to pointer, such as: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*q = 9</span><br><span class="line">q++</span><br></pre></td></tr></table></figure></p>
<p>  The <code>*q</code> refers to <code>RAM[1024]</code>, which stores
value 5. After the assignment, <code>RAM[1024]</code>stores 9
instead.</p>
<h3 id="2stack-machine-operation">2.Stack machine operation</h3>
<p>  Before implementation, we make two assumption:</p>
<ol type="1">
<li>The stack pointer will be stored in <code>RAM[0]</code>.</li>
<li>Stack base address will be <code>addr = 256</code>.</li>
</ol>
<p>  Let's <code>push</code> two value first:</p>
<p><img src="/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/image-1.png"></p>
<p>  After the <code>push</code>, the stack pointer will point to 258,
and our RAM looks like this:</p>
<p><img src="/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/image-2.png"></p>
<p>  And we push <code>12 + 5</code> into the stack, then 17 will be in
the previous available space, and stack pointer moves forward:</p>
<p><img src="/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/image-3.png"></p>
<p>  So we can write the VM code: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//push x</span><br><span class="line">*sp = x</span><br><span class="line">sp++</span><br></pre></td></tr></table></figure></p>
<p>  This can be translated into this Hack assembly: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//push x</span><br><span class="line">@x</span><br><span class="line">D = A // D = x</span><br><span class="line">@SP</span><br><span class="line">A = M // *sp = D</span><br><span class="line">M = D</span><br><span class="line">@SP //increase the location</span><br><span class="line">M = M + 1</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>  In this program, the A register plays two roles:   <em>Data
register</em> which stores x   <em>Address register</em> as usual</p>
</blockquote>
<h3 id="3vm-translator-perspective">3.VM translator perspective</h3>
<p><img src="/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/image-4.png"></p>
<ul>
<li><p>VM translator is:</p>
<ul>
<li>A program that translates VM code into machine language.</li>
<li>Each VM command generates several assembly commands.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.2.VM结构</title>
    <url>/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="72vm-abstractionthe-stack"><span class="math inline">\(7.2.\)</span>VM Abstraction——the Stack</h1>
<h3 id="1-the-stack-machine">1. The stack machine</h3>
<ul>
<li>The stack machine is an <em>abstraction</em> that consists of
<strong>an architecture, a stack and a set of operation which we can
apply to the architecture</strong>.</li>
</ul>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image.png"></p>
<ul>
<li>It can be considered an <em>array</em> which offers direct access to
every element in the memory, as oppose to the traditional stack which
only offers a stack pointer.</li>
<li>When we do <code>push x</code>, <strong>the address of
<code>x</code></strong> will be push into the stack:</li>
</ul>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-1.png"></p>
<ul>
<li><p>When we do <code>pop y</code>:</p>
<ul>
<li>the <strong>current top value in the stack</strong> will be
removed,</li>
<li>the <strong>popped value</strong> will override <code>y</code> (in
this example, when 7 is popped, 3 becomes the new top value).</li>
</ul></li>
</ul>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-2.png"></p>
<h3 id="2stack-arithmetic">2.Stack arithmetic</h3>
<p>  If we want to apply a certain function on the stack, we have to do
three different things:</p>
<ol type="1">
<li>Pop as many required operands in the stack as possible.</li>
<li>Apply the function to these operands in a separate process and get
the result.</li>
<li>Push the result back into the stack.</li>
</ol>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-3.png"></p>
<p>  The obstruction supports all these operations inherently, all we
have to do it to call <code>add</code> or <code>neg</code>, and these
things will take place.</p>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-4.png"></p>
<h3 id="3vm-commands">3.VM commands</h3>
<ul>
<li>Arithmetic commands:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// d = (2 - x) + (y + 9)</span><br><span class="line">push 2</span><br><span class="line">push x</span><br><span class="line">sub</span><br><span class="line">push y</span><br><span class="line">push 9</span><br><span class="line">add</span><br><span class="line">add </span><br><span class="line">pop d</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-5.png"></p>
<ul>
<li>Logic commands: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// (x &lt; 7) or (y == 8)</span><br><span class="line">push x </span><br><span class="line">push 7</span><br><span class="line">lt</span><br><span class="line">push y</span><br><span class="line">push 8</span><br><span class="line">eq </span><br><span class="line">or</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-6.png"></p>
<p>  Where do these commands come from? It's compiled from the
high-level language:</p>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-7.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.3.内存段</title>
    <url>/2024/04/08/7-3-%E5%86%85%E5%AD%98%E6%AE%B5/</url>
    <content><![CDATA[<h1 id="73memorysegments"><span class="math inline">\(7.3.\)</span>Memory
Segments</h1>
<h3 id="1memory-segments-intro">1.Memory segments intro</h3>
<p>  There are different variable kinds in the high-level language, such
as:</p>
<ul>
<li>Argument variables</li>
<li>Local variables</li>
<li>Static variables</li>
</ul>
<p>  Since different kind of variables <strong>play different
role</strong>, we need some mechanism to <strong>record the different
roles of different variables</strong>. We can achieve this by the notion
of <em>memory segments</em>:</p>
<p><img src="/2024/04/08/7-3-%E5%86%85%E5%AD%98%E6%AE%B5/image.png"></p>
<p>  So the program below can be translated into two ways: without
<em>memory segments</em>:</p>
<p><img src="/2024/04/08/7-3-%E5%86%85%E5%AD%98%E6%AE%B5/image-1.png"></p>
<p>  And with <em>memory segments</em>:</p>
<p><img src="/2024/04/08/7-3-%E5%86%85%E5%AD%98%E6%AE%B5/image-2.png"></p>
<p>  In this way, we will be able to preserve the role semantics of
these variables.</p>
<p>  But it seems that we lost the variable names in the process. It's
not a big deal, however, for <strong>the VM obstruction doesn't
recognize symbolic variable names</strong>, all the variables are
replaced by references to memory segments.</p>
<p>  Through memory segments, we now interact with several different
segments:</p>
<p><img src="/2024/04/08/7-3-%E5%86%85%E5%AD%98%E6%AE%B5/image-3.png"></p>
<p>  And the syntax of the command is:
<code>push / pop segment i</code></p>
<ul>
<li><em>segment</em> is the segment you want to operate on.</li>
<li><em>i</em> is the index of the command in that segment.</li>
<li><span class="math inline">\(e.g.\)</span>
:<code>push constant 17</code></li>
<li><span class="math inline">\(e.g.\)</span> : translation of
<code>let static 2 = argument 1</code>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push argument 1</span><br><span class="line">pop static 2</span><br></pre></td></tr></table></figure>
<h3 id="2the-usage-of-segment">2.The usage of segment</h3>
<ul>
<li><p>There's a lot of semantics going on in the high-level
language:</p>
<ul>
<li>static variables, local variables, argument variables, ...</li>
<li>the <em>object</em> consisting a bundle of variables</li>
</ul></li>
<li><p>We can handle all the semantics using the eight virtual
segments.</p></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.1.程序编译前瞻</title>
    <url>/2024/04/08/7-1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%89%8D%E7%9E%BB/</url>
    <content><![CDATA[<h1 id="71program-compilation-preview"><span class="math inline">\(7.1.\)</span>Program Compilation Preview</h1>
<h3 id="1problem-in-compilation">1.Problem in compilation</h3>
<p>  To start with an abstract program and end with something actually
runs on the computer, we need</p>
<ul>
<li>A computer that can run machine language code.</li>
<li>Translating the high level language into machine language.</li>
</ul>
<p><img src="/2024/04/08/7-1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%89%8D%E7%9E%BB/image.png"></p>
<p>  However, there are so many kinds of computers in the world, and
many of them <strong>use different processes, which take different
machine languages</strong>. It seems that we have to develop many
compilers, one for each processor. This is very annoying.</p>
<p>  Luckily, this "write once fix everywhere" can be replaced by a
"write once run everywhere" process.</p>
<h3 id="2-2-tier-compilation">2. 2-Tier compilation</h3>
<p>  Let's take Java as example:</p>
<ul>
<li><p>The first tier: also called <em>the top tier</em></p>
<ul>
<li><p>Java compiler translates the Java program into VM code.</p>
<ul>
<li>The VM code is designed to run on an abstract artifact called
<em>virtual machine</em>.</li>
<li>It's not a real computer, so if we want to execute the code, we have
to translate it further into machine language and realize it on real
hardware (computer, for example).</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2024/04/08/7-1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%89%8D%E7%9E%BB/image-1.png"></p>
<ul>
<li><p>The second tier:</p>
<ul>
<li>We equip the target device with <em>JVM</em>, the Java machine
implementation.</li>
<li>The JVM is a program that takes VM code and translates it into the
target code of the target platform.</li>
<li>We need such translator <strong>for every platform on which we want
to execute VM program</strong>.</li>
</ul></li>
</ul>
<p><img src="/2024/04/08/7-1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%89%8D%E7%9E%BB/image-2.png"></p>
<p>  The gap between high-level language (Java, for example) and
low-level language is huge. But by <strong>introducing an intermediate
level</strong>, we <strong>decouple this process into two separate
standalone sub-processes</strong>: the compiler of <em>VM compiler</em>
and <em>VM implementation</em>.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>6.5.Hack汇编器开发</title>
    <url>/2024/04/07/6-5-Hack%E6%B1%87%E7%BC%96%E5%99%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="65developing-a-hack-assembler"><span class="math inline">\(6.5.\)</span>Developing a Hack Assembler</h1>
<h3 id="1start-reding-a-file">1.Start reding a file</h3>
<p>  In general, this part:</p>
<ul>
<li>Need to be able to read the input and break it into parts.</li>
<li>Doesn't need to understand what the command means or how it will be
translated into machine language.</li>
<li>Need to understand the format of the input language and how it
breaks into different components.</li>
</ul>
<p>  In detail, we may divide it into several parts:</p>
<ol type="1">
<li><p>Read a file with a given name.</p>
<ul>
<li>You may want a constructor to be able to accept the file name and
then open the file for reading.</li>
</ul></li>
<li><p>Move to next command in the file:</p>
<ol type="1">
<li>Are we finished? <code>boolean hasMoreCommands()</code></li>
<li>Get the next command: <code>void advance()</code></li>
<li>Read into one line into some kind of string.</li>
<li>Skip white space including comments.</li>
</ol></li>
<li><p>Get the fields of the current command</p>
<ul>
<li>Type of command (A, C, or label)</li>
</ul></li>
</ol>
<p><img src="/2024/04/07/6-5-Hack%E6%B1%87%E7%BC%96%E5%99%A8%E5%BC%80%E5%8F%91/image.png"></p>
<h3 id="2translating-mnemonic-tocode">2.Translating mnemonic to
code</h3>
<p>  In general, this part:</p>
<ul>
<li><p>Don't need to worry about how the mnemonic fields were
obtained.</p>
<ul>
<li>No need to know what part of input line it is, etc.</li>
</ul></li>
</ul>
<p>  In detail, we:</p>
<ol type="1">
<li>Ask the parser to give us the string that corresponds to each part
of the field.</li>
<li>Once we get the three string, we go to the code object to translate
each one of them separately according to the known table.</li>
<li>Concatenate the output together.</li>
</ol>
<p><img src="/2024/04/07/6-5-Hack%E6%B1%87%E7%BC%96%E5%99%A8%E5%BC%80%E5%8F%91/image-1.png"></p>
<h3 id="3the-symbol-table">3.The symbol table</h3>
<p>  In general, this part:</p>
<ul>
<li>Don't need to know what the symbols mean.</li>
<li>Need to maintain the association between a symbol and a memory
address.</li>
</ul>
<p>  In detail, we need to be able to:</p>
<ol type="1">
<li>Create an new empty table</li>
<li>Add a (symbol, address) pair to the table</li>
<li>Does the table contain a given symbol?</li>
<li>What is the address associated with a given symbol?</li>
</ol>
<p>  And do the following things:</p>
<ol type="1">
<li><p>Create a new empty table</p></li>
<li><p>Add all the pre-defined symbols to the table</p></li>
<li><p>While reading the input, add labels and new variables to the
table</p>
<ul>
<li><p>Labels: when you see a <code>"(xxx)"</code> command,add
<code>"xxx"</code> and the address of the next machine language
command</p>
<ul>
<li>Comment 1: this requires maintaining this running address (line
number).</li>
<li>Comment 2: this may need to be done in a first pass</li>
</ul></li>
<li><p>Variables: when you see an <code>"@xxx"</code> command, where
<code>"xxx"</code> is not a number and not already in the table, add
<code>"xxx"</code> and the next free address for variable
allocation</p></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 6.Assembler</category>
      </categories>
  </entry>
  <entry>
    <title>6.4.符号的处理</title>
    <url>/2024/04/07/6-4-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="64handling-the-symbol"><span class="math inline">\(6.4.\)</span>Handling the Symbol</h1>
<h3 id="1type-of-symbol">1.Type of symbol</h3>
<p>  Generally there are three types of symbol:</p>
<ul>
<li><em>Variable symbols</em>: Which represents memory locations where
the programmer wants to maintain values.</li>
<li><em>Label symbols</em>: Which represents destinations of goto
instructions.</li>
<li><em>Pre-defined symbols</em>: Which represents special memory
lorations.</li>
</ul>
<h3 id="2pre-define-symbolstranslation">2.Pre-define symbols
translation</h3>
<ul>
<li>These symbols exist only <strong>in the context of A
instructions</strong>. So they will only be seen in expression like
<code>@preDefinedSymbol</code></li>
<li>Translating <code>@preDefinedSymbol</code>: Replace
<code>preDefineSymbol</code> with its corresponding value:</li>
</ul>
<p><img src="/2024/04/07/6-4-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/image.png"></p>
<h3 id="3label-symbols-translation">3.Label symbols translation</h3>
<p>  To begin with, there are two sorts of label:</p>
<ul>
<li>Used to label destination of <code>goto</code> commands. For
example, <code>@STOP, 0;JMP</code></li>
<li>Declared by the <em>pseudo-command</em>. For example,
<code>(STOP)</code></li>
</ul>
<blockquote>
<p>This is called pseudo-commands because <strong>it doesn't generate
any code</strong>. When we translate the program into binary. we don't
translate the label declaration instructions.</p>
</blockquote>
<p>  To allocate a specific location to each label, we
<strong>number</strong> the instruction one by one, like the left hand
side:</p>
<p><img src="/2024/04/07/6-4-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/image-1.png"></p>
<ul>
<li>We ignore <strong>white space and pseudo-commands</strong> when
numbering.</li>
</ul>
<p>  Once we complete the numbering, we can <strong>refer the label to
its corresponding line number</strong>. For example, <code>LOOP</code>
relates to 4 and <code>STOP</code> relates to 18. And when we see the
instruction <code>@LOOP</code>, we actually mean <code>@4</code>.</p>
<p>  After this pre-work, the translating is plain: * Translating
<code>@labelSymbol</code>: Replace <code>labelSymbol</code> with its
value.</p>
<h3 id="4varables-translation">4.Varables translation</h3>
<ul>
<li>Any symbol xx appearing in an assembly program which <strong>is not
pre-defined</strong> and <strong>is not defined elsewhere using the
(xxx) directive</strong> is treated as a variable</li>
<li>if a variable appears in the program for the first time, we allocate
it to a memory address <strong>starting from address 16</strong> . If we
see this varable popping up later in the program, we simply <strong>look
up the value that you assigned to it before</strong>.</li>
</ul>
<h3 id="5symbol-table-construction">5.Symbol table construction</h3>
<h4 id="afirstpass">  <span class="math inline">\(a.\)</span>First
pass</h4>
<p>  In the <em>first pass</em>, we extract from the program <strong>all
the label symbols</strong>.</p>
<ul>
<li><p>Before starting any translation, create an empty table and add
all the predefined symbos one by one.</p></li>
<li><p>March through the entire text file that constitutes the source
assembly program:</p>
<ul>
<li><p>Only <strong>look for label declarations</strong></p>
<ul>
<li>Line of code that begins with left parenthesis.</li>
</ul></li>
<li><p>Meanwhile keep track of how many lines you've read so far (only
count real instructions).</p></li>
</ul></li>
</ul>
<p><img src="/2024/04/07/6-4-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/image-2.png"></p>
<h4 id="bsecondpass">  <span class="math inline">\(b.\)</span>Second
pass</h4>
<ul>
<li>We start once again to scan the entire program.</li>
<li>Whenever we see a symbol <strong>which doesn't appear in the symbol
table</strong>, we add it to the table, assign to it <code>16</code> or
larger number (for it must be a varable).</li>
<li>If we find them in the symbol table, then they've been declared and
we can use them.</li>
</ul>
<h4 id="cmore-about-the-table">  <span class="math inline">\(c.\)</span>More about the table</h4>
<ul>
<li>When resolving a symbol, we look it up in the table, retrieve its
value, and put it into the instruction. What you get is <strong>the
meaning of this symbol</strong> according to the symbol table.</li>
<li>We maintain the table as long as the assembler is processing the
program, and then we can toss it away.</li>
</ul>
<h3 id="6summary-the-assemblyprocess">6.Summary: The assembly
process</h3>
<ul>
<li><p><em>Initialization</em>:</p>
<ul>
<li>Construct an empty symbol table,</li>
<li>Add the pre-defined symbols to the symbol table,</li>
</ul></li>
<li><p><em>First pass</em>:</p>
<ul>
<li><p>Scan the entire program;</p></li>
<li><p>For each "instruction" of the form <code>(xxx)</code>:</p>
<ul>
<li>Add the pair (xxx, address) to the symbol table, where
<em>address</em> is <strong>the number of the instruction following
<code>(xxx)</code></strong>.</li>
</ul></li>
</ul></li>
<li><p><em>Second pass</em>:</p>
<ul>
<li><p>Set n to 16</p></li>
<li><p>Scan the entire program again, for each instruction:</p>
<ul>
<li><p>If the instruction is <code>@symbol</code>, look up symbol in the
symbol table:</p>
<ul>
<li><p>If (symbol, value) is found, use value to complete the
instruction's translation;</p></li>
<li><p>If not found:</p>
<ul>
<li>Add (symbol, n) to the symbol table,</li>
<li>Use n to complete the instruction's translation,</li>
<li>n++</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>If the instruction is a C-instruction, complete the instruction's
translation.</p></li>
<li><p>Write the translated instruction to the output file.</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 6.Assembler</category>
      </categories>
  </entry>
  <entry>
    <title>5.5.Hack计算机实现</title>
    <url>/2024/04/07/5-5-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="55hack计算机实现笔记"><span class="math inline">\(5.5.\)</span>Hack计算机实现笔记</h1>
<h3 id="1cpu实现">1.CPU实现</h3>
<p><img src="/2024/04/07/5-5-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E7%8E%B0/image.png"></p>
<h4 id="a指令识别">  <span class="math inline">\(a.\)</span>指令识别</h4>
<ul>
<li><code>instruction[15]</code>:用于<strong>判断是否为<code>A</code>指令</strong>。</li>
<li><code>instruction[12]</code>用于<strong>选择ALU的第二个输入来源</strong>。当<code>instruction[12] = 0</code>时，ALU的第二个输入为<code>A</code>寄存器；否则为存储器的输入数据<code>inM</code>。</li>
<li><code>instruction[6:11]</code>:用于<strong>控制ALU的操作</strong>。</li>
<li><code>instruction[5]</code>:当<code>instruction[15] = 0</code>时，<code>instruction[5]</code><strong>就是<code>A</code>指令的一部分</strong>；否则，它就是<code>C</code>指令的一部分。</li>
<li><code>instruction[4]</code>:用于<strong>选择ALU的第二个输入</strong>。当<code>instruction[4] = 1</code>时，我们<strong>将内存中读取的数据作为ALU的第二个输入(即<code>inM</code>)</strong>；否则<strong>将<code>A</code>寄存器中的数据作为ALU的第二个输入</strong>。</li>
<li><code>instruction[3]</code>:用于<strong>指示是否要向数据内存写入数据</strong>。当<code>instruction[3] = 1</code>时，表示要向数据内存中写入数据(即<code>writeM = 1</code>)；否则不对数据内存进行写入操作。</li>
<li><code>C</code>指令对应的16位指令：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 c1 c2 c3 c4 c5 c6 d1 d2 d3 j1 j2 j3</span><br></pre></td></tr></table></figure>
<ul>
<li><code>A</code>指令对应的16位指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 address[14:0]</span><br></pre></td></tr></table></figure>
<h4 id="ba寄存器处理">  <span class="math inline">\(b.\)</span><code>A</code>寄存器处理</h4>
<figure>
<img src="/2024/04/07/5-5-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E7%8E%B0/image-1.png" alt="Alt text">
<figcaption aria-hidden="true">Alt text</figcaption>
</figure>
<ol type="1">
<li>输入的16位指令和ALU的输出经过<code>Mux16</code>作为<code>A</code>寄存器的输入：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mux16(a = instruction, b = ALUOut, sel = instruction[15], out = Ain);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>在后面的过程中，我们需要知道指令是否为<code>A</code>指令，因此我们用一个pin来记录：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Not(in = instruction[15], out = NotA);</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><p>判断是否需要将指令加载到<code>A</code>寄存器中。此时有两种情况：</p>
<ol type="1">
<li>当前指令不是<code>A</code>指令，则选择加载。</li>
<li>当前指令为<code>A</code>指令，但是<code>instruction[5] = 1</code>(该位置用于存储<code>A</code>指令有关信息)，则选择加载：</li>
</ol></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Or(a = NotA, b = instruction[5] , out=loadA);</span><br><span class="line">ARegister(in = Ain, load = loadA, out = Aout, out[0..14] = addressM);</span><br></pre></td></tr></table></figure>
<h4 id="calu运算">  <span class="math inline">\(c.\)</span>ALU运算</h4>
<p><img src="/2024/04/07/5-5-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E7%8E%B0/image-2.png"></p>
<ol type="1">
<li>我们先处理ALU的两个输入源，其中第二个输入源由<code>C</code>指令集的<code>instruction[12]</code>控制：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mux16(a = Aout, b = inM, sel = instruction[12], out = AMout);</span><br><span class="line">And(a = instruction[15], b = instruction[4], out = loadD);</span><br><span class="line">DRegister(in = ALUOut, load = loadD, out = Dout);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>然后我们根据先前的指令识别进行ALU运算并输出：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">And(a = instruction[11], b = instruction[15], out = zx);</span><br><span class="line">And(a = instruction[10], b = instruction[15], out = nx);</span><br><span class="line">Or(a = instruction[9], b = NotA, out = zy);</span><br><span class="line">Or(a = instruction[8], b = NotA, out = ny);</span><br><span class="line">And(a = instruction[7], b = instruction[15], out = f);</span><br><span class="line">And(a = instruction[6], b = instruction[15], out = no);</span><br><span class="line"></span><br><span class="line">ALU(x = Dout, y = AMout, zx = zx, nx = nx, zy = zy, ny = ny, f = f, no = no, out = outM, out = ALUOut, zr = zero, ng = nega);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>zy</code>和<code>ny</code>控制信号在<code>A</code>指令时被强制为1是为了<strong>确保ALU的输入在处理<code>A</code>指令时被简化与固定，不受<code>C</code>指令控制位的影响</strong>，从而避免不必要的计算。</p>
</blockquote>
<ol start="3" type="1">
<li>之后我们需要执行<code>C</code>指令集的跳转逻辑。我们根据<strong>ALU计算结果和指令中的跳转位</strong>来决定是否跳转。</li>
</ol>
<p>  首先对<code>C</code>指令集的跳转位进行明晰：</p>
<ul>
<li><code>instruction[0]</code>对应<code>JGT</code>，当ALU输出为正数时跳转。</li>
<li><code>instruction[1]</code>对应<code>JEQ</code>，当ALU输出为0时跳转。</li>
<li><code>instruction[2]</code>对应<code>JLT</code>，当ALU输出为负数时跳转。</li>
</ul>
<p>  于是我们可以写出以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Or(a = zero, b = nega, out = notpos);</span><br><span class="line">Not(in = notpos, out = pos);</span><br><span class="line">    </span><br><span class="line">And(a = instruction[0], b = pos, out = out3);</span><br><span class="line">And(a = instruction[1], b = zero, out = out2);</span><br><span class="line">And(a = instruction[2], b = nega, out = out1);</span><br><span class="line"></span><br><span class="line">Or(a = out1, b = out2, out = out12);</span><br><span class="line">Or(a = out12, b = out3, out = out123);</span><br><span class="line"></span><br><span class="line">And(a = out123, b = instruction[15], out = jump);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>pos</code>, <code>nega</code>,
<code>zero</code>分别代表正数、负数和恰好为0。并且注意除了满足跳转条件外，还需要<strong>确保当前是<code>C</code>指令</strong>。</p>
</blockquote>
<ol start="4" type="1">
<li>最后我们调用<code>PC</code>以存储并更新当前指令的地址：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PC(in = Aout, load = jump, reset = reset, inc = true, out[0..14] = pc);</span><br></pre></td></tr></table></figure>
<h3 id="2内存实现">2.内存实现</h3>
<p>  内存实现较为简单，根据传入的15位地址<code>address</code>的后两位以及<code>load</code>来调控RAM、屏幕以及键盘即可。</p>
<ul>
<li><code>01 and load: RAMLoad</code></li>
<li><code>10 and load: SCRLoad</code></li>
<li><code>11 and load and other digit 0: KEYLoad</code></li>
</ul>
<h3 id="3hack计算机实现">3.Hack计算机实现</h3>
<p><img src="/2024/04/07/5-5-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E7%8E%B0/image-3.png"></p>
<p>  我们根据计算机的结构，对已有芯片进行接线即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU(inM = MemoryOut, instruction = Rominstruction, reset = reset, outM = CPUoutM, writeM = CPUload, addressM = CPUaddress, pc = CPUpc);</span><br><span class="line">Memory(in = CPUoutM, load = CPUload, address = CPUaddress, out = MemoryOut);</span><br><span class="line">ROM32K(address = CPUpc, out = Rominstruction);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 5.Computer Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>6.1.汇编语言与程序</title>
    <url>/2024/04/07/6-1-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="61assemble-program-and-assembler"><span class="math inline">\(6.1.\)</span>Assemble Program and Assembler</h1>
<h3 id="1basic-assembler-logic">1.Basic assembler logic</h3>
<ul>
<li><p>Repeat:</p>
<ul>
<li>Read the next Assembly language command.</li>
<li>Break it into the different fields it is composed of.</li>
<li>Lookup the binary code for each field.</li>
<li>Combine these codes into a single machine language command.</li>
<li>Output this machine language command.</li>
</ul></li>
<li><p>One thing we need to worry about: <em>Symbols</em>:</p>
<ul>
<li><p>Two cases:</p>
<ul>
<li><em>Labels</em>: When jumping into a certain part, you give it a
name instead of hard core the address. <code>JMP loop</code></li>
<li><em>Variables</em>: You give a variable name rather than always
refer to its exact address in memory. <code>load R1, weight</code></li>
</ul></li>
<li><p>To convert it into concrete address, we use a <em>symbol
table</em>:</p></li>
</ul></li>
</ul>
<p><img src="/2024/04/07/6-1-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%A8%8B%E5%BA%8F/image.png"></p>
<ul>
<li><p>To maintain such table:</p>
<ul>
<li>When we first meet a symbol, we need to <strong>allocate a new
memory location</strong> to hold it. For the assembler, it will find the
<strong>next memory location that's available</strong>.</li>
<li>When we meet it again, we simply refer to its address in the
table.</li>
</ul></li>
<li><p>One special case: <em>Forward references</em>: We can jump into a
label before where it was defined. There are two ways to handle it:</p>
<ol type="1">
<li>Use a little bit to remember that we've set the labels but don't
know where it is yet. We leave it blank until label appears.(more
complicated)</li>
<li>In first pass just figure out all address.</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 6.Assembler</category>
      </categories>
  </entry>
  <entry>
    <title>5.4.Hack计算机</title>
    <url>/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="54hackcomputer"><span class="math inline">\(5.4.\)</span>Hack
Computer</h1>
<h3 id="1hack-computer-abstraction">1.Hack computer abstraction</h3>
<ul>
<li>A computer capable of running programs written in the Hack machine
language.</li>
</ul>
<h3 id="2cpu-operations">2.CPU operations</h3>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image.png"></p>
<figure>
<img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-1.png" alt="Alt text">
<figcaption aria-hidden="true">Alt text</figcaption>
</figure>
<ul>
<li><p>If the instruction includes <code>D And A</code>, CPU is going to
<strong>manipulate the respective D and A registers</strong>.</p></li>
<li><p>If the instruction ia an A instruction like <code>@17</code>, CPU
is going to <strong>take the 15-bit data value and store them inside the
A register</strong>. This value is <strong>emitted by
<code>addressM</code></strong>.</p></li>
<li><p>If the instruction's <em>right hand side</em> includes
<code>M</code> like <code>M = M + 1</code>, this value is <strong>read
from <code>inM</code> interface</strong>.</p></li>
<li><p>If the instruction's <em>left hand side</em> includes
<code>M</code>, then the value output should be stored in the data
memory of the selected memory register.</p>
<ul>
<li>As we discuss in the CPU, we have to provide <strong>what things we
want to write, where to write and the control bits</strong> to write
something to the data memory. As a result, <strong>the ALU output is
emitted by <code>outM</code>, and the <code>writeM</code> is
asserted</strong>.</li>
</ul></li>
<li><p>If we have a jump situation <code>@100, D = D - 1; JEQ</code>. ,
we want to jump to the address that was specified before(100, in this
case):</p>
<ul>
<li>If <code>reset == 0</code>, CPU logic uses <strong>the jump bits and
the ALU output</strong> to decide whether or not there should be a
jump.</li>
<li>If there is a jump, <code>PC = A</code></li>
<li>Else, <code>PC++</code></li>
<li>The updated <code>PC</code> value <strong>is emitted by
<em>pc</em></strong>.</li>
<li>If <code>reset == 1</code>, <em>pc</em> emits <code>0</code>,
causing a program restart</li>
</ul></li>
</ul>
<h3 id="3memory-abstraction">3.Memory abstraction</h3>
<figure>
<img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-2.png" alt="Alt text">
<figcaption aria-hidden="true">Alt text</figcaption>
</figure>
<ul>
<li><p>Three different segments:</p>
<ul>
<li>Address 0 to 16383(16k): <em>data memory</em></li>
<li>Address 16384 to 24575(next 8k): <em>screen memory map</em></li>
<li>Address 24576: <em>keyboard memory map</em></li>
</ul></li>
</ul>
<h3 id="4memory-implementation">4.Memory implementation</h3>
<p>  We bulid our memory from three different sub-chips:</p>
<ul>
<li><em>RAM:</em> 16-bit 16K RAM chip</li>
<li><em>Screen</em>: 16-bit/8K memory chip with a raster display
side-effect.</li>
<li><em>Keyboard</em>: 16-bit register with a keyboard side-effect.</li>
</ul>
<h4 id="aram">  <span class="math inline">\(a.\)</span>RAM</h4>
<p>![[Pasted image 20240406103441.png]]</p>
<ul>
<li>The inputs and outputs of RAM16 are identical to the inputs and
outputs of the overall memory chip.</li>
<li>So whoever builds the chip has to make sure to take the outside
inputs and outputs and <strong>make connections that will funnel these
value into the inner chip box, such as RAM 16K</strong>.</li>
</ul>
<h4 id="bscreen">  <span class="math inline">\(b.\)</span>Screen</h4>
<p>![[Pasted image 20240406104348.png]]</p>
<ul>
<li>We use a special built-in <em>8K screen chip</em> that knows how to
automatically refresh a connected display unit.
<ul>
<li>It's a RAM chip, which has a nice side effect of refreshing a
connected display unit.</li>
</ul></li>
</ul>
<h4 id="ckeyboard">  <span class="math inline">\(c.\)</span>Keyboard</h4>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-3.png"></p>
<ul>
<li>We use a built-in Keyboard chip featuring a keyboard capture
side-effect, which is that it always reflects what the user is pressing
on the keyboard.</li>
</ul>
<h3 id="5instruction-memory">5.Instruction memory</h3>
<h4 id="aintro">  <span class="math inline">\(a.\)</span>Intro</h4>
<ul>
<li>We implement this instruction memory using a chip called <em>ROM
32K</em>.</li>
</ul>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-4.png"></p>
<ul>
<li><p>We can <strong>loading a program</strong> in this way:</p>
<ul>
<li><p>Hardware inplementation: <em>plug-and-play ROM chips</em>: We put
our machine instruction code into a ROM chip. We take this RAM chip,
plug it into the computer. We press the <code>reset</code> button, and
the computer will start executing this particular program.</p>
<ul>
<li>If we want to run another program, we take the chip out and plug in
another chip.</li>
</ul></li>
</ul></li>
</ul>
<h4 id="brominterface">  <span class="math inline">\(b.\)</span>ROM
interface</h4>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-5.png"></p>
<ul>
<li>It's a <strong>read-only</strong> device.</li>
<li>Contains a sequence of Hack instructions (program).</li>
<li>The <em>output</em> of of the ROM is always <strong>the contents of
the register that is selected by the address input</strong>.</li>
<li>Since the <em>pc</em> always emits the address of next instruction,
if we feed this address into ROM, we are guaranteed that ROM will always
admit a 16-bit value that we can treat as the current instruction.</li>
</ul>
<h3 id="6hack-computerimplementation">6.Hack computer
implementation</h3>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-6.png"></p>
<ul>
<li>We first connect to the CPU <strong>the instruction memory which we
call ROM</strong>. The instruction input of the CPU is taken from the
output of instruction memory.</li>
<li>In the process of executing this instuction, we are going to compute
the address of the next instruction. This address is emitted by
<em>pc</em>.</li>
<li>The address goes all the way into the address of the instruction
unit, and the unit will emit the next instruction that has to be
executed in the next cycle.</li>
</ul>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-7.png"></p>
<ul>
<li>To do something useful with the outputs, we connect outputs to
<em>memory unit</em>.</li>
<li>We take the output of the memory, and connect it back into the
CPU</li>
</ul>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-8.png"></p>
<ul>
<li>The input and output units are the only two things the computer
users sees when he works.</li>
<li>With this computer is a display unit, a keyboard and the reset
button.</li>
</ul>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-9.png"></p>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-10.png"></p>
<ul>
<li>This is the overall computer architect!!!</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 5.Computer Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>5.2.获取-执行循环</title>
    <url>/2024/04/06/5-2-%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="52the-fetch-execute-cycle"><span class="math inline">\(5.2.\)</span>The Fetch-Execute Cycle</h1>
<ul>
<li><em>Fetch an instruction from the program memory</em></li>
<li><em>Execute</em> it</li>
</ul>
<h3 id="1fetching">1.Fetching</h3>
<ul>
<li><p>The next instruction is located at the <em>program memory</em>,
the program memory is in the <em>memory</em>, and its address is
specified by the <em>program counter</em>.</p></li>
<li><p>We need to basically <strong>put the location of the next
instruction into the "address" of the program memory</strong>. Then we
need to read the contents at that location and then will get the basic
instructions we need to execute.</p></li>
<li><p>We usually put the address of the next instruction into the
address input of the program memory by <em>program
counter</em>.</p></li>
</ul>
<p>  The hardware cycle of executing the fetch operation is as
below:</p>
<p><img src="/2024/04/06/5-2-%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF/image.png"></p>
<ul>
<li>When we need to jump into a new location, we <strong>manipulate the
program counter</strong> so that it will have the address of the next
instruction.</li>
<li>The output of the program counter feeds into the address
specification of program memory.</li>
<li>The program memory output comes the actual instruction code that we
need to execute.</li>
</ul>
<h3 id="2execute">2.Execute</h3>
<ul>
<li><p>The instruction code specifies "what to do"</p>
<ul>
<li>Which arithmetie or logical instruction.</li>
<li>What memory to access (read/write).</li>
<li>If/where to jump.</li>
</ul></li>
<li><p><em>Bit aspect</em>: Execute current instruction means
<strong>taking the bits from the instruction code that specifies what to
do</strong>, and do what needs to be done.</p>
<ul>
<li>Often, different subsets of the bits control different aspects of
the operation</li>
</ul></li>
<li><p><em>Hardware aspect</em>:</p></li>
</ul>
<p><img src="/2024/04/06/5-2-%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF/image-1.png"></p>
<ul>
<li><p><em>control bus</em>:</p>
<ul>
<li><p>tells the ALU what instruction to compute,</p></li>
<li><p>tells where do the data pieces come from,</p></li>
</ul></li>
</ul>
<h3 id="2the-clash">2.The clash</h3>
<p>  There's a clash in the cycle above:</p>
<ul>
<li>For <em>fetch</em>, we need to put into the address of the memory
<strong>the address of the next instruction</strong> to get the
instruction output.</li>
<li>For <em>execute</em>, we need to put into the address of the memory
<strong>the address of the data pieces</strong> that we want to operate
on to access data.</li>
<li>But we only have a single memory, so <strong>should we put into the
memory the address of data or instructions</strong>?</li>
</ul>
<p><img src="/2024/04/06/5-2-%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF/image-2.png"></p>
<p>  To solve this problem, we will do <strong>one after
another</strong>. We will achieve this through a
<em>Multiplexer</em>:</p>
<ul>
<li>In the first part, the <em>fetch cycle</em>, the multiplexer set the
memory to point into <strong>the program counter that is the location of
the next instruction</strong>.</li>
<li>While in the <em>execute cycle</em>, the multiplexer will set the
memory to point into <strong>the data address that we need to
access</strong>.</li>
</ul>
<p>  So how do we do this together?</p>
<p><img src="/2024/04/06/5-2-%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF/image-3.png"></p>
<ul>
<li>When we are in a <em>fetch cycle</em>, we get the next instruction,
and then we need to <strong>remember it inside an instruction
register</strong>.</li>
<li><strong>That instruction register is exactly what is remains holding
the value of the instruction that we are now executing in the execute
cycle.</strong> Then in the <em>execute cycle</em> we have the
instruction already stored in this register, so we can work with all the
information we need for the cycle.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 5.Computer Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>5.3.CPU</title>
    <url>/2024/04/06/5-3-CPU/</url>
    <content><![CDATA[<h1 id="53central-processing-unit"><span class="math inline">\(5.3.\)</span>Central Processing Unit</h1>
<h3 id="1abstraction">1.Abstraction</h3>
<p>  We can view CPU as <strong>a 16-bit</strong> processor, designed
to:</p>
<ul>
<li><p>Execute the current instruction.</p>
<ul>
<li>This turns the static code into reality.</li>
</ul></li>
<li><p>Figure out which instruction to execute next.</p></li>
</ul>
<h3 id="2hack-cpu-interface">2.Hack CPU interface</h3>
<p><img src="/2024/04/06/5-3-CPU/image.png"></p>
<ul>
<li>CPU is connected both to the <em>instruction memory</em> and to the
<em>data memory</em>.</li>
</ul>
<p>  here is the specific input and output connections of the CPU:</p>
<p><img src="/2024/04/06/5-3-CPU/image-1.png"></p>
<ul>
<li><p>We have three inputs coming from three completely different
sources.</p>
<ul>
<li><p>A 16-bit <em>data value</em>, which is the value of <strong>the
currently selected data memory register</strong>. This is the value CPU
is going to operate on.</p></li>
<li><p>A 16-bit <em>instruction value</em>, which is the value of
<strong>the selected instruction memory register</strong>.</p>
<ul>
<li>Remember that at any given point of time, there is always <strong>a
selected register in the instruction memory</strong>, and a
<strong>selected memory register in the data memory</strong>. So always
something comes into the CPU.</li>
</ul></li>
<li><p>A 1-bit <em>input</em>, which we <strong>decide to call the
reset</strong>.</p></li>
</ul></li>
<li><p>On the right hand side we see the outputs of ALU:</p>
<ul>
<li><p>The ALU specifies 3 different things to write something to the
data memory:</p>
<ol type="1">
<li><em>outM</em>: What we want to write.</li>
<li><em>writeM</em>: A <strong>load bit</strong> that enables the data
memory to write operations.</li>
<li><em>address</em>: Where do we want to write it.</li>
<li><em>pc</em>: It holds the <strong>address of the next
instruction</strong> that has to be fetched and executed in the next
cycle of this computer.</li>
</ol></li>
</ul></li>
</ul>
<h3 id="3cpu-implementation">3.CPU implementation</h3>
<p>  The whole CPU hardware diagram is as below:</p>
<p><img src="/2024/04/06/5-3-CPU/image-2.png"></p>
<h4 id="aainstruction">  <span class="math inline">\(a.\)</span>A
instruction</h4>
<p><img src="/2024/04/06/5-3-CPU/image-3.png"></p>
<p>  This section contains:</p>
<ul>
<li><em>A register</em> called A.</li>
<li><em>An A-instruction input</em> that connects to this register
through a <em>multiplexer</em>.</li>
</ul>
<p>  We see that this instruction seeks to load the value
<code>3001</code> into a register. In order to carry out this
instruction, the CPU do:</p>
<ol type="1">
<li>Decode the instruction into <strong>op-code + 15-bit
value</strong>.</li>
<li>Noticing that it is a A instruction, CPU <strong>stores the 15-bit
value in the A-register</strong>.</li>
<li>Take the output of A register and admit it outside.</li>
</ol>
<h4 id="b-cinstruction">  <span class="math inline">\(b.\)</span> C
instruction</h4>
<p><img src="/2024/04/06/5-3-CPU/image-4.png"></p>
<p>  This section contains:</p>
<ul>
<li>A register.</li>
<li>C instruction.</li>
</ul>
<p>  Others is the same as above.</p>
<ul>
<li><p>Say we want to gain an A instruction, we can use the
<em>Mux16</em>:</p>
<ul>
<li>If the instruction input is with an op-code <code>0</code>, we
choose the instruction input.</li>
<li>Otherwise, we choose the ALU input.</li>
</ul></li>
</ul>
<h4 id="caluoperation">  <span class="math inline">\(c.\)</span>ALU
Operation</h4>
<p><img src="/2024/04/06/5-3-CPU/image-5.png"></p>
<ul>
<li><p>The inputs of ALU come from:</p>
<ol type="1">
<li><p><em>D register</em></p></li>
<li><p>Either the value of <em>A register</em> or <em>selected memory
register</em>.</p></li>
<li><p><em>Multiplexer</em> takes care of this decision, and the control
bit of it is <strong>one of the bits in the instruction</strong>.</p>
<ul>
<li>The CPU designer has to <strong>choose this bit</strong>, and then
ALU gets the correct input.</li>
</ul></li>
</ol></li>
<li><p>ALU also has <em>6 control bits taken together</em> to
<strong>tell or specify the ALU which operation we want to carry
out</strong>.</p></li>
</ul>
<p><img src="/2024/04/06/5-3-CPU/image-6.png"></p>
<ul>
<li><p>The output of ALU is <strong>simultaneously</strong> fed
into:</p>
<ol type="1">
<li><p><em>D register</em></p></li>
<li><p><em>A register</em></p></li>
<li><p><em>M register</em></p>
<ul>
<li>It goes through a <em>Multiplexer</em>.</li>
</ul></li>
</ol></li>
</ul>
<p>  The same ALU is fanned out into 3 different places, so we have the
same ALU output knocking on three different doors. The programmer has to
decide which door to be opened. The decision is made by next field of
bits —— <em>destination bits</em>:</p>
<ul>
<li>We have 3 destination bits, which decide whether or not open the
<em>D register</em>, <em>A register</em>, <em>M register</em> and the
<em>data memory</em> to accept the ALU output.</li>
</ul>
<h4 id="dcontrol-abstraction">  <span class="math inline">\(d.\)</span>Control abstraction</h4>
<p>  The computer is loaded with some program, when you push
<code>reset</code>, <strong>the program starts running</strong>.</p>
<p>  In our previous chapter, we know that the last three bits of the
instruction is <em>jump bits</em>, which a <code>1</code> represents
unconditional <code>goto</code>. CPU realizes this functionality by
<em>program counter</em></p>
<h5 id="ipcabstraction">  <span class="math inline">\(i.\)</span>PC
abstraction</h5>
<ul>
<li><p>Emits <strong>the address of the next instruction</strong>:</p>
<ul>
<li>To start / restart the program's execution: <code>PC = 0</code>(for
we want to execute the first instruction of the program).</li>
<li>no jump: <code>PC++</code></li>
<li>unconditional <code>goto</code>: <code>PC = A</code></li>
<li>conditional <code>goto</code>: if true <code>PC = A</code> else
<code>PC++</code></li>
</ul></li>
</ul>
<h5 id="iicontrol-implementation">  <span class="math inline">\(ii.\)</span>Control implementation</h5>
<p><img src="/2024/04/06/5-3-CPU/image-7.png"></p>
<p><img src="/2024/04/06/5-3-CPU/image-8.png"></p>
<ul>
<li><p>if <code>reset == 1</code>, <code>PC=0</code></p></li>
<li><p>else</p>
<ul>
<li><p>We have to look at the <strong>jump bits</strong> and
simultaneously look at the <strong>ALU output</strong> to decide if we
want to carry out the jump.</p></li>
<li><p><code>load = f(jump bits, ALU control outputs)</code></p>
<ul>
<li>if <code>load == 1</code>, <code>PC = A</code></li>
<li>else <code>PC++</code></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 5.Computer Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>4.8.指针，输入与输出控制</title>
    <url>/2024/04/05/4-8-%E6%8C%87%E9%92%88%E3%80%81%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="48pointer-and-input-outputcontrol"><span class="math inline">\(4.8.\)</span>Pointer and Input, Output
Control</h1>
<h3 id="1pointer">1.Pointer</h3>
<p>  We use <strong>A-instruction</strong> to point to a certain
address. For example: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//   for(i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">//      arr[i] = -1</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   suppose arr = 100 and n = 10</span><br><span class="line"></span><br><span class="line">//initialize</span><br><span class="line">	@100</span><br><span class="line">	D = A</span><br><span class="line">	@arr</span><br><span class="line">	M = D</span><br><span class="line"></span><br><span class="line">	@10</span><br><span class="line">	D = A</span><br><span class="line">	@n</span><br><span class="line">	M = D</span><br><span class="line"></span><br><span class="line">	@i</span><br><span class="line">	M = 0</span><br><span class="line"></span><br><span class="line">//iteration</span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">	@i</span><br><span class="line">	D = M</span><br><span class="line">	@n </span><br><span class="line">	D = D - M</span><br><span class="line">	@END</span><br><span class="line">	D;JEQ</span><br><span class="line"></span><br><span class="line">	//RAM[arr + i] = -1</span><br><span class="line">	@i</span><br><span class="line">	D = M</span><br><span class="line">	@arr</span><br><span class="line">	A = D + M</span><br><span class="line">	M = -1</span><br><span class="line">	@i</span><br><span class="line">	M = M + 1</span><br><span class="line">	</span><br><span class="line">	@LOOP</span><br><span class="line">	0;JMP</span><br><span class="line"></span><br><span class="line">	(END)</span><br><span class="line">	@END</span><br><span class="line">	0;JMP</span><br></pre></td></tr></table></figure></p>
<p>  The key step in the program is <code>A = D + M, M = -1</code>:</p>
<ul>
<li><p>The <code>A = D + M</code> point the address of <code>arr</code>
to the <strong>base address</strong> of <code>arr</code>(the initial
address, 100) plus i, which match the expression
<code>arr + i</code>.</p></li>
<li><p>By the time we say M equals -1, the register that will be
affected is the register in A address.</p></li>
<li><p>Variables that store memory addresses like <code>arr + i</code>
are called <em>pointers</em>.</p></li>
<li><p>Typical pointer semantics:"set the address register to the
contents of some <strong>memory register</strong>"</p></li>
</ul>
<h3 id="2screen-input">2.Screen input</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//for (i = 0; i &lt; n; i ++)</span><br><span class="line">//    draw 16 black pixels at the </span><br><span class="line">//    beginning of row i</span><br><span class="line"></span><br><span class="line">//    addr = SCREEN</span><br><span class="line">//    n = RAM[0]</span><br><span class="line">//    i = 0</span><br><span class="line">//    LOOP:</span><br><span class="line">//    if i &gt; n goto END</span><br><span class="line">//    RAM[addr] = -1 1111111111111111</span><br><span class="line">//    addr = addr + 32</span><br><span class="line">//    i = i + 1</span><br><span class="line">//    goto LOOP</span><br><span class="line"></span><br><span class="line">@SCREEN</span><br><span class="line">D = A</span><br><span class="line">@addr</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">@R0</span><br><span class="line">D = M</span><br><span class="line">@n</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">@i</span><br><span class="line">M = 0</span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">	@i</span><br><span class="line">	D = M</span><br><span class="line">	@n</span><br><span class="line">	D = D - M</span><br><span class="line">	@END</span><br><span class="line">	D; JGT</span><br><span class="line"></span><br><span class="line">	@addr</span><br><span class="line">	A = M</span><br><span class="line">	M = -1</span><br><span class="line"></span><br><span class="line">	@i</span><br><span class="line">	M = M + 1</span><br><span class="line">	@32</span><br><span class="line">	D = A</span><br><span class="line">	@addr</span><br><span class="line">	M = M + D</span><br><span class="line">	(LOOP)</span><br><span class="line">	0; JMP</span><br><span class="line">	</span><br><span class="line">(END)</span><br><span class="line">	@END</span><br><span class="line">	0; JMP</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>5.1.冯·诺伊曼结构</title>
    <url>/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="51von-neumman-architect"><span class="math inline">\(5.1.\)</span>Von Neumman Architect</h1>
<h3 id="1stored-program-computer">1.Stored program computer</h3>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image.png"></p>
<ul>
<li><p><em>Memory</em>: It's used to do two things:</p>
<ol type="1">
<li>Store all the kind of the data that we're going to use in the
computation</li>
<li>Hold the program as a sequence of instructions that are going to be
executed one by one.</li>
</ol></li>
<li><p><em>CPU</em>: Carry out these instructions, run them and control
everything.</p></li>
</ul>
<p>  The detailed CPU instrcture is as below:</p>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-1.png"></p>
<ul>
<li><em>ALU</em>: A piece of <strong>hardware</strong> that is able to
add numbers and subtract numbers maybe do logical operations and so
on.</li>
<li>A bunch of <em>Register</em>: <strong>Store data</strong> that we're
going to use for the rest of computation.</li>
</ul>
<h3 id="2information-flow">2.Information flow</h3>
<h4 id="aintro">  <span class="math inline">\(a.\)</span>Intro</h4>
<ul>
<li>The memory itself has two part: the part that <strong>stores the
program</strong> and the part that <strong>stores the
data</strong>.</li>
<li>We can consider these things as <strong>a flow of
data</strong>.</li>
</ul>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-2.png"></p>
<p>  There are three types of information passed around the system:</p>
<ol type="1">
<li><em>Data</em>: When we do addition, for example, the number needs to
be moved from the data in memory to the other systematic logic unit that
is going to do something with them, and send them back.</li>
<li><em>Address</em>: The data we need to access now lies in
address.</li>
<li><em>Control</em>: It tells each part of the system what to do at
this particular point.</li>
</ol>
<ul>
<li><em>Data bus, address bus and control bus</em>.</li>
</ul>
<h4 id="baluinfo-flow">  <span class="math inline">\(b.\)</span>ALU
info flow</h4>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-3.png"></p>
<ul>
<li><p><em>Data bus</em>: ALU needs to <strong>have some information
from the data bus</strong>, and then <strong>feeds the output value
back</strong> into the data bus. It's going to go to other places that
also connect to the data bus, such as memory.</p></li>
<li><p><em>Control bus</em>: ALU needs to know what kind of operation it
dose every time, so it has to get information from the control bus
<strong>specifying the type of operation it does</strong>. On the other
hand, according to the results of the operations it did, it should be
able to <strong>tell other part of the system what to do</strong>.</p>
<ul>
<li>For example, if it sees that a certain number is greater than 0, it
can control the jump to the next instruction.</li>
</ul></li>
</ul>
<h4 id="cregisters">  <span class="math inline">\(c.\)</span>Registers</h4>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-4.png"></p>
<ul>
<li><p><em>Data bus</em>: The same as ALU.</p></li>
<li><p><em>Address bus</em>: The way we achieve indirect addressing into
a RAM or ROM is <strong>putting number address into a register</strong>
that specifies where we want to access. So we are going to have
registers control a connection to the address bus which controls
memories, and feeds into memory.</p>
<ul>
<li>We'll have registers either exclusively or both address and data
registers.</li>
</ul></li>
</ul>
<h4 id="dmemory">  <span class="math inline">\(d.\)</span>Memory</h4>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-5.png"></p>
<ul>
<li>The memory needs to specify what address we are going to work
with.</li>
</ul>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-6.png"></p>
<ul>
<li><p>Once we actually work with a certain address, we are going to be
needed to be able to read it or write into it, get information from it
or put information into it. This means we need to be connected to
<em>data bus</em>.</p>
<ul>
<li><p><em>Data memory</em> gets an address of a data piece that needs
to be operated on.</p></li>
<li><p><em>Program memory</em> requires us to <strong>put the address of
the next program instruction into the memory</strong>. We need to be
able to put an address into the program memory, and get instructions
from there.</p>
<ul>
<li>The instructions we get from the program memory may have data as
well. But it's of great importance that <strong>they tell the rest of
the system what to do</strong>.</li>
<li>We need to be able to take information from the next instruction
from the data output of the program memory and <strong>feed it into the
control bus</strong>.</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 5.Computer Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>4.7.分支，变量与迭代</title>
    <url>/2024/04/05/4-7-%E5%88%86%E6%94%AF%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<h1 id="47branchingvarables-and-iteration"><span class="math inline">\(4.7.\)</span>Branching,Varables and Iteration</h1>
<h3 id="1branching">1.Branching</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Computes:if R0&gt;0</span><br><span class="line">//            R1=1</span><br><span class="line">//         else</span><br><span class="line">//            R1=0</span><br><span class="line">@R0</span><br><span class="line">D=M</span><br><span class="line"></span><br><span class="line">@8</span><br><span class="line">D;JGT</span><br><span class="line"></span><br><span class="line">//if D isn&#x27;t greater than 0, do this block</span><br><span class="line">@R1</span><br><span class="line">M = 0</span><br><span class="line">@10</span><br><span class="line">0;JMP</span><br><span class="line"></span><br><span class="line">//else, do this</span><br><span class="line">@R1</span><br><span class="line">M = 1</span><br><span class="line"></span><br><span class="line">@10</span><br><span class="line">0;JMP</span><br></pre></td></tr></table></figure>
<ul>
<li><em>Symbolic reference</em>: The above code is correct but
unreadable. Fortunately, we have a nice feature called <em>symbolic
reference</em>. For example, the above code can be rewrited like
this:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@R0</span><br><span class="line">D=M</span><br><span class="line"></span><br><span class="line">@POSITIVE</span><br><span class="line">D;JGT</span><br><span class="line"></span><br><span class="line">@R1</span><br><span class="line">M = 0</span><br><span class="line">@END</span><br><span class="line">@10</span><br><span class="line">0;JMP</span><br><span class="line"></span><br><span class="line">(POSITIVE)</span><br><span class="line">@R1</span><br><span class="line">M = 1</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">@10</span><br><span class="line">0;JMP</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The <code>POSITIVE</code> label appears twice in the code: In the
first place we declare this label, and what we are saying is
<strong>"here is a piece of code that I want to jump to some other place
in the code called <code>POSITIVE</code>"</strong>.</p>
<ul>
<li>LABEL translates to n, where n is the instruction number following
the (LABEL) declaration, in the assembler.</li>
</ul></li>
</ul>
<h3 id="2varables">2.Varables</h3>
<p>  In machine language, besides <code>R0</code> and symbolic
reference, we can also set out own <em>varables</em>. For example:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@R0</span><br><span class="line">D = M</span><br><span class="line">@temp</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">@R1</span><br><span class="line">D = M</span><br><span class="line">@R0</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">@temp</span><br><span class="line">D = M</span><br><span class="line">@R1</span><br><span class="line">M = D</span><br></pre></td></tr></table></figure></p>
<p>  The <code>temp</code> is a varable set by ourselves, and we
represent it by using <code>@temp</code>. This kind of naming improve
the readability of our code.</p>
<blockquote>
<p>  However, assembly language does not inherently support variables.
Therefore, when we write "<span class="citation" data-cites="temp">@temp</span>", we are essentially <strong>requesting
the computer to find an available memory register in the memory
unit</strong> and <strong>assume its number to be "n"</strong>, and
then, from now on, <strong>use it to represent what we call the
"variable temp"</strong>.</p>
</blockquote>
<h3 id="3iteration">3.Iteration</h3>
<p>  Considering this question: Compute RAM[1] = 1+2+...+RAM[0]. We have
the following pseudo code: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = RO</span><br><span class="line">i = 1</span><br><span class="line">sum = 0</span><br><span class="line">LOOP:</span><br><span class="line">if i&gt;n goto STOP</span><br><span class="line">sum = sum + i</span><br><span class="line">i = i + 1</span><br><span class="line">goto LOOP</span><br><span class="line">STOP:</span><br><span class="line">R1 = sum</span><br></pre></td></tr></table></figure></p>
<p>  We can implement the pseudo code as below: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//initialize</span><br><span class="line">@R0</span><br><span class="line">D = M</span><br><span class="line">@n</span><br><span class="line">M = D</span><br><span class="line">@i</span><br><span class="line">M = 1</span><br><span class="line">@sum</span><br><span class="line">M = 0</span><br><span class="line"></span><br><span class="line">//computing</span><br><span class="line">(LOOP)</span><br><span class="line">	@i</span><br><span class="line">	D = M</span><br><span class="line">	@n</span><br><span class="line">	M = M - D</span><br><span class="line">	//the if clause</span><br><span class="line">	@STOP</span><br><span class="line">	D;JGT</span><br><span class="line"></span><br><span class="line">	@sum </span><br><span class="line">	D = M</span><br><span class="line">	@i</span><br><span class="line">	D = D + M</span><br><span class="line">	@sum</span><br><span class="line">	M = D</span><br><span class="line">	@i</span><br><span class="line">	M = M + 1</span><br><span class="line">	@LOOP</span><br><span class="line">	0;JMP</span><br><span class="line"></span><br><span class="line">(STOP)</span><br><span class="line">	@sum</span><br><span class="line">	D = M</span><br><span class="line">	@R1</span><br><span class="line">	M = D</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">	@END</span><br><span class="line">	0;JMP</span><br></pre></td></tr></table></figure></p>
<p>  We may take the process to lessen our burden with writing loop:</p>
<ol type="1">
<li>First write in pseudo code.</li>
<li>Debug your pseudo code.</li>
<li>Translating the pseudo code into machine language.</li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>4.6.寄存器与内存</title>
    <url>/2024/04/05/4-6-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="46working-with-register-and-memory"><span class="math inline">\(4.6.\)</span>Working with register and memory</h1>
<h3 id="1operations-towards-d">1.Operations towards D</h3>
<ul>
<li><p>Storing value: It turns out that there's no direct way to do it,
we have to do it indirectly. For example, if we want to store 10 in
register D: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@10</span><br><span class="line">D = A</span><br></pre></td></tr></table></figure></p></li>
<li><p>Incresing value: We can use C instructions directly:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D = D + 1</span><br></pre></td></tr></table></figure></p></li>
<li><p>Setting D to RAM value: It's similar to storing value:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@10</span><br><span class="line">D = M</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="2usage-of-d-register">2.Usage of D register</h3>
<p>  D register is of great importance in assignment operations:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//set RAM[10] to 5</span><br><span class="line">@5</span><br><span class="line">D = A</span><br><span class="line">@10</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">//set RAM[10] to RAM[5]</span><br><span class="line">@ 5</span><br><span class="line">D = M</span><br><span class="line">@10</span><br><span class="line">M = D</span><br></pre></td></tr></table></figure></p>
<h3 id="3built-in-symbol">3.Built-in symbol</h3>
<p><img src="/2024/04/05/4-6-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/image.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>4.5.输入与输出</title>
    <url>/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="45inputand-output"><span class="math inline">\(4.5.\)</span>Input
and Output</h1>
<h3 id="1-output">1. Output</h3>
<h4 id="adisplay">  <span class="math inline">\(a.\)</span>Display</h4>
<ul>
<li>The most important player in manipulating the display element is
called <em>screen memory map</em>.</li>
<li>It is a designated area which is part of the data memory(RAM).</li>
<li>The physical display unit is continuously refreshed from the
contents of the memory map, and this happens many times each second. in
the next refresh cycle,what is changed in the memory is going to be
reflected on the screen.</li>
</ul>
<p><img src="/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/image.png"></p>
<h4 id="bscreen-memory-map">  <span class="math inline">\(b.\)</span>Screen memory map</h4>
<p>  Our display unit looks like this:</p>
<p><img src="/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/image-1.png"></p>
<p>  It's a <em>table</em>, or a <em>matrix</em>, consisting of 256 rows
and 512 columns. And in each intersection of a row and a column, we have
what is known as a <em>pixel</em>. This is a black and white screen, so
we can either turn the pixel on or we can turn it off.</p>
<p>  We can use out screen memory map to manipulate it, which looks like
this:</p>
<p><img src="/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/image-2.png"></p>
<ul>
<li><p>It's a sequense of 16-bit values. Each one of these values is
called <em>word</em>.</p></li>
<li><p>For every pixel on the physical display unit, we have a bit that
represents this pixel in the screen memory map. If I want to turn on
this pixel, I put 1 in this bit, if I want to turn it off,I put 0 in
this bit.</p></li>
<li><p>To set <code>pixel(row, col)</code>on/off:</p>
<ol type="1">
<li><p><code>word = Screen[row*32 + col/16]</code></p>
<ul>
<li><strong>We cannot access individual bits</strong>.If we want to
access an individual bit, we have to first figure out <strong>in which
word this bit resides</strong>. And then I have to retrieve the entire
word, manipulate this particular bit and finally write it back into
memory.</li>
</ul></li>
<li><p><code>word = RAM[16384 + row*32 + col/16]</code></p>
<ul>
<li>If we access the <strong>screen chip</strong>, we simply use <span class="math inline">\(row\times 32+{col\over 16}\)</span>. But if we
access the <strong>OVERALL RAM</strong>, we have to take this
<strong>relative address</strong> and add it to the <strong>base
address</strong> of the memory of the memory map in the overall memory,
which happens to be 16384.</li>
</ul></li>
<li><p>Set <code>col%16</code> bit of <code>word</code> to 0 or
1</p></li>
<li><p>Commit <code>word</code> to the RAM</p></li>
<li><ol type="1">
<li>and (4) are done using 16-bit RAM access operations.</li>
</ol></li>
</ol></li>
</ul>
<h3 id="2input">2.Input</h3>
<h4 id="akeyboard">  <span class="math inline">\(a.\)</span>Keyboard</h4>
<ul>
<li>The physical keyboard is connected to the computer using a cable. If
you will trace this cable, you will see that it goes into <strong>an
area in the RAM</strong> which is called <em>keyboard memory
map</em>.</li>
</ul>
<h4 id="bkeyboard-memory-map">  <span class="math inline">\(b.\)</span>Keyboard memory map</h4>
<ul>
<li>Keyboard memory map is a single 16-bit register:</li>
</ul>
<p><img src="/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/image-3.png"></p>
<ul>
<li><p>When a key is pressed on the keyboard, the key's
<strong>scan-code</strong>, which is an agreed-upon value, travels
through the cable and appears in the keyboard memory map.</p>
<ul>
<li><span class="math inline">\(e.g.\)</span> If I press 'K', 75 is
going to appear in its binary manifestation in the in the keyboard
chip.</li>
</ul></li>
</ul>
<p><img src="/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/image-4.png"></p>
<ul>
<li><p>if you want to check if which key is currently pressed, all we
have to do is <strong>probe the contents of the keyboard
chip</strong>.</p>
<ul>
<li>In Hack computer, We probe the contents of RAM in address 24576, for
this is where the keyboard memory map happens to reside.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>4.4.Hack语言规范</title>
    <url>/2024/04/05/4-4-Hack%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="44hack-language-specification"><span class="math inline">\(4.4.\)</span>Hack Language Specification</h1>
<h3 id="1the-binary-syntax-for-ainstruction">1.The binary syntax for A
instruction</h3>
<ul>
<li><p>The first zero of a binary number is called <em>operate code</em>
in HL.</p></li>
<li><p>Syntax: Starts with <code>0</code>, and the <code>value</code> is
less or equal than <span class="math inline">\(2^{15}-1\)</span>.</p>
<ul>
<li>For example: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//set A register to 21</span><br><span class="line">0000000000010101</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="2the-binary-syntax-for-cinstruction">2.The binary syntax for C
instruction</h3>
<p>  The binary syntax correspond to symbolic syntax is as below:</p>
<p><img src="/2024/04/05/4-4-Hack%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/image.png"></p>
<ul>
<li>The <code>comp</code> mapping table from symbolic to binary is as
below:</li>
</ul>
<p><img src="/2024/04/05/4-4-Hack%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/image-1.png"></p>
<ul>
<li>The <code>dest</code> mapping table from symbolic to binary is as
below:</li>
</ul>
<p><img src="/2024/04/05/4-4-Hack%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/image-2.png"></p>
<ul>
<li>The <code>jump</code> mapping table from symbolic to binary is as
below:</li>
</ul>
<p><img src="/2024/04/05/4-4-Hack%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/image-3.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>3.4.计数器</title>
    <url>/2024/04/05/3-4-%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="34counter"><span class="math inline">\(3.4.\)</span>Counter</h1>
<h3 id="1counter-intro">1.Counter intro</h3>
<p>  A counter is used to direct certain instruction among instructions.
It contains these features:</p>
<ul>
<li><code>Reset</code>: Fetch the first instruction.</li>
<li><code>Next</code>: Fetch the next instruction.</li>
<li><code>Goto</code>: Fetch instruction n.</li>
</ul>
<p>   Its "black box" diagram looks like this:</p>
<p><img src="/2024/04/05/3-4-%E8%AE%A1%E6%95%B0%E5%99%A8/image.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 3.Memory</category>
      </categories>
  </entry>
  <entry>
    <title>3.3.存储单元</title>
    <url>/2024/04/04/3-3-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<h1 id="33memoryunits"><span class="math inline">\(3.3.\)</span>Memory
Units</h1>
<h3 id="1from-1-bit-to-register">1.From 1-bit to register</h3>
<p>  the previous unit ended up with a description of how a single bit
register works. And it doesn't take a big stretch of imagination to
understand that you can <strong>take several such one bit register and
put them one next to the other</strong>. And by doing this, you can
create <em>an abstraction of a 16-bit number</em>.</p>
<p><img src="/2024/04/04/3-3-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/image.png"></p>
<ul>
<li>The <strong>width</strong> of the register, in general, is a
parameter called <span class="math inline">\(w\)</span>. In some
computers it's 16-bit, in other computers it may be 32-bits or
64-bit.</li>
<li>The register's <strong>state</strong> refers to the value which is
currently stored in the register.</li>
</ul>
<p>  let's take a user's perspective of this of this device:</p>
<ul>
<li>How do we <strong>read</strong> the value of this register? We
simply probe the output. Because at any given point of time, the output
simply emits the state of the register.</li>
<li>How do we <strong>write</strong> the value of this register? We set
<code>in</code> to the new value <span class="math inline">\(v\)</span>,
and set <code>load</code> to 1, then the register state becomes 1.</li>
<li>And from the next cycle onward, the output of the register will also
start emitting this value <span class="math inline">\(v\)</span>. From
the next cycle onward, the register will effectively store the value
<span class="math inline">\(v\)</span>. And it will keep on storing this
value forever until we decide to change this value in the very same
manner.</li>
</ul>
<h3 id="2ram">2.RAM</h3>
<p>  A RAM can be abstracted as a sequence of n addressable registers,
with addresses from 0 to n-1:</p>
<p><img src="/2024/04/04/3-3-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/image-1.png"></p>
<ul>
<li>There's one thing very important to emphasize: at any given point
of time, <strong>only one register is selected and only one register is
working</strong>, all the other registers don't take any part in the
game.</li>
</ul>
<p>  Given this fact, we have to say <strong>which is the register on
which we want to operate</strong>, <strong>which is the register that we
want to read</strong>, or <strong>which is the register whose value we
want to change</strong>.</p>
<ul>
<li><p>To <strong>read</strong> a particular register, we:</p>
<ol type="1">
<li>Sent the address to RAM.</li>
<li>Probe the output.</li>
</ol></li>
<li><p>To <strong>write</strong> a particular register, we:</p>
<ol type="1">
<li>Sent the address to RAM.</li>
<li>Set the value and <code>load</code>.</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 3.Memory</category>
      </categories>
  </entry>
  <entry>
    <title>3.2.触发器</title>
    <url>/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="32flipflops"><span class="math inline">\(3.2.\)</span>Flip
Flops</h1>
<h3 id="1clocked-data-flip-flops">1.Clocked Data Flip Flops</h3>
<p>  To implement the sequential logic, we need an element that
<em>remember one bit of information from <span class="math inline">\(t-1\)</span> so that it can be used at time <span class="math inline">\(t\)</span></em>. It remembers by "flipping"
between the possible states. Such gates that can flip between two states
are called <em>Flip Flop</em>:</p>
<p><img src="/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/image.png"></p>
<p>  Take the clock below as example:</p>
<p><img src="/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/image-1.png"></p>
<ul>
<li>At time 1, we don't exactly know what our output will be because we
haven't specified what happened in the previous time unit. So we just
don't know what the output is.</li>
<li>At time 2, the output is exactly what the input was in time 1,
<code>1</code>.</li>
<li>......</li>
</ul>
<h3 id="2sequential-logicimplementation">2.Sequential logic
implementation</h3>
<p>  Here is a generic paradigm of how we're going to build all our
logic in the computer, and it's going to be a combination
of <em>remembering information via this basic D flip flops</em> and then
<em>manipulating them using combinatorial logics</em>:</p>
<p><img src="/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/image-2.png"></p>
<ul>
<li>We have an array of D flip flops which basically compromise all of
our memory in the system.</li>
<li>Their output is going to be fed into some combinatorial
logic together with the new input that you get in this time unit.</li>
<li>All of this is going to change the state that we have in the D flip
flop for the next time unit.</li>
</ul>
<h3 id="31-bit-register">3.1-bit Register</h3>
<p>  The 1-bit Register has these functionalities:</p>
<ul>
<li>Once we take the load bit and put the 1 into it, we want it
<strong>remember the input bit at that time</strong>.</li>
<li>When the load bit goes down to 0 we want it <strong>keep remembering
the last input that was loaded into it for infinity, until a new load
operation is performed</strong>.</li>
</ul>
<p><img src="/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/image-3.png"></p>
<p>  Notice that there are two source into the DFF: one is the output
from the previous stage, the other is the new input. Whether source to
be chosen is decided by <code>load</code>, so we may use a
<code>Mux</code> to solve this:</p>
<p><img src="/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/image-4.png"></p>
<ul>
<li>The DFF serves the purpose of storing and maintaining the previous
input value in this process. When the load bit is set to 1, the DFF
<strong>stores the input value and holds it unchanged until the next
load operation</strong>. When the load bit is 0, the DFF
<strong>maintains the value from the previous load and continues to
output this value in the next time</strong> unit until a new load
operation occurs. Therefore, the DFF is essentially used to remember and
sustain the state of the input value.</li>
<li><strong>The final output is determined by the multiplexer
(Mux)</strong>. The DFF is responsible for storing the previously loaded
value and sending it to the multiplexer based on the state of the load
bit. The multiplexer <strong>selects whether to accept the new input
value or the previously loaded value based on the load bit's
status</strong>, and then outputs the selected value.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 3.Memory</category>
      </categories>
  </entry>
  <entry>
    <title>4.2.机器语言组成元素</title>
    <url>/2024/04/04/4-2-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="42the-elements-of-machine-language"><span class="math inline">\(4.2.\)</span>The Elements of Machine Language</h1>
<h3 id="1machine-language">1.Machine language</h3>
<ul>
<li><p>The machine language is a most important <em>interface between
hardware and software</em>. It's exactly the way software can control
hardware.</p>
<ul>
<li>What are the supported operations?</li>
<li>What do they operate on?</li>
<li>How is the program controlled?</li>
</ul></li>
<li><p>This kind of interface is done in a almost one-to-one
correspondence with the actual hardware implementation. The idea is that
the hardware is built in a way that directly corresponds to <em>the type
of functionality that is provided by the software layer above
it</em>.</p></li>
<li><p>When we actually go to design a machine language, the basic
element is a <em>cost-performance tradeoff</em>. The more sophisticated
operations that we want to give our machine language, the more <em>large
or sophisticated data types</em> it operates on, the more
<em>costly</em> it will be to actually build this.</p></li>
<li><p>Each machine language defines a set of operations which fall into
several categories:</p>
<ul>
<li><strong>Arithmetic Operations</strong>: add, subtract, ...</li>
<li><strong>Logical Operations</strong>: <code>And</code>,
<code>Or</code>, ...</li>
<li><strong>Flow Control</strong>: <code>goto instructionX</code>,
<code>if C then goto instruction Y</code></li>
</ul></li>
</ul>
<h3 id="2memory">2.Memory</h3>
<ul>
<li><p>accessing memory is an expensive operation in at least two
related points of view :</p>
<ol type="1">
<li>If you have a large memory, specifying what part of memory you want
to work with requires a large amount of bits.</li>
<li>It's going to be wasteful in terms of instruction, for accessing a
value from a large memory takes relatively long time.</li>
</ol></li>
</ul>
<p>  To solve this, we introduce memory hierarchy*:</p>
<ul>
<li><p>The basic idea is instead of having just one large block of
memory, we're going to have a whole sequence of memories that
<strong>are getting bigger and bigger</strong>.</p>
<ul>
<li><p>The smallest memories are going to be very easy to access.
Because:</p>
<ol type="1">
<li>We don't have to specify large address space because there are only
going to be a very few of them.</li>
<li>The amount of them is small, so we can get information from them
very quickly.</li>
</ol></li>
<li><p>Then, there is going to be slight larger memories called
<em>cache</em>.</p></li>
<li><p>And even big memory, called <em>main memory</em>.</p></li>
<li><p>And maybe even even larger memory called <em>disk</em>.</p></li>
</ul></li>
</ul>
<p><img src="/2024/04/04/4-2-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0/image.png"></p>
<ul>
<li>At each time we get farther away from the arithmetic unit itself,
our memory gets bigger, accessing it becomes harder both in terms of
giving a larger, wider address, and in terms of the time we need to wait
until we get the value. But we have more information there.</li>
</ul>
<h3 id="3registers">3.Registers</h3>
<ul>
<li><p>Almost every CPU has a few <em>easy-accessed registers</em> that
are located inside the CPU. Since there are so few of them and
everything requires very few bits, getting the information of them is
extremely quickly.</p></li>
<li><p>There are two kinds of register:</p>
<ol type="1">
<li><p><em>Data Registers</em>: We can put numbers, etc, in the
register. And when we are saying something like add the register 1 to
register 2, what will happen is <strong>the contents of register
1</strong> will be added to <strong>the contents of register
2</strong>.</p></li>
<li><p><em>Address Register</em>: We can put into the register an
address into main memory. It allow us to specify at which part of the
bigger memory we want to access for operations.</p>
<ul>
<li>For example, say we have a operation like storing the contents of
register 1 into memory address that is specified by that register called
A. Once we actually perform this operation in the hardware, the number
77 will be written into the main memory.</li>
</ul></li>
</ol></li>
</ul>
<p><img src="/2024/04/04/4-2-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0/image-1.png"></p>
<h3 id="4addressing-modes">4.Addressing modes</h3>
<ul>
<li><em>Register</em>: <span class="math inline">\(e.g.\)</span><code>Add R1 R2</code> means adding
R2 to R1.</li>
<li><em>Direct</em>: We can have direct access to memory.<span class="math inline">\(e.g.\)</span> <code>Add R1 M[200]</code> means
adding R1 to memory location <code>200</code>.</li>
<li><em>Indirect</em>: This is a example we had previously for using the
A register where the <code>@A</code> memory address that we access is
not specified as part of instruction, but rather is already written
inside <em>the address register</em> that <strong>was previously loaded
inside the CPU with some correct value</strong>.<span class="math inline">\(e.g.\)</span> <code>Add R1 @A</code></li>
<li><em>Immediate</em>: <span class="math inline">\(e.g.\)</span>
<code>Add R1 73</code></li>
</ul>
<h3 id="5dealing-with-input-andoutput">5.Dealing with input and
output</h3>
<ul>
<li><p>One way to actually access these input or output
devices(keyboard, for example) is to actually <strong>connect the
registers which control these output devices as part of your
memory</strong>.</p>
<ul>
<li>For example, we may have a mouse that is connected in a way that
whenever the user moves the mouse, the last movement is written into
some kind of a register. And that register is accessible by the computer
in a certain address as part of the memory. This gives us access to
input and output as though we are accessing the memory itself.</li>
</ul></li>
<li><p>Software are usually part of the <strong>drivers</strong> in an
operating system. It must know exactly not only <strong>what are the
addresses to which this input or output device is connected</strong>,but
also <strong>how to speak with it</strong>.</p></li>
</ul>
<h3 id="6flow-control">6.Flow control</h3>
<ul>
<li>Sometimes we need to "jump" unconditionally to another location, for
example:</li>
</ul>
<p><img src="/2024/04/04/4-2-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0/image-2.png"></p>
<ul>
<li>Sometimes we need to jump only if some condition is met, for
example:</li>
</ul>
<p><img src="/2024/04/04/4-2-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0/image-3.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>4.3.机器语言</title>
    <url>/2024/04/04/4-3-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="43machine-language"><span class="math inline">\(4.3.\)</span>Machine Language</h1>
<h3 id="1background-knowledge-ofhack-computer">1.Background knowledge of
Hack Computer</h3>
<h4 id="ahardware">  <span class="math inline">\(a.\)</span>Hardware</h4>
<p><img src="/2024/04/04/4-3-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/image.png"></p>
<ul>
<li><em>Data memory</em>(RAM): It is a sequence of 16-bit values.And
each of these values is going to be stored in a memory register</li>
<li><em>Instruction memory(ROM)</em>: It is a separate memory space that
is also a sequence of 16 bit values.</li>
<li><em>CPU</em>: It is a device which is capable of
<strong>manipulating 16 bit values</strong> using mostly the ALU which
resides inside the CPU.</li>
<li><em>Instruction buses, data buses, address buses</em>: It enables us
to move data from one place to another.</li>
</ul>
<p>  The Hack machine language recognizes three registers:</p>
<ul>
<li>D holds a 16-bit value</li>
<li>A holds a 16-bit value</li>
<li>M represents the 16-bit RAM register addressed by A</li>
</ul>
<h4 id="blanguage">  <span class="math inline">\(b.\)</span>Language</h4>
<ul>
<li><p>The Hack machine language includes:</p>
<ul>
<li>16-bit A-instructions</li>
<li>16-bit C-instructions</li>
</ul></li>
</ul>
<h4 id="cregister">  <span class="math inline">\(c.\)</span>Register</h4>
<p>  The hack computer recognizes three registers:</p>
<ol type="1">
<li><em>D register</em>: It holds a 16-bit data which represent a piece
of <strong>data</strong>.</li>
<li><em>A register</em>: It holds a 16-bit data which represent either a
<strong>data value</strong> or an <strong>address</strong>.</li>
<li><em>M register</em>. It is called <strong>selected memory
register</strong>.</li>
</ol>
<h3 id="2syntax">2.Syntax</h3>
<h4 id="aainstruction">  <span class="math inline">\(a.\)</span>A
instruction</h4>
<ul>
<li><p>Syntax: <code>@value</code>, value is either:</p>
<ul>
<li>a non-negative decimal constant or</li>
<li>a symbol referring to such a constant</li>
</ul></li>
<li><p>Semantics:</p>
<ol type="1">
<li>Sets the A register to value</li>
<li>Side effect: RAM[A]becomes the selected RAM register.</li>
</ol></li>
<li><p>We always need A instruction before we operate on the
memory.</p></li>
</ul>
<p>  <span class="math inline">\(e.g.\)</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//set RAM[100] to -1</span><br><span class="line">@100 //A = 100</span><br><span class="line">M = -1 //RAM[100] = -1, M denotes register number 100 in the memory unit</span><br></pre></td></tr></table></figure> ####
  <span class="math inline">\(b.\)</span>C instruction</p>
<ul>
<li><p>syntax:`dest=comp; jump.</p></li>
<li><p><code>comp</code> contains:<code>0</code>, <code>1</code>,
<code>-1</code>, <code>D</code>, <code>A</code>, <code>-D</code>,
<code>!A</code>, <code>D-A</code>, <code>D+1</code>, <code>D-M</code>,
etc.</p></li>
<li><p><code>dest</code>: We have 8 possible
destination:<code>null</code>, <code>D</code>, <code>M</code>,
<code>MD</code>, <code>A</code>, <code>AM</code>, <code>AD</code>,
<code>AMD</code>(<code>M</code> refers to RAM)</p>
<ul>
<li><code>null</code> means we don't want to to store the results of a
computation at all.</li>
<li>We can store the result in RAM register or D-register and
simultaneously both in M and in D. That is, we can simultaneously in
more than one containers, and the programmer is free to use any he
wants.</li>
<li><code>jump</code>: <code>null</code>, <code>JGT</code>,
<code>JEQ</code>, <code>JGE</code>, <code>JLT</code>, <code>JNE</code>,
<code>JLE</code>,<code>JMP</code>. They always compare the result of the
computation to 0. And <code>if (comp jump 0)</code> jumps to execute the
instruction in RAM[A].<br>
</li>
<li>If we want to do unconditional jump, we do <code>0; JMP</code>.</li>
</ul></li>
<li><p>Semantics:</p>
<ol type="1">
<li>Compute the value of comp</li>
<li>Stores the result in dest:</li>
<li>If the Boolean expression (comp jump B)is true,</li>
<li>jumps to execute the instruction stored in ROM[A].</li>
</ol></li>
</ul>
<p>  <span class="math inline">\(e.g.\)</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//if (D-1==0) jump to execute the instruction stored in ROM[56]</span><br><span class="line">@56</span><br><span class="line">D-1; JEQ</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>3.1.时序逻辑</title>
    <url>/2024/04/04/3-1-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1 id="31sequential-logic"><span class="math inline">\(3.1.\)</span>Sequential Logic</h1>
<h3 id="1background">1.Background</h3>
<p>  In the previous chapter, we've completely ignored the issue of
time:</p>
<ul>
<li><p><strong>Everything happened immediately</strong>, there were
inputs and immediately the outputs were some function of them.</p></li>
<li><p><strong>The inputs never change</strong>, we didn't have any
notion of change.</p></li>
<li><p>We didn't have any notion of things <strong>happening one thing
after another</strong>. Just was some kind of logical mapping from
inputs to outputs.</p></li>
</ul>
<p>  So, there are two things that we want to complement:</p>
<ol type="1">
<li><p>Be able to use the same hardware to <strong>compute many things
one time after another</strong>. We need to be able to reuse our
hardware.</p>
<ul>
<li>For example, if we take some kind of loop in a hard, in a, in some
kind of software program, that the loop calls for doing the same thing
many times, we want to be able to use a same hardware to do that.</li>
</ul></li>
<li><p><strong>Remember things from the past</strong>.When we need to
remember intermediate results,we need to remember where we are in a
computation.</p></li>
</ol>
<h3 id="2the-clock">2.The clock</h3>
<p>  What we're going to do is to <strong>convert the continuous
physical time into discrete time</strong>.</p>
<p>  To do this, we're going to have a <em>clock</em>:</p>
<ul>
<li>It is some kind of <em>oscillator going up and down at a certain
fixed rate</em>.</li>
<li>Each cycle of the clock is treated as one <em>digital integer time
unit</em>.</li>
</ul>
<p><img src="/2024/04/04/3-1-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/image.png"></p>
<ul>
<li><p>With each time unit, we are going to deal it as a indivisible
thing. <em>Nothing changes in a time unit</em>.</p></li>
<li><p>In a time unit, it will compute the output from the input <em>in
an instantaneous manner</em>.</p></li>
</ul>
<h3 id="3delay">3.Delay</h3>
<p>  However, for a physical signal, it doesn't change instantaneously
in a number time between time as we suppose. In reality, the little
course current builds slowly, and the voltage may change slowly. That is
to say, the actual analog signal takes time to reach its final stage,
both input and output.</p>
<p><img src="/2024/04/04/3-1-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/image-1.png"></p>
<p>  Therefore, we will give ourselves enough time between consecutive
time units. For example, we will give the logical operations <em>at the
end of the grey area</em> to make sure that <em>all the hardware there
really stabilizes:</em></p>
<p><img src="/2024/04/04/3-1-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/image-2.png"></p>
<p>  And then,we can simply ignore these inconsistencies because
now,whatever happened before the gray area,we don't need to worry about
it because we know it's gone by the end of the clock cycle.</p>
<h3 id="4combinatorial-logic">4.Combinatorial logic</h3>
<ul>
<li>Combinatorial logic: It's a stateless logic, where <em>the output
depends solely on the current input state:</em><span class="math inline">\(out(t)=f(in(t))\)</span>. Our ALU and bool chips
take this logic.</li>
<li>Sequential logic: <span class="math inline">\(out(t)=f(in(t-1))\)</span>.</li>
</ul>
<h3 id="5state-feedback">5.State feedback</h3>
<ul>
<li><p>The sequential logic points out a new way of thinking, which is
to <strong>consider inputs and outputs as the same bits, capable of
being transmitted on the same bus and occupying the same hardware
location</strong>. This design allows us to <strong>feed output values
back to the input</strong>, creating a <strong>state</strong> rather
than simply passing data. Thus, we can use a particular bit in the
circuit to store state information rather than solely transmitting
data.</p></li>
<li><p>This new way of thinking alters our understanding of time.
Instead of viewing time as continuous, we now divide it into discrete
integer time steps and observe the events happening sequentially at each
time step. This approach enables us to <strong>change the state
incrementally</strong>, remembering the result from the previous time
step at each subsequent step and building upon it.</p></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 3.Memory</category>
      </categories>
  </entry>
  <entry>
    <title>2.4.算术逻辑单元</title>
    <url>/2024/04/04/2-4-%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<h1 id="24arthimetic-logic-unit"><span class="math inline">\(2.4.\)</span>Arthimetic Logic Unit</h1>
<h3 id="1alu-intro">1.ALU intro</h3>
<p>  The Arithmetic Logic Unit (ALU) is a crucial component in
computers, responsible for <em>executing various arithmetic and logic
operations</em>. Typically <em>part of the CPU</em>, it handles
arithmetic operations such as addition, subtraction, multiplication, and
division, as well as logic operations including <code>AND</code>,
<code>OR</code>, <code>NOT</code>, and <code>XOR</code>, based on
instructions provided.</p>
<h3 id="2alu-structure">2.ALU structure</h3>
<p>  We can describe the ALU through the diagram below:</p>
<p><img src="/2024/04/04/2-4-%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/image.png"></p>
<ul>
<li><p>The ALU computes a function on the two inputs, and outputs the
result.</p></li>
<li><p><strong>f</strong>:one out of a family of pre-defined arithmetic
and logical functions. It contains:</p>
<ul>
<li>Arithmetic operations:integer addition, multiplication, division,
...</li>
<li>Logical operations: And, Or, Xor....</li>
</ul></li>
</ul>
<blockquote>
<p><span class="math inline">\(p.s.\)</span>There is a interesting
question towards ALU: Which operation should ALU operate? If we choose
to ignore some operation in ALU, when we want to use it, we have to
implement it in the software. This is also called a <em>Hardware and
Software trade off</em>.</p>
</blockquote>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 2.Boolean Calculation &amp; ALU</category>
      </categories>
  </entry>
  <entry>
    <title>2.3.二进制运算</title>
    <url>/2024/04/04/2-3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="23binary-arithmetic"><span class="math inline">\(2.3.\)</span>Binary Arithmetic</h1>
<h3 id="1negative-numberrepresentation">1.Negative number
representation</h3>
<p>  For a negative number <span class="math inline">\(x\)</span>, we
use <span class="math inline">\(2^n - x\)</span> to represent it.</p>
<ul>
<li><span class="math inline">\(e.g.\)</span>-4 is represent as
<code>1100</code> in four-bit binary number, also equal to 16-4=12.</li>
</ul>
<p>  In order not to mistake this representation with positive number,
we prescribe that <em>a positive number cannot use the left-most bit to
represent number</em>.</p>
<h3 id="2binary-addition">2.Binary addition</h3>
<p>  Before discuss the numerical addition, we first take a look at the
bit-to-bit addition. We use the folloing API to deal with the carry:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP AddBit &#123;</span><br><span class="line">	IN a, b;</span><br><span class="line">	OUT out, carry;</span><br><span class="line"></span><br><span class="line">	PARTS:</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  After the implementation, for a number, we just need to do
<code>AddBit</code> for each bit of it.</p>
<blockquote>
<p><span class="math inline">\(p.s.:\)</span>How do we deal with the
following 4-bit addition<code>1000 + 1100</code>?   The answer is
<code>0100</code>. This is because the left-most bit addition gets a
carry, but it is out of the bit range. This is called <em>integer
overflow</em>. When facing this, the computer will do <span class="math inline">\(\mod 2^n\)</span> to the true result, where <span class="math inline">\(n\)</span> is the bit number.</p>
</blockquote>
<blockquote>
<p><span class="math inline">\(p.s:\)</span>By the <em>integer
overflow</em> theory, we can prove that the <em>simple positive addition
also suits negative numbers</em>.</p>
<p><span class="math inline">\(proof:\)</span>Assume there are two
negative number <span class="math inline">\(x,y\)</span>, they are
represented as <span class="math inline">\(2^n-x,2^n-y\)</span>. Add
them together, and we get <span class="math inline">\(2^{n+1}-x-y\)</span>. The result apparently
overflow the range, so<span class="math inline">\(\mod 2^n\)</span>, and
we get <span class="math inline">\(2^n - x - y\)</span>. This is the
binary representation of <span class="math inline">\(-x-y\)</span>,
<span class="math inline">\(QED\)</span>.</p>
</blockquote>
<h3 id="3binary-subtraction">3.Binary subtraction</h3>
<p>  To do subtraction, we just need to add a number's negation. We know
that <span class="math inline">\(-x\)</span> is represented as <span class="math inline">\(2^n-x\)</span>. Let's do some transformation
like:</p>
<p><span class="math display">\[(2^n-1)-x+1\]</span></p>
<p>  Why this? Notice that <span class="math inline">\(2^n-1\)</span> is
<code>1111</code>, and it's easy to subtract other number, for carry
will never occur in this instance. For <span class="math inline">\(+1\)</span>, since we have implement addition,
it's also easy.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 2.Boolean Calculation &amp; ALU</category>
      </categories>
  </entry>
  <entry>
    <title>1.5.硬件模拟</title>
    <url>/2024/04/03/1-5-%E7%A1%AC%E4%BB%B6%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1 id="15hardware-simulation"><span class="math inline">\(1.5.\)</span>Hardware simulation</h1>
<ol type="1">
<li><p><strong>Interactive Simulation:</strong> We can load an HDL file
into a hardware simulator program, which allows us to interactively test
various operations of the chip. This mode of testing is called
interactive simulation.</p></li>
<li><p><strong>Script-Based Simulation:</strong> Alternatively, we can
write a test script in a special testing language designed for this
purpose. This script outlines predetermined tests, enabling systematic
testing of the chip's functionality without manual interaction. This
mode is called script-based simulation.</p></li>
<li><p><strong>Output Comparison:</strong> We can record simulation
output to an output file and compare it to a desired output stored in a
compare file. This allows us to validate the chip's behavior against
expected results. Moreover, we can change our test script to compare
file, so that it can do comparation.</p></li>
</ol>
<ul>
<li><p>Additionally, we'll discuss the use of compare files, which
enable comparison of simulation outputs with desired results. These
files can be generated through behavioral simulation, where the chip
logic is implemented in high-level languages and tested before HDL
implementation.</p></li>
<li><p><strong>System architect</strong>: They design how to achieve the
functionality, breaking the overall behaviour into smaller chips. They
offer:</p>
<ul>
<li>A chip API</li>
<li>A test script</li>
<li>A compare file</li>
</ul></li>
<li><p><strong>Developer</strong>: You receive stub files documenting
chip interfaces, along with test scripts and compare files prepared by
system architects. Your task will be to write the HDL code to implement
the missing functionality.</p></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 1.Boolean Function</category>
      </categories>
  </entry>
  <entry>
    <title>1.4.硬件描述语言</title>
    <url>/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="14hardware-description-language"><span class="math inline">\(1.4.\)</span>Hardware description language</h1>
<h3 id="1logic-gate">1.Logic gate</h3>
<ul>
<li>An <em>elementary logic gate</em> is an elementary chip which is
designed to deliver a well-defined functionality.</li>
<li>A <em>composite logic gate</em> is one which is made up from
elementary logic gate and other composite logic gates.</li>
</ul>
<p>  The <code>AND</code> gate, <code>OR</code> gate and
<code>NOT</code> gate can be represented by these diagrams:</p>
<p><img src="/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/image.png"></p>
<p><img src="/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/image-1.png"></p>
<p>  By connecting the elementary gate together, we can get composite
gates that have more complicated funtionality. For example:</p>
<p><img src="/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/image-2.png"></p>
<h3 id="2hdl">2.HDL</h3>
<h4 id="aintro">  <span class="math inline">\(a.\)</span>Intro</h4>
<p>  We can actually build and implement the logic gates using a
formalism called <em>Hardware Description Language</em> or HDL. Once you
build a logic gate in HDL,you can actually simulate it, test it.And
finally,build it in hardware.</p>
<p>  The hardware description of a logic gate contains these
structure:</p>
<ul>
<li><em>Interface</em>: It describe what the chip takes in as input and
the output.</li>
<li><em>Implementation</em>: It describe how the chip achieves its
functionality.</li>
</ul>
<p>  For example the gate below can be describe as :</p>
<p><img src="/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/image-3.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP Xor &#123;</span><br><span class="line">	IN a, b;</span><br><span class="line">	OUT out;</span><br><span class="line">	</span><br><span class="line">	PARTS:</span><br><span class="line">	Not (in = a, out = nota);</span><br><span class="line">	Not (in = b, out = notb);</span><br><span class="line">	And (a = a, b = notb, out = aAndNotb);</span><br><span class="line">	And (a = nota, b = b, out = NotaAndb);</span><br><span class="line">	Or (a = aAndNotb, b = NotaAndb, out = out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bdiagram-development">  <span class="math inline">\(b.\)</span>Diagram development</h4>
<p>  Then how can we develop a diagram through its functionality
description? The following steps might help:</p>
<ol type="1">
<li><p><em>draw the boundary of the chip diagram.</em></p>
<ul>
<li>we use this dash to outline for this purpose and what remains
outside the boundary is the user's view of this gate. In other
word,the,the gate interface.All the users knows is that he or she has a
gate that has two inputs,a and b,an output called out and
altogether.They somehow, this chip as if by magic,delivers Xor
functionality</li>
</ul></li>
</ol>
<p><img src="/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/image-4.png"></p>
<ol start="2" type="1">
<li><p>Notice how the a signal is being copied and sent simultaneously
into two different destinations.Take a as an example, one of them is
sent to <code>And</code> gate and the other <code>Not</code>
gate.</p></li>
<li><p>Whenever you use an off-the-shelf gate,you are bound to <em>use
the names of the gate's input and output as advertised.</em></p>
<ul>
<li>In other words, the gate comes along with what can be called the
gate's signature or the gate's APl. So we have no degrees of freedom
here.</li>
</ul></li>
<li><p>The red connections are use to <em>connect the different chip
parts together</em>. The rule is that every one of these connections
<em>has to be named</em> and it's our responsibility to come up with
self-descriptive names.</p></li>
</ol>
<h4 id="csomefeatures">  <span class="math inline">\(c.\)</span>Some
features</h4>
<ul>
<li><p>The interface of one chip is <strong>unique</strong>. That's
because there's only one way to describe the chip.</p></li>
<li><p>The implementation of one chip is not unique, however.</p></li>
<li><p>HDL is a <em>functional or declarative language</em>. There is no
procedure going on.There's no program execution going on. It is nothing
more than <em>a static description of the gate diagram</em>.</p>
<ul>
<li>So because HDL is a functional language,we can actually write those
HDL statements <em>in any order that we wish</em>.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 1.Boolean Function</category>
      </categories>
  </entry>
  <entry>
    <title>1.2.布尔函数合成</title>
    <url>/2024/04/03/1-2-%E5%B8%83%E5%B0%94%E5%87%BD%E6%95%B0%E5%90%88%E6%88%90/</url>
    <content><![CDATA[<h1 id="12boolean-function-construction"><span class="math inline">\(1.2.\)</span>Boolean function construction</h1>
<h3 id="1basic-method">1.Basic method</h3>
<p>  Our goal is to create a boolean function that fits in the given
truth table. To achieve this, we can do the following steps:</p>
<ol type="1">
<li>Select the line that has the bool value <code>0</code>and
<code>1</code> separately.</li>
<li>For each line that has the bool value <code>0</code>, create a
function that is able to get the value.</li>
<li>Combine these functions with <code>or</code>, thus get a new
function(say <code>f1</code>).</li>
<li>Do the same thing for bool value <code>1</code>，and get a new
function <code>f2</code>.</li>
<li>Combine the two function with <code>and</code> :
<code>f1 and f2</code>.</li>
</ol>
<p>  Take this truth table as an example:</p>
<p><img src="/2024/04/03/1-2-%E5%B8%83%E5%B0%94%E5%87%BD%E6%95%B0%E5%90%88%E6%88%90/image.png"></p>
<ul>
<li>For line 1, 3, 5 that equal <code>1</code>, we each get:
<code>NOT x</code>, <code>NOT x</code>, <code>NOT y</code>.</li>
<li>Thus the new function for <code>1</code> is
<code>NOT x OR NOT x OR NOT y</code>.(Actually, it could have multiple
forms)</li>
<li>For line 2, 4, 6, 7, 8, we each get: <code>NOT z</code>,
<code>NOT y</code>, <code>NOT x</code>, <code>NOT x</code>,
<code>NOT x</code>, <code>NOT x</code>.</li>
<li>Thus the new function for <code>0</code> is
<code>NOT x OR NOT y OR NOT x OR NOT x OR NOT x OR NOT x OR NOT x OR NOT x</code>.</li>
<li>Combine the two new functions, we get the final result:
<code>(NOT x OR NOT x OR NOT y) AND (NOT x OR NOT y OR NOT x OR NOT x OR NOT x OR NOT x OR NOT x OR NOT x)</code>.</li>
</ul>
<p>  Once we get the final result, we can use boolean function
calculation to simplify it.</p>
<h3 id="2simplify-the-system">2.Simplify the system</h3>
<p>  Actually, we don't need <code>OR</code> to join the process, we can
complete the task only by <code>AND</code> and <code>NOT</code>. This is
because the <em>De Morgan's laws</em> allow us to transform an
<code>OR</code> into <code>AND</code> clause.</p>
<p>  Furthermore, we define <code>NAND</code> as <code>NOT AND</code>.
For example, <code>x NAND y</code> is equal to <code>NOT x AND y</code>.
We can prove that every boolean function can be represented by only the
<code>NAND</code> statement.</p>
<p>  <span class="math inline">\(proof:\)</span>Since we are able to
represent all boolean functions by <code>AND</code> and
<code>NOT</code>, we only need to represent <code>AND</code> and
<code>NOT</code> using <code>NAND</code>:</p>
<ul>
<li><code>NOT x</code> can be represented by <code>x NAND x</code>, this
is obvious.</li>
<li><code>x AND y</code> can be represent by
<code>(x NAND y)NAND(x NAND y)</code>. We can rewrite the statement as
<code>NOT(NOT x AND y)</code>, the statement in the parentheses is
<code>x NAND y</code> itself, so it is transform into
<code>NOT x NAND y</code>. Using <code>NOT</code> representation again,
and we get the result.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 1.Boolean Function</category>
      </categories>
  </entry>
</search>
