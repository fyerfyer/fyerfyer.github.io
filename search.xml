<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.1.Great Indea Intro</title>
    <url>/2024/05/18/1-1-Great-Idea-Intro/</url>
    <content><![CDATA[<h3><span id="1cs61c-intro">1.CS61C intro</span></h3>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-4.png"></p>
<ul>
<li>The hareware is composed of <strong>a gazillion computers in
parallel</strong>.</li>
<li>The computers are consisted of <strong>parallel computers within the
processing unit</strong>.</li>
<li>We get parallelism all the way down the stack.</li>
</ul>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-5.png"></p>
<h3><span id="2abstraction">2.Abstraction</span></h3>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image.png"></p>
<ul>
<li>Each level of abstraction is only influenced by <strong>the level
above or below by one</strong>.</li>
<li>We can change out the architecture and keep the same machine
language to make program run faster.</li>
</ul>
<h3><span id="3moores-law">3.Moore's law</span></h3>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-1.png"></p>
<ul>
<li><em>Moore's law</em>: Over time, the number of transistors that's
actual switches keeps growing exponentially.</li>
<li>However, we hit a brick wall that getting more performance is no
longer a matter of improving processes and adding transistors, but
<strong>exploiting parallelsome</strong>.</li>
</ul>
<h3><span id="4localitymemory-hierarchy">4.Locality/Memory Hierarchy</span></h3>
<ul>
<li>It's about <strong>how far away is a piece of data</strong>.</li>
</ul>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-2.png"></p>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-3.png"></p>
<h3><span id="5parallelism">5.Parallelism</span></h3>
<ul>
<li>We do lots of things at once, even within the most processor.</li>
<li>On the program, we spilt things up.</li>
</ul>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-6.png"></p>
<ul>
<li>However, there's a limit called <em>Amdahl's Law</em>: The amount
you can speed up something by parallelization depends on <strong>the
amount that's actually parallelizable</strong>. If the problem isn't
parallelizable, then it will fail.</li>
</ul>
<h3><span id="6dependability-viaredundancy">6.Dependability via
redundancy</span></h3>
<ul>
<li>To deal with failures, we use <em>redundancy</em> so that a failing
piece doesn't make the whole thing fail:</li>
</ul>
<p><img src="/2024/05/18/1-1-Great-Idea-Intro/image-7.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 1.Intro</category>
      </categories>
  </entry>
  <entry>
    <title>1.2.Number Representation</title>
    <url>/2024/05/19/1-2-Number-Representation/</url>
    <content><![CDATA[<h1><span id="12number-representation"><span class="math inline">\(1.2.\)</span>Number Representation</span></h1>
<h3><span id="1binary-representation">1.Binary representation</span></h3>
<p><img src="/2024/05/19/1-2-Number-Representation/image.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-1.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-2.png"></p>
<ul>
<li>We move -1 to the right by one, -2 to the right, etc. Then the two
0s overlap:</li>
</ul>
<p><img src="/2024/05/19/1-2-Number-Representation/image-3.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-4.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-5.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-6.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-7.png"></p>
<h3><span id="2bias-encoding">2.Bias encoding</span></h3>
<p><img src="/2024/05/19/1-2-Number-Representation/image-8.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-9.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-10.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-11.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-12.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-13.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-14.png"></p>
<ul>
<li>Because the biased number are all <strong>start at 0</strong>,
<strong>the MSB doesn't represent the sign anymore</strong>. So in
floating point, we can compare two biased number directly as if they
were unsigned number.</li>
</ul>
<h3><span id="3iec-standard-prefixes">3.IEC standard prefixes</span></h3>
<p><img src="/2024/05/19/1-2-Number-Representation/image-15.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-16.png"></p>
<p><img src="/2024/05/19/1-2-Number-Representation/image-17.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 1.Intro</category>
      </categories>
  </entry>
  <entry>
    <title>1.3.C Intro</title>
    <url>/2024/05/22/1-3-C-Intro/</url>
    <content><![CDATA[<h1><span id="13c-intro"><span class="math inline">\(1.3.\)</span>C Intro</span></h1>
<h3><span id="1c-compilation">1.C compilation</span></h3>
<p><img src="/2024/05/22/1-3-C-Intro/image.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-1.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-2.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-3.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-4.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-5.png"></p>
<h3><span id="2some-c-grammar">2.Some C grammar</span></h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-6.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-7.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-8.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-9.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-10.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-11.png"></p>
<h3><span id="3c-pointer">3.C pointer</span></h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-12.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-13.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-14.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-15.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-16.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-17.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-18.png"></p>
<h3><span id="4pointer-operation">4.Pointer operation</span></h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-19.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-20.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-21.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-22.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-23.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-24.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-25.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-26.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-27.png"></p>
<blockquote>
<p>Why? * <em>Address validity</em>: The pointer is used to store the
memory address and point at the specified data. If we cast an integer to
a pointer, the integer may <strong>not be an valid memory
address</strong>, and visit this address will lead to program crash. *
<em>Type system protection</em>: Cast ignores the protection of the type
system. An important function of the type system is to ensure that the
operations in your code are safe. For example, converting an integer to
a pointer and accessing it, skipping the type system check, might result
in accessing an incorrect data type.</p>
</blockquote>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-28.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-29.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-30.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-31.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-32.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-33.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-34.png"></p>
<h3><span id="5c-string">5.C string</span></h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-35.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-36.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-37.png"></p>
<h3><span id="6c-structures">6.C structures</span></h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-38.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-39.png"></p>
<h3><span id="7error-types">7.Error types</span></h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-40.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-41.png"></p>
<h3><span id="8c-array">8.C array</span></h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-42.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-43.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-44.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-45.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-46.png"></p>
<h3><span id="9endianness">9.Endianness</span></h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-47.png"></p>
<h3><span id="10c-memory-management">10.C memory management</span></h3>
<p><img src="/2024/05/22/1-3-C-Intro/image-48.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-49.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-50.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-51.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-52.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-53.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-54.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-55.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-56.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-57.png"></p>
<blockquote>
<p>For example, the following program is right: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void functionB(int *ptr) &#123;</span><br><span class="line">    printf(&quot;Value: %d\n&quot;, *ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void functionA() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    functionB(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Because
the local variable is stored on the stack during the run of
<code>functionB</code>, it's safe to pass its pointer to the
function.</p>
<p>However, this program is wrong: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* function() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    return &amp;x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void example() &#123;</span><br><span class="line">    int *p = function(); </span><br><span class="line">    printf(&quot;Value: %d\n&quot;, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> After the function is
returned, <strong>the stack frame where <code>x</code> is located is
released</strong>, and <strong>the memory address pointed to by pointer
<code>p</code> may be overwritten by other data</strong>. This can lead
to undefined behavior</p>
</blockquote>
<p><img src="/2024/05/22/1-3-C-Intro/image-58.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-59.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-60.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-61.png"></p>
<blockquote>
<p>Static string constants are typically <strong>stored in read-only
memory</strong>, and modifying these is an undifined behavior in C.</p>
</blockquote>
<p><img src="/2024/05/22/1-3-C-Intro/image-62.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-63.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-64.png"></p>
<blockquote>
<p>The main reason for placing 4 bytes of data on multiples of 4 is to
<strong>optimize the processor's memory access efficiency</strong>.
Suppose a processor has a 4-byte memory bus width. When accessing 4-byte
aligned data, the processor <strong>can retrieve the entire data in one
memory read operation</strong>. If the data is not aligned (for example,
an int spanning two memory addresses) , the processor may <strong>need
to perform two memory reads and then merge the two reads</strong>. This
can cause performance degradation.</p>
</blockquote>
<figure>
<img src="/2024/05/22/1-3-C-Intro/image-65.png" alt="Alt text">
<figcaption aria-hidden="true">Alt text</figcaption>
</figure>
<blockquote>
<p>Let's take an example to illustrate the alignment process:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Example &#123; </span><br><span class="line">	char a; </span><br><span class="line">	int b; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> The <code>a</code> requires 1 byte, and alignment requires
1 byte, so it can be placed at the starting address of the
struction.</p>
<p>The <code>b</code> requires 4 bytes, and alignement requires 4 bytes,
so <strong>it must be placed on a multiple of 4 address.</strong> To
satisfy <code>b</code>'s alignment requirements, the compiler
<strong>inserts three padding bytes after <code>a</code></strong>,
making <code>b</code>'s address a multiple of 4.</p>
</blockquote>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-66.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-67.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-68.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-69.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-70.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-71.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-72.png"></p>
<hr>
<p><img src="/2024/05/22/1-3-C-Intro/image-73.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-74.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-75.png"></p>
<p><img src="/2024/05/22/1-3-C-Intro/image-76.png"></p>
<hr>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 1.Intro</category>
      </categories>
  </entry>
  <entry>
    <title>1.2.布尔函数合成</title>
    <url>/2024/04/03/1-2-%E5%B8%83%E5%B0%94%E5%87%BD%E6%95%B0%E5%90%88%E6%88%90/</url>
    <content><![CDATA[<h1><span id="12boolean-function-construction"><span class="math inline">\(1.2.\)</span>Boolean function construction</span></h1>
<h3><span id="1basic-method">1.Basic method</span></h3>
<p>  Our goal is to create a boolean function that fits in the given
truth table. To achieve this, we can do the following steps:</p>
<ol type="1">
<li>Select the line that has the bool value <code>0</code>and
<code>1</code> separately.</li>
<li>For each line that has the bool value <code>0</code>, create a
function that is able to get the value.</li>
<li>Combine these functions with <code>or</code>, thus get a new
function(say <code>f1</code>).</li>
<li>Do the same thing for bool value <code>1</code>，and get a new
function <code>f2</code>.</li>
<li>Combine the two function with <code>and</code> :
<code>f1 and f2</code>.</li>
</ol>
<p>  Take this truth table as an example:</p>
<p><img src="/2024/04/03/1-2-%E5%B8%83%E5%B0%94%E5%87%BD%E6%95%B0%E5%90%88%E6%88%90/image.png"></p>
<ul>
<li>For line 1, 3, 5 that equal <code>1</code>, we each get:
<code>NOT x</code>, <code>NOT x</code>, <code>NOT y</code>.</li>
<li>Thus the new function for <code>1</code> is
<code>NOT x OR NOT x OR NOT y</code>.(Actually, it could have multiple
forms)</li>
<li>For line 2, 4, 6, 7, 8, we each get: <code>NOT z</code>,
<code>NOT y</code>, <code>NOT x</code>, <code>NOT x</code>,
<code>NOT x</code>, <code>NOT x</code>.</li>
<li>Thus the new function for <code>0</code> is
<code>NOT x OR NOT y OR NOT x OR NOT x OR NOT x OR NOT x OR NOT x OR NOT x</code>.</li>
<li>Combine the two new functions, we get the final result:
<code>(NOT x OR NOT x OR NOT y) AND (NOT x OR NOT y OR NOT x OR NOT x OR NOT x OR NOT x OR NOT x OR NOT x)</code>.</li>
</ul>
<p>  Once we get the final result, we can use boolean function
calculation to simplify it.</p>
<h3><span id="2simplify-the-system">2.Simplify the system</span></h3>
<p>  Actually, we don't need <code>OR</code> to join the process, we can
complete the task only by <code>AND</code> and <code>NOT</code>. This is
because the <em>De Morgan's laws</em> allow us to transform an
<code>OR</code> into <code>AND</code> clause.</p>
<p>  Furthermore, we define <code>NAND</code> as <code>NOT AND</code>.
For example, <code>x NAND y</code> is equal to <code>NOT x AND y</code>.
We can prove that every boolean function can be represented by only the
<code>NAND</code> statement.</p>
<p>  <span class="math inline">\(proof:\)</span>Since we are able to
represent all boolean functions by <code>AND</code> and
<code>NOT</code>, we only need to represent <code>AND</code> and
<code>NOT</code> using <code>NAND</code>:</p>
<ul>
<li><code>NOT x</code> can be represented by <code>x NAND x</code>, this
is obvious.</li>
<li><code>x AND y</code> can be represent by
<code>(x NAND y)NAND(x NAND y)</code>. We can rewrite the statement as
<code>NOT(NOT x AND y)</code>, the statement in the parentheses is
<code>x NAND y</code> itself, so it is transform into
<code>NOT x NAND y</code>. Using <code>NOT</code> representation again,
and we get the result.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 1.Boolean Function</category>
      </categories>
  </entry>
  <entry>
    <title>1.4.硬件描述语言</title>
    <url>/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1><span id="14hardware-description-language"><span class="math inline">\(1.4.\)</span>Hardware description language</span></h1>
<h3><span id="1logic-gate">1.Logic gate</span></h3>
<ul>
<li>An <em>elementary logic gate</em> is an elementary chip which is
designed to deliver a well-defined functionality.</li>
<li>A <em>composite logic gate</em> is one which is made up from
elementary logic gate and other composite logic gates.</li>
</ul>
<p>  The <code>AND</code> gate, <code>OR</code> gate and
<code>NOT</code> gate can be represented by these diagrams:</p>
<p><img src="/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/image.png"></p>
<p><img src="/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/image-1.png"></p>
<p>  By connecting the elementary gate together, we can get composite
gates that have more complicated funtionality. For example:</p>
<p><img src="/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/image-2.png"></p>
<h3><span id="2hdl">2.HDL</span></h3>
<h4><span id="aintro">  <span class="math inline">\(a.\)</span>Intro</span></h4>
<p>  We can actually build and implement the logic gates using a
formalism called <em>Hardware Description Language</em> or HDL. Once you
build a logic gate in HDL,you can actually simulate it, test it.And
finally,build it in hardware.</p>
<p>  The hardware description of a logic gate contains these
structure:</p>
<ul>
<li><em>Interface</em>: It describe what the chip takes in as input and
the output.</li>
<li><em>Implementation</em>: It describe how the chip achieves its
functionality.</li>
</ul>
<p>  For example the gate below can be describe as :</p>
<p><img src="/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/image-3.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP Xor &#123;</span><br><span class="line">	IN a, b;</span><br><span class="line">	OUT out;</span><br><span class="line">	</span><br><span class="line">	PARTS:</span><br><span class="line">	Not (in = a, out = nota);</span><br><span class="line">	Not (in = b, out = notb);</span><br><span class="line">	And (a = a, b = notb, out = aAndNotb);</span><br><span class="line">	And (a = nota, b = b, out = NotaAndb);</span><br><span class="line">	Or (a = aAndNotb, b = NotaAndb, out = out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="bdiagram-development">  <span class="math inline">\(b.\)</span>Diagram development</span></h4>
<p>  Then how can we develop a diagram through its functionality
description? The following steps might help:</p>
<ol type="1">
<li><p><em>draw the boundary of the chip diagram.</em></p>
<ul>
<li>we use this dash to outline for this purpose and what remains
outside the boundary is the user's view of this gate. In other
word,the,the gate interface.All the users knows is that he or she has a
gate that has two inputs,a and b,an output called out and
altogether.They somehow, this chip as if by magic,delivers Xor
functionality</li>
</ul></li>
</ol>
<p><img src="/2024/04/03/1-4-%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/image-4.png"></p>
<ol start="2" type="1">
<li><p>Notice how the a signal is being copied and sent simultaneously
into two different destinations.Take a as an example, one of them is
sent to <code>And</code> gate and the other <code>Not</code>
gate.</p></li>
<li><p>Whenever you use an off-the-shelf gate,you are bound to <em>use
the names of the gate's input and output as advertised.</em></p>
<ul>
<li>In other words, the gate comes along with what can be called the
gate's signature or the gate's APl. So we have no degrees of freedom
here.</li>
</ul></li>
<li><p>The red connections are use to <em>connect the different chip
parts together</em>. The rule is that every one of these connections
<em>has to be named</em> and it's our responsibility to come up with
self-descriptive names.</p></li>
</ol>
<h4><span id="csomefeatures">  <span class="math inline">\(c.\)</span>Some
features</span></h4>
<ul>
<li><p>The interface of one chip is <strong>unique</strong>. That's
because there's only one way to describe the chip.</p></li>
<li><p>The implementation of one chip is not unique, however.</p></li>
<li><p>HDL is a <em>functional or declarative language</em>. There is no
procedure going on.There's no program execution going on. It is nothing
more than <em>a static description of the gate diagram</em>.</p>
<ul>
<li>So because HDL is a functional language,we can actually write those
HDL statements <em>in any order that we wish</em>.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 1.Boolean Function</category>
      </categories>
  </entry>
  <entry>
    <title>1.1~1.5的一些概念</title>
    <url>/2024/05/31/1.1-1.5%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1><span id="someconceptsinfrom11to15"><span class="math inline">\(some\;concepts\;in\;from\;1.1\;to\;1.5\)</span></span></h1>
<h3><span id="1environment">1.<span class="math inline">\(Environment\)</span></span></h3>
<blockquote>
<p>  An environment in which an expression is evaluated consists of a
sequence of frames, depicted as boxes. Each frame contains bindings,
each of which associates a name with its corresponding value. Assignment
and import statements add entries to the first frame of the current
environment.</p>
</blockquote>
<h3><span id="2function-as-abstractions">2.<span class="math inline">\(Function\)</span> <span class="math inline">\(as\)</span> <span class="math inline">\(abstractions\)</span></span></h3>
<p>  我们以下面这个简单的程序为例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add, mul</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> mul(x, x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_squares</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> add(square(x), square(y))</span><br></pre></td></tr></table></figure></p>
<p>  我们可以<strong>写出求和平方，而不必考虑如何求一个数的平方</strong>。如何计算平方的细节可以去掉，以后再考虑。事实上，就<span class="math inline">\(sum\_square\)</span>而言，<span class="math inline">\(square\)</span>不是一个特定的函数体，而是<strong>一个函数的抽象，即函数抽象</strong>。我们可以将<span class="math inline">\(square\)</span>看作一个“黑匣子”，我们放入一个值，然后函数输出一个值，而<strong>中间的实现细节我们并不关心</strong>。</p>
<p>  为了掌握函数抽象的使用，考虑它的三个核心属性通常是有用的：</p>
<ul>
<li><strong>函数的域(domain)</strong> 是它可以接受的一组参数。</li>
<li><strong>函数的范围(range)</strong> 是它可以返回的值的集合。</li>
<li><strong>函数的目的(intent)</strong>
是它计算输入和输出之间的关系(以及它可能产生的任何副作用)，可以看作是输入到输出的抽象映射。</li>
</ul>
<p>  例如对于<span class="math inline">\(sum\_square\)</span>，其：</p>
<ul>
<li><span class="math inline">\(domain\)</span>：两个数。</li>
<li><span class="math inline">\(range\)</span>：非负实数。</li>
<li><span class="math inline">\(intent\)</span>：返回两个数的平方和。</li>
</ul>
<p>  这些属性没有指定如何执行意图；<strong>这些细节被抽象掉了</strong>。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 1.Building Abstractions with Functions</category>
      </categories>
  </entry>
  <entry>
    <title>1.5.硬件模拟</title>
    <url>/2024/04/03/1-5-%E7%A1%AC%E4%BB%B6%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1><span id="15hardware-simulation"><span class="math inline">\(1.5.\)</span>Hardware simulation</span></h1>
<ol type="1">
<li><p><strong>Interactive Simulation:</strong> We can load an HDL file
into a hardware simulator program, which allows us to interactively test
various operations of the chip. This mode of testing is called
interactive simulation.</p></li>
<li><p><strong>Script-Based Simulation:</strong> Alternatively, we can
write a test script in a special testing language designed for this
purpose. This script outlines predetermined tests, enabling systematic
testing of the chip's functionality without manual interaction. This
mode is called script-based simulation.</p></li>
<li><p><strong>Output Comparison:</strong> We can record simulation
output to an output file and compare it to a desired output stored in a
compare file. This allows us to validate the chip's behavior against
expected results. Moreover, we can change our test script to compare
file, so that it can do comparation.</p></li>
</ol>
<ul>
<li><p>Additionally, we'll discuss the use of compare files, which
enable comparison of simulation outputs with desired results. These
files can be generated through behavioral simulation, where the chip
logic is implemented in high-level languages and tested before HDL
implementation.</p></li>
<li><p><strong>System architect</strong>: They design how to achieve the
functionality, breaking the overall behaviour into smaller chips. They
offer:</p>
<ul>
<li>A chip API</li>
<li>A test script</li>
<li>A compare file</li>
</ul></li>
<li><p><strong>Developer</strong>: You receive stub files documenting
chip interfaces, along with test scripts and compare files prepared by
system architects. Your task will be to write the HDL code to implement
the missing functionality.</p></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 1.Boolean Function</category>
      </categories>
  </entry>
  <entry>
    <title>1.7.递归函数</title>
    <url>/2024/05/31/1.7.%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1><span id="17递归函数"><span class="math inline">\(1.7\)</span>递归函数</span></h1>
<h2><span id="一-递归函数的概念与分类">一、递归函数的概念与分类</span></h2>
<h3><span id="1概念">1.概念</span></h3>
<p>  如果<strong>函数体直接或间接调用函数本身</strong>，则函数称为递归函数。也就是说，执行递归函数体的过程可能反过来又需要再次应用该函数。</p>
<h3><span id="2递归的原理">2.递归的原理</span></h3>
<p>  一般的递归由以下结构构成：</p>
<ul>
<li>基本情况：当递归函数递归到一个或多个基本情况时，函数将直接返回某个值，跳出递归</li>
<li>递归调用：随着递归调用，问题逐渐得到简化</li>
</ul>
<p>  以阶乘的求解为例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n*f(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>   递归函数<span class="math inline">\(fact\)</span>用一个更简单的问题：<span class="math inline">\(fact(n-1)\)</span>表示了<span class="math inline">\(fact(n)\)</span>。该递归的基本情况是<span class="math inline">\(1!=1,0!=1\)</span>。</p>
<p>  当递归<strong>通过递归函数的连续调用“展开”到越来越简单的问题时，结果最终会从基本情况开始构建</strong>。递归结束时将参数<span class="math inline">\(1\)</span>传递给<span class="math inline">\(fact\)</span>;
<strong>每个调用的结果取决于下一个调用，直到达到基本情况。</strong></p>
<p>  在我们利用以上计算模型得出递归的最终结果时，也可<strong>将递归调用看作函数抽象</strong>。在阶乘中，我们不关心<span class="math inline">\(fact(n-1)\)</span>是怎么计算出来的，我们应该简单地相信它计算的是<span class="math inline">\(n-1\)</span>的阶乘。这种对递归函数的看法被称作<span class="math inline">\(recursive\;leap\;of\;faith\)</span>，即<strong>我们相信递归调用简单情况时函数会得出正确结果，在这个认知的基础上去计算复杂情况</strong>。例如计算阶乘时，我们相信<span class="math inline">\(fact(n-1)\)</span>能正确计算出<span class="math inline">\((n-1)!\)</span>，<strong>只需检查<span class="math inline">\(n!\)</span>在这个假设成立下是否能得到正确计算</strong>。通过这种方式，验证递归函数的正确性是一种<strong>数学归纳法</strong>。</p>
<h3><span id="3递归与循环函数的区别">3.递归与循环函数的区别</span></h3>
<p>  我们以阶乘函数的循环写法为例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact_iter</span>(<span class="params">n</span>):</span><br><span class="line">        total, k = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">            total, k = total * k, k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></p>
<p>  我们从两个角度看待它们的区别：</p>
<h4><span id="a实现方式">  <span class="math inline">\(a.\)</span>实现方式：</span></h4>
<p>  阶乘的循环写法是通过逐项相乘实现的，而阶乘的递归写法是通过当前项<span class="math inline">\(fact(n)\)</span>与前一项<span class="math inline">\(fact(n-1)\)</span>的关系实现的。</p>
<h4><span id="b调用参数">  <span class="math inline">\(b.\)</span>调用参数</span></h4>
<p>  阶乘的循环写法需要调用两个额外参数<span class="math inline">\(total,k\)</span>，而递归则没有这两个参数。在递归中，<span class="math inline">\(fact(n)\)</span>本身的返回值及相当于循环中的<span class="math inline">\(total\)</span>，而<span class="math inline">\(n\)</span>则用来隐式地跟踪<span class="math inline">\(n!\)</span>计算到哪一步，相当于循环中的<span class="math inline">\(k\)</span>。</p>
<h2><span id="二-相互递归调用">二、相互递归调用</span></h2>
<h3><span id="1概念">1.概念</span></h3>
<p>  当一个递归过程分为<strong>两个相互调用的函数</strong>时，这两个函数被称为相互递归的。</p>
<p>  对于<strong>多主体</strong>的问题，利用相互递归调用可以得到很完美的解决。</p>
<h3><span id="2实例讲解">2.实例讲解</span></h3>
<p>  <span class="math inline">\(e.g.1.\)</span>考虑如下所述对于奇偶的定义：</p>
<ul>
<li><span class="math inline">\(0\)</span>为偶数</li>
<li>若<span class="math inline">\(n-1\)</span>为偶数，则<span class="math inline">\(n\)</span>为奇数</li>
<li>若<span class="math inline">\(n-1\)</span>为奇数，则<span class="math inline">\(n\)</span>为偶数 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> is_odd(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_odd</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> is_even(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  <span class="math inline">\(p.s.\)</span>通过<strong>打破两个函数之间的抽象边界</strong>，可以将相互递归的函数转换为单个递归函数。如上述函数可如下改写：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> (n-<span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> is_even((n-<span class="number">1</span>)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(e.g.2.\)</span>考虑一个两人博弈，在这个博弈中，一张桌子上有
<span class="math inline">\(n\)</span>个初始卵石。玩家轮流从桌子上移走一个或两个鹅卵石，移走最后一个鹅卵石的玩家获胜。假设爱丽丝和鲍勃玩这个游戏，每个人都使用一个简单的策略:</p>
<ul>
<li>爱丽丝总是拿走一块鹅卵石</li>
<li>如果桌子上的鹅卵石数量是偶数，那么鲍勃就会移除两个鹅卵石，另一个是偶数</li>
</ul>
<p>  给定<span class="math inline">\(n\)</span>个最初的卵石和爱丽丝开始，谁赢得了比赛？</p>
<p>  <span class="math inline">\(solve\)</span>：这里爱丽丝与鲍勃是不同主体，分设为两个函数即可：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">alice</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Bob wins&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> bob(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bob</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Alice wins&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> alice(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<h2><span id="三-树形递归">三、树形递归</span></h2>
<h3><span id="1树形递归的概念">1.树形递归的概念</span></h3>
<p>  树形递归是一种常用的递归，在树形递归中，递归函数被调用不止一次。</p>
<p>  我们以斐波那契数列的递归求解为例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">2</span>) + fib(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>  可以看到，递归的写法与斐波那契的定义<span class="math inline">\(Fib_n=Fib_{n-1}+Fib_{n-2}\)</span>是完全契合的。</p>
<h3><span id="2实例讲解">2.实例讲解</span></h3>
<p>  <span class="math inline">\(e.g.1.\)</span>将<span class="math inline">\(n\)</span>分解为某个单调递增的序列，且序列中数的最大值不超过<span class="math inline">\(m\)</span>。给出<span class="math inline">\(n,m\)</span>，求出满足条件序列的数量。</p>
<p>  <span class="math inline">\(solve\)</span>：我们考虑下面两件事：</p>
<ol type="1">
<li><p>分组方法：为了保证不重不漏，我们从序列中最大值<span class="math inline">\(m\)</span>入手，可分为以下情况：</p>
<ul>
<li>选一个<span class="math inline">\(m\)</span>，然后对<span class="math inline">\(n-m\)</span>执行相同操作</li>
<li>不选<span class="math inline">\(m\)</span>，此时序列中最大值变为<span class="math inline">\(m-1\)</span>，然后继续执行相同操作</li>
</ul></li>
<li><p>基本情况：</p>
<ul>
<li><code>n==0</code>：<span class="math inline">\(return
1\)</span></li>
<li><code>n&lt;0</code>：<span class="math inline">\(return
0\)</span></li>
<li><code>m==0</code>：<span class="math inline">\(return
0\)</span></li>
</ul></li>
</ol>
<p>  于是可写出如下代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">n,m</span>):</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> div(n-m,m)+div(n,m-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
  我们可以把一个树形递归函数看作是在<strong>探索不同的可能性</strong>。在这个例子中，我们探索了使用<span class="math inline">\(m\)</span>的可能性以及不使用的可能性。第一个和第二个递归调用对应于这些可能性。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 1.Building Abstractions with Functions</category>
      </categories>
  </entry>
  <entry>
    <title>1.6.高阶函数</title>
    <url>/2024/05/31/1.6.%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1><span id="16高阶函数"><span class="math inline">\(1.6\)</span>高阶函数</span></h1>
<h3><span id="1引入">1.引入</span></h3>
<p>  由前面的讲解我们知道，<strong>函数是一种抽象方法，它描述独立于其参数的特定值的复合操作。</strong>
例如对函数<span class="math inline">\(square\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br></pre></td></tr></table></figure>
  我们讨论的并不是某个特定的数的平方，而是对任何数的平方的普遍规律。同时，函数中的<code>*</code>也是一种抽象映射，代表乘法。当抽象映射较简单时，我们可以直接用符号来表示；但当抽象映射非常复杂时，我们就会<strong>用一个特定函数来实现这个抽象映射</strong>。</p>
<p>  然而，在将相应的抽象映射转化为特定函数后，我们要<strong>将这个特定函数放入原有函数中，构造出能够接受该特定函数作为参数或返回函数作为值的函数</strong>。这样的函数即被称为<strong>高阶函数</strong>。</p>
<h3><span id="2作为参数的函数">2.作为参数的函数</span></h3>
<p>  我们考虑对下面三种求和的代码实现：</p>
<ul>
<li><p><span class="math inline">\(1+2+\cdots +n\)</span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum1</span>(<span class="params">n</span>):</span><br><span class="line">    tot,k=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        tot,k=tot+k,k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure></p></li>
<li><p><span class="math inline">\(1^3+2^3+\cdots +n^3\)</span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum2</span>(<span class="params">n</span>):</span><br><span class="line">    tot,k=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        tot,k=tot+k,k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> tot </span><br></pre></td></tr></table></figure></p></li>
<li><p><span class="math inline">\({4\over{1·3}}+{4\over{3·5}}+\cdots+{4\over{(2n-1)·(2n+1)}}\)</span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum2</span>(<span class="params">n</span>):</span><br><span class="line">    tot,k=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        tot,k=tot+<span class="number">4</span>/((<span class="number">2</span>*k-<span class="number">1</span>)*(<span class="number">2</span>*k+<span class="number">1</span>)),k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure>   可以看出，上述求和都可以归纳为以下模式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">n</span>):</span><br><span class="line">    tot,k=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        tot,k=f(k),k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure>
  这种<strong>公共模式的存在强有力地证明了有一个有用的抽象正等待着被提出来。</strong>通过更进一步的抽象，我们的函数将不止能求解这些特定类型的求和，而是可以求出所有普遍意义上的求和。于是我们<strong>使用函数作为参数</strong>，将原来程序改写如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_abstraction</span>(<span class="params">n,f</span>):</span><br><span class="line">    tot,k=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k&lt;=n:</span><br><span class="line">        tot,k=tot+f(k),k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> tot</span><br><span class="line"></span><br><span class="line"><span class="comment">#以第2个求和为例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n*n*n</span><br><span class="line"><span class="comment">#则sum2可以写成</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum2</span>:</span><br><span class="line">    <span class="keyword">return</span> sum_abstraction(n,f2)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3><span id="3作为一般方法的函数">3.作为一般方法的函数</span></h3>
<p>  上一节“作为参数的函数”中，我们用函数表示某种抽象数值运算模式，将某个具体的运算抽象化。在这一节中，我们<strong>将设计一些函数来表示一般的计算方法，它们独立于调用它们的函数</strong>。</p>
<p>  我们考虑下面这个求解黄金分割比<span class="math inline">\(\varphi\)</span>的程序。我们采用迭代的求法来求。函数的主体为迭代函数<span class="math inline">\(update\)</span>与检查函数<span class="math inline">\(close\)</span>，这里的每个函数都对应着一个一般方法。</p>
<p>  对于迭代函数，由黄金分割比的性质：<span class="math inline">\(\varphi=1+{1\over{1+{1\over{1+{1\over{\cdots}}}}}}\)</span>可以得到如下程序：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> check(guess):</span><br><span class="line">        guess=<span class="number">1</span>/guess+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> guess</span><br></pre></td></tr></table></figure></p>
<p>  对于<span class="math inline">\(check\)</span>函数，也即<span class="math inline">\(update\)</span>的边界函数，由黄金分割比满足的方程：<span class="math inline">\(x^2=x+1\)</span>可得如下程序： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> close(guess*guess,guess+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">a,b,tolerance=<span class="number">1e-15</span></span>):</span><br><span class="line">    <span class="keyword">return</span>(<span class="built_in">abs</span>(a-b)&lt;tolerance)</span><br></pre></td></tr></table></figure></p>
<p>  从而得到最终的程序如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">update,check,guess=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> check(guess):</span><br><span class="line">        guess=update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br></pre></td></tr></table></figure></p>
<p>  通过本题可以看出模块化编程思想的重要性：我们<strong>将整个程序拆成几个小的组件，在编写完每个组件后再进行合并，实现复杂的功能。</strong>同时我们在编写组件时，对每个抽象过程都可以<strong>先命名一个函数，把这个过程抽象化</strong>，然后再实现这一过程，这样可以有效降低函数的复杂性。</p>
<h3><span id="4函数的嵌套定义">4.函数的嵌套定义</span></h3>
<p>  上面的示例演示了<strong>将函数作为参数传递</strong>的做法如何将<strong>每个一般概念或方程都映射到它自己的短函数上</strong>。但在这种方法中，由于每个短函数是在全局独立定义的，全局框架会因为众多函数的加入变得杂乱无章。同时，在某些场合中，我们需要让函数只保持一个参数，这时我们可以考虑建立嵌套函数。</p>
<p>  以平方根的计算为例。我们一般通过以下程序迭代实现平方根的计算：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> (x+y)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt_update</span>(<span class="params">x,a</span>):</span><br><span class="line">    <span class="keyword">return</span> average(x,a/x)</span><br></pre></td></tr></table></figure></p>
<p>  这两个函数都是双参的函数，而待实现的<span class="math inline">\(sqrt\)</span>是单参函数；并且这两个函数单独调用只能实现一次更新。解决这个问题的方法是<strong>将函数定义放在其他定义的主体中。</strong>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> average(x,a/x)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> close(x*x,a)</span><br><span class="line">    <span class="keyword">return</span> solve(update,close)</span><br></pre></td></tr></table></figure></p>
<p>  与局部赋值一样，局部<span class="math inline">\(def\)</span>语句只影响当前的局部内容。当<span class="math inline">\(sqrt\)</span>被计算时，这些函数只在作用域中。与我们的计算过程一致，<strong>在调用<span class="math inline">\(sqrt\)</span>之前，这些本地<span class="math inline">\(def\)</span>语句甚至不会被计算</strong>。由此可引出新概念：</p>
<blockquote>
<p>  <strong>词法范围</strong>：在函数内部被定义的函数可以共享定义它们的函数的参数。例如本例的<span class="math inline">\(update\)</span>，其引用参数<span class="math inline">\(a\)</span>就是封闭函数<span class="math inline">\(sqrt\)</span>的参数。对于在封闭函数内定义的函数，<span class="math inline">\(a\)</span>就相当于一个可以任意调用的常数。</p>
</blockquote>
<p>  由此，我们的变量环境就分成了两个环境：</p>
<ul>
<li>每个用户自定义函数都有一个父环境：<strong>定义它的环境</strong></li>
<li>当调用用户定义函数时，<strong>调用函数的内部扩展出的新环境</strong></li>
</ul>
<p>  仍然以<span class="math inline">\(sqrt\)</span>为例讲解嵌套函数。利用嵌套函数实现的<span class="math inline">\(sqrt\)</span>计算如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> (x+y)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">update,check,guess=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> check(guess):</span><br><span class="line">        guess=update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eq</span>(<span class="params">x,y,tolerance=<span class="number">1e-15</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x-y)&lt;tolerance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x,a/x</span>):</span><br><span class="line">        <span class="keyword">return</span> average(x,a/x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>:</span><br><span class="line">        <span class="keyword">return</span> eq(x*x,a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solve(update,check)</span><br><span class="line"></span><br><span class="line">result=sqrt(<span class="number">256</span>)</span><br></pre></td></tr></table></figure></p>
<p>  该函数的执行流程及对应范围如下： 1.
定义函数，此时所有函数均为全局范围 2. 调用<span class="math inline">\(sqrt\)</span>，此时<span class="math inline">\(def\)</span>内部的<span class="math inline">\(update\)</span>、<span class="math inline">\(check\)</span>函数为词法范围，同时<span class="math inline">\(update\)</span>、<span class="math inline">\(check\)</span>继承词法范围内的变量<span class="math inline">\(a\)</span> 3. 执行<span class="math inline">\(solve\)</span>，通过迭代计算出<span class="math inline">\(sqrt\)</span>的值。</p>
<p><img src="/2024/05/31/1.6.%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/image-1.png"></p>
<p>  通过本例我们也可以了解拓展环境的概念：</p>
<blockquote>
<p>  <strong>拓展环境</strong>：一个环境可以<strong>由任意长的框架链组成，框架链总是以全局框架结束</strong>。在<span class="math inline">\(sqrt\)</span>之前，环境最多只有两个帧:
局部帧和全局帧。通过调用在其他函数中定义的函数，通过嵌套的<span class="math inline">\(def\)</span>语句，我们可以创建更长的链。调用 <span class="math inline">\(update\)</span>的环境由三个框架组成:
<strong>局部<span class="math inline">\(update\)</span>框架、定义 <span class="math inline">\(update\)</span>的<span class="math inline">\(sqrt\)</span>框架和全局框架</strong>。</p>
</blockquote>
<p>  由上述框架的概念，我们可以得出框架的优先级：<span class="math inline">\(update\)</span>先在本地框架中找<span class="math inline">\(a\)</span>的值，没找到；于是<span class="math inline">\(update\)</span>去定义<span class="math inline">\(update\)</span>的<span class="math inline">\(sqrt\)</span>框架找，找到<span class="math inline">\(256\)</span>，于是<span class="math inline">\(a=256\)</span>。</p>
<p>  由此，我们得出了词法范围的优点：</p>
<ul>
<li><p>局部函数的名称不会干扰定义它的函数的外部名称，<strong>因为局部函数名称将绑定在定义它的当前局部环境中，而不是全局环境中。</strong></p></li>
<li><p>局部函数<strong>可以访问封闭函数的环境</strong>，因为局部函数体是在扩展其定义的封闭函数环境中进行定义的。</p></li>
</ul>
<p>  这种在本地框架中定义的函数被称为<strong>闭包</strong>，例如本题中的<span class="math inline">\(sqrt\)</span>函数。在闭包中定义的函数可以获取闭包内的数据信息，而且闭包内的信息是封闭的、不会泄露到外部环境中。</p>
<h3><span id="5作为返回值的函数">5.作为返回值的函数</span></h3>
<p>  词法范围的一个重要特性是：<strong>本地定义的函数在返回时维护其父环境</strong>。下面举一个应用该特性的例子。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">f,g</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> f(g(x))</span><br><span class="line">    <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>
  这是复合函数的程序。正是通过本地定义函数继承父环境的性质，该函数实现了多个函数间的复合。</p>
<p>  一般地，返回函数的函数具有以下优点：</p>
<ul>
<li><p><strong>灵活性和可复用性</strong>：
函数作为返回值可以增加代码的灵活性。通过返回函数，你可以根据需要在运行时动态选择返回不同的实现，使得代码更加灵活和可复用。</p></li>
<li><p><strong>封装和抽象</strong>：
函数作为返回值有助于封装和抽象代码。你可以将一些复杂的逻辑封装在函数内部，然后返回这个函数，从而隐藏内部实现细节，使得接口更加简洁，提高代码的可维护性。</p></li>
<li><p><strong>延迟执行</strong>：
返回函数可以支持延迟执行的模式。例如，你可以返回一个函数对象，该对象在调用时才会执行具体的逻辑。这种延迟执行的方式有助于提高性能，特别是在涉及昂贵计算或者需要从外部获取资源的情况下。</p></li>
<li><p><strong>函数封装</strong>：
返回函数的能力使得函数成为一种函数工厂。你可以根据一些参数或者条件返回不同的函数，从而实现更加通用和可配置的代码结构。</p></li>
</ul>
<h3><span id="6高阶函数的经典应用">6.高阶函数的经典应用</span></h3>
<h4><span id="a牛顿迭代法">  <span class="math inline">\(a.\)</span>牛顿迭代法</span></h4>
<h5><span id="i牛顿迭代的原理">  <span class="math inline">\(i.\)</span>牛顿迭代的原理</span></h5>
<p><img src="/2024/05/31/1.6.%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/image.png"></p>
<h5><span id="ii牛顿迭代法的实现">  <span class="math inline">\(ii.\)</span>牛顿迭代法的实现</span></h5>
<p>  我们考虑实现<span class="math inline">\(\sqrt[n]{a}\)</span>的计算。首先令<span class="math inline">\(\sqrt[n]{a}=x\)</span>，则问题转化为求<span class="math inline">\(x^n=a\)</span>的实根。我们根据牛顿迭代法将程序拆分为以下模块：
*
牛顿迭代函数的实现：由于我们要实现一个函数的封装，采用返回函数的高阶函数：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">newton_update</span>(<span class="params">f,df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x-f(x)/df(x)</span><br><span class="line">    <span class="keyword">return</span> update</span><br></pre></td></tr></table></figure>   我们将抽象过程<span class="math inline">\(f\)</span>与<span class="math inline">\(df\)</span>命名为了两个函数，下面考虑如何实现两者。</p>
<ul>
<li><p><span class="math inline">\(f\)</span>：<span class="math inline">\(f\)</span>即为<span class="math inline">\(x^n\)</span> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> power(x,n)</span><br><span class="line">```   </span><br><span class="line">&amp;emsp;&amp;emsp;同理：</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> n*power(x,n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>   接下来是实现<span class="math inline">\(power\)</span>：</p></li>
<li><p><span class="math inline">\(power\)</span>:简单的连乘即可：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x,n</span>):</span><br><span class="line">    mul,cnt=<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> cnt&lt;n:</span><br><span class="line">        mul,cnt=mul*x,cnt+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> mul</span><br></pre></td></tr></table></figure></p></li>
<li><p>寻找零点函数的实现：寻找零点分为两步：检验是否为零点与牛顿迭代。我们分别实现这两个功能，然后将它们封装为寻找零点函数：</p>
<ul>
<li>检验是否为零点：判断<span class="math inline">\(f(x)-a\)</span>是否在误差范围即可：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">iszero</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> eq(f(x),<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>函数封装： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">update, is_zero</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iteratively_solve</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_approx_zero(x):</span><br><span class="line">            x = update(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> iteratively_solve</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_zero</span>(<span class="params">f,df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_zero</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> eq(f(x),<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> solve(newton_update(f,df),is_zero)</span><br></pre></td></tr></table></figure></p></li>
<li><p>最终函数封装： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nth_root_of_a</span>(<span class="params">n,a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> power(x,n)-a</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> n*power(x,n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> find_zero(f,df)</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">newton_update</span>(<span class="params">f, df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x - f(x) / df(x)</span><br><span class="line">    <span class="keyword">return</span> update</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">update, is_approx_zero, max_iter=<span class="number">1000</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iteratively_improve</span>(<span class="params">x</span>):</span><br><span class="line">        iteration = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_approx_zero(x) <span class="keyword">and</span> iteration &lt; max_iter:</span><br><span class="line">            x = update(x)</span><br><span class="line">            iteration += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> iteratively_improve</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_zero</span>(<span class="params">f, df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">near_zero</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> approx_eq(f(x), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> improve(newton_update(f, df), near_zero)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return x * x * x * ... * x for x repeated n times.&quot;&quot;&quot;</span></span><br><span class="line">    product, k = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; n:</span><br><span class="line">        product, k = product * x, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">approx_eq</span>(<span class="params">a, b, epsilon=<span class="number">1e-6</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a - b) &lt; epsilon</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nth_root_of_a</span>(<span class="params">n, a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> power(x, n) - a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> n * power(x, n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> find_zero(f, df)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4><span id="bcurry化">  <span class="math inline">\(b.\)</span><span class="math inline">\(Curry\)</span>化</span></h4>
<h5><span id="i一般的curry化">  <span class="math inline">\(i.\)</span>一般的<span class="math inline">\(Curry\)</span>化</span></h5>
<p>  我们可以通过高阶函数的方法，可以将一个有很多参数的函数拆分成一个函数链，每个函数链节都是单参函数。</p>
<p>  以双参函数<span class="math inline">\(pow(a,n)\)</span>为例。我们可以用以下程序将<span class="math inline">\(pow(a,n)\)</span>转化为<span class="math inline">\(h(a)(n)\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curried_pow</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x,y)</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>curried_pow(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
  除了满足单参的需求，由于将原函数拆成了多个函数，<span class="math inline">\(Curry\)</span>化的函数还可以通过改动某个函数，使<span class="math inline">\(Curry\)</span>化后的函数能实现不同的功能。例如下面计算<span class="math inline">\(2^1\sim 2^{10}\)</span>的程序： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">map_to_range</span>(<span class="params">start,end,f</span>):</span><br><span class="line">    <span class="keyword">while</span> start&lt;end:</span><br><span class="line">        <span class="built_in">print</span>(f(start))</span><br><span class="line">        start+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">map_to_range(<span class="number">1</span>,<span class="number">10</span>,<span class="built_in">pow</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
  这里，<span class="math inline">\(Curry\)</span>函数<span class="math inline">\(pow(2)\)</span>只执行“以<span class="math inline">\(2\)</span>为底”这一模块。而另一个参数“<span class="math inline">\(n\)</span>次幂”则由<span class="math inline">\(map\_to\_range\)</span>传递。</p>
<h5><span id="ii自动化">  <span class="math inline">\(ii.\)</span>自动化</span></h5>
<p>  以下程序可以实现对输入函数的<span class="math inline">\(Curry\)</span>化与<span class="math inline">\(Uncurry\)</span>化： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curry</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">            <span class="keyword">return</span> f(x,y)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uncurry</span>(<span class="params">g</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x,y</span>):</span><br><span class="line">        <span class="keyword">return</span> g(x)(y)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">pow_curried=curry(<span class="built_in">pow</span>)</span><br><span class="line"><span class="built_in">pow</span>=uncurry(pow_curried)</span><br></pre></td></tr></table></figure></p>
<h4><span id="clambda表达式">  <span class="math inline">\(c.\)</span><span class="math inline">\(lambda\)</span>表达式</span></h4>
<p>  <span class="math inline">\(lambda\)</span>表达式可以在不声明函数的情况下，将变量转换为一个函数。下面这个程序就是<span class="math inline">\(lambda\)</span>表达式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">composel</span>(<span class="params">f,g</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:f(g(x))</span><br></pre></td></tr></table></figure>
  我们可以用如下表格理解<span class="math inline">\(lambda\)</span>表达式的概念：</p>
<p><img src="/2024/05/31/1.6.%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/image-2.png"></p>
<p>  <span class="math inline">\(lambda\)</span>表达式的返回值称作
<strong><span class="math inline">\(lambda\)</span>函数</strong> 。<span class="math inline">\(lambda\)</span>函数没有内置名称，但可以和普通的函数一样调用：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0xf3f490</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s(<span class="number">12</span>)</span><br><span class="line"><span class="number">144</span></span><br></pre></td></tr></table></figure></p>
<p>  对于较简单的函数，利用<span class="math inline">\(lambda\)</span>表达式可以简化代码；但如果函数较为复杂，<span class="math inline">\(lambda\)</span>就很可能给人带来理解上的困难。因此在代码较复杂、层层嵌套时，还是用传统的<code>def</code>为佳。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 1.Building Abstractions with Functions</category>
      </categories>
  </entry>
  <entry>
    <title>10.2.对变量的处理</title>
    <url>/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1><span id="112handling-variables"><span class="math inline">\(11.2\)</span>Handling Variables</span></h1>
<h3><span id="1program-compilation">1.Program compilation</span></h3>
<p>  Remember that the VM language doesn't have symbolic variables, it
only has <code>local</code>, <code>this</code> and so on. In order to
resolve this pseudocode into final executable VM code, we have to
<strong>map these symbolic variables on what is called <em>virtual
memory segments</em></strong>. And to do this, we:</p>
<ul>
<li>need the <strong>variable properties</strong>.</li>
<li>also have to know <strong>the index of the variable of its
kind</strong>(first, second, etc.).</li>
</ul>
<p>  And the properties of variables include:</p>
<ul>
<li><p><em>name</em>: It's an identifier.</p></li>
<li><p><em>type</em>: <code>int</code>, <code>char</code>,
<code>boolean</code> and <strong>all class name</strong>.</p></li>
<li><p><em>kind</em>: There are two kinds of variables, and we view them
separately:</p>
<ul>
<li><em>class level</em>: <code>field</code>, <code>static</code>
variables.</li>
<li><em>subroutine level</em>: <code>argument</code> and
<code>local</code> variables.</li>
</ul></li>
<li><p><em>scope</em>, which is the region of the code in which it is
recognized.</p></li>
</ul>
<h3><span id="2symbol-table">2.Symbol table</span></h3>
<p>  We handle the property of variables using a <em>symbol
table</em>:</p>
<p><img src="/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/image.png"></p>
<ul>
<li>A method is always designed to operate on the current object which
is called <code>this</code>. Therefore, the symbol table of method
<strong>always begins with <code>this</code> entry</strong>, which
represents the properties of current object.</li>
<li><code>this</code> is always treated as <code>argument 0</code></li>
<li>The type of current object is <strong>the name of the class to which
this subroutine belongs</strong>.</li>
</ul>
<p>  The class level symbol table can be reset each time we begin to
compile a new class, for <strong>classes are standalone compilation
unity</strong>. Something similar happens when we compile
subroutines.</p>
<p>  The code writer is going to encounter all sorts of variable
declaration commands, of which in Jack we have three:
<code>local</code>, <code>field</code> and <code>static</code>.</p>
<p>  Then it's going to elucidate all important properties of the
declared variables, and <strong>add the information to the respective
symbol table</strong>. It generates no code whatsoever beyond updating
the symbol tables.</p>
<ul>
<li>If we are defining a <code>field</code> or a <code>static</code>
variable, the code writer will add a new row to the end of the class
level symbol table.</li>
<li>If we are defining <code>local</code> or <code>argument</code>, the
code writer will update the symbol table of the subroutine which is
currently being compiled.</li>
<li>Arguments are being defined as <strong>part of the parameter list of
the method's signature</strong>. When the code writer goes through the
parameter list, it adds the respective lines to the subroutine's symbol
table.</li>
</ul>
<p><img src="/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/image-1.png"></p>
<p>  What about using variables within the context of expressions or
statements. Take <code>let dx = x - other.getX();</code> as an
example:</p>
<ul>
<li><p>For each variable in the code, we <strong>look up this variable
in the subroutine level symbol table</strong>.</p>
<ul>
<li>If we find it there, we know which property we have to use.</li>
<li>If don't, we revert to <strong>looking it up in the class level
symbol table</strong>.</li>
<li>If don't either, we can conclude that the variable is undefined and
throw an error message.</li>
</ul></li>
</ul>
<p>  How can the statements be translated into VM code? Take
<code>let y = y +dy</code> for example:</p>
<ol type="1">
<li>In the process of generating code, the code generator will look up
the respective table.</li>
<li>It finds out that <strong><code>y</code> stands for the second
<code>field</code> of the current object</strong>, so it will be
translated into <code>this 1</code></li>
<li><code>dy</code> stands for the second <code>local</code> variable,
so it will be translated into <code>local 1</code></li>
</ol>
<p><img src="/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/image-2.png"></p>
<p><img src="/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/image-3.png"></p>
<h3><span id="3handling-variables-ingeneral">3.Handling variables in
general</span></h3>
<p>  High level of programming languages vary in terms of:</p>
<ul>
<li>variable types</li>
<li>variable kinds</li>
<li>nested scoping rules</li>
</ul>
<p>  And the symbol table generation and usage we discussed right now
can be easily entended to handle any number of possible variables types
and kinds.</p>
<p>  Some languages, like Java, feature <em>unlimited scoping</em>. this
means that whenever you define a block of code with a pair of curly
brackets, you can define variables within this code which are recognized
only within that block. <code>x</code> in this scope doesn't mean the
same as <code>x</code> in that block.</p>
<p>  To represent the information in our symbol table mechanism, we use
<strong>a linked list of symbol tables</strong>:</p>
<ul>
<li>When start compiling the class, we first create an linked list.</li>
<li>The first symbol table we add to the list is the class level symbol
table.</li>
<li>When we start compiling a method, we create the method symbol table
like before.</li>
<li>Whenever we have another scoping region, we <strong>add another
symbol table to the linked list</strong>.</li>
</ul>
<p><img src="/2024/04/20/10-2-%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%84%E7%90%86/image-4.png"></p>
<p>  When you encounter some variable <code>x</code> in the code we:</p>
<ol type="1">
<li>Look up <code>x</code> in the current scope, which is also the first
table.</li>
<li>If fail, we move to the next symbol table.</li>
<li>We simply go on downstream until we get to the class level symbol
table.</li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.11.编译器实现笔记</title>
    <url>/2024/05/04/10-11-%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1><span id="1011编译器实现笔记"><span class="math inline">\(10.11.\)</span>编译器实现笔记</span></h1>
<h3><span id="1symbol-table实现">1.<code>Symbol Table</code>实现</span></h3>
<p>  为了方便读取单一字符，我们选择<strong>利用<code>tokenizer</code>生成的代码</strong>来构建我们的<code>Symbol Table</code>.</p>
<h4><span id="a准备工作">  <span class="math inline">\(a.\)</span>准备工作</span></h4>
<ol type="1">
<li>虽然理论上应该对于每一个子程序，我们都应该实时地产生一个对应的<code>subroutineMap</code>，但是由于较难实现，我选择遍历整个程序后，将每个子程序对应的<code>subroutineMap</code>用一个新的<span class="math inline">\(Map\)</span>来存储：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for convenience, we store the symbolTable of each subroutine into a map.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Map&lt;String, Integer&gt;&gt; mapOfSubVar = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Map&lt;String, String&gt;&gt; mapOfSubVarType = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Map&lt;String, String&gt;&gt; mapOfSubVarKind = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; subroutineVar = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; typeOfSubroutineVar = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; kindOfSubroutineVar = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>  同时，这要求我们记录下当前遍历的子程序的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">currentStringName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>由于对每个<code>class</code>，我们都要生成一个新的<code>Symbol Table</code>，
因此我们在生成对应的<code>Symbol Table</code>前先要对储存表格的<span class="math inline">\(Map\)</span>进行初始化：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startClass</span><span class="params">()</span> &#123;</span><br><span class="line">    classVar.clear();</span><br><span class="line">    typeOfClassVar.clear();</span><br><span class="line">    kindOfClassVar.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>在后续生成VM代码的过程中，我们需要每个变量对应的序号，因此我们需要设置变量对其进行存储：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//use to return the kind index</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">classNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">argNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">localNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//and for subroutine, we store their argNum and localNum</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; subroutineArgNum = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; subroutineLCLNum = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4><span id="b类变量处理">  <span class="math inline">\(b.\)</span>类变量处理</span></h4>
<p>  类中定义的变量遵循以下结构：</p>
<p><span class="math display">\[kind+type+name(,name);\]</span></p>
<p>  由于该结构具有普适性，我们可以用<strong>递归</strong>的方法读取并处理我们读入的<em>token</em>：</p>
<ol type="1">
<li>处理一定存在的<span class="math inline">\(kind+type+name\)</span>.</li>
<li>判断是否有<span class="math inline">\(,name\)</span>部分，如果有的话进行处理.</li>
<li>递归执行上述步骤，直至下一个传入变量不是<code>local</code>变量.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dealClassVar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Tokenizer.getNextString().equals(<span class="string">&quot;field&quot;</span>) || Tokenizer.getNextString().equals(<span class="string">&quot;static&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// get the kind</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classVarKind</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        <span class="comment">// get the type</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classVarType</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        <span class="comment">// get the name</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classVarName</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        <span class="comment">// add to correspond kind</span></span><br><span class="line">        <span class="keyword">if</span> (classVarKind.equals(<span class="string">&quot;static&quot;</span>)) &#123;</span><br><span class="line">            classVar.put(classVarName, classNum++);</span><br><span class="line">            typeOfClassVar.put(classVarName, classVarType);</span><br><span class="line">            kindOfClassVar.put(classVarName, <span class="string">&quot;this&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (classVarKind.equals(<span class="string">&quot;field&quot;</span>)) &#123;</span><br><span class="line">            classVar.put(classVarName, classNum++);</span><br><span class="line">            typeOfClassVar.put(classVarName, classVarType);</span><br><span class="line">            kindOfClassVar.put(classVarName, <span class="string">&quot;this&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if there&#x27;s a &#x27;,&#x27;, there remains some vars</span></span><br><span class="line">        <span class="keyword">while</span> (Tokenizer.getNextString().equals(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            Tokenizer.stringAdvance();</span><br><span class="line">            <span class="type">String</span> <span class="variable">nextName</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">            <span class="comment">// after the operation, there will be &#x27;,&#x27; or &#x27;;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (classVarKind.equals(<span class="string">&quot;static&quot;</span>)) &#123;</span><br><span class="line">                classVar.put(nextName, classNum++);</span><br><span class="line">                typeOfClassVar.put(nextName, classVarType);</span><br><span class="line">                kindOfClassVar.put(nextName, <span class="string">&quot;this&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (classVarKind.equals(<span class="string">&quot;field&quot;</span>)) &#123;</span><br><span class="line">                classVar.put(nextName, classNum++);</span><br><span class="line">                typeOfClassVar.put(nextName, classVarType);</span><br><span class="line">                kindOfClassVar.put(nextName, <span class="string">&quot;this&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// then we meets &#x27;;&#x27;, we skip it</span></span><br><span class="line">        Tokenizer.stringAdvance();</span><br><span class="line">        <span class="comment">// we continuously deal with rest classVar recursively</span></span><br><span class="line">        <span class="keyword">if</span> (Tokenizer.getNextString().equals(<span class="string">&quot;field&quot;</span>) || Tokenizer.getNextString().equals(<span class="string">&quot;static&quot;</span>)) &#123;</span><br><span class="line">            dealClassVar();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// finally, update the current string</span></span><br><span class="line">        currentStringName.setLength(<span class="number">0</span>);</span><br><span class="line">        currentStringName.append(Tokenizer.stringAdvance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4><span id="c子程序变量">  <span class="math inline">\(c.\)</span>子程序变量</span></h4>
<p>  子程序变量结构与类变量相似，这里略过。需要注意：子程序中包含参数变量，这也需要我们纳入考虑的范畴：</p>
<ul>
<li><p>对参数的处理： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dealFuncArgVar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//the function features: Dec + type + funcName + ( + args + )</span></span><br><span class="line">    <span class="comment">//so we need to ignore the irrelevant elements</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">subroutineType</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">    currentSubroutineName.setLength(<span class="number">0</span>);</span><br><span class="line">    currentSubroutineName.append(className + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    currentSubroutineName.append(Tokenizer.stringAdvance());</span><br><span class="line">    Tokenizer.stringAdvance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//we continue read the arguments until we meet &quot;)&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (!Tokenizer.getNextString().equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// type + name</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        subroutineVar.put(name, argNum++);</span><br><span class="line">        typeOfSubroutineVar.put(name, type);</span><br><span class="line">        kindOfSubroutineVar.put(name, <span class="string">&quot;argument&quot;</span>);</span><br><span class="line">        <span class="comment">//if there&#x27;s a &#x27;,&#x27;, then we have more args</span></span><br><span class="line">        <span class="keyword">while</span> (Tokenizer.getNextString().equals(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//ignore the &#x27;,&#x27;</span></span><br><span class="line">            Tokenizer.stringAdvance();</span><br><span class="line">            type = Tokenizer.stringAdvance();</span><br><span class="line">            name = Tokenizer.stringAdvance();</span><br><span class="line">            subroutineVar.put(name, argNum++);</span><br><span class="line">            typeOfSubroutineVar.put(name, type);</span><br><span class="line">            kindOfSubroutineVar.put(name, <span class="string">&quot;argument&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//we ignore the &quot;)&quot;</span></span><br><span class="line">    Tokenizer.stringAdvance();</span><br><span class="line">    <span class="comment">//then we ignore the &quot;&#123;&quot;</span></span><br><span class="line">    Tokenizer.stringAdvance();</span><br><span class="line">    currentStringName.setLength(<span class="number">0</span>);</span><br><span class="line">    currentStringName.append(Tokenizer.stringAdvance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p>对程序体内部变量的处理：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dealFuncLCLVar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;var&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//var + type + name</span></span><br><span class="line">        <span class="comment">//we skip var first</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Tokenizer.stringAdvance();</span><br><span class="line"></span><br><span class="line">        subroutineVar.put(name, localNum++);</span><br><span class="line">        typeOfSubroutineVar.put(name, type);</span><br><span class="line">        kindOfSubroutineVar.put(name, <span class="string">&quot;local&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//deal with &quot;,&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (Tokenizer.getNextString().equals(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            Tokenizer.stringAdvance();</span><br><span class="line">            name = Tokenizer.stringAdvance();</span><br><span class="line">            subroutineVar.put(name, localNum++);</span><br><span class="line">            typeOfSubroutineVar.put(name, type);</span><br><span class="line">            kindOfSubroutineVar.put(name, <span class="string">&quot;local&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//we meet a &quot;;&quot;</span></span><br><span class="line">    Tokenizer.stringAdvance();</span><br><span class="line">    currentStringName.setLength(<span class="number">0</span>);</span><br><span class="line">    currentStringName.append(Tokenizer.stringAdvance());</span><br><span class="line">    <span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;var&quot;</span>)) dealFuncLCLVar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4><span id="dsymbol-table最终构建">  <span class="math inline">\(d.\)</span><code>Symbol Table</code>最终构建</span></h4>
<p>  有了上述方法的铺垫， 我们只需要在遇到对应的<span class="math inline">\(token\)</span>时调用对应的方法即可。我们利用<code>private static String currentStringName</code>来记录当前读入的<span class="math inline">\(token\)</span>，如果遇到了声明类或子程序的关键字，就跳转到对应的变量处理程序中：</p>
<ol type="1">
<li>当遇到<code>class</code>关键字，我们在忽略掉<span class="math inline">\(class+className+{\)</span>后着手处理类变量：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if we meet &quot;class&quot;, then we call dealClass</span></span><br><span class="line"><span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;class&quot;</span>)) &#123;</span><br><span class="line">    startClass();</span><br><span class="line"></span><br><span class="line">    className = Tokenizer.stringAdvance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ignore the &#x27;&#123;&#x27;</span></span><br><span class="line">    Tokenizer.stringAdvance();</span><br><span class="line"></span><br><span class="line">    dealClassVar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!currentStringName.toString().equals(<span class="string">&quot;class&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>当遇到<code>funcDec</code>关键词，我们只处理<code>varDec</code>部分，并将得到的<span class="math inline">\(Map\)</span>存入对应子程序的<span class="math inline">\(Map\)</span>中：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;method&quot;</span>)</span><br><span class="line">        || currentStringName.toString().equals(<span class="string">&quot;function&quot;</span>)</span><br><span class="line">        || currentStringName.toString().equals(<span class="string">&quot;constructor&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//deal with the arguments first</span></span><br><span class="line">    startSubroutine();</span><br><span class="line">    <span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;method&quot;</span>)) startMethod();</span><br><span class="line">    dealFuncArgVar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//after the argument comes the body of func</span></span><br><span class="line">    <span class="comment">//we only care about varDec</span></span><br><span class="line">    <span class="keyword">if</span> (currentStringName.toString().equals(<span class="string">&quot;var&quot;</span>)) dealFuncLCLVar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//we copy the current ArrayList and deliver the copyList</span></span><br><span class="line">    Map&lt;String, Integer&gt; copyVar = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(subroutineVar);</span><br><span class="line">    Map&lt;String, String&gt; copyType = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(typeOfSubroutineVar);</span><br><span class="line">    Map&lt;String, String&gt; copyKind = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(kindOfSubroutineVar);</span><br><span class="line"></span><br><span class="line">    mapOfSubVar.put(currentSubroutineName.toString(), copyVar);</span><br><span class="line">    mapOfSubVarType.put(currentSubroutineName.toString(), copyType);</span><br><span class="line">    mapOfSubVarKind.put(currentSubroutineName.toString(), copyKind);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//store the index of arg and lcl</span></span><br><span class="line">    subroutineLCLNum.put(currentSubroutineName.toString(), localNum);</span><br><span class="line">    subroutineArgNum.put(currentSubroutineName.toString(), argNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4><span id="d供其他类使用的函数">  <span class="math inline">\(d.\)</span>供其他类使用的函数</span></h4>
<p>  对于给定的输入，返回该输入在<span class="math inline">\(Map\)</span>中对应的值即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">varCount</span><span class="params">(String <span class="keyword">var</span>, String subroutine)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subroutine != <span class="literal">null</span> &amp;&amp; mapOfSubVar.get(subroutine).containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> mapOfSubVar.get(subroutine).get(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (classVar.containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> classVar.get(<span class="keyword">var</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The variable is undefined&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">varType</span><span class="params">(String <span class="keyword">var</span>, String subroutine)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subroutine != <span class="literal">null</span> &amp;&amp; mapOfSubVarType.get(subroutine).containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> mapOfSubVarType.get(subroutine).get(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (typeOfClassVar.containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> typeOfClassVar.get(<span class="keyword">var</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The variable is undefined&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">varKind</span><span class="params">(String <span class="keyword">var</span>, String subroutine)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subroutine != <span class="literal">null</span> &amp;&amp; mapOfSubVarKind.get(subroutine).containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> mapOfSubVarKind.get(subroutine).get(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (kindOfClassVar.containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> kindOfClassVar.get(<span class="keyword">var</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The variable is undefined.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if it&#x27;s a classVar, then subroutine is null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">kindCount</span><span class="params">(String kindName, String subroutine)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subroutine.equals(<span class="string">&quot;Output.printInt&quot;</span>)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (kindName.equals(<span class="string">&quot;argument&quot;</span>)) <span class="keyword">return</span> subroutineArgNum.get(subroutine);</span><br><span class="line">        <span class="keyword">if</span> (kindName.equals(<span class="string">&quot;local&quot;</span>)) <span class="keyword">return</span> subroutineLCLNum.get(subroutine);</span><br><span class="line">        <span class="keyword">if</span> (kindName.equals(<span class="string">&quot;field&quot;</span>) || kindName.equals(<span class="string">&quot;static&quot;</span>)) <span class="keyword">return</span> classNum;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The kind is out of range.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="2vmwriter实现">2.<code>VMWriter</code>实现</span></h3>
<p>  为满足<code>CompileEngine</code>VM代码的生成，我们在<code>VMWriter</code>中设计以下函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writePush</span><span class="params">(String segment, <span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writePop</span><span class="params">(String segment, <span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeOp</span><span class="params">(String command)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeUnaryOp</span><span class="params">(String command)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeCall</span><span class="params">(String name, <span class="type">int</span> argNum)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeFunctionDec</span><span class="params">(String name, <span class="type">int</span> lclNum)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeFunctionCall</span><span class="params">(String name, <span class="type">int</span> argNum)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">writeReturn</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">writeString</span><span class="params">(String string)</span></span><br></pre></td></tr></table></figure>
<h3><span id="3compileengine实现">3.<code>CompileEngine</code>实现</span></h3>
<p>  在<code>CompileEngine</code>中我们希望读入完整的表达式以生成对应的VM代码，因此我们选择直接读入源程序，然后根据读入行的关键字判断其表达式类型。</p>
<h4><span id="a准备工作">  <span class="math inline">\(a.\)</span>准备工作</span></h4>
<p>  为了防止<code>if</code>和<code>while</code>的<span class="math inline">\(label\)</span>重复，我们可以定义<code>private static int ifLabelCount, whileLabelCount</code>。</p>
<p>  同时，由于在调用函数时需要知道函数的返回值类型，我们也要在编译过程中存储我们遇到的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; funcType</span><br></pre></td></tr></table></figure>
<h4><span id="b表达式计算">  <span class="math inline">\(b.\)</span>表达式计算</span></h4>
<p>  我们知道，<code>Jack</code>中的表达式有以下性质： 1.
当没有括号时，从左到右依次计算。 2. 有括号时，优先计算括号内式子。</p>
<p>  因此，我们<strong>从左往右</strong>处理输入的表达式，并<strong>优先考虑是否有括号，如果遇到括号优先处理括号内语句</strong>。</p>
<blockquote>
<p><span class="math inline">\(p.s.\)</span>:由于我们先计算内侧括号、再计算外侧括号，一个自然的想法是<strong>找到最内侧的括号对，处理完其内部表达式后将其抹去，向外延展</strong>。但是这样不满足性质一，因而会导致失败。</p>
</blockquote>
<p>  我们可以利用<strong>栈</strong>来进行括号对的匹配，然后计算对应下标表达式的值。</p>
<p>  在<code>Jack</code>语法一章中，我们知道表达式具有如下结构：</p>
<p><span class="math display">\[expression=term(op\;term)\]</span></p>
<p>  我们可以继续沿用该结构，<strong>利用<code>op</code>将原表达式拆分成一个个子表达式，然后分别递归计算</strong>。但是，我们并不能确定<span class="math inline">\(term\)</span>的个数，因此我们对上面的结构进行改动：</p>
<p><span class="math display">\[expression=term(op\;expression)\]</span></p>
<p>  该结构的变量个数是确定的，我们只需分别递归计算即可：</p>
<blockquote>
<p><span class="math inline">\(p.s\)</span>这里有一个比较棘手的问题：对于<span class="math inline">\(unary\;op\)</span>的处理。在<code>-(1+2)</code>这个表达式中，第一个<code>-</code>并不起到拆分的作用。注意到我们是以<span class="math inline">\(term\)</span>为基本处理单元的，而<strong>在<span class="math inline">\(term\)</span>中<span class="math inline">\(unary\;op\)</span>只能在第一个位置</strong>。因此，我们在从左往右计算前<strong>先判断第一个元素是否为<span class="math inline">\(op\)</span>，如果是，我们对其进行计算，然后在计算完第一个<span class="math inline">\(term\)</span>后记录该表达式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if the first character belongs unary op //then we skip it </span></span><br><span class="line"><span class="type">String</span> <span class="variable">unaryOp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; </span><br><span class="line"><span class="keyword">if</span> (isOp(line.charAt(<span class="number">0</span>))) &#123; </span><br><span class="line">	unaryOp = Character.toString(line.charAt(<span class="number">0</span>)); </span><br><span class="line">	line = line.substring(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!unaryOp.isEmpty()) expression.add(VMWriter.writeUnaryOp(unaryOp));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileExpression</span><span class="params">(String line)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; expression = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if the first character belongs unary op</span></span><br><span class="line">    <span class="comment">//then we skip it</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">unaryOp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isOp(line.charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">        unaryOp = Character.toString(line.charAt(<span class="number">0</span>));</span><br><span class="line">        line = line.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!containOP(line)) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; term = compileTerm(line);</span><br><span class="line">        expression.addAll(term);</span><br><span class="line">        <span class="keyword">if</span> (!unaryOp.isEmpty())</span><br><span class="line">            expression.add(VMWriter.writeUnaryOp(unaryOp));</span><br><span class="line">        <span class="keyword">return</span> expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if we meet (, deal with it first</span></span><br><span class="line">    <span class="keyword">if</span> (line.charAt(<span class="number">0</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.charAt(i) == <span class="string">&#x27;(&#x27;</span>) stack.push(i);</span><br><span class="line">            <span class="keyword">if</span> (line.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) stack.pop();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    rightIndex = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">termExp</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, rightIndex + <span class="number">1</span>);</span><br><span class="line">        expression.addAll(compileTerm(termExp));</span><br><span class="line">        <span class="keyword">if</span> (!unaryOp.isEmpty()) expression.add(VMWriter.writeUnaryOp(unaryOp));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the ) is not the last, then after it comes an op</span></span><br><span class="line">        <span class="comment">//it&#x27;s defined by the Jack grammar</span></span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; line.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            expression.addAll(compileExpression(line.substring(rightIndex + <span class="number">2</span>)));</span><br><span class="line">            expression.add(VMWriter.writeOp(Character.toString(line.charAt(rightIndex + <span class="number">1</span>))));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//we deal with the next op</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">opIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">curOp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOp(line.charAt(i))) &#123;</span><br><span class="line">            opIndex = i;</span><br><span class="line">            curOp = Character.toString(line.charAt(i));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">termExp1</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, opIndex);</span><br><span class="line">    <span class="type">String</span> <span class="variable">termExp2</span> <span class="operator">=</span> line.substring(opIndex + <span class="number">1</span>);</span><br><span class="line">    expression.addAll(compileTerm(termExp1));</span><br><span class="line">    <span class="keyword">if</span> (!unaryOp.isEmpty())</span><br><span class="line">        expression.add(VMWriter.writeUnaryOp(unaryOp));</span><br><span class="line">    <span class="keyword">if</span> (!termExp2.isEmpty())</span><br><span class="line">        expression.addAll(compileExpression(termExp2));</span><br><span class="line">    expression.add(VMWriter.writeOp(curOp));</span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  对于<span class="math inline">\(term\)</span>的处理较为简单，只需注意对函数的判断方式即可：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileTerm</span><span class="params">(String line)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; term = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line.matches(<span class="string">&quot;-?\\d+&quot;</span>)) &#123;</span><br><span class="line">        term.add(VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, Integer.parseInt(line)));</span><br><span class="line">        <span class="keyword">return</span> term;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line.contains(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//if the first is &quot;(&quot;, then it&#x27;s (expression)</span></span><br><span class="line">        <span class="keyword">if</span> (line.charAt(<span class="number">0</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            term.addAll(compileExpression(line.substring(<span class="number">1</span>, line.length() - <span class="number">1</span>)));</span><br><span class="line">            <span class="keyword">return</span> term;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//else, it&#x27;s a functionCall</span></span><br><span class="line">            ArrayList&lt;String&gt; functionCall = compileSubroutineCall(line);</span><br><span class="line">            term.addAll(functionCall);</span><br><span class="line">            <span class="keyword">return</span> term;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if line contains &#x27;[&#x27;, it must be an array</span></span><br><span class="line">    <span class="keyword">if</span> (line.contains(<span class="string">&quot;[&quot;</span>)) &#123;</span><br><span class="line">        term.addAll(compileArray(line));</span><br><span class="line">        <span class="keyword">return</span> term;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if it&#x27;s a stringConstant, we use string method to append char by char</span></span><br><span class="line">    <span class="keyword">if</span> (line.charAt(<span class="number">0</span>) == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> line.substring(<span class="number">1</span>, line.length() - <span class="number">1</span>);</span><br><span class="line">        term.addAll(VMWriter.writeString(string));</span><br><span class="line">        <span class="keyword">return</span> term;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//else, it&#x27;s a variable</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        term.add(VMWriter.writePush(SymbolTable.varKind(line, curSubroutine.toString()), SymbolTable.varCount(line, curSubroutine.toString())));</span><br><span class="line">        <span class="keyword">return</span> term;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4><span id="creturn语句">  <span class="math inline">\(c.\)</span><code>return</code>语句</span></h4>
<p>  根据<code>return</code>变量进行分类处理即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileReturnStatement</span><span class="params">(String line)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; returnStatement = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract the return value from the line</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">returnVal</span> <span class="operator">=</span> line.substring(<span class="number">6</span>, line.indexOf(<span class="string">&quot;;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!returnVal.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isKeywordConstant(returnVal)) &#123;</span><br><span class="line">            <span class="comment">// Handle keyword constants</span></span><br><span class="line">            <span class="keyword">if</span> (returnVal.equals(<span class="string">&quot;this&quot;</span>)) &#123;</span><br><span class="line">                returnStatement.add(VMWriter.writePush(<span class="string">&quot;pointer&quot;</span>, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (returnVal.equals(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line">                returnStatement.add(VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, <span class="number">0</span>));</span><br><span class="line">                returnStatement.add(<span class="string">&quot;not&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (returnVal.equals(<span class="string">&quot;false&quot;</span>) || returnVal.equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                returnStatement.add(VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnVal.matches(<span class="string">&quot;-?\\d+&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// Handle integer constants</span></span><br><span class="line">            returnStatement.add(VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, Integer.parseInt(returnVal)));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnVal.charAt(<span class="number">0</span>) == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// Handle string constants</span></span><br><span class="line">            returnVal = returnVal.substring(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> returnVal.substring(<span class="number">0</span>, returnVal.length() - <span class="number">1</span>);</span><br><span class="line">            returnStatement.addAll(VMWriter.writeString(string));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Handle variable return values</span></span><br><span class="line">            returnStatement.add(VMWriter.writePush(SymbolTable.varKind(returnVal, curSubroutine.toString()), SymbolTable.varCount(returnVal, curSubroutine.toString())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If no return value, push 0</span></span><br><span class="line">        returnStatement.add(VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add return command</span></span><br><span class="line">    returnStatement.add(<span class="string">&quot;return&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnStatement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4><span id="ddo语句">  <span class="math inline">\(d.\)</span><code>do</code>语句</span></h4>
<p>  <code>do</code>语句只需处理被调用的函数即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileDoStatement</span><span class="params">(String line)</span> &#123;</span><br><span class="line">	line = line.substring(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> compileSubroutineCall(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="elet语句">  <span class="math inline">\(e.\)</span><code>let</code>语句</span></h4>
<p>  对<code>let</code>语句的处理需要注意分类的依据：<strong>左侧的表达式是否为数组</strong>，如果左侧为数组，我们需要加入以下的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop temp 0</span><br><span class="line">pop pointer 1</span><br><span class="line">push temp 0</span><br><span class="line">pop that 0</span><br></pre></td></tr></table></figure>
<p>  否则左侧表达式只能是一个普通的变量，我们将其<code>pop</code>即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileLetStatement</span><span class="params">(String line)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; letstatement = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        line = line.substring(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;=&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> line.substring(line.indexOf(<span class="string">&quot;=&quot;</span>) + <span class="number">1</span>, line.indexOf(<span class="string">&quot;;&quot;</span>));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//case 1: array var + expression</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var1.contains(<span class="string">&quot;[&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">exp1</span> <span class="operator">=</span> var1.substring(var1.indexOf(<span class="string">&quot;[&quot;</span>) + <span class="number">1</span>, var1.indexOf(<span class="string">&quot;]&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> var1.substring(<span class="number">0</span>, var1.indexOf(<span class="string">&quot;[&quot;</span>));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            ArrayList&lt;String&gt; expression1 = compileExpression(exp1);</span><br><span class="line"></span><br><span class="line">            letstatement.addAll(expression1);</span><br><span class="line"></span><br><span class="line">            letstatement.add(VMWriter.writePush(SymbolTable.varKind(name1, curSubroutine.toString()), SymbolTable.varCount(name1, curSubroutine.toString())));</span><br><span class="line"></span><br><span class="line">            letstatement.add(<span class="string">&quot;add&quot;</span>);</span><br><span class="line"></span><br><span class="line">            letstatement.addAll(compileExpression(var2));</span><br><span class="line"></span><br><span class="line">            letstatement.add(VMWriter.writePop(<span class="string">&quot;temp&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            letstatement.add(VMWriter.writePop(<span class="string">&quot;pointer&quot;</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            letstatement.add(VMWriter.writePush(<span class="string">&quot;temp&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            letstatement.add(VMWriter.writePop(<span class="string">&quot;that&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> letstatement;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4><span id="e函数体模块设计ampif-while处理手段">  <span class="math inline">\(e.\)</span>函数体模块设计&amp;<code>if, while</code>处理手段</span></h4>
<p>  在处理<code>if</code>语句时，我们需要在处理<code>if</code>花括号括起的部分后添加<code>IF_ENDLabelindex</code>。因此，我们自然地想到引入<code>compileSubroutineBody</code>函数对函数体模块进行整体地编译(而非一条语句一条语句地离散处理)，它接受的参数是<strong>多条语句构成的函数体<code>ArrayList&lt;String&gt;</code></strong>。</p>
<p>  那么如何实现<code>if</code>语句呢？一个自然地想法如下：</p>
<ol type="1">
<li>设计一个函数<code>compileIfStatement()</code>，它接受一个<code>ArrayList&lt;String&gt;</code>，返回编译后的<code>ArrayList&lt;String&gt;</code>。</li>
<li>传入<code>if</code>语句对应的子程序，然后输出结果。</li>
</ol>
<p>  但是，当我们得到输出结果并往下继续处理时，那些属于<code>if</code>子程序的代码会<strong>被重复处理</strong>。这并不是我们想要的结果。笔者曾试过处理完<code>if</code>的子程序后将其删去，但最终失败了。因此笔者想到了下面的方法：</p>
<ol type="1">
<li>我们依然对<code>if</code>对应的子程序进行读取。</li>
<li>但我们并不将其作为参数传入<code>compileIfStatement</code>，而是<strong>记录下该子程序的行数</strong><code>ifIndex</code>。</li>
<li>同时，在<code>compileSubroutineBody</code>中，我们实时更新当前的代码行数<code>currentIndex</code>。</li>
<li>我们通过记录的<code>currentIndex</code>和<code>ifIndex</code><strong>计算出应该添加<span class="math inline">\(label\)</span>的行数</strong>，然后<strong>当<code>currentIndex</code>的值与其相等时添加<span class="math inline">\(label\)</span></strong>。</li>
</ol>
<p>  同时，我们依然保留<code>compileIfStatement</code>这个方法，只是该方法仅用来编译<code>if(expression)</code>语句。</p>
<blockquote>
<p>如果遇到<code>else</code>语句，直接忽略即可。</p>
</blockquote>
<blockquote>
<p>另：我们不能直接用类中定义的<code>static int ifLabelCount</code>作为标记的序号，因为当存在嵌套条件循环时，由于不管遇到哪个<code>if</code>该值都会增加1，这会导致<strong>同一个<code>if</code>的前后标记序号不一致</strong>。对此，我们<strong>用一个<span class="math inline">\(Map\)</span>来存储特定<code>lineIndex</code>对应的标记序号</strong>，由于<code>lineIndex</code>是唯一的，我们的前后标记序号将会一致。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileSubroutineBody</span><span class="params">(ArrayList&lt;String&gt; lines)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; subroutinebody = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lineIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ifstatementLineNum</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">whilestatementLineNum</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lineIndex == ifstatementLineNum) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">labelCnt</span> <span class="operator">=</span> loopCount.get(ifstatementLineNum);</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;label IF_FALSE&quot;</span> + Integer.toString(labelCnt));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lineIndex == whilestatementLineNum) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">labelCnt</span> <span class="operator">=</span> loopCount.get(whilestatementLineNum);</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;goto WHILE_EXP&quot;</span> + Integer.toString(labelCnt));</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;label WHILE_END&quot;</span> + Integer.toString(labelCnt));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;else&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            line = line.substring(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;do&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            subroutinebody.addAll(compileDoStatement(line));</span><br><span class="line">            lineIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;let&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            subroutinebody.addAll(compileLetStatement(line));</span><br><span class="line">            lineIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;return&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            subroutinebody.addAll(compileReturnStatement(line));</span><br><span class="line">            lineIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;if&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ifstatement</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;&#123;&quot;</span>)) &#123;</span><br><span class="line">                ifstatement = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;&#123;&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ifstatement = line;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            subroutinebody.addAll(compileIfStatement(ifstatement));</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;if-goto IF_TRUE&quot;</span> + Integer.toString(ifLabelCount));</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;goto IF_FALSE&quot;</span> + Integer.toString(ifLabelCount));</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;label IF_TRUE&quot;</span> + Integer.toString(ifLabelCount));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;&#123;&quot;</span>) &amp;&amp; line.indexOf(<span class="string">&quot;&#123;&quot;</span>) != line.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                ArrayList&lt;String&gt; statement = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                statement.add(line.substring(line.indexOf(<span class="string">&quot;&#123;&quot;</span>) + <span class="number">1</span>));</span><br><span class="line">                subroutinebody.addAll(compileSubroutineBody(statement));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ifstatementLineNum = Operation.selectContent(Operation.subList(lines, lineIndex)).size() + lineIndex++;</span><br><span class="line">            loopCount.put(ifstatementLineNum, ifLabelCount++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;while&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">whilestatement</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;&#123;&quot;</span>)) &#123;</span><br><span class="line">                whilestatement = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;&#123;&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                whilestatement = line;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            subroutinebody.add(<span class="string">&quot;label WHILE_EXP&quot;</span> + Integer.toString(whileLabelCount));</span><br><span class="line">            subroutinebody.addAll(compileWhileStatement(whilestatement));</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;not&quot;</span>);</span><br><span class="line">            subroutinebody.add(<span class="string">&quot;if-goto WHILE_END&quot;</span> + Integer.toString(whileLabelCount));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;&#123;&quot;</span>) &amp;&amp; line.indexOf(<span class="string">&quot;&#123;&quot;</span>) != line.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                ArrayList&lt;String&gt; statement = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                statement.add(line.substring(line.indexOf(<span class="string">&quot;&#123;&quot;</span>) + <span class="number">1</span>));</span><br><span class="line">                subroutinebody.addAll(compileSubroutineBody(statement));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            whilestatementLineNum = Operation.selectContent(Operation.subList(lines, lineIndex)).size() + lineIndex++;</span><br><span class="line">            loopCount.put(whilestatementLineNum, whileLabelCount++);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lineIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subroutinebody;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="f其他杂项的处理">  <span class="math inline">\(f.\)</span>其他杂项的处理</span></h4>
<p>  在实现了框架的大部分内容后，针对VM代码自身的特定，我们需要额外补充对一些操作的实现：</p>
<ol type="1">
<li>对数组的处理：我们将数组名称所在内存段和内部表达式的值<code>add</code>，然后<code>pop pointer 1</code>，<code>push that 0</code>即可：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileArray</span><span class="params">(String line)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the array consists of varName + [ + expression + ]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">varName</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;[&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">exp</span> <span class="operator">=</span> line.substring(line.indexOf(<span class="string">&quot;[&quot;</span>) + <span class="number">1</span>, line.indexOf(<span class="string">&quot;]&quot;</span>));</span><br><span class="line">    ArrayList&lt;String&gt; expression = compileExpression(exp);</span><br><span class="line"></span><br><span class="line">    array.add(VMWriter.writePush(SymbolTable.varKind(varName, curSubroutine.toString()), SymbolTable.varCount(varName, curSubroutine.toString())));</span><br><span class="line">    array.addAll(expression);</span><br><span class="line">    array.add(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">    array.add(VMWriter.writePop(<span class="string">&quot;pointer&quot;</span>, <span class="number">1</span>));</span><br><span class="line">    array.add(VMWriter.writePush(<span class="string">&quot;that&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>调用函数：将函数所需参数<code>push</code>，然后计算参数个数、调用即可。需要注意判断函数是否为<code>void</code>型，如果是的话需要<code>pop temp 0</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileSubroutineCall</span><span class="params">(String line)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; subroutine = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">argNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we first store the functionName</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">funcName</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;(&quot;</span>));</span><br><span class="line">    line = line.substring(line.indexOf(<span class="string">&quot;(&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!funcName.contains(<span class="string">&quot;.&quot;</span>)) funcName = className + <span class="string">&quot;.&quot;</span> + funcName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then comes the expressionList</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expressionList</span> <span class="operator">=</span> line.substring(line.indexOf(<span class="string">&#x27;(&#x27;</span>) + <span class="number">1</span>, line.indexOf(<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!expressionList.isEmpty()) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; expressions = compileExpressionList(expressionList);</span><br><span class="line">        subroutine.addAll(expressions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!expressionList.isEmpty()) &#123;</span><br><span class="line">        argNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; expressionList.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expressionList.charAt(i) == <span class="string">&#x27;,&#x27;</span>) argNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// finally we call the method</span></span><br><span class="line">    <span class="keyword">if</span> (Tokenizer.funcCollection.contains(funcName)) &#123;</span><br><span class="line">        subroutine.add(VMWriter.writeFunctionCall(funcName, argNum));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : Tokenizer.funcCollection) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.substring(s.indexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>).equals(funcName.substring(funcName.indexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>))) &#123;</span><br><span class="line">                subroutine.add(VMWriter.writeFunctionCall(s, argNum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (funcType.get(funcName).equals(<span class="string">&quot;void&quot;</span>))</span><br><span class="line">        subroutine.add(VMWriter.writePop(<span class="string">&quot;temp&quot;</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subroutine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="gcompileengine最终构建">  <span class="math inline">\(g.\)</span>
<code>CompileEngine</code>最终构建</span></h4>
<ol type="1">
<li><p>预处理。将待编译的一个或多个文件作为参数传入<code>SymbolTable.constructor</code>，以构建每个文件对应的<code>Symbol Table</code>。</p></li>
<li><p>编译时，如果遇到一个函数/方法名，先将其存入<code>funcType</code>中，以在后续调用该函数时能够找到该函数/方法名。</p></li>
<li><p>对<code>constructor</code>，<code>method</code>需要进行各自的预处理。</p></li>
<li><p>我们可以将待编译的代码如下分类：</p>
<ul>
<li>方法/函数的声明。</li>
<li>变量声明。</li>
<li>方法/函数体。</li>
</ul></li>
</ol>
<p>  对每一类，分别编译即可。需要注意，处理函数体时，我们需要读入整个子程序，将其放入<code>ArrayList&lt;String&gt;</code>中作为<code>compileSubroutineBody</code>的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">constructor</span><span class="params">(String[] files)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String filename : files) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> filename.substring(<span class="number">0</span>, filename.length() - <span class="number">5</span>);</span><br><span class="line">        Operation.addToArray(Tokenizer.className, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String filename : files) &#123;</span><br><span class="line">        SymbolTable.constructor(filename);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">vmFile</span> <span class="operator">=</span> filename.substring(<span class="number">0</span>, filename.length() - <span class="number">5</span>) + <span class="string">&quot;.vm&quot;</span>;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filename));</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(vmFile));</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> Operation.modify(reader.readLine());</span><br><span class="line">            <span class="keyword">while</span> (line != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!line.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (line.indexOf(<span class="string">&quot;class&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        className.setLength(<span class="number">0</span>);</span><br><span class="line">                        className.append(line.substring(<span class="number">5</span>, line.length() - <span class="number">1</span>));</span><br><span class="line">                        line = Operation.modify(reader.readLine());</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (isSubroutineDec(line)) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">subroutineKind</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">subroutineType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">subroutineLength</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">typeLength</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; subroutineDec.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (line.indexOf(subroutineDec[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                                subroutineKind = subroutineDec[i];</span><br><span class="line">                                subroutineLength = subroutineDec[i].length();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        line = line.substring(subroutineLength);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// then comes the type</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; type.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (line.indexOf(type[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                                subroutineType = type[i];</span><br><span class="line">                                typeLength = type[i].length();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        line = line.substring(typeLength);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">subroutine</span> <span class="operator">=</span> className + <span class="string">&quot;.&quot;</span> + line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;(&quot;</span>));</span><br><span class="line">                        curSubroutine.setLength(<span class="number">0</span>);</span><br><span class="line">                        curSubroutine.append(subroutine);</span><br><span class="line">                        funcType.put(curSubroutine.toString(), subroutineType);</span><br><span class="line">                        writer.write(VMWriter.writeFunctionDec(curSubroutine.toString(), SymbolTable.kindCount(<span class="string">&quot;local&quot;</span>, curSubroutine.toString())));</span><br><span class="line">                        writer.newLine();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (subroutineKind.equals(<span class="string">&quot;constructor&quot;</span>)) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">line1</span> <span class="operator">=</span> VMWriter.writePush(<span class="string">&quot;constant&quot;</span>, SymbolTable.kindCount(<span class="string">&quot;field&quot;</span>, <span class="literal">null</span>));</span><br><span class="line">                            <span class="type">String</span> <span class="variable">line2</span> <span class="operator">=</span> VMWriter.writeCall(<span class="string">&quot;Memory.alloc&quot;</span>, <span class="number">1</span>);</span><br><span class="line">                            writer.write(line1);</span><br><span class="line">                            writer.newLine();</span><br><span class="line">                            writer.write(line2);</span><br><span class="line">                            writer.newLine();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (subroutineKind.equals(<span class="string">&quot;method&quot;</span>)) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">line1</span> <span class="operator">=</span> VMWriter.writePush(<span class="string">&quot;argument&quot;</span>, <span class="number">0</span>);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">line2</span> <span class="operator">=</span> VMWriter.writePop(<span class="string">&quot;pointer&quot;</span>, <span class="number">0</span>);</span><br><span class="line">                            writer.write(line1);</span><br><span class="line">                            writer.newLine();</span><br><span class="line">                            writer.write(line2);</span><br><span class="line">                            writer.newLine();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        line = Operation.modify(reader.readLine());</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// case 2: varDec, we just ignore it</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (isVarDec(line)) &#123;</span><br><span class="line">                        <span class="keyword">while</span> (isVarDec(line)) &#123;</span><br><span class="line">                            line = Operation.modify(reader.readLine());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// case 3: subroutineBody</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        ArrayList&lt;String&gt; subroutineCode = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        <span class="keyword">while</span> (line != <span class="literal">null</span> &amp;&amp; !isSubroutineDec(line)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!line.isEmpty()) &#123;</span><br><span class="line">                                System.out.println(line);</span><br><span class="line">                                subroutineCode.add(line);</span><br><span class="line">                            &#125;</span><br><span class="line">                            line = Operation.modify(reader.readLine());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ArrayList&lt;String&gt; subroutineBody = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(compileSubroutineBody(subroutineCode));</span><br><span class="line">                        <span class="keyword">for</span> (String s : subroutineBody) &#123;</span><br><span class="line">                            writer.write(s);</span><br><span class="line">                            writer.newLine();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        line = Operation.modify(reader.readLine());</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                line = Operation.modify(reader.readLine());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            reader.close();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.3.对表达式的处理</title>
    <url>/2024/04/20/10-3-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1><span id="113handling-expression"><span class="math inline">\(11.3.\)</span>Handling Expression</span></h1>
<h3><span id="1expressions-definitionreview">1.Expressions definition
review</span></h3>
<p><img src="/2024/04/20/10-3-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/image-5.png"></p>
<h3><span id="2parse-tree">2.Parse tree</span></h3>
<p><img src="/2024/04/20/10-3-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/image-6.png"></p>
<ul>
<li><em>infix</em>: that's sort of ingrained into our brains in
elementary school.</li>
<li><em>prefix</em>: that's what we do when we define functions: we put
the function name and then a list of operands or parameters or
arguments.</li>
<li><em>postfix</em>: that's closely related to the stack machine. Say
we want to do an <code>add</code> operation, we <code>push x</code>,
<code>push y</code> and finally <code>pop</code>, this is exactly
postfix.</li>
</ul>
<h3><span id="3generating-code-forexpressions">3.Generating code for
expressions</span></h3>
<p>  In high level language like Java, we declare expressions in infix,
and the target language, so our compiler has to translate from infix to
postfix. Here are two ways to do this:</p>
<p><img src="/2024/04/20/10-3-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/image-7.png"></p>
<ol type="1">
<li>We generate a parse tree through the infix expression.</li>
<li>The parser takes the source code and produces XML code from it.</li>
<li>We go through every node in the parse tree in a certain order.</li>
</ol>
<p>  To convert the parse tree into the VM code, we use the
<em>deep-first tree traversal algorithm</em>:</p>
<ul>
<li>We go all the way down, and when we hit a terminal leaf, we process
it.</li>
</ul>
<p>  However, the parse tree we have may be gigantic, so it may be
better not to have the side effect. We will use the following code
generation algorithm instead:</p>
<p><img src="/2024/04/20/10-3-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/image-8.png"></p>
<ul>
<li>Whatever is the mapping of <code>x</code> is dictated by the symbol
table which is always in the background of the co-generation
algorithms.</li>
</ul>
<p>  The nice thing about this algorithm is that not only does it
<strong>capture the semantics of the input expression</strong>, it also
<strong>computes the value of this expression</strong>. That is, in the
runtime the value of the expression is going to be placed on the
stack.</p>
<h3><span id="4from-parsing-to-codegeneration">4.From parsing to code
generation</span></h3>
<p>  In the previous project, we develop a Jack Analyzer that generate
static XML code, but in this part, the XML is completely irrelevant now.
Instead, we generate actual executable VM code. And there are some
general guidelines on what has to be done:</p>
<ul>
<li>We have <strong>operator priority</strong> in some operation, such
as mathematics operations (however, Jack doesn't have this). Since the
compiler will ignore it, we ourselves must take this into
consideration.</li>
<li>Once we have parenthesis in Jack, we have to take operator priority
into consideration. We have to make the code write algorithm work in the
proper order as dictated by the parenthesis.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>9.3.语法</title>
    <url>/2024/04/16/10-3-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1><span id="93grammars"><span class="math inline">\(9.3.\)</span>Grammars</span></h1>
<h3><span id="1grammar-introduction">1.Grammar introduction</span></h3>
<p>  In the previous unit, we gain the ability to think about the
program as a set of tokens, but the effect that we have a set of valid
tokens doesn't imply that we have a valid program. <strong>It's not only
the tokens that are important, the order of the tokens is critically
important as well</strong>.</p>
<p>  And the artifact that <strong>defines in what order we can put
tokens together legibly</strong> is referred to as <em>grammar</em>.</p>
<ul>
<li>A grammar is a set of rules, describing how tokens can be combined
to create valid language constructs</li>
</ul>
<p>  Take the English language as an example:</p>
<p><img src="/2024/04/16/10-3-%E8%AF%AD%E6%B3%95/image.png"></p>
<p>  It's just a subset of English language, but is sufficiently rich to
support plenty of inputs. Consider the sentence "The dog ate my
homework":</p>
<ul>
<li>'The' is a det and 'dog' is a noun, so the sentence begins with a
noun phrase.</li>
<li>'ate' is a verb and 'my homework' is once again a noun phrase, so
this subsentence is a verb phrase.</li>
<li>Taken together, we have a noun phrase followed by a verb phrase,
therefore we have a legitimate sentence.</li>
</ul>
<p>  In this example, we notice that grammar is indeed made of a set of
rules. And these rules fall into two broad categories:</p>
<ol type="1">
<li><em>Terminal rule</em>: Its right-hand side consists of constants
only.</li>
<li><em>Non-terminal rule</em>: Its right-hand side consists of names of
other rules, and probably constants.</li>
</ol>
<h3><span id="2jack-grammar">2.Jack grammar</span></h3>
<p>  Let's focus on a subset of Jack language in which we have three
possible statements: <code>if</code>, <code>while</code>,
<code>let</code>:</p>
<p><img src="/2024/04/16/10-3-%E8%AF%AD%E6%B3%95/image-1.png"></p>
<ul>
<li>We use <code>*</code> to indicate 0 or more.</li>
<li>We use <code>|</code> to denote choice.</li>
<li>We use <code>?</code> to denote 0 or 1.</li>
</ul>
<p>  And the process of <strong>determining if a given input conforms to
a grammar</strong> is called <em>prasing</em>.</p>
<p>  Notice that in the process of doing this confirmation, we also
<strong>uncover the entire grammatical structure of the given
input</strong>, because we analyze how the input corresponds to the
various components of the rule.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 9.Syntax Analyze</category>
      </categories>
  </entry>
  <entry>
    <title>10.4.对控制流的处理</title>
    <url>/2024/04/20/10-4-%E5%AF%B9%E6%8E%A7%E5%88%B6%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1><span id="114handling-flow-of-control"><span class="math inline">\(11.4.\)</span>Handling Flow of Control</span></h1>
<p><img src="/2024/04/20/10-4-%E5%AF%B9%E6%8E%A7%E5%88%B6%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86/image.png"></p>
<ul>
<li>The <code>not</code> operation will <strong>turn the expression into
a boolean value</strong>, thus make out code simpler and tighter.</li>
<li>The compiler generates these labels automatically.</li>
</ul>
<p><img src="/2024/04/20/10-4-%E5%AF%B9%E6%8E%A7%E5%88%B6%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86/image-1.png"></p>
<p>  In a program, we may have multiple <code>if</code> and
<code>while</code>statements, to deal we this, we only have to assure
that <strong>the compiler generates unique labels</strong>.</p>
<p>  Also the <code>if</code> and <code>while</code> statements may be
nested. That is , <strong>the compiler employs a highly recursive
compilation</strong>.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>9.4.解析树</title>
    <url>/2024/04/16/10-4-%E8%A7%A3%E6%9E%90%E6%A0%91/</url>
    <content><![CDATA[<h1><span id="94parsetree"><span class="math inline">\(9.4.\)</span>Parse
Tree</span></h1>
<h3><span id="1parse-tree-introduction">1.Parse tree introduction</span></h3>
<p>  In this part we are going to be specific about the grammatical
structure. Take the sentence "the dog ate my homework" for example,
here's the grammatical structure of it:</p>
<p><img src="/2024/04/16/10-4-%E8%A7%A3%E6%9E%90%E6%A0%91/image.png"></p>
<p>  It's recorded using a <em>parse tree</em>. The tree is a recursive
structure, and the grammatical structure of the inputs are
<strong>recursive</strong>, too.</p>
<ul>
<li>The <code>sentence</code> consists of two lower-level sub parse
tree.</li>
<li>We continue to expanding the tree until get to the boundary of the
tree, called <em>leaves</em> or <em>terminal nodes</em>. In the case of
lexical analysis, they are <strong>the tokens from which the input is
constructed</strong>.</li>
</ul>
<p>  Then let's move to Jack. Take the input
<code>while (count &lt; 100) &#123;let count = count + 1;&#125;</code> for
example:</p>
<p><img src="/2024/04/16/10-4-%E8%A7%A3%E6%9E%90%E6%A0%91/image-1.png"></p>
<blockquote>
<p>The notion of a parse tree is an obstruct artifact that sits
somewhere above all these nice diagrams. And this diagram here is just
one way to describe this parse tree.</p>
</blockquote>
<p>  To motivate this, let's focus on some subset of the prase tree:</p>
<p><img src="/2024/04/16/10-4-%E8%A7%A3%E6%9E%90%E6%A0%91/image-2.png"></p>
<p>  Another way of describing the same parse tree can be <em>XML
format</em>:</p>
<p><img src="/2024/04/16/10-4-%E8%A7%A3%E6%9E%90%E6%A0%91/image-3.png"></p>
<ul>
<li>In XML, we describe the structure of data using <em>markup
tags</em>.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 9.Syntax Analyze</category>
      </categories>
  </entry>
  <entry>
    <title>10.5.对对象的处理——底层特性</title>
    <url>/2024/04/22/10-5-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1><span id="105handling-objects-low-levelaspects"><span class="math inline">\(10.5.\)</span>Handling Objects: Low-level
Aspects</span></h1>
<p><img src="/2024/04/22/10-5-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/image.png"></p>
<h3><span id="1handling-objects">1.Handling objects</span></h3>
<p>  Let's review how we handle <code>local</code> and
<code>argument</code> first:</p>
<p><img src="/2024/04/22/10-5-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/image-1.png"></p>
<ul>
<li><p>The first five words in the RAM are used as <strong>pointer that
hold the current value of the stack pointer, namely the base address of
the <code>local</code>, <code>argument</code>, <code>this</code>,
<code>that</code></strong>.</p></li>
<li><p>The VM implementation also allocates a certain area on RAM to
hold the global stack which <strong>keeps the working stack of the
currentlt running VM functions</strong> and all the working stack and
memory segments of the functions that wait to for the current function
to terminate, namely the functions which <strong>are on the calling
chain</strong>.</p></li>
<li><p>The VM implementation recalls the location of these segments of
the stack by <strong>using the two pointers <code>LCL</code> and
<code>ARG</code></strong>. It records the base address of this segment
in the <code>LCL</code>.</p></li>
</ul>
<p>  Then how can we use the same architecture to represent object and
array data?</p>
<ol type="1">
<li>We use a different area altogether on the RAM called
<em><code>heap</code></em>.</li>
<li>On the <code>heap</code>, we recall the data of all the objects and
the arrays that the current program seeks to manipulate.</li>
</ol>
<p><img src="/2024/04/22/10-5-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/image-2.png"></p>
<p>  As opposed to the <code>local</code> and <code>argument</code>
segments which have only one of each to worry about, here you may have
many objects on the heap. So before we access an object using
<code>this</code> segment, we have to tell the system <strong>to which
object are we actually referring</strong>?</p>
<ul>
<li>The implementation of <code>this</code> location is first
<strong>use the pointer <code>this</code> and
<code>that</code></strong>.</li>
<li>Before we use the two segments, we <strong>first have to use the
<code>pointer</code> segment</strong> to <strong>tell the system where
we want to align <code>this</code> and <code>that</code> on the
RAM</strong>.</li>
</ul>
<blockquote>
<p>We had to provide a mechanism to anchor this and that on the
particular object and array the code has to operate on and we are using
this virtual segment pointer for this purpose.</p>
</blockquote>
<p>  Now, suppose we want to access RAM words 8000, 8001, 8002... We can
achieve this by the following VM code:</p>
<p><img src="/2024/04/22/10-5-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E5%BA%95%E5%B1%82%E7%89%B9%E6%80%A7/image-3.png"></p>
<ul>
<li>Once we set <code>THIS</code> pointer to a particular address,
<strong><code>THIS</code>can be used as if it's anchored exactly on the
8000th address in RAM</strong>. Given this desired mapping, we can use
command related to <code>THIS</code>.</li>
<li><code>push this 0</code> will <strong>take the value which is
currently located in <code>RAM 8000</code> onto the stack</strong>.</li>
<li><code>pop this 0</code> will <strong>take something off the stack
and put it into <code>RAM 8000</code></strong>.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.6.对对象的处理——构造</title>
    <url>/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<h1><span id="106handling-objects-construction"><span class="math inline">\(10.6.\)</span>Handling Objects: Construction</span></h1>
<p><img src="/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/image.png"></p>
<ul>
<li>What we have here is two completely separate compilation units. We
are facing the challenge of compiling the caller class and the callee
class.</li>
</ul>
<h3><span id="1high-level-of-objectconstruction">1.High level of object
construction</span></h3>
<ul>
<li>When we do <code>var Point p1</code>, the compiler will end up
generating code on <strong>some location in the stack which is going to
be initialized to 0</strong>.</li>
<li>When we call the constructor, the compiled code will end up
<strong>creating the object proper on the heap</strong>.</li>
<li>The two class running together will end up <strong>taking the base
address of the newly created object</strong> and <strong>storing it in
what we assign previously the p1 variable</strong>.</li>
</ul>
<h3><span id="2the-callerss-side">2.The callers's side</span></h3>
<p><img src="/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/image-1.png"></p>
<ul>
<li><p>Whenever the compiler encounters a variable declaration, it
<strong>generates no code whatsover</strong>. The only thing the
compiler does is it <strong>update the relevant symbol table</strong>.
Because we are now compiling code that resides in a certain subroutine,
we will end up <strong>updating the symbol table of the
subroutine</strong>.</p></li>
<li><p><code>Point.new(2, 3)</code> is a call to some subroutine, so we
handle it just like other subroutine. We push the two arguments and
<code>call Point.new</code></p></li>
<li><p>The calling code assumes that when the constructor will execute,
it will end up <strong>allocating some space on the RAM</strong> for the
newly constructed object. It will also take the base address of this
space on the RAM and <strong>return it to the caller</strong>.</p></li>
<li><p>So we <strong><code>pop</code> the topmost value of the stack
into <code>p1</code></strong>, because we want <code>p1</code> to point
at the base address of this object.</p></li>
</ul>
<h3><span id="3resulting-impact">3.Resulting impact</span></h3>
<p><img src="/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/image-2.png"></p>
<ul>
<li>Only when we call the constructors will we actually create the
objects on RAM.</li>
<li>Object construction is a <strong>two-stage affair that happens both
during compile time and run time</strong>.</li>
</ul>
<h3><span id="4the-big-picture-ofconstructors">4.The big picture of
constructors</span></h3>
<p><img src="/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/image-3.png"></p>
<p>  A constructor is typically designed to do at least two things:</p>
<ol type="1">
<li><strong>Arrange some place</strong> on RAM for the new object.</li>
<li><strong>Assign certain values</strong> to the fields of the newly
constructed object.</li>
</ol>
<p>  To do this, the constructor must have access to the object's
fields:</p>
<ul>
<li>We can <strong>manipulate <code>THIS</code> segment</strong> to
manipulate the object that the constructor juct created.</li>
<li>To access <code>THIS</code> segment, we first <strong>anchor it
properly on the right address in the RAM</strong> using
<code>pointer</code> segment.</li>
</ul>
<h3><span id="5compiling-constuctor">5.Compiling constuctor</span></h3>
<ol type="1">
<li>The first thing we meet is the constructor signature. The compiler
will generate no code whatsover. The only thing it will do is <strong>it
will create the subroutine symbol table</strong> and <strong>record in
it two variables <code>ax</code> and <code>ay</code> which are both
arguments </strong></li>
</ol>
<p>  Then comes the question: how much space is needed?</p>
<ol start="2" type="1">
<li>The compiler can <strong>consult the class level symbol
table</strong> and realize that objects of the point class requires two
words only, <code>x</code> and <code>y</code>.</li>
</ol>
<p>  Then how do we find such a free memory block on RAM?</p>
<ol start="3" type="1">
<li><p>The <em>operating system</em> supplies a function called
<code>alloc</code>, if you provide <code>alloc(x)</code> with a certain
argument, it will <strong>find a memory block on the RAM</strong> and
<strong>return the base address of it.</strong> The memory block has two
important properties:</p>
<ol type="1">
<li>It's <code>x</code> words long.</li>
<li>It's free, no one needs it now, so the constructor can safely use
it.</li>
</ol></li>
</ol>
<p><img src="/2024/04/25/10-6-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%9E%84%E9%80%A0/image-4.png"></p>
<ol type="1">
<li>We <code>push 2</code>, because we <strong>need 2 words to store the
arguments</strong>.</li>
<li>We want to push <code>THIS</code> into the stack, we need 1 word, so
we <code>call Memory.alloc 1</code>.</li>
<li>As usual, we anchor <code>THIS</code> at the base address:
<code>pop pointer 0</code>.</li>
</ol>
<blockquote>
<p>If we do <code>pop pointer 0</code>, we are going to align the
virtual segment ot the object we currently constructed on the RAM. We do
this because I know that with very high likelihood the next commands in
the constructor will want to access the fields of the newly created
object.</p>
</blockquote>
<ol start="4" type="1">
<li>Since <code>THIS</code> is anchored on the right endness, to
<code>return</code>, we simply do <code>push pointer 0</code>. And when
the caller of constructor do <code>pop pointer 0</code>, it can
successfully get the address of the newly created object.</li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.7.对对象的处理——操纵对象</title>
    <url>/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1><span id="107handling-objects-manipulation"><span class="math inline">\(10.7.\)</span>Handling Objects: Manipulation</span></h1>
<h3><span id="1compiling-method-calls">1.Compiling method calls</span></h3>
<ul>
<li>In compiler, we are going to translate the OO method calls into
<strong>procedural style language</strong> like VM language or machine
language, they don't understand what an object is.</li>
</ul>
<p>  In order to do this:</p>
<ul>
<li>We can <strong>treat the object as the first, implicit
argument</strong>. We push it onto the stack, because we want it to
<strong>be the first argument on which the method is going to
operate</strong>.</li>
</ul>
<p><img src="/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/image-5.png"></p>
<ol type="1">
<li>We <code>push</code> the object into the stack.</li>
<li>We <code>push</code> enough arguments into the stack.</li>
<li>We <code>call</code> the method.</li>
</ol>
<p>  When we say "put the object onto the stack", we don't care what the
object is, we are only interested in its <em>base address</em>.</p>
<h3><span id="2compiling-methods">2.Compiling methods</span></h3>
<p>  Methods are used to operate on the object which refers to as
<code>THIS</code>. Therefore, each method's code needs to <strong>access
to the object's <code>field</code> variables</strong>.</p>
<p>  In the previous unit, we know that we can access the <span class="math inline">\(ith\)</span> <code>field</code> by
<code>THIS i</code>. However, before we use <code>THIS</code>, we have
to anchor it on the proper address on the RAM first, so we also need
<code>pointer</code>.</p>
<p><img src="/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/image-6.png"></p>
<p>  Let's take the <code>distance</code> method as an example:</p>
<ol type="1">
<li>The method is compiled within a class, so we will <strong>compile
the class variables</strong>, namely <code>x, y, pointCount</code>. This
will end up generating no code.</li>
<li>Both the method declaration and variable declaration generate no
code, either. Instead, the compiler <strong>creates the symbol table of
the subroutine</strong> and <strong>populates it within the
<code>this</code> object as well as the explicit variables that is found
in the parameter list and the variable declaration.</strong></li>
<li>We can anticipate that the method will want to operate on the
current object, so we need to generate code that will <strong>anchor
this on the correct address in memory</strong>. And we know that the
current object address is <code>argument 0</code>, so we do
<code>push argument 0</code> and <code>pop pointer 0</code> to let
<code>THIS</code> pointer to contain the address of the current
object.</li>
</ol>
<p>  When the <code>distance</code> method completes execution and
terminates, control will return to the caller. The compiled code of the
caller is as below:</p>
<p><img src="/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/image-7.png"></p>
<ul>
<li>We know that the method returns a value on the top of stack, so we
remove it and put it into <code>d</code>.</li>
</ul>
<h3><span id="3void-methodcompilation">3.<code>void</code> method
compilation</span></h3>
<p><img src="/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/image-8.png"></p>
<p>  The <code>void</code> doesn't expect to get a return value, while
according to the rules of the game, we must return a value. As a result,
we:</p>
<ol type="1">
<li>To obey the rule, we <strong>generate code at the end of each method
that returns a value</strong>.</li>
<li>Since we have nothing to return, we <code>push constant 0</code>,
which is a dummy value and then <code>return</code>.</li>
</ol>
<p>  But now the compiled code faces a slight problem: the stack
contains uncessary value and we want to get rid of it.</p>
<ol start="3" type="1">
<li>To do this, we simply <code>pop temp 0</code>.</li>
</ol>
<p><img src="/2024/04/26/10-7-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86-%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1/image-9.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>10.1.二叉搜索树</title>
    <url>/2024/05/31/10.1.Binary%20Search%20Trees/</url>
    <content><![CDATA[<h1><span id="101二叉搜索树"><span class="math inline">\(10.1\)</span>二叉搜索树</span></h1>
<h3><span id="1bst相关概念">1.<span class="math inline">\(BST\)</span>相关概念</span></h3>
<ul>
<li>The tree is made up of <span class="math inline">\(nodes\)</span>
that contain <span class="math inline">\(links\)</span> that are either
<span class="math inline">\(null\)</span> or references to other
nodes.</li>
<li>Every node is pointed to by just one other node, which is called its
<span class="math inline">\(parent\)</span> (except for one node, the
<span class="math inline">\(root\)</span>, which has no nodes pointing
to it).</li>
<li>Each node has exactly two links, which are called its <span class="math inline">\(left\)</span> and <span class="math inline">\(right\)</span> links, that point to nodes called
its <span class="math inline">\(left child\)</span> and <span class="math inline">\(right child\)</span>.</li>
<li>we can define a binary tree as a either a null link or a node with a
left link and a right link, each references to (disjoint) subtrees that
are themselves <span class="math inline">\(binary trees\)</span>. In a
binary search tree, each node also has a key and a value, with an
ordering restriction to support efficient search</li>
</ul>
<p><img src="/2024/05/31/10.1.Binary%20Search%20Trees/image.png"></p>
<p>  <span class="math inline">\(BST\)</span>也遵循如下的性质：</p>
<p><img src="/2024/05/31/10.1.Binary%20Search%20Trees/image-1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">BST</span>&lt;Key&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Key key;</span><br><span class="line">    <span class="keyword">private</span> BST left;</span><br><span class="line">    <span class="keyword">private</span> BST right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key, BST lf, BST rt)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.left = lf;</span><br><span class="line">        <span class="built_in">this</span>.right = rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2bst操作">2.<span class="math inline">\(BST\)</span>操作</span></h3>
<h4><span id="afind">  <span class="math inline">\(a.\)</span><code>find</code></span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">find</span><span class="params">(BST T, Key sk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sk.equals(T.key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sk &lt; T.key) &#123;</span><br><span class="line">        <span class="keyword">return</span> find(T.left, sk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(T.right, sk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="binsert">  <span class="math inline">\(b.\)</span><code>insert</code></span></h4>
<p>  我们永远只插入左节点！ <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">insert</span><span class="params">(BST T, Key sk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BST</span>(sk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sk &lt; T.key) &#123;</span><br><span class="line">        T.left = insert(T.left, sk);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sk &gt; T.key) &#123;</span><br><span class="line">        T.right = insert(T.right, sk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="cdelete">  <span class="math inline">\(c.\)</span><code>delete</code></span></h4>
<p>  我们可以通过将一个节点替代为它的后继节点，来实现该节点的删除。一个节点的后继节点(<span class="math inline">\(successor\)</span>)是它右子树的最小节点。我们可以通过以下步骤实现<code>delete</code>：</p>
<ol type="1">
<li>保存待删除节点(<span class="math inline">\(x\)</span>)的链接(<span class="math inline">\(link\)</span>)。</li>
<li>让<span class="math inline">\(x\)</span>指向后继节点(<span class="math inline">\(y\)</span>)。</li>
<li>将<span class="math inline">\(x\)</span>的右链接指向<code>deleteMin(t.right)</code>，其中<code>deleteMin</code>会返回指向右子树的链接，而右子树中所有元素都大于(<span class="math inline">\(x\)</span>)。</li>
<li>让后继节点的左链接指向<span class="math inline">\(x\)</span>的左子树。</li>
</ol>
<p>  下面是该过程的图示：</p>
<p><img src="/2024/05/31/10.1.Binary%20Search%20Trees/image-2.png"></p>
<p>  下面我们分部实现<code>delete</code>操作。</p>
<h5><span id="ideletemin">  <span class="math inline">\(i.\)</span><code>deleteMin</code></span></h5>
<p>  我们可以通过如下方式递归实现<code>deleteMin</code>：</p>
<ol type="1">
<li>找到最小的节点，然后返回它的父亲的右儿子(把指向它的链接给忽略掉了，这样就相当于删掉这个元素了)。</li>
<li>把父节点的左链接指向返回的节点。</li>
<li>更新子树的大小。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMin</span><span class="params">()</span> &#123;</span><br><span class="line">    root = deleteMin(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteMin</span><span class="params">(Node p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.left = deleteMin(p.left);</span><br><span class="line">    p.size = p.left.size + p.right.size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5><span id="ii最小节点">  <span class="math inline">\(ii.\)</span>最小节点</span></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">min</span><span class="params">(Node p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(p.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="iiidelete操作">  <span class="math inline">\(iii\)</span><code>delete</code>操作</span></h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">    root = delete(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node p, Key key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(p.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        p.right = delete(p.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        p.left = delete(p.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// solve the one-node condition.</span></span><br><span class="line">        <span class="keyword">if</span> (p.right == <span class="literal">null</span>) <span class="keyword">return</span> p.left;</span><br><span class="line">        <span class="keyword">if</span> (p.left == <span class="literal">null</span>) <span class="keyword">return</span> p.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//store the to-delete node, so that we can connect its subtree.</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> p;</span><br><span class="line">        p = min(t.right);</span><br><span class="line">        p.right = deleteMin(t.right);</span><br><span class="line">        p.left = t.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.size = p.left.size + p.right.size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>10.Trees</category>
      </categories>
  </entry>
  <entry>
    <title>10.8.对数组的处理</title>
    <url>/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1><span id="108handling-array"><span class="math inline">\(10.8.\)</span>Handling Array</span></h1>
<h3><span id="1array-construction">1.Array construction</span></h3>
<p>  Assume that the high-level programmer writes
<code>var Array arr</code>.</p>
<ul>
<li>In response to this, the compiler will only <strong>allocate a
<code>local</code> variable</strong> to represent the array and
<strong>initialize this variable to 0</strong>.</li>
<li>This statement <strong>generates no code</strong>. The compiler will
<strong>get a variable called <code>loca1 0</code>, its type
<code>Array</code> and name <code>arr</code></strong>.</li>
</ul>
<p>  When we construct this array by calling the subroutine of the
<code>Array</code> class: <code>let arr = Array.new(5)</code>.</p>
<ul>
<li>The compiler and OS will magically <strong>allocate sufficient space
in the heap</strong> to represent the array.</li>
<li>The base address of the new allocated block is going to be stored in
<code>local 0</code>, regardless of the address may be.</li>
<li>What we have here is <strong>a standard call to a Jack
subroutine</strong>, which we already knew how to handle.</li>
</ul>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image.png"></p>
<h3><span id="2array-manipulation">2.Array manipulation</span></h3>
<h4><span id="athis-and-thatreview">  <span class="math inline">\(a.\)</span><code>THIS</code> and <code>THAT</code>
review</span></h4>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-1.png"></p>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-2.png"></p>
<h5><span id="bgenerating-code">  <span class="math inline">\(b.\)</span>Generating code</span></h5>
<p>  Suppose we want to conduct <code>arr[2] = 17</code>:</p>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-3.png"></p>
<ul>
<li><p>Since the base address of <code>arr</code> is stored in
<code>THAT</code>, we simply <code>push arr</code> then
<code>push index</code>, and <code>add</code> to get
<code>arr + 2</code>.</p></li>
<li><p>Then the <code>THAT</code> pointer will be aligned with the
address we want to manipulate.</p></li>
<li><p>Notice that:</p>
<ol type="1">
<li>We use <strong>only <code>THAT 0</code></strong>, we don't use other
entries from <code>THAT</code> segment.</li>
<li>The VM code you have <strong>operates in a completely symbolic
logical world</strong>. It doesn't know where the array is located in
RAM or which address we are manipulating. In this respect, it's a very
safe code, for it cannot reach out of the VM world, because all the
physical considerations are being implemented by the VM translator, and
VM code itself is completely oblivious of the host platform. This is
very important because we have numerous different computers, we don't
know where this code is going to run, and we <strong>don't have the
luxury of making any assumptions about the underlying hardware
platform</strong>.</li>
</ol></li>
</ul>
<p>  What about <code>arr[exp1] = exp2</code>? As above, we may write
the following code:</p>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-4.png"></p>
<p>  This seems make sense, but when we try to write
<code>a[i] = b[j]</code>, there comes a crush:</p>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-5.png"></p>
<p>  To avoid this, we:</p>
<ol type="1">
<li>First deal with the right hand side and left hand side separately.
Once we complete this, the stack is going to <strong>contain two
addresses</strong>: the address of <code>a[i]</code> and the address of
<code>b[j]</code>:</li>
</ol>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-6.png"></p>
<ol start="2" type="1">
<li>We <strong><code>pop</code> the topmost value</strong> onto
<code>pointer 1</code>, which is <code>b[i]</code> in this example. Once
is done, we are going to get the following state:</li>
</ol>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-7.png"></p>
<ol start="3" type="1">
<li>Now that <code>That 0</code> is aligned with <code>b[j]</code>, we
<strong><code>push</code> the value in <code>b[j]</code> and
<code>pop</code> it into <code>temp 0</code></strong>. This is the
picture of the VM segments after the process:</li>
</ol>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-8.png"></p>
<ol start="4" type="1">
<li>Because we have <strong>safely saved the value of
<code>b[i]</code></strong>, we can <strong>take the address of
<code>a[i]</code> and <code>pop</code> it onto
<code>pointer 1</code></strong></li>
<li>We finally <strong><code>push temp 0</code> onto the stack</strong>
and <strong><code>pop</code> it onto <code>that 0</code></strong>, which
is on the address of <code>a[i]</code>:</li>
</ol>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-9.png"></p>
<p>  The general solution for generating array access code is as
below:</p>
<p>![[Pasted image 20240507234141.png]]</p>
<p><img src="/2024/04/27/10-8-%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%84%E7%90%86/image-10.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 10.Code Generator</category>
      </categories>
  </entry>
  <entry>
    <title>11.1.一些概念</title>
    <url>/2024/05/31/11.1%20Some%20concepts/</url>
    <content><![CDATA[<h1><span id="111一些概念"><span class="math inline">\(11.1\)</span>一些概念</span></h1>
<h3><span id="1o与最坏运行时间的区别">1.<span class="math inline">\(O()\)</span>与最坏运行时间的区别</span></h3>
<p>  大<span class="math inline">\(O\)</span>不等于最坏运行时间！<span class="math inline">\(O\)</span>表示的是运行时间的上界，只要一个函数的运行时间小于<span class="math inline">\(O(times)\)</span>，那么它就算在<span class="math inline">\(O\)</span>内。最坏运行时间比<span class="math inline">\(O\)</span>更为严苛，因为对于最坏运行时间<span class="math inline">\(worst_time\)</span>，函数必须能取到这个时间、而非仅仅小于等于这个时间。</p>
<h3><span id="2对bst性能的衡量">2.对<span class="math inline">\(BST\)</span>性能的衡量</span></h3>
<p>  <span class="math inline">\(BST\)</span>性能的衡量需要考虑以下概念：</p>
<ul>
<li>深度(<span class="math inline">\(depth\)</span>)：节点到树根间链接的数量。</li>
<li>高度(<span class="math inline">\(height\)</span>)：树的最大深度。</li>
<li>平均深度(<span class="math inline">\(average\)</span>)：树所有深度的平均值，可以用<span class="math inline">\({\sum_{i=0}^D d_in_i}\over N\)</span>，<span class="math inline">\(d_i\)</span>代表深度，<span class="math inline">\(n_i\)</span>代表节点的数字。</li>
</ul>
<p>  <span class="math inline">\(BST\)</span>的高度代表了它的最坏运行时间，而平均深度决定了它的平均运行时间。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>11.Balanced Trees</category>
      </categories>
  </entry>
  <entry>
    <title>11.2.B树</title>
    <url>/2024/05/31/11.2%20B-Trees/</url>
    <content><![CDATA[<h1><span id="112b树"><span class="math inline">\(11.2\)</span><span class="math inline">\(B\)</span>树</span></h1>
<h3><span id="1b树的引入">1.<span class="math inline">\(B\)</span>树的引入</span></h3>
<p>  导致<span class="math inline">\(BST\)</span>最坏运行时间的原因是：每次<code>insert</code>操作，我们都选择在叶子上进行，这导致了树的高度的增加。因此，一个自然的想法是：能否在不增加树的高度的前提下插入节点。</p>
<p>  为了达到这个目的，我们可以在一个叶子中插入多个节点，这样就不会导致叶子高度的增加了。</p>
<p>  但如果无限制地在一个叶子中插入，那么这个叶子就会退化成一个链表了。因此，我们可以对单个叶子能够装入节点的数量设置限度(<span class="math inline">\(limit\)</span>)，例如<span class="math inline">\(4\)</span>。当叶子中节点个数超过<span class="math inline">\(4\)</span>个时，就通过弹出中间的节点，把这个叶子分开(<span class="math inline">\(split\)</span>)。</p>
<h3><span id="22-3搜索树">2.<span class="math inline">\(2-3\)</span>搜索树</span></h3>
<p>  一棵<span class="math inline">\(2-3\)</span>搜索树是满足如下条件的树：</p>
<ul>
<li>空的(<span class="math inline">\(empty\)</span>)。</li>
<li>一个叶子存储一个节点，同时有两个链接(<span class="math inline">\(link\)</span>)，和<span class="math inline">\(BST\)</span>类似。</li>
<li>一个叶子存储二个节点，同时有三个链接。设二个节点分别为<span class="math inline">\(x,y\)</span>，则三个链接所指向的其它叶子分别满足<span class="math inline">\(a_i\leq x,x\leq a_i\leq y,a_i\leq
y\)</span>。</li>
</ul>
<p><img src="/2024/05/31/11.2%20B-Trees/image.png"></p>
<h3><span id="3查找流程">3.查找流程</span></h3>
<p>  <span class="math inline">\(2-3\)</span>搜索树查找节点的流程如下：</p>
<p><img src="/2024/05/31/11.2%20B-Trees/image-1.png"></p>
<h3><span id="4插入流程">4.插入流程</span></h3>
<p>  <span class="math inline">\(2-3\)</span>搜索树插入节点的流程如下：</p>
<ol type="1">
<li>我们仍然一直在左叶子进行插入操作。</li>
<li>将节点插入对应的叶子时，如果该叶子的节点个数大于<span class="math inline">\(3\)</span>，则弹出中间靠左的节点(如果是奇数个节点就直接弹出中间的)，然后相应地重新排列子树。</li>
<li>重复上述步骤，直到找到一个有空位的父节点或者遍历到根节点。</li>
</ol>
<p>  一些插入情况对应的图示如下：</p>
<p><img src="/2024/05/31/11.2%20B-Trees/image-2.png"></p>
<p><img src="/2024/05/31/11.2%20B-Trees/image-3.png"></p>
<p>  分开叶子的图示如下：</p>
<p><img src="/2024/05/31/11.2%20B-Trees/image-4.png"></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>11.Balanced Trees</category>
      </categories>
  </entry>
  <entry>
    <title>11.3.B-树的不变量</title>
    <url>/2024/05/31/11.3.%20B-Tree%20invariants/</url>
    <content><![CDATA[<h1><span id="113b-树的不变量"><span class="math inline">\(11.3\)</span><span class="math inline">\(B\)</span>-树的不变量</span></h1>
<h3><span id="1b-树的性质">1.<span class="math inline">\(B\)</span>-树的性质</span></h3>
<p>  由于<span class="math inline">\(B\)</span>-树会在叶子容量过大时将叶子对半分开、然后重构子树，这使得我们可以以任意次序插入元素，而不用担心最坏运行时间的发生。</p>
<p>  一棵<span class="math inline">\(B\)</span>-树具有如下有用的性质：</p>
<ul>
<li>每个叶子到它的源头(<span class="math inline">\(source\)</span>)的距离必须相等。</li>
<li>一个有<span class="math inline">\(k\)</span>个元素的非叶子节点，它必须有<span class="math inline">\(k+1\)</span>个孩子。</li>
</ul>
<h3><span id="2b-树运行时间分析">2.<span class="math inline">\(B\)</span>-树运行时间分析</span></h3>
<p>  <span class="math inline">\(B\)</span>-树的最坏运行情况是：在树的底部的叶子的最右侧的节点找到某个元素。由于<span class="math inline">\(B\)</span>-树的构造方式，树的深度<span class="math inline">\(O(\log
n)\)</span>，而由于我们限制了每个叶子结点承载元素的数量，因此从叶子左端到右端的搜索时间为常数。则总的运行时间为<span class="math inline">\(O(\log n)\)</span>。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>11.Balanced Trees</category>
      </categories>
  </entry>
  <entry>
    <title>11.4.树的旋转</title>
    <url>/2024/05/31/11.4.Rotating%20Trees/</url>
    <content><![CDATA[<h1><span id="114树的旋转"><span class="math inline">\(11.4\)</span>树的旋转</span></h1>
<p>  The formal definition of rotation is:</p>
<ul>
<li><p><code>rotateLeft(G): Let x be the right child of G. Make G the new left child of x.</code></p></li>
<li><p><code>rotateRight(G): Let x be the left child of G. Make G the new right child of x.</code></p></li>
</ul>
<p>  As in the picture, it means:</p>
<ul>
<li><span class="math inline">\(RotateLeft(G)\)</span>: G moves left,
promote its right child in the only natural way.(Promoting P means P is
the new parent of G.)</li>
<li><span class="math inline">\(RotateRight(P)\)</span>: P moves right,
promote its left child in the only natural way.</li>
</ul>
<p><img src="/2024/05/31/11.4.Rotating%20Trees/image-5.png"></p>
<p><img src="/2024/05/31/11.4.Rotating%20Trees/image-6.png"></p>
<p>  We can implement these operations by following codes:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.left);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.right = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make a right-leaning link lean to the left</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="comment">// assert (h != null) &amp;&amp; isRed(h.right);</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>11.Balanced Trees</category>
      </categories>
  </entry>
  <entry>
    <title>11.5.红黑树</title>
    <url>/2024/05/31/11.5.Red-Black%20Trees/</url>
    <content><![CDATA[<h1><span id="115红黑树未完结"><span class="math inline">\(11.5\)</span>红黑树(未完结)</span></h1>
<h3><span id="1红黑树的引入与相关概念">1.红黑树的引入与相关概念</span></h3>
<p>  前面介绍的<span class="math inline">\(B\)</span>-树很符合我们对运行时间的的需要，但是它很难用代码实现。因此，我们设想创造一种树，它利用<span class="math inline">\(BST\)</span>实现，但结构上与<span class="math inline">\(B\)</span>-树等价。</p>
<p>  在<span class="math inline">\(2-3\)</span>树中，叶子只有一个节点的情况和<span class="math inline">\(BST\)</span>是完全一样的。而对于两个节点的情况，我们考虑将链接分成两种类型：红色(<span class="math inline">\(red\)</span>)的和黑色(<span class="math inline">\(black\)</span>)的。对于一个叶子三个节点的情况，我们可以用如下的形式表示：</p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-7.png"></p>
<p>  这么处理的好处是：我们可以不修改原有的<span class="math inline">\(BST\)</span>来实现<span class="math inline">\(2-3\)</span>树。给定任意一个<span class="math inline">\(2-3\)</span>树，我们都可以立即生成一个对应的<span class="math inline">\(BST\)</span>。例如下面的<span class="math inline">\(2-3\)</span>树到红黑树的转换：</p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-9.png"></p>
<h3><span id="2左斜红黑树的性质">2.左斜红黑树的性质</span></h3>
<p>  为了模拟<span class="math inline">\(2-3\)</span>树，红黑树必须具有以下性质：</p>
<ol type="1">
<li>红色链接左斜。</li>
<li>没有一个节点与两个红色链接相连。</li>
<li>红黑树具有完美的“黑色平衡”：从根节点到空节点间的每个路径都具有相同数量的褐色链接。</li>
</ol>
<p>  如果将红色链接画成水平的，那么可以得到下面的图示，这和<span class="math inline">\(2-3\)</span>树几乎一致：</p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-10.png"></p>
<h3><span id="2红黑树的旋转操作">2.红黑树的旋转操作</span></h3>
<p>  红黑树的左旋操作如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node <span class="title function_">rotateLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-11.png"></p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-12.png"></p>
<p>  红黑树的右旋操作如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node <span class="title function_">rotateRight</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.right = h;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/2024/05/31/11.5.Red-Black%20Trees/image-13.png"></p>
<p><img src="/2024/05/31/11.5.Red-Black%20Trees/image-14.png"></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>11.Balanced Trees</category>
      </categories>
  </entry>
  <entry>
    <title>12.1.Hashing的引入</title>
    <url>/2024/05/31/12.1.The%20introduction%20of%20Hashing/</url>
    <content><![CDATA[<h1><span id="121hashing的引入"><span class="math inline">\(12.1\)</span><span class="math inline">\(Hashing\)</span>的引入</span></h1>
<h3><span id="1hasing的引入">1.<span class="math inline">\(Hasing\)</span>的引入</span></h3>
<p>  在先前的树结构中，我们实现了对数据的高效查找。但树的使用有以下的限制：</p>
<ol type="1">
<li>树需要对象具有可比较性(<span class="math inline">\(comparable\)</span>)。对于某些元素(比如字符串)，它们不能进行比较，因此就无法插入<span class="math inline">\(BST\)</span>中了。</li>
<li><span class="math inline">\(BST\)</span>的运行时间为<span class="math inline">\(\Theta(\log
N)\)</span>，但我们希望有更优的运行时间。</li>
</ol>
<p>  假设我们想要实现对整数的查找，我们可以通过检测数组第<span class="math inline">\(i\)</span>位是否为<span class="math inline">\(1\)</span>，从而得到该整数是否存在。该数据结构如下实现：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataIndexedIntegerSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] present;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataIndexedIntegerSet</span><span class="params">()</span> &#123;</span><br><span class="line">        present = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2000000000</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        present[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> present[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>  该数据结构的查找与插入都只需要<span class="math inline">\(\Theta(1)\)</span>的运行时间。然而，它有以下的问题：</p>
<ol type="1">
<li>空间浪费较大。</li>
<li>不具有普适性。该数据结构只适用于整数。</li>
</ol>
<h3><span id="2字符串到整数的转换">2.字符串到整数的转换</span></h3>
<p>  以字符串为例，我们可以考虑将字符串按如下的方式转换成一个整数：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">letterNum</span><span class="params">(String s, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">/** Converts ith character of String to a letter number.</span></span><br><span class="line"><span class="comment">    * e.g. &#x27;a&#x27; -&gt; 1, &#x27;b&#x27; -&gt; 2, &#x27;z&#x27; -&gt; 26 */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ithChar</span> <span class="operator">=</span> s.charAt(i)</span><br><span class="line">    <span class="keyword">if</span> ((ithChar &lt; <span class="string">&#x27;a&#x27;</span>) || (ithChar &gt; <span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ithChar - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">englishToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">intRep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0l</span> i &lt; s.length(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        intRep = intRep * <span class="number">26</span>;</span><br><span class="line">        intRep += letterNum(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intRep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样，我们就实现了字符串到整数的转换。然而，这并未解决我们提出的问题。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>12.Hashing</category>
      </categories>
  </entry>
  <entry>
    <title>12.2.Hashing的实现方法(1)</title>
    <url>/2024/05/31/12.2.The%20solution%20to%20Hashing%20problems(1)/</url>
    <content><![CDATA[<h1><span id="122hashing的实现方法1"><span class="math inline">\(12.2\)</span><span class="math inline">\(Hashing\)</span>的实现方法(1)</span></h1>
<h3><span id="1整数溢出">1.整数溢出</span></h3>
<p>  在先前将字符串转换为整数的操作中，我们忽略了一个问题：转换得到的整数过大导致溢出怎么办？例如，溢出后的<code>melt banana</code>与<code>subterresetrial anticosmetic</code>的<span class="math inline">\(Hash\)</span>值是一样的，如果我们通过比较它们的<span class="math inline">\(Hash\)</span>值来确定它们是否相等，会得到相反的答案。</p>
<p>  整数的溢出是无法避免的，因为<span class="math inline">\(Java\)</span>能够表示的最大整数只有<span class="math inline">\(2147483647\)</span>。因此我们引入下面的方法：</p>
<h3><span id="2hashcodes">2.<span class="math inline">\(Hash\;Codes\)</span></span></h3>
<p>  在<span class="math inline">\(Java\)</span>中，每个对象都有一个默认的<code>.hashcode()</code>方法。<span class="math inline">\(Java\)</span>通过该对象在内存中的位置来得出它的<span class="math inline">\(hashCode\)</span>。这个方法对每个独立的对象都会给出不重复的<span class="math inline">\(hashCode\)</span>。</p>
<p>  有时，我们也会自己定义<code>.hashcode()</code>方法，来满足自己定义的一些类的需要。</p>
<p>  <span class="math inline">\(hashCode\)</span>具有如下性质：</p>
<ol type="1">
<li>它是一个整数</li>
<li>对同一对象多次调用<code>.hashcode()</code>，得到的结果都相同。</li>
<li>两个<code>.equal()</code> 的对象必须具有相同的<span class="math inline">\(hashCode\)</span>。</li>
</ol>
<p>  然而，并不是所有<span class="math inline">\(hashCode\)</span>相等的对象都<code>.equal()</code>，因此，我们应当让对象的<span class="math inline">\(.hashode()\)</span>方法生成的<span class="math inline">\(hashCode\)</span>尽可能分布均匀。</p>
<p>  到此为止，我们实现了<span class="math inline">\(Hashing\)</span>的普适性。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>12.Hashing</category>
      </categories>
  </entry>
  <entry>
    <title>12.3.Hashing的实现方法(2)</title>
    <url>/2024/05/31/12.3.The%20solution%20to%20Hashing%20problems(2)/</url>
    <content><![CDATA[<h1><span id="123hashing的实现方法2"><span class="math inline">\(12.3\)</span><span class="math inline">\(Hashing\)</span>的实现方法(2)</span></h1>
<h3><span id="1冲突处理">1.冲突处理</span></h3>
<p>  假如我们得到一个对象的<span class="math inline">\(hashCode\)</span>为<span class="math inline">\(h\)</span>：</p>
<ul>
<li>当<span class="math inline">\(h\)</span>索引不存在时，我们就对<span class="math inline">\(h\)</span>索引创建一个新的<code>LinkedList</code>，并把这个对象插入链表中。</li>
<li>当<span class="math inline">\(h\)</span>索引存在时，我们就将对象插入已有的链表中。</li>
</ul>
<blockquote>
<p>  <span class="math inline">\(p.s.\)</span>我们的数据结构是不允许重复的，因此在插入时，我们必须将待插入对象与链表中所有已插入对象进行比较。当该对象已经存在时，就直接跳过。这说明我们会需要遍历整个链表。</p>
</blockquote>
<p>  这样，我们就可以得到<span class="math inline">\(Hashing\)</span>的具体流程了：</p>
<ul>
<li><p><code>add</code> item</p>
<ul>
<li>Get hashcode (i.e., index) of item.</li>
<li>If index has no item, create new List, and place item there.</li>
<li>If index has a List already, check the List to see if item is
already in there. If not, add item to List.</li>
</ul></li>
<li><p><code>contains</code> item</p>
<ul>
<li>Get hashcode (i.e., index) of item.</li>
<li>If index is empty, return <code>false</code>.</li>
<li>Otherwise, check all items in the List at that index, and if the
item exists, return true.</li>
</ul></li>
</ul>
<h3><span id="2内存的处理">2.内存的处理</span></h3>
<p>  为了避免使用过大的数组，我们可以固定数组的大小，然后采用取模的方法，让所有的<span class="math inline">\(hashCode\)</span>都落入该数组的索引范围内(类似我们在<span class="math inline">\(ArrayList\)</span>中使用的方法)。就算此时发生了哈希冲突，我们也可以用上面的方法处理它。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>12.Hashing</category>
      </categories>
  </entry>
  <entry>
    <title>12.4.数据结构的最终实现</title>
    <url>/2024/05/31/12.4.Final%20Data%20Structure/</url>
    <content><![CDATA[<h1><span id="124数据结构的最终实现"><span class="math inline">\(12.4\)</span>数据结构的最终实现</span></h1>
<h3><span id="1运行时间的优化">1.运行时间的优化</span></h3>
<p>  假设我们存放索引的数组的大小为<span class="math inline">\(5\)</span>，当我们插入<span class="math inline">\(100\)</span>个元素时，最坏的情况是：所有元素的索引都是一致的。这样，我们就得到了一个长度为<span class="math inline">\(100\)</span>的链表。</p>
<p>  这显然不是我们希望看到的情况。对此，我们有两种处理方法：</p>
<ol type="1">
<li>动态地扩大我们的哈希表。</li>
<li>改进我们的<span class="math inline">\(hashCode\)</span>。</li>
</ol>
<h4><span id="a动态扩容">  <span class="math inline">\(a.\)</span>动态扩容</span></h4>
<p>  假设我们有<span class="math inline">\(M\)</span>个筐和<span class="math inline">\(N\)</span>个元素，我们定义负载系数(<span class="math inline">\(load\;factor\)</span>)为<span class="math inline">\(N\over M\)</span>(这即是我们的最佳运行时间)。</p>
<p>  为了让我们的负载系数维持在一个较低的范围内，我们可以直接让<span class="math inline">\(M\)</span>变为<span class="math inline">\(2M\)</span>，并进行如下操作：</p>
<ul>
<li><p>创建一个新的容量为<span class="math inline">\(2M\)</span>的哈希表。</p></li>
<li><p>迭代遍历原有的哈希表，然后把原有的元素复制到新的哈希表中。</p>
<ul>
<li>我们需要一个一个复制元素，是因为哈希表的容量改变了，因此我们的模数也变了，从而需要用新的模数一个一个将元素复制到新哈希表对应的位置。</li>
</ul></li>
</ul>
<p>  这样，我们得到了一个运行时间<span class="math inline">\(\Theta(N\over
M)\)</span>的哈希表。由于我们限定<span class="math inline">\(N\over
M\)</span>必须小于一个常数，因此最优运行时间为<span class="math inline">\(\Theta(N\over M)=\Theta(1)\)</span>。</p>
<h4><span id="b改进hashcode">  <span class="math inline">\(b.\)</span>改进<span class="math inline">\(hashCode\)</span></span></h4>
<ul>
<li><p>Use a 'base' strategy similar to the one we developed
earlier.</p></li>
<li><p>Use a 'base' that's a small prime.</p>
<ul>
<li>Base 126 isn't actually very good, because using base 126 means that
any string that ends in the same last 32 characters has the same
hashcode.</li>
<li>This happens because of overflow.</li>
<li>Using prime numbers helps avoid overflow issues (i.e., collisions
due to overflow).</li>
<li>Why a small prime? Because it's easier to compute.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>12.Hashing</category>
      </categories>
  </entry>
  <entry>
    <title>13.1.优先队列接口</title>
    <url>/2024/05/31/13.1.PQ%20Interface/</url>
    <content><![CDATA[<h1><span id="131优先队列接口"><span class="math inline">\(13.1\)</span>优先队列接口</span></h1>
<h3><span id="1优先队列的引入">1.优先队列的引入</span></h3>
<p>  我们知道<span class="math inline">\(BST\)</span>可以实现数据的快速搜索，那么如果我们只关心对最大(最小)元素的查找呢？</p>
<p>  这时，我们就可以引入优先队列(<span class="math inline">\(Priority\;Queue\)</span>)的<span class="math inline">\(ADT\)</span>。在优先队列中，我们只能对一组数据中的最小元素进行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** (Min) Priority Queue: Allowing tracking and removal of </span></span><br><span class="line"><span class="comment">  * the smallest item in a priority queue. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MinPQ</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="comment">/** Adds the item to the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="comment">/** Returns the smallest item in the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getSmallest</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/** Removes the smallest item from the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeSmallest</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/** Returns the size of the priority queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2优先队列的实现">2.优先队列的实现</span></h3>
<p>  假如我们用链表实现以下的问题：</p>
<p>  <span class="math inline">\(question:\)</span></p>
<ul>
<li>Consider the scenario where we are monitoring text messages between
citizens and want to keep track of unharmonious conversations.</li>
<li>Each day, you prepare a report of <span class="math inline">\(M\)</span> messages that are the most unharmonious
using a HarmoniousnessComparator.</li>
</ul>
<p>  用链表将得到如下实现： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">unharmoniousTexts</span><span class="params">(Sniffer sniffer, <span class="type">int</span> M)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt;allMessages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(); timer.hours() &lt; <span class="number">24</span>; ) &#123;</span><br><span class="line">        allMessages.add(sniffer.getNextMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Comparator&lt;String&gt; cmptr = <span class="keyword">new</span> <span class="title class_">HarmoniousnessComparator</span>();</span><br><span class="line">    Collections.sort(allMessages, cmptr, Collections.reverseOrder());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allMessages.sublist(<span class="number">0</span>, M);</span><br></pre></td></tr></table></figure></p>
<p>  然而，这种方式的弊端为：我们只需要<span class="math inline">\(\Theta(M)\)</span>空间内的变量，但该方法使用了<span class="math inline">\(\Theta(N)\)</span>的空间。</p>
<p>  为了优化内存的占用，我们可以尝试用下面的数据结构实现优先队列：</p>
<ul>
<li>Ordered Array
<ul>
<li><code>add</code>:<span class="math inline">\(\Theta(N)\)</span></li>
<li><code>getSmallest</code>:<span class="math inline">\(\Theta(1)\)</span></li>
<li><code>removeSmallest</code>:<span class="math inline">\(\Theta(N)\)</span></li>
</ul></li>
<li>Bushy BST
<ul>
<li><code>add</code>:<span class="math inline">\(\Theta(\log
N)\)</span></li>
<li><code>getSmallest</code>:<span class="math inline">\(\Theta(\log
N)\)</span></li>
<li><code>removeSmallest</code>:<span class="math inline">\(\Theta(\log
N)\)</span></li>
</ul></li>
<li>HashTable
<ul>
<li><code>add</code>:<span class="math inline">\(\Theta(1)\)</span></li>
<li><code>getSmallest</code>:<span class="math inline">\(\Theta(N)\)</span></li>
<li><code>removeSmallest</code>:<span class="math inline">\(\Theta(N)\)</span></li>
</ul></li>
</ul>
<p>  那么，我们有更优秀的实现方法吗？</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>13.Heap &amp; Priority Queue</category>
      </categories>
  </entry>
  <entry>
    <title>13.2.堆结构</title>
    <url>/2024/05/31/13.2.Heap%20Structure/</url>
    <content><![CDATA[<h1><span id="132堆结构"><span class="math inline">\(13.2\)</span>堆结构</span></h1>
<h3><span id="1堆结构的引入">1.堆结构的引入</span></h3>
<p>  由先前的分析，我们得出拥有最佳运行时间的是<span class="math inline">\(BST\)</span>。然而，对<span class="math inline">\(BST\)</span>进行修饰后，我们可以得到更好的运行时间。</p>
<p>  我们定义我们的二叉堆遵循以下性质：</p>
<ul>
<li>最小性：每个节点都小于等于它的儿子节点。</li>
<li>完全性：缺失的元素只能位于堆的底部；堆中元素排列应尽可能左偏。</li>
</ul>
<p>  如图，绿色的堆是符合条件的，而红色的是不符合条件的。</p>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image.png"></p>
<h3><span id="2树的表示">2.树的表示</span></h3>
<p>  我们可以用如下的方式表示一棵树： * <span class="math inline">\(Tree1A\)</span>：用指针表示： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1A</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1A left;</span><br><span class="line">  Tree1A middle;</span><br><span class="line">  Tree1A right;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image-1.png"></p>
<ul>
<li><span class="math inline">\(Tree1B\)</span>：用父节点元素与数组混合表示：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1B</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1B[] children;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image-2.png"></p>
<ul>
<li><span class="math inline">\(Tree1C\)</span>：用父节点元素、指向第一个孩子的元素和<span class="math inline">\(next\)</span>指针(<span class="math inline">\(sibling\)</span>)表示： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree1C</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key k;</span><br><span class="line">  Tree1C favoredChild;</span><br><span class="line">  Tree1C sibling;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image-3.png"></p>
<p>  这些表示树的方式都直接引用(<span class="math inline">\(explicit\;reference\)</span>)了节点的儿子。下面介绍一些不存储对儿子的引用的表示方式：</p>
<ul>
<li><span class="math inline">\(Approach\;2\)</span>
<ul>
<li>我们可以用类似并查集的表示方式，创建一个<span class="math inline">\(parents\)</span>数组和一个<span class="math inline">\(key\)</span>数组： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree2</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key[] keys;</span><br><span class="line">  <span class="type">int</span>[] parents;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image-4.png"></p>
<p>  当我们假定我们的堆是完全的时，我们还可以只用一个一维数组来表示： *
<span class="math inline">\(Approach\;3\)</span> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeC</span>&lt;Key&gt; &#123;</span><br><span class="line">  Key[] keys;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/13.2.Heap%20Structure/image-5.png"></p>
<p>  这种树的表示方法十分简便，我们在堆的实现中将使用这种方法。</p>
<h3><span id="3swim方法">3.<code>swim</code>方法</span></h3>
<p>  在堆的构建中，我们定义如下的<code>swim</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys[parent(k)] ≻ keys[k]) &#123;</span><br><span class="line">       swap(k, parent(k));</span><br><span class="line">       swim(parent(k));              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  如果对<span class="math inline">\(Approach\;3\)</span>进行观察的话，可以发现如下规律：</p>
<p><span class="math display">\[
\begin{cases}
parent=i\\
leftchild=2i+1\\
rightchild=2i+2
\end{cases}
\]</span></p>
<p>  如果我们让数组的<span class="math inline">\(0\)</span>位置为空(不放置元素)，则可以得到更简洁的规律：</p>
<p><span class="math display">\[
\begin{cases}
parent=i\\
leftchild=2i\\
rightchild=2i+1
\end{cases}
\]</span></p>
<p>  这样，我们就可以将数组中的元素与树上的元素一一对应了。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>13.Heap &amp; Priority Queue</category>
      </categories>
  </entry>
  <entry>
    <title>15.2.Trie的实现</title>
    <url>/2024/05/31/15.2.Implementation/</url>
    <content><![CDATA[<h1><span id="152trie的实现"><span class="math inline">\(15.2\)</span><span class="math inline">\(Trie\)</span>的实现</span></h1>
<h3><span id="1trie的介绍">1.<span class="math inline">\(Trie\)</span>的介绍</span></h3>
<p>  在<span class="math inline">\(Trie\)</span>中，我们使用以下的计策来存储一系列单词(字符串)：</p>
<ol type="1">
<li>每个节点只存储一个字母。</li>
<li>每个节点可以被多个键共用。</li>
</ol>
<p>  下面的树结构即是一组单词的<span class="math inline">\(Trie\)</span>，蓝色意味着这是一个单词的结尾：</p>
<p><img src="/2024/05/31/15.2.Implementation/image.png"></p>
<p>  同样地，<span class="math inline">\(Trie\)</span>亦可用作<span class="math inline">\(map\)</span>：</p>
<p><img src="/2024/05/31/15.2.Implementation/image-1.png"></p>
<p>  需要注意，当我们需要处理某个特定(<span class="math inline">\(specificity\)</span>)的问题时，我们可以改进我们原有的、通用的数据结构(通常是对其加以限制(<span class="math inline">\(constraint\)</span>))，来更好地实现我们想要的功能。例如，如果我们用<span class="math inline">\(HashMap\)</span>来实现对单词的存放，那么我们的查找就需要遍历所有已有的字符串，这样的效率显然很低。</p>
<ul>
<li><p><span class="math inline">\(ADT\)</span>与特殊实现(<span class="math inline">\(specific\;implementations\)</span>)是有区别的。例如，并查集是一种<span class="math inline">\(ADT\)</span>，它具有<code>connect(x, y)</code>与<code>isConnected(x, y)</code>两个方法。而这来个方法有四种不同的实现方式：<span class="math inline">\(Quick\;find\)</span>、<span class="math inline">\(Quick\;union\)</span>、<span class="math inline">\(Weight\;QU\)</span>、<span class="math inline">\(WQUPC\)</span>。</p></li>
<li><p>在这里，<span class="math inline">\(Trie\)</span>就是当<span class="math inline">\(Set\)</span>或<span class="math inline">\(Map\)</span>存储的数据类型是字符串时的特殊实现：</p>
<ul>
<li>We give each node a single character and each node can be a part of
several keys inside of the trie.</li>
<li>Searching will only fail if we hit an unmarked node or we fall off
the tree</li>
<li>Short for Retrieval tree, almost everyone pronounces it as "try" but
Edward Fredkin suggested it be pronounced as "tree"</li>
</ul></li>
</ul>
<h3><span id="2trie的构建">2.<span class="math inline">\(Trie\)</span>的构建</span></h3>
<p>  利用先前的策略，我们让每个节点存储字母、孩子和颜色。由于每个节点都是一个字母，我们可以用<code>DataIndexedCharMap</code>来存储节点的所有孩子：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataIndexedCharMap</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> V[] items;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataIndexedCharMap</span><span class="params">(<span class="type">int</span> R)</span> &#123;</span><br><span class="line">        items = (V[]) <span class="keyword">new</span> <span class="title class_">Object</span>[R];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">char</span> c, V val)</span> &#123;</span><br><span class="line">        items[c] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">// ASCII</span></span><br><span class="line">   <span class="keyword">private</span> Node root;    <span class="comment">// root of trie</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">char</span> ch;  </span><br><span class="line">      <span class="keyword">private</span> <span class="type">boolean</span> isKey;   </span><br><span class="line">      <span class="keyword">private</span> DataIndexedCharMap next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> c, <span class="type">boolean</span> blue, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">         ch = c; </span><br><span class="line">         isKey = blue;</span><br><span class="line">         next = <span class="keyword">new</span> <span class="title class_">DataIndexedCharMap</span>&lt;Node&gt;(R);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/15.2.Implementation/image-2.png"></p>
<p>  然而，当我们的节点只有很少的孩子时，由于我们创建了<span class="math inline">\(128\)</span>个空间，只有很少的空间是真正被使用的。</p>
<p>  注意到两个节点间存在链接当且仅当两个节点都存储了字符，我们可以删掉<span class="math inline">\(Node\)</span>的<span class="math inline">\(ch\)</span>变量，而用该节点在父节点的<span class="math inline">\(next\)</span>中的位置来表征： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">// ASCII</span></span><br><span class="line">   <span class="keyword">private</span> Node root;    <span class="comment">// root of trie</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">boolean</span> isKey;   </span><br><span class="line">      <span class="keyword">private</span> DataIndexedCharMap next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(<span class="type">boolean</span> blue, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">         isKey = blue;</span><br><span class="line">         next = <span class="keyword">new</span> <span class="title class_">DataIndexedCharMap</span>&lt;Node&gt;(R);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/15.2.Implementation/image-3.png"></p>
<p>  同时，为了减少空间浪费，我们可以用<span class="math inline">\(HashMap\)</span>代替<span class="math inline">\(DataIndexedCharMap\)</span>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;    <span class="comment">// root of trie</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isKey;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Character, Node&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(<span class="type">boolean</span> isKey)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.isKey = isKey;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="3trie的运行时间">3.<span class="math inline">\(Trie\)</span>的运行时间</span></h3>
<p>  给定字符串的<span class="math inline">\(Trie\)</span>，其对应的<span class="math inline">\(Map\)</span>、<span class="math inline">\(Set\)</span>操作运行时间如下：</p>
<ul>
<li><code>add</code>：<span class="math inline">\(\Theta(1)\)</span></li>
<li><code>contains</code>：<span class="math inline">\(\Theta(1)\)</span></li>
</ul>
<p>  这是因为<span class="math inline">\(Trie\)</span>的运行时间只取决于单词的长度，而与<span class="math inline">\(Trie\)</span>中键的多少无关。我们在查询时只会遍历我们需要的单词。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>15.Tries</category>
      </categories>
  </entry>
  <entry>
    <title>15.3.字符串操作</title>
    <url>/2024/05/31/15.3.Trie%20String%20Operations/</url>
    <content><![CDATA[<h1><span id="153字符串操作"><span class="math inline">\(15.3\)</span>字符串操作</span></h1>
<h3><span id="1键的收集与前缀匹配">1.键的收集与前缀匹配</span></h3>
<p>  由于在<span class="math inline">\(trie\)</span>中，字符和键(<span class="math inline">\(key\)</span>)都是被隐性表示的，当我们想让我们的键变得可迭代时，我们不能只在<span class="math inline">\(trie\)</span>中直接寻找它们。我们可以用一个可迭代的<code>collect</code>方法，该方法会维护一个字符串，它用于储存路径上的字符：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> get(root, key, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">get</span><span class="params">(Node x, String key, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (d == key.length()) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(d);<span class="comment">// use dth key char of key to find subtrie</span></span><br><span class="line">    <span class="keyword">return</span> get(x.next[c], key, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title function_">keys</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> keysWithPrefix(<span class="string">&quot;&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//collect keys in a trie.</span></span><br><span class="line"><span class="comment">//the &quot;get&quot; method will return the node containing the prefix</span></span><br><span class="line"><span class="comment">//so we can collect any string that starts from this node</span></span><br><span class="line"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title function_">keysWithPrefix</span><span class="params">(String pre)</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;String&gt;();</span><br><span class="line">    collect(get(root, pre, <span class="number">0</span>), pre, q);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(Node x, String pre, Queue&lt;String&gt; q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x.value != <span class="literal">null</span>) q.enqueue(pre);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c += <span class="number">1</span>) &#123;</span><br><span class="line">        collect(x.next[c], pre + c, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  整个搜索键的过程如下：</p>
<p><img src="/2024/05/31/15.3.Trie%20String%20Operations/image-4.png"></p>
<p>  <code>keysWithPrefix</code>方法的执行过程如下：</p>
<p><img src="/2024/05/31/15.3.Trie%20String%20Operations/image-5.png"></p>
<h3><span id="2通配符匹配">2.通配符匹配</span></h3>
<p>  为了实现<code>keysThatMatch()</code>方法，我们使用一个类似的程序，但添加一个参数<span class="math inline">\(pat\)</span>来表示我们需要<span class="math inline">\(collect()\)</span>的字符串。当模式字符是通配符(<span class="math inline">\(wildcard\)</span>)时，我们调用它的所有链接；否则，我们只调用和通配符相关的链接。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title function_">keysThatMatch</span><span class="params">(String pat)</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;String&gt;();</span><br><span class="line">    collect(root, <span class="string">&quot;&quot;</span>, pat, q);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collect</span><span class="params">(Node x, String pre, String pat, Queue&lt;String&gt; q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> pre.length();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (d == pat.length() &amp;&amp; x.val != <span class="literal">null</span>) q.enqueue(pre);</span><br><span class="line">    <span class="keyword">if</span> (d == pat.length()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> <span class="variable">next</span> <span class="operator">=</span> pat.charAt(d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; R; c += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="string">&#x27;.&#x27;</span> || next == c) &#123;</span><br><span class="line">            collect(x.next[c]. pre + c, pat, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>15.Tries</category>
      </categories>
  </entry>
  <entry>
    <title>16.1.四叉树</title>
    <url>/2024/05/31/16.1.QuadTrees/</url>
    <content><![CDATA[<h1><span id="161四叉树"><span class="math inline">\(16.1\)</span>四叉树</span></h1>
<h3><span id="1问题的引入">1.问题的引入</span></h3>
<p>  考虑这样的问题：给定下面一系列点，求落入矩形区域的点的数量。</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image.png"></p>
<p>  我们希望不用遍历所有的点，一个自然的想法是利用<span class="math inline">\(BST\)</span>的性质进行搜索。在对一系列的点坐标<span class="math inline">\((x,y)\)</span>构建<span class="math inline">\(BST\)</span>时。对于单个的<span class="math inline">\(x\)</span>坐标或<span class="math inline">\(y\)</span>坐标，我们可以很容易地构建出对应的<span class="math inline">\(BST\)</span>。但对于二维的坐标，当一个点的<span class="math inline">\(x\)</span>坐标大于另一个点、而<span class="math inline">\(y\)</span>坐标小于另一个点时，我们该怎么排序呢？</p>
<h3><span id="2四叉树">2.四叉树</span></h3>
<p>  该问题的解决办法为：让我们的树从四个方向同时(<span class="math inline">\(simultaneously\)</span>)分割空间，实现这一操作的结构称作四叉树。</p>
<h4><span id="a四叉树的构建">  <span class="math inline">\(a.\)</span>四叉树的构建</span></h4>
<p>  四叉树具有四个指针，每个指针分别指向东南、东北、西南、西北区域。假如我们以<span class="math inline">\(A\)</span>为根节点，则初始的四叉树如下：</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-1.png"></p>
<p>  对应的二维空间如下：</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-2.png"></p>
<p>  接下来，我们插入<span class="math inline">\(B(2,2)\)</span>这个节点。由于<span class="math inline">\(B\)</span>在<span class="math inline">\(A\)</span>的东北方向，<span class="math inline">\(A\)</span>的<span class="math inline">\(NE\)</span>指针指向<span class="math inline">\(B\)</span>：</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-3.png"></p>
<p>  此时对应的二维空间如下：</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-4.png"></p>
<p>  我们以同样地方式插入<span class="math inline">\(C\)</span>、<span class="math inline">\(D\)</span>、<span class="math inline">\(E\)</span>，可得到以下的四叉树和二维空间：</p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-5.png"></p>
<p><img src="/2024/05/31/16.1.QuadTrees/image-6.png"></p>
<h4><span id="b四叉树的搜索">  <span class="math inline">\(b.\)</span>四叉树的搜索</span></h4>
<p>  回到开篇的问题，我们用我们构建的四叉树来搜索符合条件的节点。</p>
<ol type="1">
<li>从根节点<span class="math inline">\(A\)</span>开始搜索。<span class="math inline">\(A\)</span>不属于矩形区域，故返回<span class="math inline">\(null\)</span>。</li>
<li>然后，我们考虑：<span class="math inline">\(A\)</span>的哪个子空间(<span class="math inline">\(subspace\)</span>)可能会有符合条件的点？由于矩形区域在<span class="math inline">\(A\)</span>的东北方向，因此我们只需搜索<span class="math inline">\(A\)</span>的<span class="math inline">\(NE\)</span>子树：</li>
</ol>
<p><img src="/2024/05/31/16.1.QuadTrees/image-7.png"></p>
<ol start="3" type="1">
<li>接着我们搜索<span class="math inline">\(B\)</span>节点，<span class="math inline">\(B\)</span>在矩形区域内，所以返回它的坐标。</li>
<li>接着我们考虑：<span class="math inline">\(B\)</span>的哪个子空间可能会有符合条件的点？可以看到<span class="math inline">\(B\)</span>的四个方向都符合条件。</li>
<li>......</li>
</ol>
<p>  可以看到，四叉树具有良好的剪枝(<span class="math inline">\(pruning\)</span>)效果，这提高了我们的搜索效率，我们可以利用递归进行我们的搜索流程。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>16.QuadTrees</category>
      </categories>
  </entry>
  <entry>
    <title>16.2.K-D树</title>
    <url>/2024/05/31/16.2.K-D%20Trees/</url>
    <content><![CDATA[<h1><span id="162k-dtrees"><span class="math inline">\(16.2\)</span><span class="math inline">\(K-D\;Trees\)</span></span></h1>
<h3><span id="1引入">1.引入</span></h3>
<p>  对于二维的空间，我们可以利用四叉树完成搜索。那对于更高维的空间呢？比如下面的例子：</p>
<ul>
<li><p>Example: Want to find songs with the following features:</p>
<ul>
<li>Length between 3 minutes and 6 minutes.</li>
<li>Between 1000 and 20,000 listens.</li>
<li>Between 120 to 150 BPM.</li>
<li>Were recorded after 2004.</li>
</ul></li>
</ul>
<p>  这时，我们就可以采用<span class="math inline">\(K-D\;Tree\)</span>的数据结构来对数据进行划分，从而优化搜索。</p>
<h4><span id="2k-d树的原理与构造">2.<span class="math inline">\(K-D\)</span>树的原理与构造</span></h4>
<p>  以二维坐标为例，我们按照以下的规则构建<span class="math inline">\(K-D\;Tree\)</span>：</p>
<ul>
<li><p>Each level has a "cutting dimension"</p></li>
<li><p>Cycle through the dimensions as you walk down the tree.</p></li>
<li><p>Each node contains a point P = (x,y)</p></li>
<li><p>To find (x',y') you only compare coordinate from the cutting
dimension</p>
<ul>
<li>e.g. if cutting dimension is x, then you ask: is x’ &lt; x</li>
</ul></li>
</ul>
<p>  每个节点都拥有两个子空间。在搜索中，我们像在四叉树中做的一样，只在可能有最优解的子空间进行搜索。</p>
<p>  例如，我们可以如下插入以下坐标：</p>
<p><img src="/2024/05/31/16.2.K-D%20Trees/image-8.png"></p>
<h4><span id="3k-d树的搜索">3.<span class="math inline">\(K-D\)</span>树的搜索</span></h4>
<p>  以搜索到某个点距离最小的点为例，我们可以按照以下的步骤进行搜索：</p>
<ul>
<li><p>Start at the root and store that point as the "best so far".
Compute its distance to the query point, and save that as the "score to
beat". In the image above, we start at A whose distance to the flagged
point is 4.5.</p></li>
<li><p>This node partitions the space around it into two subspaces. For
each subspace, ask: "Can a better point be possibly found inside of this
space?" This question can be answered by computing the shortest distance
between the query point and the edge of our subspace (see dotted purple
line below).</p></li>
<li><p>Continue recursively for each subspace identified as containing a
possibly better point.</p></li>
<li><p>In the end, our "best so far" is the best point; the point
closest to the query point.</p></li>
</ul>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>16.QuadTrees</category>
      </categories>
  </entry>
  <entry>
    <title>13.3.优先队列的实现</title>
    <url>/2024/05/31/13.3.The%20Implementation/</url>
    <content><![CDATA[<h1><span id="133优先队列的实现"><span class="math inline">\(13.3\)</span>优先队列的实现</span></h1>
<p>(注：这里实现的是大根堆)</p>
<h3><span id="1优先队列的初始化">1.优先队列的初始化</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] pq; <span class="comment">// heap-ordered complete binary tree</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// in pq[1..N] with pq[0] unused</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPQ</span><span class="params">(<span class="type">int</span> maxN)</span> &#123; </span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[maxN+<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> N; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key v)</span> &#123; </span><br><span class="line">        pq[++N] = v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="type">Key</span> <span class="variable">max</span> <span class="operator">=</span> pq[<span class="number">1</span>]; <span class="comment">// Retrieve max key from top.</span></span><br><span class="line">        swap(<span class="number">1</span>, N--); <span class="comment">// Exchange with last item.</span></span><br><span class="line">        pq[N+<span class="number">1</span>] = <span class="literal">null</span>; <span class="comment">// Avoid loitering.</span></span><br><span class="line">        sink(<span class="number">1</span>); <span class="comment">// Restore heap property.</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2辅助方法的实现">2.辅助方法的实现</span></h3>
<h4><span id="aless-swap方法">  <span class="math inline">\(a.\)</span><code>less</code>、<code>swap</code>方法</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">Ket</span> <span class="variable">t</span> <span class="operator">=</span> pq[i];</span><br><span class="line">    pq[i] = pq[j];</span><br><span class="line">    pq[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="bswim方法">  <span class="math inline">\(b.\)</span><code>swim</code>方法</span></h4>
<p>  <code>swim</code>方法用于将堆底部的元素向上洄游，以维护堆的性质：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">        swap(k / <span class="number">2</span>, k);</span><br><span class="line">        k = k / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/13.3.The%20Implementation/image-7.png"></p>
<h4><span id="csink方法">  <span class="math inline">\(c.\)</span><code>sink</code>方法</span></h4>
<p>  <code>sink</code>方法用于将堆顶部的元素下沉，以维护堆的性质：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">        <span class="comment">//assure that the parent is the biggest of its children</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>)) &#123;</span><br><span class="line">            swap (j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!less(k, j)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap (k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/13.3.The%20Implementation/image-6.png"></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>13.Heap &amp; Priority Queue</category>
      </categories>
  </entry>
  <entry>
    <title>17.1.图的构建</title>
    <url>/2024/05/31/17.1.The%20construction%20of%20Graphs/</url>
    <content><![CDATA[<h1><span id="171图的构建"><span class="math inline">\(17.1\)</span>图的构建</span></h1>
<h3><span id="1图的api">1.图的<span class="math inline">\(API\)</span></span></h3>
<p><img src="/2024/05/31/17.1.The%20construction%20of%20Graphs/image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.V = V;</span><br><span class="line">        <span class="built_in">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[])<span class="keyword">new</span> <span class="title class_">Bag</span>[V];<span class="comment">// Create array of lists.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; V; v += <span class="number">1</span>) &#123;</span><br><span class="line">            adj[v] = <span class="keyword">new</span> <span class="title class_">Bag</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(In in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(in.readInt()); <span class="comment">// Read V and construct this graph.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">E</span> <span class="operator">=</span> in.readInt(); <span class="comment">// Read E.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; E; i++) &#123; <span class="comment">// Add an edge.</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> in.readInt(); <span class="comment">// Read a vertex,</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> in.readInt(); <span class="comment">// read another vertex,</span></span><br><span class="line">            addEdge(v, w); <span class="comment">// and add edge connecting them.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        adj[w].add(v);</span><br><span class="line">        E += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2dfs">2.<span class="math inline">\(dfs\)</span></span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepthFirstSearch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepthFirstSearch</span><span class="params">(Graph G, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V];</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Graph G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        marked[v] = <span class="literal">true</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w : G.adj[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) dfs(G, w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">marked</span><span class="params">(<span class="type">int</span> w)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="3路径的寻找">3.路径的寻找</span></h3>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>17.Graphs</category>
      </categories>
  </entry>
  <entry>
    <title>18.1.选择排序</title>
    <url>/2024/05/31/18.1.Selection%20Sort/</url>
    <content><![CDATA[<h1><span id="181selection-sort"><span class="math inline">\(18.1\)</span>Selection Sort</span></h1>
<h3><span id="1the-step-of-selection-sort">1.The step of Selection sort</span></h3>
<p>  In selection sort, we basically do these three things:</p>
<ol type="1">
<li>Find the smallest item.</li>
<li>Move it to the front.</li>
<li>Selection sort the rest(using recursion).</li>
</ol>
<p>  For each step, we can design an individual method to implement
it.</p>
<h3><span id="2step-implementation">2.Step implementation</span></h3>
<p>  As the moving step requires the index of the to-moving element, the
value we return should be index of elements, too.</p>
<h4><span id="afind">  <span class="math inline">\(a.\)</span><code>Find</code></span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;</span><br><span class="line">            i = minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Given that we may need to <code>Find</code> the minimun in asked
range, we may improve our method by passing an extra parameter which
point to the start index(We'll use it in the following procedure)：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> st)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (st &gt;= arr.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[minIndex]) &#123;</span><br><span class="line">            i = minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="bswap">  <span class="math inline">\(b.\)</span><code>swap</code></span></h4>
<p>  We are going to implement the method by manipulating the index of
the elements: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[x];</span><br><span class="line">    arr[x] = arr[y];</span><br><span class="line">    arr[y] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="cmainmethod">  <span class="math inline">\(c.\)</span>Main
method</span></h4>
<p>  Since we would like to do the sorting recursively, we may introduce
a helper method and invoke it recursively: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        sortHelper(arr, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sortHelper</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//basic situation</span></span><br><span class="line">        <span class="keyword">if</span> (index == arr.length()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//find the smallest item</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> find(arr, index);</span><br><span class="line">        <span class="comment">//Move it to the front</span></span><br><span class="line">        swap(arr, index, minIndex);</span><br><span class="line">        <span class="comment">//Recursively call the method</span></span><br><span class="line">        sortHelper(arr, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>18.Basic Sorting</category>
      </categories>
  </entry>
  <entry>
    <title>18.2.堆排序</title>
    <url>/2024/05/31/18.2.Heap%20Sort/</url>
    <content><![CDATA[<h1><span id="182heapsort"><span class="math inline">\(18.2\)</span>Heap
Sort</span></h1>
<h3><span id="1the-step-of-heap-sorting">1.The step of Heap Sorting</span></h3>
<p>  The simplest method to implement sorting via heap is to put the
whole array into a heap, and pick out top of the heap one by one.</p>
<p>  However, this method will lead to unnecessarily memory waste, for
we can do heap sorting in place without creating a new heap.</p>
<h3><span id="2step-impletation">2.Step impletation</span></h3>
<h4><span id="abasic-heap-operation">  <span class="math inline">\(a.\)</span>Basic Heap operation</span></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(Comparable[] pq, <span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k;<span class="comment">//left child</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; n &amp;&amp; less(pq, j, j + <span class="number">1</span>)) j += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!less(pq, k, j)) <span class="keyword">break</span>;</span><br><span class="line">        swap(pq, k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable[] pq, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pq[i - <span class="number">1</span>].compareTo(pq[j - <span class="number">1</span>]) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Object[] pq, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> pq[i - <span class="number">1</span>];</span><br><span class="line">    pq[i - <span class="number">1</span>] = pq[j - <span class="number">1</span>];</span><br><span class="line">    pq[j - <span class="number">1</span>] = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="bheapsorting">  <span class="math inline">\(b.\)</span>Heap
Sorting</span></h4>
<p>  The in place heap sorting use the following step: 1. Sink the
element in the array one by one, so that the array forms a heap.</p>
<p><img src="/2024/05/31/18.2.Heap%20Sort/image.png"></p>
<p><img src="/2024/05/31/18.2.Heap%20Sort/image-1.png"></p>
<ol start="2" type="1">
<li>Pop the front element one by one, and move the popped element to the
back of the array.</li>
</ol>
<p><img src="/2024/05/31/18.2.Heap%20Sort/image-2.png"></p>
<p><img src="/2024/05/31/18.2.Heap%20Sort/image-3.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] pq)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pq.length;</span><br><span class="line">    <span class="comment">//heapify</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k --) sink(pq, k, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort and swap</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//pop the heaptop</span></span><br><span class="line">        swap(pq, <span class="number">1</span>, k--);</span><br><span class="line">        <span class="comment">//why k--?Because the kth element is sorted, so we only need to care about the k-1 th</span></span><br><span class="line">        <span class="comment">//maintain the heap property</span></span><br><span class="line">        sink(pq, <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>18.Basic Sorting</category>
      </categories>
  </entry>
  <entry>
    <title>18.3.归并排序</title>
    <url>/2024/05/31/18.3.Merge%20Sort/</url>
    <content><![CDATA[<h1><span id="183mergesort"><span class="math inline">\(18.3.\)</span>Merge
Sort</span></h1>
<h3><span id="1the-step-of-merge-sort">1.The step of Merge Sort</span></h3>
<ul>
<li>Split items into 2 roughly even pieces.</li>
<li>Mergesort each half (steps not shown, this is a recursive
algorithm!)</li>
<li>Merge the two sorted halves to form the final result.</li>
</ul>
<h3><span id="2step-implementation">2.Step implementation</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">merge</span><span class="params">(<span class="type">double</span>[] a, <span class="type">double</span>[] b)</span> &#123;</span><br><span class="line">    <span class="type">double</span>[] c = <span class="keyword">new</span> <span class="title class_">double</span>[a.length + b.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; c.length; k += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= a.length) c[k] = b[j++];</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= b.length) c[k] = a[i++];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= b[j]) c[k] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> c[k] = b[j++]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span>[] mergeSort(<span class="type">double</span>[] input) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> input.length;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> input;</span><br><span class="line">    <span class="type">double</span>[] a = <span class="type">double</span>[N / <span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span>[] b = <span class="type">double</span>[N - N / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i += <span class="number">1</span>) a[i] = input[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; b.length; j += <span class="number">1</span>) b[j] = input[j + N / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(a), mergeSort(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>18.Basic Sorting</category>
      </categories>
  </entry>
  <entry>
    <title>18.4.插入排序</title>
    <url>/2024/05/31/18.4.Insertion%20Sort/</url>
    <content><![CDATA[<h1><span id="184insertion-sort"><span class="math inline">\(18.4.\)</span>Insertion Sort</span></h1>
<h3><span id="1the-step-of-insertion-sort">1.The step of Insertion Sort</span></h3>
<p>  The insertion sort follows these general strategies:</p>
<ul>
<li>Starting with an empty output sequence.</li>
<li>Add each item from input, inserting into output at right
places.</li>
</ul>
<p>  Also, this method requires a new array, which takes up some
memory.As a result, we may try in place sorting by using swapping
method.</p>
<p>  Take the below array as example.Suppose we have sorted the first
two elements.It's worth noting that we use a <span class="math inline">\(j\)</span> to track the current spot of the
travelling element:</p>
<p><img src="/2024/05/31/18.4.Insertion%20Sort/image-4.png"></p>
<p>  The <span class="math inline">\(2\)</span> element will experience
the following steps:</p>
<p><img src="/2024/05/31/18.4.Insertion%20Sort/image-5.png"></p>
<p><img src="/2024/05/31/18.4.Insertion%20Sort/image-6.png"></p>
<p>  After these steps, the <span class="math inline">\(2\)</span>
element reach its right place, and we get the first third elements
sorted:</p>
<p><img src="/2024/05/31/18.4.Insertion%20Sort/image-7.png"></p>
<p>  Do it recursively, then we can get a sorted array.</p>
<h3><span id="2step-implementation">2.Step implementation</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="comment">//compare with its front element, if it&#x27;s not in order, swap it</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j - <span class="number">1</span>]); j --) &#123;</span><br><span class="line">            swap(a, j, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo + <span class="number">1</span>; i &lt; hi; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; lo &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--) &#123;</span><br><span class="line">                swap(a, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="3some-property-of-insertionsort">3.Some property of Insertion
Sort</span></h3>
<p>  Since the principle of insertion sort is to maintain the order of
each subsequence, for arrays that are almost sorted, we only need to do
few swaps, thus makes sorting fast.</p>
<p>  Suppose that there are <span class="math inline">\(K\)</span>
inversions in the array, the runtime of Insertion Sort is <span class="math inline">\(\Theta (N+K)\)</span>.</p>
<p>  Moreover, we can define an almost sorted array as one in which
numbers of inversions <span class="math inline">\(\leq\;cN\)</span>,
insertion sort is excellent on these arrays.</p>
<p>  Ususally, for small arrays(with N less than 15), insertion sort is
fast.</p>
<h3><span id="4sorting-summary">4.Sorting Summary</span></h3>
<p><img src="/2024/05/31/18.4.Insertion%20Sort/image-8.png"></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>18.Basic Sorting</category>
      </categories>
  </entry>
  <entry>
    <title>2.3.二进制运算</title>
    <url>/2024/04/04/2-3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1><span id="23binary-arithmetic"><span class="math inline">\(2.3.\)</span>Binary Arithmetic</span></h1>
<h3><span id="1negative-numberrepresentation">1.Negative number
representation</span></h3>
<p>  For a negative number <span class="math inline">\(x\)</span>, we
use <span class="math inline">\(2^n - x\)</span> to represent it.</p>
<ul>
<li><span class="math inline">\(e.g.\)</span>-4 is represent as
<code>1100</code> in four-bit binary number, also equal to 16-4=12.</li>
</ul>
<p>  In order not to mistake this representation with positive number,
we prescribe that <em>a positive number cannot use the left-most bit to
represent number</em>.</p>
<h3><span id="2binary-addition">2.Binary addition</span></h3>
<p>  Before discuss the numerical addition, we first take a look at the
bit-to-bit addition. We use the folloing API to deal with the carry:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHIP AddBit &#123;</span><br><span class="line">	IN a, b;</span><br><span class="line">	OUT out, carry;</span><br><span class="line"></span><br><span class="line">	PARTS:</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  After the implementation, for a number, we just need to do
<code>AddBit</code> for each bit of it.</p>
<blockquote>
<p><span class="math inline">\(p.s.:\)</span>How do we deal with the
following 4-bit addition<code>1000 + 1100</code>?   The answer is
<code>0100</code>. This is because the left-most bit addition gets a
carry, but it is out of the bit range. This is called <em>integer
overflow</em>. When facing this, the computer will do <span class="math inline">\(\mod 2^n\)</span> to the true result, where <span class="math inline">\(n\)</span> is the bit number.</p>
</blockquote>
<blockquote>
<p><span class="math inline">\(p.s:\)</span>By the <em>integer
overflow</em> theory, we can prove that the <em>simple positive addition
also suits negative numbers</em>.</p>
<p><span class="math inline">\(proof:\)</span>Assume there are two
negative number <span class="math inline">\(x,y\)</span>, they are
represented as <span class="math inline">\(2^n-x,2^n-y\)</span>. Add
them together, and we get <span class="math inline">\(2^{n+1}-x-y\)</span>. The result apparently
overflow the range, so<span class="math inline">\(\mod 2^n\)</span>, and
we get <span class="math inline">\(2^n - x - y\)</span>. This is the
binary representation of <span class="math inline">\(-x-y\)</span>,
<span class="math inline">\(QED\)</span>.</p>
</blockquote>
<h3><span id="3binary-subtraction">3.Binary subtraction</span></h3>
<p>  To do subtraction, we just need to add a number's negation. We know
that <span class="math inline">\(-x\)</span> is represented as <span class="math inline">\(2^n-x\)</span>. Let's do some transformation
like:</p>
<p><span class="math display">\[(2^n-1)-x+1\]</span></p>
<p>  Why this? Notice that <span class="math inline">\(2^n-1\)</span> is
<code>1111</code>, and it's easy to subtract other number, for carry
will never occur in this instance. For <span class="math inline">\(+1\)</span>, since we have implement addition,
it's also easy.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 2.Boolean Calculation &amp; ALU</category>
      </categories>
  </entry>
  <entry>
    <title>18.6.基数排序</title>
    <url>/2024/05/31/18.5.Radix%20Sort/</url>
    <content><![CDATA[<h1><span id="186radixsort"><span class="math inline">\(18.6.\)</span>Radix
Sort</span></h1>
<h3><span id="1counting-sort">1.Counting Sort</span></h3>
<p>   In the previous text, we have proved that sorting using comparison
has a worst case running time of <span class="math inline">\(\Theta(n\log n)\)</span>.However, what if we don't
compare at all?</p>
<p>  Suppose we have a couple of characters, saying <span class="math inline">\(acdsjlfkm\)</span>, we can sort them in alphabet
order through the following steps:</p>
<ol type="1">
<li>Creat an array with the same size of an alphabet(<span class="math inline">\(26\)</span>).</li>
<li>For each character, put it in the <span class="math inline">\(ch-&#39;a&#39;\)</span> index.</li>
<li>Scan the whole array, and the former character are always less than
the latter. Insert the character into a new array in order, then we get
a sorted array.</li>
</ol>
<p>  This kind of sorting method is called counting sort. If the length
of data is <span class="math inline">\(N\)</span>, and the size of
alphabet is <span class="math inline">\(R\)</span>, then the runtime of
counting sort is <span class="math inline">\(\Theta(N+R)\)</span>. It's
liner runtime!</p>
<p><img src="/2024/05/31/18.5.Radix%20Sort/image-9.png"></p>
<p>  However, the algorithm falls to sort hard-to-count items like
String, so we need improvement.</p>
<h3><span id="2lsd-radix-sort">2.LSD Radix Sort</span></h3>
<p>  The LSD(Least Significant Digit) radix sort sort each digit of the
item independently form rightmost digit towards left, take the below
table as example:</p>
<p><img src="/2024/05/31/18.5.Radix%20Sort/image-10.png"></p>
<p>  The runtime of LSD radix sort is <span class="math inline">\(\Theta(WN+WR)\)</span>,where N is Number of items,
R is size of alphabet, and W is the maximun length of these items.</p>
<p>  What if the length of each item isn't same? We can treat empty
spaces as less than all other characters:</p>
<p><img src="/2024/05/31/18.5.Radix%20Sort/image-11.png"></p>
<h3><span id="3msd-radix-sort">3.MSD Radix Sort</span></h3>
<p>  The MSD(Most Significant Digit) radix sort is similiar to LSD radix
sort. However, it sorts from the left digit to the right.</p>
<p>  After first sorting process, we may get items as below:</p>
<p><img src="/2024/05/31/18.5.Radix%20Sort/image-12.png"></p>
<p>  The items are not in correct order yet! To solve this, we can treat
items with same left digit as a group, and compare the next left
character within groups:</p>
<p><img src="/2024/05/31/18.5.Radix%20Sort/image-13.png"></p>
<p>  The runtime of MSD radix sort is the same as LSD radix sort.</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>18.Basic Sorting</category>
      </categories>
  </entry>
  <entry>
    <title>2.4.算术逻辑单元</title>
    <url>/2024/04/04/2-4-%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<h1><span id="24arthimetic-logic-unit"><span class="math inline">\(2.4.\)</span>Arthimetic Logic Unit</span></h1>
<h3><span id="1alu-intro">1.ALU intro</span></h3>
<p>  The Arithmetic Logic Unit (ALU) is a crucial component in
computers, responsible for <em>executing various arithmetic and logic
operations</em>. Typically <em>part of the CPU</em>, it handles
arithmetic operations such as addition, subtraction, multiplication, and
division, as well as logic operations including <code>AND</code>,
<code>OR</code>, <code>NOT</code>, and <code>XOR</code>, based on
instructions provided.</p>
<h3><span id="2alu-structure">2.ALU structure</span></h3>
<p>  We can describe the ALU through the diagram below:</p>
<p><img src="/2024/04/04/2-4-%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/image.png"></p>
<ul>
<li><p>The ALU computes a function on the two inputs, and outputs the
result.</p></li>
<li><p><strong>f</strong>:one out of a family of pre-defined arithmetic
and logical functions. It contains:</p>
<ul>
<li>Arithmetic operations:integer addition, multiplication, division,
...</li>
<li>Logical operations: And, Or, Xor....</li>
</ul></li>
</ul>
<blockquote>
<p><span class="math inline">\(p.s.\)</span>There is a interesting
question towards ALU: Which operation should ALU operate? If we choose
to ignore some operation in ALU, when we want to use it, we have to
implement it in the software. This is also called a <em>Hardware and
Software trade off</em>.</p>
</blockquote>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 2.Boolean Calculation &amp; ALU</category>
      </categories>
  </entry>
  <entry>
    <title>2.2.单链表</title>
    <url>/2024/05/31/2.2.SLLists/</url>
    <content><![CDATA[<h1><span id="22单链表"><span class="math inline">\(2.2\)</span>单链表</span></h1>
<p>  在前一章中，我们搭建了整型链表<span class="math inline">\(IntList\)</span>，但在实际应用中，<span class="math inline">\(IntList\)</span>较难使用，并且会导致代码难以理解与维护。</p>
<p>  这些问题的来源是：<span class="math inline">\(IntList\)</span>是一个裸裸递归结构：<span class="math inline">\(IntList\)</span>在函数内部直接调用自身的递归，而没有其他辅助操作或条件检查。</p>
<p>  下面我们对<span class="math inline">\(IntList\)</span>进行一系列优化，来搭建新的类<span class="math inline">\(SLList\)</span>。</p>
<h3><span id="1重构">1.重构</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">        item = i;</span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  为了避免<span class="math inline">\(IntList\)</span>的复杂使用，我们创建一个单独的<span class="math inline">\(SLList\)</span>类给用户使用： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IntNode first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(SLList\)</span>的实现隐藏了<span class="math inline">\(IntList\)</span>的一些细节，使得定义链表变得更简洁：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntList</span> <span class="variable">L1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">SLList</span> <span class="variable">L2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<h3><span id="2addfirstgetfirst">2.<code>addFirst</code>，<code>getFirst</code></span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> first.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这样优化后的链表很方便使用： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">15</span>);</span><br><span class="line">L.addFirst(<span class="number">10</span>);</span><br><span class="line">L.addFirst(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> L.getFirst();</span><br><span class="line"></span><br><span class="line"><span class="comment">//compared with IntList//</span></span><br><span class="line"><span class="type">IntList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, <span class="literal">null</span>);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">10</span>, L);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, L);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> L.first;</span><br></pre></td></tr></table></figure></p>
<p>  可以看到，<span class="math inline">\(SLList\)</span>类扮演了链表使用者和裸递归数据结构间中介人的角色。</p>
<h3><span id="3public和private">3.<code>public</code>和<code>private</code></span></h3>
<p>  先前定义的<span class="math inline">\(SLList\)</span>有一个问题：用户的一些操作会导致链表的异常。例如：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SLList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">15</span>);</span><br><span class="line">L.addFirst(<span class="number">10</span>);</span><br><span class="line">L.first.next.next = L.first.next;</span><br></pre></td></tr></table></figure></p>
<p>  这会导致链表的无限延长，而这是我们不希望看到的。我们可以采用下面的方法来杜绝这件事：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IntNode first;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>  <code>private</code>变量和方法只能被同一个<code>.java</code>文件内的代码访问，其他文件访问它时，会返回<code>first has private access in SLList</code>的错误。</p>
<p>  在软件工程中，<code>private</code>关键字表明一段代码应该被用户忽略、也不需要被用户理解。<code>public</code>关键字则声明了一个方法是可用的、并且永远不会出错(不管用户做出什么更改)。因此，要谨慎使用<code>public</code>关键字。</p>
<blockquote>
<p>  As an analogy, a car has certain public features, e.g. the
accelerator and brake pedals. Under the hood, there are private details
about how these operate. In a gas powered car, the accelerator pedal
might control some sort of fuel injection system, and in a battery
powered car, it may adjust the amount of battery power being delivered
to the motor. While the private details may vary from car to car, we
expect the same behavior from all accelerator pedals. Changing these
would cause great consternation from users, and quite possibly terrible
accidents.</p>
</blockquote>
<h3><span id="4嵌套类">4.嵌套类</span></h3>
<p>  目前为止我们定义了两个类：<span class="math inline">\(IntNode\)</span>和<span class="math inline">\(SLList\)</span>，但是<span class="math inline">\(IntNode\)</span>实际上只是辅助<span class="math inline">\(SLList\)</span>的。</p>
<p>  对此，<span class="math inline">\(Java\)</span>允许我们在一个类里面定义其他类：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">            <span class="keyword">public</span> IntNode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">                item = i;</span><br><span class="line">                next = n;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> IntNode first; </span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">           first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">       &#125; </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>  创建一个嵌套类与分开定义两个类的效果是一样的，只是前者能让代码看起来更为整齐。</p>
<p>  如果嵌套类不需要使用<span class="math inline">\(SLList\)</span>中的任何实例方法或者变量，我们可以用<code>static</code>来声明它。<code>static</code>关键字说明静态类(<span class="math inline">\(static\;class\)</span>)中的方法不能访问任何在封闭类中的成员。在这个例子中，这意味着<span class="math inline">\(IntNode\)</span>不能够访问<code>first</code>，<code>addFirst</code>或者<code>getFirst</code>。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">            <span class="keyword">public</span> IntNode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">                item = i;</span><br><span class="line">                next = n;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> IntNode first;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>  这样的做法可以节约一些内存，因为之后<span class="math inline">\(IntNode\)</span>就不需要再追踪它怎么访问它所处的<span class="math inline">\(SLList\)</span>了，从而<span class="math inline">\(IntNode\)</span>不会调用<span class="math inline">\(SLList\)</span>。</p>
<blockquote>
<p>  if you don't use any instance members of the outer class, make the
nested class static.</p>
</blockquote>
<h3><span id="5addlast-size">5.<code>addLast</code>、<code>size</code></span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Adds an item to the end of the list. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advance p to the end of the list. */</span></span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the size of the list starting at IntNode p. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(IntNode p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + size(p.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这个<span class="math inline">\(size\)</span>函数也是<span class="math inline">\(O(n)\)</span>复杂度的。为了减少时间消耗，我们可以像创建<span class="math inline">\(SLList\)</span>一样创建一个“中介人”，来实现用户对<span class="math inline">\(Size\)</span>的访问： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Returns the size of the list starting at IntNode p. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(IntNode p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + size(p.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这里出现了两个方法，名称都叫<span class="math inline">\(size\)</span>。这是允许的，因为它们有不同的参数。我们把这种方法名字相同、参数不同的方法称作重载(<span class="math inline">\(overloaded\)</span>)。</p>
<h3><span id="6缓存cashing">6.缓存<span class="math inline">\(cashing\)</span></span></h3>
<p>  除了用上面的方法计算<span class="math inline">\(size\)</span>，我们还可以在<span class="math inline">\(SLList\)</span>类中添加一个<span class="math inline">\(size\)</span>变量： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    ... <span class="comment">/* IntNode declaration omitted. */</span></span><br><span class="line">    <span class="keyword">private</span> IntNode first;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这种通过保存关键信息来加速检索的方法被称为缓存(<span class="math inline">\(cashing\)</span>)。</p>
<h3><span id="7空链表">7.空链表</span></h3>
<p>  我们<span class="math inline">\(SLList\)</span>的框架可以轻松地初始化链表：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;</span><br><span class="line">    first = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="8哨兵节点sentinel">8.哨兵节点(<span class="math inline">\(sentinel\)</span>)</span></h3>
<p>  我们可以按照上一章的方法实现<code>addLast</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  但是，当传入的链表是空链表时，由于<code>first == null</code>，<code>while(p.next != null),p.next</code>这些方法都会导致<code>null pointer exceptation</code>的错误。</p>
<p>  我们可以单独讨论<code>first == null</code>的情况，但这样会让程序变得复杂。因此我们设法将所有的链表都统一成一种情况。</p>
<p>  我们可以在链表的开头创建一个节点，叫作哨兵节点(<span class="math inline">\(sentinel\;node\)</span>)，不管链表是否为空，这个节点都存在。</p>
<p><img src="/2024/05/31/2.2.SLLists/image-9.png"></p>
<p><img src="/2024/05/31/2.2.SLLists/image-10.png"></p>
<p>  在将所有情况统一后，我们就可以更好地实现<code>addLast</code>：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">    <span class="keyword">while</span>(p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="9不变量invarient">9.不变量<span class="math inline">\(invarient\)</span></span></h3>
<p>  不变量，就是数据结构中必须要遵守的事实(<span class="math inline">\(fact\;that\;is\;guaranteed\;to\;be\;true\)</span>)。</p>
<p>  一个<span class="math inline">\(SLList\)</span>至少要遵循以下不变量：</p>
<ul>
<li><code>sentinel</code>总是指向哨兵节点。</li>
<li>链表最前面的元素(如果存在的话)永远是<code>sentinel.next.item</code>。</li>
<li><code>size</code>变量永远代指被加入链表的元素的数量。</li>
</ul>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>2.List</category>
      </categories>
  </entry>
  <entry>
    <title>2.1.Java语言特性</title>
    <url>/2024/05/31/2.1.Mystery%20of%20the%20Walrus/</url>
    <content><![CDATA[<h1><span id="21-java语言特性"><span class="math inline">\(2.1\)</span> <span class="math inline">\(Java\)</span>语言特性</span></h1>
<h3><span id="1比特bit">1.比特(<span class="math inline">\(bit\)</span>)</span></h3>
<p>  在计算机中，所有的信息都<strong>以<span class="math inline">\(01\)</span>串的形式</strong>存储于内存中，例如：</p>
<ul>
<li><span class="math inline">\(72\)</span>被存储为<code>01001000</code></li>
<li><span class="math inline">\(H\)</span>字母被存储为<code>01001000</code></li>
</ul>
<p>  <span class="math inline">\(72\)</span>和<span class="math inline">\(H\)</span>的<span class="math inline">\(01\)</span>串是相同的，<span class="math inline">\(Java\)</span>代码通过数据类型(<span class="math inline">\(tyep\)</span>)区分它们： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="string">&#x27;H&#x27;</span>;</span><br><span class="line"><span class="type">int</span> x=c;</span><br><span class="line">System.out.println(c);</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">H</span><br><span class="line"><span class="number">72</span></span><br></pre></td></tr></table></figure>
<p>  在这个例子中，<code>x</code>和<code>c</code>变量都有相同的<span class="math inline">\(01\)</span>串，但解释器会在打印它们的时候对其进行不同的处理。</p>
<p>  在<span class="math inline">\(Java\)</span>中，有<span class="math inline">\(8\)</span>种基本数据类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>float</code>，<code>double</code>，<code>boolean</code>，<code>char</code>。</p>
<h3><span id="2变量的声明简化">2.变量的声明(简化)</span></h3>
<p>  我们可以将计算机想象成一个一个拥有大量记忆比特(<span class="math inline">\(memory\;bits\)</span>)来存储信息的机器，<strong>每个比特都有独立的地址</strong>。</p>
<p>  在声明某一基本数据类型的变量时，<span class="math inline">\(Java\)</span>会<strong>找到一个区域(<span class="math inline">\(blocks\)</span>)</strong>，这个区域有足够的比特来存储该类型的信息。我们可以把这些区域比喻为
<strong>一个装着比特的盒子(<span class="math inline">\(box\)</span>)</strong>。</p>
<p>  除了安置内存，<span class="math inline">\(Java\)</span>解释器还会<strong>创造一个内部表格的入口(<span class="math inline">\(entry\)</span>)</strong>，它<strong>将每个变量的名字与它们对应盒子的第一个比特相对应(<span class="math inline">\(map\)</span>)</strong>。</p>
<p>  例如，当我们声明<code>int x</code>和<code>double y</code>这两个变量时，<span class="math inline">\(Java\)</span>可能会决定用内存中的第<span class="math inline">\(352\)</span>到第<span class="math inline">\(384\)</span>位比特来存储<code>x</code>，用第<span class="math inline">\(20800\)</span>到第<span class="math inline">\(20864\)</span>位比特来存储<code>y</code>。解释器会接着记录<code>x</code>从第<span class="math inline">\(352\)</span>位比特开始存储，<code>y</code>从第<span class="math inline">\(20800\)</span>位比特开始存储。在执行下面的代码后：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br></pre></td></tr></table></figure></p>
<p>  我们会得到下面两个<span class="math inline">\(32\)</span>位和<span class="math inline">\(64\)</span>位的盒子：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image.png"></p>
<p>  <span class="math inline">\(java\)</span>语言<strong>并没有像<span class="math inline">\(C\)</span>语言一样提供访问盒子地址的途径</strong>。这虽然阻止了某些类型优化，但也防止了一大类非常棘手的编程错误。</p>
<p>  在变量声明后，<span class="math inline">\(Java\)</span>并不会在预留的盒子里写入任何默认的东西，也就是说，<strong>每个变量并没有默认值</strong>。因此，在这个盒子被通过<code>=</code>运算符装满比特之前，<span class="math inline">\(Java\)</span>解释器会阻止我们使用这个变量。而<strong>当我们对内存盒子(<span class="math inline">\(memory\;box\)</span>)进行赋值后，这个盒子就会装入我们指定的值</strong>。</p>
<p>  例如，当我们执行下面的程序时： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = -<span class="number">1431195969</span>;</span><br><span class="line">y = <span class="number">567213.112</span>;</span><br></pre></td></tr></table></figure></p>
<p>  每个变量的内存盒子会像下面这样被填满。这种标记被叫做盒子标记法(<span class="math inline">\(box\;notation\)</span>)：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-1.png"></p>
<p>  为了简化，我们将盒子标记简化为如下格式：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-2.png"></p>
<h3><span id="3等式的黄金规则groe">3.等式的黄金规则(<span class="math inline">\(GRoE\)</span>)</span></h3>
<p>  <strong>当我们写下<code>y=x</code>，我们在告诉<span class="math inline">\(Java\)</span>解释器把<code>x</code>的比特复制给<code>y</code></strong>。这个规则是理解下面这个谜题的基础：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;</span><br><span class="line">b = a;</span><br><span class="line">b.weight = <span class="number">5</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure></p>
<h3><span id="4引用类型referencetype">4.引用类型(<span class="math inline">\(reference\;type\)</span>)</span></h3>
<p>  在之前我们介绍了<span class="math inline">\(Java\)</span>的基本类型，除了基本类型外的其他类型，如数组，被称为<strong>引用类型</strong>。</p>
<h4><span id="a对象实例化">  <span class="math inline">\(a.\)</span>对象实例化</span></h4>
<p>  当我们利用<code>new</code>语句将某个对象实例化(<span class="math inline">\(instantiate\)</span>)后，<span class="math inline">\(Java\)</span>会先<strong>给这个类(<span class="math inline">\(class\)</span>)的每个实例变量分配一个盒子</strong>，然后<strong>在盒子里面装一个默认值</strong>。</p>
<p>  例如，当我们的<span class="math inline">\(Warlus\)</span>类如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Walrus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> tuskSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Walrus</span><span class="params">(<span class="type">int</span> w, <span class="type">double</span> ts)</span> &#123;</span><br><span class="line">          weight = w;</span><br><span class="line">          tuskSize = ts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  并且我们创造了一个实例<code>new Walrus(1000,8.3)</code>，那么我们就会得到下面这两个独立的盒子：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-3.png"></p>
<h4><span id="b引用类型变量的声明">  <span class="math inline">\(b.\)</span>引用类型变量的声明</span></h4>
<p>  我们上面所举的例子是匿名的实例，它没有被存储到一个变量中。</p>
<p>  当我们声明任何一个引用类型的变量时，<span class="math inline">\(Java\)</span><strong>会给这个变量分配一个<span class="math inline">\(64\)</span>比特的盒子，不管这个对象是什么类型的</strong>。这是因为：这个<span class="math inline">\(64\)</span>比特的盒子并不是装这个对象(例如<span class="math inline">\(Walrus\)</span>)的具体数据的，而是装<strong>这个对象在内存中的地址</strong>。</p>
<p>  例如，当我们如下调用变量时： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Walrus someWalrus;</span><br><span class="line">someWalrus = new Walrus(1000, 8.3);</span><br></pre></td></tr></table></figure></p>
<p>  我们假设<span class="math inline">\(Walrus\)</span>的<code>weight</code>存储在开始于<code>5051956592385990207</code>的比特里，而<code>tuskSize</code>存储在开始于<code>5051956592385990239</code>的比特里，我们会<strong>把<code>5051956592385990207</code>存储在<span class="math inline">\(Walrus\)</span>变量中</strong>：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-4.png"></p>
<p>  我们也可以对引用变量赋予特殊值<code>null</code>：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-5.png"></p>
<p>  这样表示引用变量的比特较为复杂，因此我们引入箭头标记：</p>
<ul>
<li>如果一个地址全部为空，就用<code>null</code>来表示。</li>
<li><strong>如果一个地址非空，就用箭头指向它所代指的对象实例</strong>。</li>
</ul>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-6.png"></p>
<p>  回到下面这个问题： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;</span><br><span class="line">b = a;</span><br><span class="line">b.weight = <span class="number">5</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure></p>
<p>  执行完下面的语句后，可以得到下面的标记： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;</span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-7.png"></p>
<h3><span id="5参数传递">5.参数传递</span></h3>
<p>  当我们给一个函数传递参数时，我们也只是<strong>将参数的比特复制过去</strong>。<span class="math inline">\(GRoE\)</span>原则同样适用于参数的传递。比特复制也被称作传递数值(<span class="math inline">\(passing\;by\;value\)</span>)。在<span class="math inline">\(Java\)</span>中，我们经常使用这种做法。</p>
<p>  注意到，<strong>对于基本类型变量，比特表示的是它们的数值而非地址</strong>；而<strong>对于引用类型的变量，比特表示的是它们的地址</strong>，因此<strong>函数对两者的作用并不相同</strong>。</p>
<p>  考虑下面这个例子： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassByValueFigure</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="type">Walrus</span> <span class="variable">walrus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">3500</span>, <span class="number">10.5</span>);</span><br><span class="line">           <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">           doStuff(walrus, x);</span><br><span class="line">           System.out.println(walrus);</span><br><span class="line">           System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doStuff</span><span class="params">(Walrus W, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">           W.weight = W.weight - <span class="number">100</span>;</span><br><span class="line">           x = x - <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   该例子对应的标记图如下：</p>
<p><img src="/2024/05/31/2.1.Mystery%20of%20the%20Walrus/image-8.png"></p>
<p>  可以看到，<span class="math inline">\(doStuff\)</span>只对<span class="math inline">\(Walrus\)</span>的对象有作用，对<code>x</code>并无作用。</p>
<h3><span id="6数组的实例化">6.数组的实例化</span></h3>
<p>  像先前对引用变量的讲解，用于存储数组的变量也遵循相同的规则。例如下面这个整数数组的创建：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">95</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  这里的<code>new</code>关键词会创建<span class="math inline">\(5\)</span>个<span class="math inline">\(32\)</span>比特的盒子，并返回赋值给<code>x</code>的整个对象的地址。</p>
<p>  如果丢失了和对象的地址相关的比特，对象可能被遗失。例如如果上例的<code>x</code>是右侧数组唯一的备份(<span class="math inline">\(copy\)</span>)，那么<code>x=null</code>的赋值语句会导致原先数组的丢失。这并非坏事，因为有时我们的确需要遗忘一些对象。</p>
<h3><span id="7整型链表intlist">7.整型链表(<span class="math inline">\(IntList\)</span>)</span></h3>
<h4><span id="a整型链表的构建">  <span class="math inline">\(a.\)</span>整型链表的构建</span></h4>
<p>  类似<span class="math inline">\(python\)</span>中的<span class="math inline">\(Linked\;list\)</span>，可以用递归的方式实现初步的整型链表：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> first;</span><br><span class="line">    <span class="keyword">public</span> IntList rest;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntList</span><span class="params">(<span class="type">int</span> f, IntList r)</span> &#123;</span><br><span class="line">        first = f;</span><br><span class="line">        rest = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这种形式的链表使用起来非常不方便、容易出错，之后我们将会通过在类中添加辅助方法(<span class="math inline">\(helper\;method\)</span>)的面向对象编程策略来优化它：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line">L.rest = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">10</span>, <span class="literal">null</span>);</span><br><span class="line">L.rest.rest = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">IntList</span> <span class="variable">L</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">15</span>, <span class="literal">null</span>);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">10</span>, L);</span><br><span class="line">L = <span class="keyword">new</span> <span class="title class_">IntList</span>(<span class="number">5</span>, L);</span><br></pre></td></tr></table></figure></p>
<h4><span id="bsize函数的递归与迭代实现">  <span class="math inline">\(b.\)</span><span class="math inline">\(Size\)</span>函数的递归与迭代实现</span></h4>
<p>  整型链表的<span class="math inline">\(Size\)</span>函数的递归实现如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Return the size of the list using... recursion! */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">this</span>.rest.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这里有一个要点：为什么递归的基本条件不写<code>if(this == null)</code>呢？问题出在<code>L == null</code>这种特殊情况，我们不能对一个<code>null</code>对象使用实例方法。</p>
<p>  <span class="math inline">\(Size\)</span>函数的迭代实现如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Return the size of the list using no recursion! */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">iterativeSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">IntList</span> <span class="variable">p</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        totalSize += <span class="number">1</span>;</span><br><span class="line">        p = p.rest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  需要注意，在迭代时我们需要一个指针<code>p</code>，因为在<span class="math inline">\(java\)</span>中，我们不能重新分配(<span class="math inline">\(reassign\)</span>)<code>this</code>。</p>
<blockquote>
<p><code>this</code>refers to the current object. It's like saying: "I
am" or "my name is". You can't change who you are.</p>
</blockquote>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>2.List</category>
      </categories>
  </entry>
  <entry>
    <title>2.2.数据抽象</title>
    <url>/2024/05/31/2.2.%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<h1><span id="22数据抽象"><span class="math inline">\(2.2\)</span>数据抽象</span></h1>
<h3><span id="1数据抽象的概念">1.数据抽象的概念</span></h3>
<p>  将数据分开表示为如何表示数据的部分<span class="math inline">\(constructor\)</span>与如何操作数据的部分<span class="math inline">\(operator\)</span>的方法被称为<strong>数据抽象</strong>。</p>
<p>  数据抽象在概念上与函数抽象类似。当我们创建函数抽象时，函数实现的细节可以被抑制，特定函数本身可以被具有相同整体行为的任何其他函数替换。换句话说，我们可以<strong>制作一个抽象，将函数的使用方式与函数的实现细节分开</strong>。而数据抽象也将对<strong>复合数据的处理方式</strong>与<strong>对复合数据的构造方式</strong>分离开来。</p>
<p>  数据抽象的基本思想是组织程序，使它们能够在抽象的数据上运行。也就是说，我们的程序使用数据的方式应该尽可能少地对数据进行假设(即基本的操作步骤尽可能少)。同时将具体的数据表示定义为程序的一个独立部分。</p>
<p>  程序操作抽象数据的部分和定义数据表示的部分，由一小组函数连接起来，这些函数根据具体表示实现抽象数据。下举一例说明数据抽象流程的实现。</p>
<h3><span id="2实例讲解对有理数操作的实现">2.实例讲解——对有理数操作的实现：</span></h3>
<p>  有理数的定义是两个整数的和。由于计算机的浮点数计算会降低运算精度，我们通过分数实现有理数的表示与运算。</p>
<h4><span id="a通过假设实现operator">  <span class="math inline">\(a.\)</span>通过假设实现<span class="math inline">\(operator\)</span></span></h4>
<p>  通过先前的函数抽象，我们知道，在实现程序的某些部分之前，我们就可以有效地开始编程。让我们<strong>先假设我们已经有了一种方法，可以从分子和分母构造出一个有理数</strong>。我们还假设，<strong>给定一个有理数，我们有一种方法来选择它的分子和分母分量</strong>。我们<strong>进一步假设构造函数和选择函数可以作为以下三个函数使用:</strong></p>
<ul>
<li><code>ration(n,d)</code>：返回<span class="math inline">\(n\over
d\)</span>表示的有理数</li>
<li><code>numer(x)</code>：返回<span class="math inline">\(x\)</span>的分子</li>
<li><code>denom(x)</code>：返回<span class="math inline">\(x\)</span>的分母</li>
</ul>
<p>  在这里我们用到了程序设计的重要思想：<span class="math inline">\(wishful\;thinking\)</span>。我们并不知道这三个函数具体如何实现，但我们假设它们已经实现了，于是就可以通过假设实现加、减、乘、除等基本操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_rationals</span>(<span class="params">x, y</span>):</span><br><span class="line">    nx, dx = numer(x), denom(x)</span><br><span class="line">    ny, dy = numer(y), denom(y)</span><br><span class="line">    <span class="keyword">return</span> rational(nx * dy + ny * dx, dx * dy)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul_rationals</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> rational(numer(x) * numer(y), denom(x) * denom(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_rational</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(numer(x), <span class="string">&#x27;/&#x27;</span>, denom(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rationals_are_equal</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> numer(x) * denom(y) == numer(y) * denom(x)</span><br><span class="line"><span class="comment">#这是未约分后的，约分后结果除以gcd即可</span></span><br></pre></td></tr></table></figure>   现在我们实现了基于<span class="math inline">\(selector\)</span>变量与<span class="math inline">\(constructor\)</span>变量的<span class="math inline">\(operator\)</span>函数，剩下的任务就是具体实现我们的假设。</p>
<h4><span id="bselector与constructor的实现">  <span class="math inline">\(b.\)</span><span class="math inline">\(selector\)</span>与<span class="math inline">\(constructor\)</span>的实现</span></h4>
<p>  我们利用<span class="math inline">\(python\)</span>自带的<span class="math inline">\(list\)</span>功能实现<span class="math inline">\(pair\)</span>的构建： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rational</span>(<span class="params">n, d</span>):</span><br><span class="line">    <span class="keyword">return</span> [n, d]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numer</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">denom</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>  这样，利用我们的数据抽象与基本操作，可以实现有理数的大多数操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>half = rational(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(half)</span><br><span class="line"><span class="number">1</span> / <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>third = rational(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(mul_rationals(half, third))</span><br><span class="line"><span class="number">1</span> / <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_rational(add_rationals(third, third))</span><br><span class="line"><span class="number">6</span> / <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="3抽象屏障">3.抽象屏障</span></h3>
<p>  一般来说，数据抽象的基本思想是<strong>确定一组基本的操作，以此来表示对某种值的所有操作，然后只使用这些操作来操作数据</strong>。通过以这种方式限制操作的使用，更容易在不改变程序行为的情况下改变抽象数据的表示。对有理数的基本操作如下：</p>
<p><img src="/2024/05/31/2.2.%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/image.png"></p>
<p>  在上面的每一层中，<strong>最后一列中的函数强制执行抽象屏障</strong>。这些函数<strong>由较高级别调用，并使用较低抽象级别实现</strong>。</p>
<p>  例如，实现有理数的平方和应如下书写： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square_rational</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> mul_rational(x, x)</span><br></pre></td></tr></table></figure></p>
<p>  抽象屏障使程序更容易维护和修改。<strong>依赖于特定表示形式的函数越少，想要更改该表示形式时所需的更改就越少</strong>。按照如上方式定义的平方和函数，在维护和修改时只需要调整<span class="math inline">\(mul\)</span>函数即可。</p>
<h3><span id="4数据的属性">4.数据的属性</span></h3>
<p>  一般来说，我们可以使用一组选择器<span class="math inline">\(selector\)</span>和构造函数<span class="math inline">\(constructor\)</span>以及一些行为条件<span class="math inline">\(operator\)</span>来表示抽象数据。只要<strong>满足行为条件</strong>(如上面的除法属性)
，<strong>选择器和构造器就构成了一种数据的有效表示</strong>。抽象屏障之下的实现细节可能会改变，但<strong>如果行为没有改变，那么抽象化仍然有效</strong>，并且使用这个抽象化编写的任何程序都将保持正确。</p>
<p>  例如上述对有理数的操作，我们并没有说明什么是<span class="math inline">\(pair\)</span>，只是说该数据提供了用两个元素创建和操作列表的方法。我们需要实现一对的行为是将两个值粘合在一起，并且能够分别调用两值中的任意一个。我们也可以用如下函数实现这个操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pair</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a function that represents a pair.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">index</span>):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> y</span><br><span class="line">        <span class="keyword">return</span> get</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">p, i</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the element at index i of pair p.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> p(i)</span><br><span class="line"></span><br><span class="line">p = pair(<span class="number">20</span>, <span class="number">14</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select(p, <span class="number">0</span>)</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>  由此可以看出，我们对数据的抽象化有很多种表示方式，我们可以在多种表达方式中自由切换。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>2.3.双链表</title>
    <url>/2024/05/31/2.3.DLLists/</url>
    <content><![CDATA[<h1><span id="23双链表"><span class="math inline">\(2.3\)</span>双链表</span></h1>
<h3><span id="1对addlast的优化">1.对<code>addLast</code>的优化</span></h3>
<p>  让我们回顾一下<span class="math inline">\(SLList\)</span>的<code>addList</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    <span class="type">IntNode</span> <span class="variable">p</span> <span class="operator">=</span> sentinel;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这个方法的问题在于速度太慢。对此，我们可以像处理<span class="math inline">\(size\)</span>一样，在链表中多存储一个关键信息<span class="math inline">\(last\)</span>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> IntNode last;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        last = last.next;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  但这样会让<code>deleteLast</code>的操作变得困难，因为要删除<span class="math inline">\(last\)</span>，必须知道<span class="math inline">\(last\)</span>前面的元素。如果我们再缓存<span class="math inline">\(secondlast\)</span>，就相应地需要缓存<span class="math inline">\(thirdlast\)</span>...这说明缓存并不能解决问题，这引出了我们下面的解决方案：</p>
<h3><span id="2指向前面元素的指针">2.指向前面元素的指针</span></h3>
<p>  上面问题的解决方案就是给<span class="math inline">\(IntNode\)</span>添加一个指向前面元素的指针：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IntNode prev;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  通过这种操作，我们的链表就与前后两个节点都产生了链接。这种链表被称为双链表(<span class="math inline">\(double\;linked\;list\)</span>)。下面的图示显示了双链表的具体构建：</p>
<p><img src="/2024/05/31/2.3.DLLists/image-11.png"></p>
<h3><span id="3哨兵节点的改进">3.哨兵节点的改进</span></h3>
<p>  向后的指针有时会指向哨兵节点，有时会指向真实节点，在特殊情况下，这会导致原先代码的错误。对此，我们有两种解决办法：</p>
<ol type="1">
<li>在前后各设置一个哨兵节点：</li>
</ol>
<p><img src="/2024/05/31/2.3.DLLists/image-12.png"></p>
<ol start="2" type="1">
<li>将链表变为循环链表：</li>
</ol>
<p><img src="/2024/05/31/2.3.DLLists/image-13.png"></p>
<h3><span id="4通用型链表">4.通用型链表</span></h3>
<p>  有时，链表中的元素不止是<span class="math inline">\(int\)</span>型，还可能是其他类型。我们可以用以下语句声明能表示任何引用类型的数据结构：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*create a class able to contain any type*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLList</span>&lt;T&gt; () &#123;</span><br><span class="line">    <span class="comment">//create an item able to carry any type</span></span><br><span class="line">    <span class="keyword">public</span> T item;</span><br><span class="line">    <span class="comment">//create an array able to carry any type</span></span><br><span class="line">    <span class="keyword">public</span> T[] arr = (T[])<span class="keyword">new</span> <span class="title class_">Object</span>[capacity]; </span><br><span class="line">    <span class="comment">//print this type of item</span></span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>2.List</category>
      </categories>
  </entry>
  <entry>
    <title>2.4.可变数据</title>
    <url>/2024/05/31/2.4.%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1><span id="24可变数据"><span class="math inline">\(2.4\)</span>可变数据</span></h1>
<p>  在模块化程序设计中的一个重要技术是<strong>合并随时间变化的数据</strong>，这样，合并后的数据就可以表示一个独立的对象、不被程序的其他部分限制。<strong>将状态加入数据中</strong>是“面向对象编程”的核心要素。</p>
<h2><span id="一-对象objection及其相关概念">一、对象(<span class="math inline">\(objection\)</span>)及其相关概念</span></h2>
<p>  对象包含<strong>数据的值(<span class="math inline">\(value\)</span>)与数据行为(<span class="math inline">\(behaviour\)</span>)</strong>。</p>
<p>  以<span class="math inline">\(python\)</span>库中的<code>date</code>为例：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br></pre></td></tr></table></figure>
  在这里，<code>date</code>函数与<code>class</code>被绑定在一起。<code>class</code>是一类数值的总称，单独的<code>date</code>是<code>class</code>中的一个例子。</p>
<p>  我们可以如下对<code>date</code>赋值与对<code>date</code>进行运算，像普通数据一样：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues = date(<span class="number">2014</span>, <span class="number">5</span>, <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(date(<span class="number">2014</span>, <span class="number">5</span>, <span class="number">19</span>) - tues)</span><br><span class="line"><span class="number">6</span> days, <span class="number">0</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure></p>
<p>  同时，对象具有<strong>属性</strong>(attribute)，属性即是<strong>对象不同部分的数值</strong>。可以通过如下方式访问其属性：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;expression&gt;.&lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues.year</span><br><span class="line"><span class="number">2014</span></span><br></pre></td></tr></table></figure></p>
<p>  对象还具有<strong>方法</strong>(method)，方法就是<strong>一个内置的函数</strong>，当调用方法时，<strong>对象会自己执行、输出对应的结果</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues.strftime(<span class="string">&#x27;%A, %B %d&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Tuesday, May 13&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>  不仅<code>data</code>，<span class="math inline">\(python\)</span>中的其他值(如<code>string,numbers...</code>)都是对象，因为他们都有<strong>属性和对应的行为</strong>。</p>
<h2><span id="三-序列对象">三、序列对象</span></h2>
<h3><span id="1可改变对象">1.可改变对象</span></h3>
<h4><span id="a概念与性质">  <span class="math inline">\(a.\)</span>概念与性质</span></h4>
<p>  <strong>可改变对象</strong>(<span class="math inline">\(mutable\;objects\)</span>)用于<strong>表示随时间变化的量</strong>。例如，我们可以改变<span class="math inline">\(list\)</span>内的内容，利用<span class="math inline">\(list\)</span>自带的方法。而<span class="math inline">\(number\)</span>是不可改变对象。</p>
<p>  下面这个例子展示了<span class="math inline">\(list\)</span>的可改变性： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chinese = [<span class="string">&#x27;coin&#x27;</span>, <span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;myriad&#x27;</span>]</span><br><span class="line">suits = chinese</span><br><span class="line">suits.pop()</span><br><span class="line">suits.remove(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">suits.append(<span class="string">&#x27;cup&#x27;</span>)</span><br><span class="line">suits.extend([<span class="string">&#x27;sword&#x27;</span>, <span class="string">&#x27;club&#x27;</span>])</span><br><span class="line">suits[<span class="number">2</span>] = <span class="string">&#x27;spade&#x27;</span></span><br><span class="line">suits[<span class="number">0</span>:<span class="number">2</span>] = [<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese  <span class="comment"># This name co-refers with &quot;suits&quot; to the same changing list</span></span><br><span class="line">[<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>]</span><br></pre></td></tr></table></figure>
  由于我们一直在改变一个<span class="math inline">\(list\)</span>而非创造一个新<span class="math inline">\(list\)</span>，与原<span class="math inline">\(list\)</span>绑定的<code>chinese</code>也随之改变，因为<strong>它们是同一个对象</strong>。因此，<strong>对于可改变对象，对某个名字(<span class="math inline">\(name\)</span>)使用的方法不改变另一个名字的值，当且仅当它们不共享同一个对象</strong>。</p>
<blockquote>
<p>  <span class="math inline">\(p.s.\)</span>这里的“共享”<strong>并不仅仅是相同</strong>，当一个变量的某一部分用可改变对象赋值时，改变可改变对象也会导致这一变量改变：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nest = <span class="built_in">list</span>(suits)  <span class="comment"># Bind &quot;nest&quot; to a second list with the same elements</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nest[<span class="number">0</span>] = suits     <span class="comment"># Create a nested list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits.insert(<span class="number">2</span>, <span class="string">&#x27;Joker&#x27;</span>)  <span class="comment"># Insert an element at index 2, shifting the rest</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nest</span><br><span class="line">[[<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;Joker&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>], <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>  需要注意，<strong>经过序列解析后得到的新序列不与先前序列共享一个对象</strong>。</p>
<h4><span id="bis运算">  <span class="math inline">\(b.\)</span><span class="math inline">\(is\)</span>运算</span></h4>
<p>  由上述论证，我们定义表达式<span class="math inline">\(is\)</span>为<strong>两个名字是否同属一个对象</strong>，如下例：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">suits = [<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>]</span><br><span class="line">nest = <span class="built_in">list</span>(suits)</span><br><span class="line">nest[<span class="number">0</span>] = suits</span><br><span class="line">suits.insert(<span class="number">2</span>, <span class="string">&#x27;Joker&#x27;</span>)</span><br><span class="line">joke = nest[<span class="number">0</span>].pop(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits <span class="keyword">is</span> nest[<span class="number">0</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits <span class="keyword">is</span> [<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>]</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suits == [<span class="string">&#x27;heart&#x27;</span>, <span class="string">&#x27;diamond&#x27;</span>, <span class="string">&#x27;spade&#x27;</span>, <span class="string">&#x27;club&#x27;</span>]</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>   此处的<span class="math inline">\(list\)</span>是新创建的<span class="math inline">\(list\)</span>,因此是新的对象。</p>
<h3><span id="2元组与字典">2.元组与字典</span></h3>
<h4><span id="a元组tuple">  <span class="math inline">\(a.\)</span>元组(<span class="math inline">\(Tuple\)</span>)</span></h4>
<p>  下面的几种序列形式都属于元组： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>, <span class="number">2</span> + <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&quot;the&quot;</span>, <span class="number">1</span>, (<span class="string">&quot;and&quot;</span>, <span class="string">&quot;only&quot;</span>))</span><br><span class="line">(<span class="string">&#x27;the&#x27;</span>, <span class="number">1</span>, (<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;only&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>( (<span class="number">10</span>, <span class="number">20</span>) )</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>  元组的查询操作如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>code = (<span class="string">&quot;up&quot;</span>, <span class="string">&quot;up&quot;</span>, <span class="string">&quot;down&quot;</span>, <span class="string">&quot;down&quot;</span>) + (<span class="string">&quot;left&quot;</span>, <span class="string">&quot;right&quot;</span>) * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(code)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code[<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;down&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code.count(<span class="string">&quot;down&quot;</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code.index(<span class="string">&quot;left&quot;</span>)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
  由于<strong>元组是不可改变对象，因此<span class="math inline">\(list\)</span>诸如<code>pop,insert</code>等方法对元组都不适用</strong>。</p>
<p>  虽然元组是不可改变对象，但当调用元组内部的可改变对象时，它依然是可改变的：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nest = (<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line">nest[<span class="number">2</span>].pop()</span><br></pre></td></tr></table></figure></p>
<h4><span id="b字典dictionary">  <span class="math inline">\(b.\)</span>字典(<span class="math inline">\(dictionary\)</span>)</span></h4>
<p>  字典是一个<strong>储存键值对的容器</strong>。字典的作用是<strong>提供一种抽象，用于存储和检索那些不是通过连续整数而是通过描述性键进行索引的值</strong>。</p>
<p>  下面的几种序列形式都是字典： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numerals = &#123;<span class="string">&#x27;I&#x27;</span>: <span class="number">1.0</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>  字典的查询等操作如下，由于字典是可改变对象，可以对字典进行插入、删改等操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numerals[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numerals[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numerals[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numerals</span><br><span class="line">&#123;<span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>   需要注意，字典内元素有如下性质：</p>
<ul>
<li>字典的键<strong>不能是或包含可变的值</strong>。</li>
<li>对于给定的键，<strong>最多只能有一个值</strong>。</li>
</ul>
<p>  字典中的元素都可通过可迭代的对象属性<code>keys</code>、<code>values</code>、<code>items</code>来访问，并可用<span class="math inline">\(sum\)</span>等函数进行数据合并：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(numerals.values())</span><br><span class="line"><span class="number">66</span></span><br></pre></td></tr></table></figure></p>
<p>  一系列键值对可以直接转化为字典类型： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="number">3</span>, <span class="number">9</span>), (<span class="number">4</span>, <span class="number">16</span>), (<span class="number">5</span>, <span class="number">25</span>)])</span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure>
  字典也有类似列表解析的操作： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2><span id="四-局部状态localstate">四、局部状态(<span class="math inline">\(local\;state\)</span>)</span></h2>
<h3><span id="1局部状态的概念">1.局部状态的概念</span></h3>
<p>  列表与字典等可改变对象具有的这种性质被称为<strong>局部状态</strong>：在程序的执行过程中，它们的一些特定的内容会发生改变。“状态”一词说明对象的状态会在包含它的过程中发生改变。</p>
<p>  函数也具有局部状态。我们假设一个函数<code>withdraw</code>来模拟从银行取钱的过程。假设我们的银行账户有<span class="math inline">\(100\)</span>元，我们希望通过引用<code>withdraw</code>得到下列序列：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>withdraw(<span class="number">25</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>withdraw(<span class="number">25</span>)</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>withdraw(<span class="number">60</span>)</span><br><span class="line"><span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>withdraw(<span class="number">15</span>)</span><br><span class="line"><span class="number">35</span></span><br></pre></td></tr></table></figure>
  表达式<code>withdraw</code>被调用两次，返回不同的结果，因此这个函数是非纯函数：引用该函数不仅返回一个值、还对函数本身有副作用。</p>
<p>  为了实现<code>withdraw</code>，它还需创建一个初始的银行账户，我们用高阶函数<code>make_withdraw</code>来实现这一功能，让<code>withdraw</code>作为返回的函数：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_withdraw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span>(amount&gt;balance):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Not enough&#x27;</span></span><br><span class="line">        balance=balance-amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd=make_withdraw(<span class="number">20</span>)</span><br><span class="line">wd(<span class="number">5</span>)</span><br><span class="line">wd(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>   对该函数的框架分析如下：</p>
<ul>
<li>第一个定义的函数将<code>make_withdraw</code>与全局框架绑定。</li>
<li>第二个定义的函数是局部定义的，将<code>withdraw</code>与局部框架绑定。</li>
<li>每次调用<code>wd</code>，都会<strong>创造出一个新的局部框架</strong>。</li>
</ul>
<p>  而对于<code>balance</code>,在执行<code>nonlocal</code>语句后，<strong>任何<code>balance</code>在左侧的赋值语句都不会将<code>balance</code>与当前框架绑定。相反地，它会去寻找<code>balance</code>已经被定义的框架，并把<code>balance</code>与该框架绑定。</strong>而当<code>balance</code>还没被赋过一个值，<code>nonlocal</code>语句便会报错。</p>
<p>  在先前对嵌套函数的学习中，我们知道一个局部定义的函数可以调用局部框架以外的变量，并不需要<code>nonlocal</code>语句。但<strong>只有<code>nonlocal</code>可以让局部函数改变名称绑定的框架</strong>。</p>
<h3><span id="2python的语言特性">2.<span class="math inline">\(python\)</span>的语言特性</span></h3>
<p>  上面说到的<code>nonlocal</code>语句是<span class="math inline">\(python\)</span>高阶函数与词法范围的特性。事实上，<code>nonlocal</code>语句经常是其它编程语言的默认行为。</p>
<p>  <span class="math inline">\(python\)</span>语句还有一个限制：<strong>在函数体内部，所有名字(<span class="math inline">\(name\)</span>)的实例必须处于同一框架</strong>。因此，在<span class="math inline">\(python\)</span>中，一个局部函数不能在非局部框架中查询一个名字的值、然后将其绑定到局部框架中，否则一个名字就属于两个不同的框架了。这个限制允许<span class="math inline">\(Python\)</span>在执行函数体之前预先计算包含每个名称的框架。</p>
<p>  下面这个例子说明了<span class="math inline">\(python\)</span>的这一特性： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_withdraw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">            balance = balance - amount</span><br><span class="line">            <span class="keyword">return</span> balance</span><br><span class="line">        <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd = make_withdraw(<span class="number">20</span>)</span><br><span class="line">wd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;UnboundLocalError: local variable <span class="string">&#x27;balance&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure></p>
<p>  在<code>withdraw</code>中，原本处于<code>make_withdraw</code>框架中的<code>balance</code>在局部框架中被赋值，违反了<span class="math inline">\(python\)</span>的限制。</p>
<h3><span id="3nonlocal的好处">3.<code>nonlocal</code>的好处</span></h3>
<p>  <code>nonlocal</code>语句是我们<strong>将程序视为相互交互而彼此独立的集合</strong>的重要步骤。</p>
<p>  特别地，<code>nonlocal</code>语句让我们<strong>能够维护那些属于某个函数的局部框架、但随着调用不断更新的状态。</strong>像上面的与<code>withdraw</code>联系的<code>balance</code>在对<code>withdraw</code>的多次调用中得到共享。但是，<strong>这个<code>balance</code>与<code>withdraw</code>的联系对函数的其它部分是不可访问的、仅对<code>wd</code>生效。</strong>当我们再次调用<code>make_withdraw</code>后，它会创建一个独立的框架，与一个跟新的<code>balance</code>的独特的联系。</p>
<p>  下面这个对原来例子的拓展很好地说明了这个问题： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_withdraw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">         <span class="keyword">nonlocal</span> balance</span><br><span class="line">         <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">        balance = balance - amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd = make_withdraw(<span class="number">20</span>)</span><br><span class="line">wd2 = make_withdraw(<span class="number">7</span>)</span><br><span class="line">wd2(<span class="number">6</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="number">1</span></span><br><span class="line">wd(<span class="number">8</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="number">12</span></span><br></pre></td></tr></table></figure>
  通过这个方式，<strong>每个<code>withdraw</code>的实例(<code>instance</code>)都维护了自己独有的<code>balance</code>值，并且这个值对其它函数而言是不可访问的。</strong>这样，我们就创建了一个完全独立的<span class="math inline">\(bank\;account\)</span>对象。</p>
<h3><span id="4关于相等same的思考">4.关于相等(<span class="math inline">\(same\)</span>)的思考</span></h3>
<p>  对于一个函数，以上面的<code>make_withdraw</code>为例，<code>wd</code>与<code>wd2</code>绑定的都是同一个函数<code>make_withdraw</code>，但是两者是否相等呢？由上述讨论知两者并不相等。但对于以下例子，两者就变成完全相等的了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_withdraw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">        balance = balance - amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd = make_withdraw(<span class="number">12</span>)</span><br><span class="line">wd2 = wd</span><br><span class="line">wd2(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="number">11</span></span><br><span class="line">wd(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>
  这时，<code>make_withdraw</code>的一个实例被两个不同的名字<code>wd</code>和<code>wd2</code>所表示，这是很不寻常的。而分析这个问题的关键在于<strong>只有调用函数才可以引入新的框架，并且赋值语句只会改变现有框架中的绑定关系</strong>。</p>
<p>  这引发了对“相等”的讨论。在先前对<code>rational number</code>的定义中，只要分子分母相等的数就是相等的；但如今，<code>rational number</code>又有了与其所在框架相关的属性——<code>identity</code>。而对于上面<span class="math inline">\(account\)</span>的例子，<code>wd2</code>与<code>wd</code>的值并不相同，但它们是同一个<span class="math inline">\(account\)</span>。这一差异让程序设计变得更为复杂。</p>
<h2><span id="五-对象的具体实现以列表与字典为例">五、对象的具体实现——以列表与字典为例</span></h2>
<h3><span id="1列表的实现">1.列表的实现</span></h3>
<p>  我们将用一个以链表作为局部状态的函数代表可变列表，先考虑下面这些基本的设计：</p>
<ul>
<li><strong>具有与框架相关的属性——<code>identity</code></strong>，像普通的可变列表一样。</li>
<li>不能用<code>None</code>表示空列表，因为两个不同的空列表不是相等的值，但<code>None is None</code>。而<code>empty</code>可以实现<code>identity</code>属性。</li>
</ul>
<p>  既然是用函数实现，那么应该用什么作为函数的参数呢？该问题的答案揭示了编程中的一般模式：</p>
<h4><span id="a分派函数dispatchfunction">  <span class="math inline">\(a.\)</span>分派函数(<span class="math inline">\(dispatch\;function\)</span>)</span></h4>
<p>  分派函数的<strong>第一个参数是<code>message</code>——一个字符串，用于指挥这个函数该调用哪个方法</strong>；其余参数是各个方法需要的参数。</p>
<p>  分派函数实际上是<strong>多个函数的集成体</strong>：<code>message</code>参数决定了函数的行为，其余参数则在这个行为中被调用:
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mutable_link</span>():</span><br><span class="line">    contents=empty</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">message,value=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> contents</span><br><span class="line">        <span class="keyword">if</span> messages==<span class="string">&#x27;len&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> len_link(contents)</span><br><span class="line">        <span class="keyword">elif</span> messages==<span class="string">&#x27;getitem&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> getitem_link(contents,value)</span><br><span class="line">        <span class="keyword">elif</span> messages==<span class="string">&#x27;push_first&#x27;</span>:</span><br><span class="line">            contents=link(value,contens)</span><br><span class="line">        <span class="keyword">elif</span> message==<span class="string">&#x27;pop_first&#x27;</span>:</span><br><span class="line">            f=first(contents)</span><br><span class="line">            contents=rest(contens)</span><br><span class="line">            <span class="keyword">return</span> f</span><br><span class="line">        <span class="keyword">elif</span> message==<span class="string">&#x27;str&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> join_link(contents,<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> dispatch</span><br></pre></td></tr></table></figure></p>
<p>  我们还可以创建一个将<span class="math inline">\(python\)</span>内置的序列数据类型表示为<code>mutable_list</code>类型的函数：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">to_mutable_link</span>(<span class="params">source</span>):</span><br><span class="line">    s=multible_link()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reverse(source):</span><br><span class="line">        s(<span class="string">&#x27;push_first&#x27;</span>,i)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = to_mutable_link(suits)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(s)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s(<span class="string">&#x27;str&#x27;</span>))</span><br><span class="line">heart, diamond, spade, club</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s(<span class="string">&#x27;pop_first&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;heart&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s(<span class="string">&#x27;str&#x27;</span>))</span><br><span class="line">diamond, spade, club</span><br></pre></td></tr></table></figure>
  这样，<code>mutable list</code>的封装就完成了。这种<strong>通过在一个函数内封装对某个数据值的所有操作的方法被称作信息传递原则(<span class="math inline">\(message\;passing\)</span>)。一个运用信息传递原则的函数会定义分派函数、并通过传递<code>message</code>来组织计算</strong>。</p>
<h3><span id="2字典的实现">2.字典的实现</span></h3>
<p>  利用上面的逻辑，我们也可以实现字典的封装： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dictionart</span>():</span><br><span class="line">    records=[]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getitem</span>(<span class="params">key</span>):</span><br><span class="line">        matches=[r <span class="keyword">for</span> r <span class="keyword">in</span> records <span class="keyword">if</span> r[<span class="number">0</span>]==key]:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span>(matches)==<span class="number">1</span>):</span><br><span class="line">            key,value=matches[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setitem</span>(<span class="params">key,value</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> records</span><br><span class="line">        non_matches=[r <span class="keyword">for</span> r <span class="keyword">in</span> records <span class="keyword">if</span> r[<span class="number">0</span>]!=key]</span><br><span class="line">        records=non_matches+[[key,value]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">message,key=<span class="literal">None</span>,value=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> message==<span class="string">&#x27;getitem&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> getitem(key)</span><br><span class="line">        <span class="keyword">elif</span> message==<span class="string">&#x27;setitem&#x27;</span>:</span><br><span class="line">            setitem(key,value)</span><br><span class="line">    <span class="keyword">return</span> dispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dictionary()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d(<span class="string">&#x27;setitem&#x27;</span>, <span class="number">3</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d(<span class="string">&#x27;setitem&#x27;</span>, <span class="number">4</span>, <span class="number">16</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d(<span class="string">&#x27;getitem&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d(<span class="string">&#x27;getitem&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<h2><span id="六-分派字典dispatchdictionary">六、分派字典(<span class="math inline">\(dispatch\;dictionary\)</span>)</span></h2>
<h3><span id="1分派字典的概念">1.分派字典的概念</span></h3>
<p>  分派函数是抽象数据传递接口的一种通用方法，而我们可以<strong>用字典这种数据类型来实现分派函数的分派功能</strong>。</p>
<h3><span id="2分派字典的实现">2.分派字典的实现</span></h3>
<p>  以先前的<span class="math inline">\(account\)</span>为例，我们创建一个可变数据类型<code>account</code>，它由<span class="math inline">\(constructor\)</span><code>account</code>与<span class="math inline">\(selector\)</span><code>check_balance</code>组成：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">account</span>(<span class="params">initial_balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">amount</span>):</span><br><span class="line">        dispatch[<span class="string">&#x27;balance&#x27;</span>]+=amount</span><br><span class="line">        <span class="keyword">return</span> dispatch[<span class="string">&#x27;balance&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        <span class="keyword">if</span> amount&gt;dispatch[<span class="string">&#x27;balance&#x27;</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">        dispatch[<span class="string">&#x27;balance&#x27;</span>]-=amount</span><br><span class="line">        <span class="keyword">return</span> dispatch[<span class="string">&#x27;balance&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    dispatch=&#123;<span class="string">&#x27;deposit&#x27;</span>:deposit,<span class="string">&#x27;withdraw&#x27;</span>:withdraw,<span class="string">&#x27;balance&#x27;</span>:initial_balance&#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">account,amount</span>):</span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">&#x27;withdraw&#x27;</span>](amount)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">account,amount</span>):</span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">&#x27;deposit&#x27;</span>](amount)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_balance</span>(<span class="params">account</span>):</span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">&#x27;balance&#x27;</span>]</span><br><span class="line"></span><br><span class="line">a=account(<span class="number">20</span>)</span><br><span class="line">deposit(a,<span class="number">5</span>)</span><br><span class="line">withdraw(a,<span class="number">17</span>)</span><br><span class="line">check_balance(a)</span><br><span class="line">&gt;&gt;&gt;<span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>  在这里，我们<strong>通过把<code>balance</code>存储在字典中而非直接存储在<code>account</code>框架里，避免了使用<code>nonlocal</code>语句</strong>。</p>
<h2><span id="七-约束传递propagatingconstraints">七、约束传递(<span class="math inline">\(propagating\;constraints\)</span>)</span></h2>
<h3><span id="1新的抽象系统基于约束的系统constraint-basedsystem">1.新的抽象系统——基于约束的系统(<span class="math inline">\(constraint-based\;system\)</span>)</span></h3>
<p>  可改变数据<strong>允许我们模拟随时改变的系统</strong>，同时也为我们提供了新的抽象方法。下面介绍利用<code>nonlocal</code>赋值、<span class="math inline">\(list\)</span>、字典搭建的基于约束器的系统。这是声明式编程(<span class="math inline">\(declarative\;programming\)</span>)的重要部分。</p>
<p>  在这个系统中，我们将<strong>程序表达为约束(<span class="math inline">\(constraint\)</span>)</strong>，确定待解决问题的结构，但将解决问题的细节进行抽象。</p>
<p>  这个系统的引入是基于计算机程序的特性——<strong>单向计算性</strong>(<span class="math inline">\(one-directional\;computations\)</span>)。在计算机程序中，我们将问题抽象为一个系统，模拟系统中各个数量的关系，在系统中传入给定的参数，然后计算出想要的答案。但很多事物，如下面的公式，并不是单向的：</p>
<p><span class="math display">\[pV=nRT\]</span></p>
<p>  在这个公式中，给出任意四个量，显然可以求出第五个量的值。但在计算机程序中，一个设计好用来求解<span class="math inline">\(p\)</span>的程序<strong>由于参数被固定了，并不能用于求解<span class="math inline">\(T\)</span>或其他量</strong>，即使我们已知其中四个量。</p>
<p>  于是我们构想一个模拟这种线性关系的模型。我们先定义<strong>一些初始的约束器</strong>，例如<strong>加法器</strong><code>adder(a,b,c)</code>，它强制(<span class="math inline">\(enforce\)</span>)了数学的加法关系<code>a+b=c</code>。</p>
<p>  我们再定义一种合并的方法，使得初始的约束器能被合并以表达更复杂的关系。我们<strong>构建一个网络(<span class="math inline">\(network\)</span>)，在这个网络中，约束器被连接器(<span class="math inline">\(connector\)</span>)连接在一起</strong>。连接器<strong>是一个连接一个或多个限制的对象，它自身会携带一个值</strong>。例如摄氏度与华氏度的换算<span class="math inline">\(9\times
c=5\times(f-32)\)</span>可表示为如下网络：</p>
<p><img src="/2024/05/31/2.4.%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE/image-3.png"></p>
<p>  基于这个网络的计算流程如下：</p>
<ul>
<li>当一个连接器被赋值，它<strong>会唤醒所有与它相连的约束器，告诉它们自己获得了一个值。</strong></li>
<li>每个约束器<strong>检测(<span class="math inline">\(poll\)</span>)自己的连接器，看自己是否有足够多的信息来决定连接器的值。</strong></li>
<li>如果<strong>能决定，约束器就重设连接器的值，然后连接器接着执行唤醒操作。</strong></li>
</ul>
<p>  对于温度换算的例子，该网络执行如下操作：</p>
<ul>
<li>先在<span class="math inline">\(w\)</span>、<span class="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>这些放常数的盒子(<span class="math inline">\(constant\;box\)</span>)里放入常数。</li>
<li>连接器唤醒加法器<code>adder</code>和乘法器<code>multiplier</code></li>
<li>由于<span class="math inline">\(celsius\)</span>的输入，最左侧乘法器将连接器<span class="math inline">\(u\)</span>的值重设，同时<span class="math inline">\(u\)</span>唤醒右侧的乘法器；最右侧同理。</li>
</ul>
<h3><span id="2约束系统的使用">2.约束系统的使用</span></h3>
<h4><span id="a连接器的创建与连接">  <span class="math inline">\(a.\)</span>连接器的创建与连接</span></h4>
<p>  为创建两个表示温度的连接器，我们调用<code>connector</code><span class="math inline">\(constructor\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;celsius=connector(<span class="string">&#x27;Celsius&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;fahrenheit=connector(<span class="string">&#x27;Fahrenheit&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>  然后我们把这些连接器组装到如上图的网络中。这里的<code>converter</code>函数用于组装该系统的诸多连接器与约束器：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">converter</span>(<span class="params">c,f</span>):</span><br><span class="line">    u,v,w,x,y=[connector()<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">    <span class="comment">#apply a new connector for each variables</span></span><br><span class="line">    multiplier(c,w,u)</span><br><span class="line">    multiplier(v,x,u)</span><br><span class="line">    adder(v,y,f)</span><br><span class="line">    constant(w,<span class="number">9</span>)</span><br><span class="line">    constant(x,<span class="number">5</span>)</span><br><span class="line">    constant(y,<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">converter(celsius,fahrenheit)</span><br></pre></td></tr></table></figure> ####   <span class="math inline">\(b.\)</span>连接器与限制器的协调
  我们用之前介绍的<span class="math inline">\(message\;passing\)</span>系统来协调连接器与约束器。这里，约束器是不持有局部状态的字典，它们对<code>message</code>的回应是会改变连接器值的非纯函数。</p>
<p>  而连接器是<strong>持有当前值、并回应接收到的<code>message</code>从而改变当前值的字典</strong>。约束器不会立即改变连接器的值，而是发送信息，这样连接器就可以根据收到的信息来唤醒其他约束器。通过这一流程，连接器不仅表示当前值、而且还封装了一系列行为。</p>
<p>  向连接器发送信号，以<code>set_val</code>为例，的方法如下：(这里的<code>user</code>是我们，发送信号的人)
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;celsius[<span class="string">&#x27;set_val&#x27;</span>](<span class="string">&#x27;user&#x27;</span>,<span class="number">25</span>)</span><br><span class="line">celsius=<span class="number">25</span></span><br><span class="line">fahrenheit=<span class="number">77.0</span></span><br></pre></td></tr></table></figure></p>
<p>  在<code>set_val</code>被执行后，不仅<span class="math inline">\(celsius\)</span>的值变成了<span class="math inline">\(25\)</span>，它的值通过网络传递导致了<span class="math inline">\(fahrenheit\)</span>的改变。这个改变被打印出来，因为<span class="math inline">\(constructor\)</span><code>converter</code>将两个名称绑定在同一网络里。</p>
<p>  那假如我们对其中一个名称输入一个与原结果相矛盾的值呢？
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fahrenheit[<span class="string">&#x27;set_val&#x27;</span>](<span class="string">&#x27;user&#x27;</span>, <span class="number">212</span>)</span><br><span class="line">Contradiction detected: <span class="number">77.0</span> vs <span class="number">212</span></span><br></pre></td></tr></table></figure></p>
<p>  此时连接器报错了：它的值是<span class="math inline">\(77.0\)</span>，但有人想把它变成<span class="math inline">\(212\)</span>。如果我们想让这个网络采纳这个新值，就要<strong>让<span class="math inline">\(celsius\)</span>忘记它的旧值</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>celsius[<span class="string">&#x27;forget&#x27;</span>](<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line">Celsius <span class="keyword">is</span> forgotten</span><br><span class="line">Fahrenheit <span class="keyword">is</span> forgotten</span><br></pre></td></tr></table></figure></p>
<p>  在接受到<code>forget</code>的指令后，<strong>不仅<span class="math inline">\(celsius\)</span>撤回了原先的值，该指令通过网络传递给<span class="math inline">\(fahrenheit\)</span>，<span class="math inline">\(fahrenheit\)</span>也忘记了原先的值</strong>。此时再对<span class="math inline">\(fahrenheit\)</span>进行赋值就可成立：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fahrenheit[<span class="string">&#x27;set_val&#x27;</span>](<span class="string">&#x27;user&#x27;</span>, <span class="number">212</span>)</span><br><span class="line">Fahrenheit=<span class="number">212</span></span><br><span class="line">Celsius=<span class="number">100.0</span></span><br></pre></td></tr></table></figure></p>
<p>  在这整个过程中体现出的系统的<strong>非方向性是约束系统的显著特征</strong>。</p>
<h3><span id="3约束系统的实现">3.约束系统的实现</span></h3>
<p>  我们想让连接器对如下<code>message</code>做出回应：</p>
<ul>
<li><code>connector['set_val'](source, value)</code>：为连接器赋值。</li>
<li><code>connector['has_val']()</code>：返回是否有值。</li>
<li><code>connector['val']</code>：输出连接器当前值。</li>
<li><code>connector['forget'](source)</code>：告诉连接器<code>source</code>让它忘记当前值。</li>
<li><code>connector['connect'](source)</code>：让连接器与<code>source</code>相连</li>
</ul>
<p>  约束器也是字典，它接受连接器传来的两种信息：</p>
<ul>
<li><code>constraint['new_val']()</code>：表明与约束器相连的某个连接器有一个新值。</li>
<li><code>constraint['forget']()</code>：表明与约束器相连的某个连接器忘记了它的值。</li>
</ul>
<p>  当约束器收到<code>message</code>后，会将它们传给其他的连接器。</p>
<p>  下面展示一般三元约束(<span class="math inline">\(generic\;ternary\)</span>)的实现。在三元约束系统中，我们用三个连接器和三个从加法器<code>adder</code>创建的函数来创建约束：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_tenery_constraint</span>(<span class="params">a,b,c,ab,ca,cb</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_value</span>():</span><br><span class="line">        av,bv,cv=[connector[<span class="string">&#x27;has_val&#x27;</span>]<span class="keyword">for</span> connector <span class="keyword">in</span> (a,b,c)]</span><br><span class="line">        <span class="keyword">if</span> av <span class="keyword">and</span> bv:</span><br><span class="line">            c[<span class="string">&#x27;set_val&#x27;</span>](constraint,ab(a[<span class="string">&#x27;val&#x27;</span>],b[<span class="string">&#x27;val&#x27;</span>]))</span><br><span class="line">        <span class="keyword">elif</span> bv <span class="keyword">and</span> cv:</span><br><span class="line">            a[<span class="string">&#x27;set_val&#x27;</span>](constraint,bc(b[<span class="string">&#x27;val&#x27;</span>],c[<span class="string">&#x27;val&#x27;</span>]))</span><br><span class="line">        <span class="keyword">elif</span> av <span class="keyword">and</span> cv:</span><br><span class="line">            b[<span class="string">&#x27;set_val&#x27;</span>](constraint,ac(a[<span class="string">&#x27;val&#x27;</span>],c[<span class="string">&#x27;val&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forget_value</span>():</span><br><span class="line">        <span class="keyword">for</span> connector <span class="keyword">in</span> (a,b,c):</span><br><span class="line">            connector[<span class="string">&#x27;forget&#x27;</span>](constraint)</span><br><span class="line">    </span><br><span class="line">    constraint=[<span class="string">&#x27;new_val&#x27;</span>:new_value,<span class="string">&#x27;forget&#x27;</span>:forget_value]</span><br><span class="line">    <span class="keyword">for</span> connector <span class="keyword">in</span>(a,b,c):</span><br><span class="line">        connectot[<span class="string">&#x27;connect&#x27;</span>](constraint)</span><br><span class="line">    <span class="keyword">return</span> constraint</span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(constraint\)</span>既是分派字典、又是<span class="math inline">\(constraint\)</span>对象本身，它负责回应连接器传来的信息。函数的实现逻辑如下：</p>
<ul>
<li><span class="math inline">\(constraint\)</span>的<code>new_value</code>局部函数在约束器被告知它的连通器获得了一个新值时会被调用。当其<strong>检测到两个值时，它就会告知对应连接器：把值设置成两个值约束后的值</strong>。</li>
<li>当约束器<strong>被告知它的连通器忘记了某个值时，它要求所有与它相连的连接器忘掉它们的值</strong>。</li>
</ul>
<p>  乘法器的实现与加法器类似： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul,truediv</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">muitiplier</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="keyword">return</span> make_tenery_constraint(a,b,c,mul,truediv,truediv)</span><br></pre></td></tr></table></figure></p>
<p>  常数也是一种约束器，但<strong>它不会发送任何信息，因为它只有一个刚创建时创建的连接器</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">constant</span>(<span class="params">connector,value</span>):</span><br><span class="line">    constraint=&#123;&#125;</span><br><span class="line">    connector[<span class="string">&#x27;set_val&#x27;</span>](constraint,value)</span><br><span class="line">    <span class="keyword">return</span> constraint</span><br></pre></td></tr></table></figure></p>
<h3><span id="4连接器的实现">4.连接器的实现</span></h3>
<p>  连接器是一个不仅包含自身值、还包含回应函数的字典。一个连接器需要跟踪给它赋予当前值的<code>informant</code>(<code>source</code>)与和它相连的<code>constraint</code>。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connector</span>(<span class="params">name=<span class="literal">None</span></span>):</span><br><span class="line">    informant=<span class="literal">None</span></span><br><span class="line">    constraint=[]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_value</span>(<span class="params">source,value</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> informant</span><br><span class="line">        val=connect[<span class="string">&#x27;val&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            informant,connector[<span class="string">&#x27;val&#x27;</span>]=source,value</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(name,<span class="string">&#x27;=&#x27;</span>,value)</span><br><span class="line">            inform_all_except(source,<span class="string">&#x27;new_val&#x27;</span>,constraints)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> val!=value:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Contradiction detected:&#x27;</span>,val,<span class="string">&#x27;vs&#x27;</span>,value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forger_value</span>(<span class="params">source</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> informant</span><br><span class="line">        <span class="keyword">if</span> informant==source:</span><br><span class="line">            informant,connector[<span class="string">&#x27;val&#x27;</span>]=<span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(name,<span class="string">&#x27;is forgotten&#x27;</span>)</span><br><span class="line">            inform_all_except(source,<span class="string">&#x27;forget&#x27;</span>,constraints)</span><br><span class="line"></span><br><span class="line">    connector=&#123;<span class="string">&#x27;val&#x27;</span>:<span class="literal">None</span>,</span><br><span class="line">               <span class="string">&#x27;set_val&#x27;</span>:set_value,</span><br><span class="line">               <span class="string">&#x27;forget&#x27;</span>:forget_value,</span><br><span class="line">               <span class="string">&#x27;has_val&#x27;</span>:<span class="keyword">lambda</span>:connector[<span class="string">&#x27;val&#x27;</span>]<span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>,</span><br><span class="line">               <span class="string">&#x27;connect&#x27;</span>:<span class="keyword">lambda</span> source:constraints.append(source)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> connector</span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(connector\)</span>同样既是分派字典又是<span class="math inline">\(connector\)</span>对象本身，字典的其中四项代表方法函数，最后一项返回<span class="math inline">\(connector\)</span>的值。函数的实现逻辑如下：</p>
<ul>
<li>当<strong>收到设置连接器当前值的请求</strong>时，<code>set_value</code>被调用。</li>
<li>当此时的连接器没有值时，它<strong>会设置一个值，并将请求设置值的源约束器<code>source</code>作为<code>informant</code></strong>。然后连接器就会<strong>告知除源约束器外的所有与它相连的约束器</strong>。</li>
<li>当连接器被告知要忘记当前值时，它<strong>调用<code>forget_value</code>，接着告知除源约束器外的所有与它相连的约束器</strong>。</li>
</ul>
<p>  告知函数可如下实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inform_all_except</span>(<span class="params">source,message,constraints</span>):</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> constraints:</span><br><span class="line">        <span class="keyword">if</span> c!=source:</span><br><span class="line">            c[message]()</span><br></pre></td></tr></table></figure></p>
<h3><span id="5约束系统的性质">5.约束系统的性质</span></h3>
<p>  约束系统中的约束器与连接器都是<strong>通过传递<code>message</code>来操作的对象</strong>。当某个连接器的值被改变时，传递的<code>message</code><strong>不仅改变了连接器的值，还确认了值的正确性、将值的效果传递给其他对象</strong>。这使得程序更为完善</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>2.3.序列</title>
    <url>/2024/05/31/2.3.%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1><span id="23序列"><span class="math inline">\(2.3.\)</span>序列</span></h1>
<h3><span id="1序列的概念">1.序列的概念</span></h3>
<p>  序列是一系列<strong>有序</strong>的值的<strong>集合</strong>。序列有很多种不同的表示形式，但它们都有以下共同的性质：</p>
<ul>
<li><strong>长度</strong>：序列都有有限的长度</li>
<li><strong>元素选择</strong>。序列的任意元素<strong>有一个小于其长度的索引元素</strong>，对于第一个元素从<span class="math inline">\(0\)</span>开始。</li>
</ul>
<h2><span id="二-序列基础">二、序列基础</span></h2>
<h3><span id="1lists的概念及操作">1.<span class="math inline">\(Lists\)</span>的概念及操作</span></h3>
<p>  <span class="math inline">\(list\)</span>是一个<strong>可以具有任意长度</strong>的序列。<span class="math inline">\(list\)</span>具有大量的内置行为，以及表示这些行为的特定语法。如下是几个<span class="math inline">\(list\)</span>的例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">digits=[<span class="number">1</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(digits)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits[<span class="number">3</span>]</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>   初始化<span class="math inline">\(list\)</span>、构造一个空<span class="math inline">\(list\)</span>的步骤如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = [[] <span class="keyword">for</span> i <span class="keyword">in</span> player_indices]<span class="comment">#初始化为空列表</span></span><br><span class="line">result = [[<span class="number">0</span> <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(n)-<span class="number">1</span>)] <span class="keyword">for</span> n <span class="keyword">in</span> times_per_player]<span class="comment">#初始化为0</span></span><br></pre></td></tr></table></figure>
  对于<span class="math inline">\(list\)</span>，加法和乘法与数学运算中不同，而是<strong>组合和复制序列本身</strong>。也就是说，运算符模块(和<code>+</code>运算符)中的<code>add</code>函数生成一个列表，该列表是所添加参数的串联。运算符中的<code>mul</code>函数(以及<code>*</code>运算符)可以获取一个列表和一个整数<span class="math inline">\(k\)</span>，以返回由原始列表的<span class="math inline">\(k\)</span>重复组成的列表。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>,<span class="number">7</span>] + digits * <span class="number">2</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
  同时，也可以在<span class="math inline">\(list\)</span>中嵌套<span class="math inline">\(list\)</span>，嵌套与访问的方式如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pairs=[[<span class="number">10</span>,<span class="number">20</span>],[<span class="number">30</span>,<span class="number">40</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs[<span class="number">1</span>]</span><br><span class="line">[<span class="number">30</span>,<span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="2序列迭代">2.序列迭代</span></h3>
<p>  在许多情况下，我们希望<strong>对序列的元素进行迭代，并依次为每个元素执行一些计算</strong>。</p>
<h4><span id="afor语句">  <span class="math inline">\(a.\)</span><span class="math inline">\(for\)</span>语句</span></h4>
<p>  <span class="math inline">\(for\)</span>语句的声明如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(for\)</span>语句的执行过程如下：</p>
<ol type="1">
<li><p>计算<span class="math inline">\(expression\)</span>，<span class="math inline">\(expression\)</span>必须产生一个可迭代的值。</p></li>
<li><p>对于可迭代值的每一个元素值执行：</p>
<ol type="1">
<li>将<code>&lt;name&gt;</code>绑定到当前框架中的值。</li>
<li>执行<code>&lt;suite&gt;</code>。</li>
</ol></li>
</ol>
<h4><span id="brange语句">  <span class="math inline">\(b.\)</span><span class="math inline">\(range\)</span>语句</span></h4>
<p>  <span class="math inline">\(range\)</span>的声明如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>) <span class="comment"># Includes 1, but not 10</span></span><br></pre></td></tr></table></figure>   在<span class="math inline">\(list\)</span>中调用<span class="math inline">\(range\)</span>可返回<span class="math inline">\(range\)</span>范围内的<span class="math inline">\(list\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>,<span class="number">8</span>))</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>   如果<span class="math inline">\(range\)</span>函数只传了一个参数，那么就返回从<span class="math inline">\(0\)</span>到<span class="math inline">\(i-1\)</span>间的序列： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>   <span class="math inline">\(range\)</span>经常与<span class="math inline">\(for\)</span>结合，以达到迭代<span class="math inline">\(list\)</span>的一部分的目的。这里有一种特殊情况：当<code>&lt;name&gt;='_'</code>时，整个序列会被重复<span class="math inline">\(i\)</span>次： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Go Bears!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br></pre></td></tr></table></figure></p>
<h4><span id="c序列解包">  <span class="math inline">\(c.\)</span>序列解包</span></h4>
<p>  当某个<span class="math inline">\(list\)</span>的内部仍然为<span class="math inline">\(list\)</span>，但内部的<span class="math inline">\(list\)</span>长度固定时，我们可以在调用<span class="math inline">\(for\)</span>循环时使用多个<code>&lt;name&gt;</code>，以打开内部的<span class="math inline">\(list\)</span>，读取其中元素。下举一例：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs=[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> pairs:</span><br><span class="line">    <span class="keyword">if</span>(x==y):</span><br><span class="line">        same_count+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>same_count</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>  这一操作与我们在将多个名称绑定到多个值的赋值语句中看到的模式相同。</p>
<h2><span id="三-对序列的基本处理">三、对序列的基本处理</span></h2>
<h3><span id="1列表解析listcomprehension">1.列表解析<span class="math inline">\(List\;Comprehension\)</span></span></h3>
<p>  有时我们要对序列中的所有元素执行一个统一的操作，并输出处理后的序列。这时我们可以用<strong>列表解析</strong>的方法：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#改变列表元素的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odds=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x+<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> odds]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将列表元素归到其他结构里面</span></span><br><span class="line">&gt;&gt;&gt;s=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;t=[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[[s[i]+t[i]]<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">&gt;&gt;&gt;[[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>   这里的<span class="math inline">\(for\)</span>并不是<span class="math inline">\(for\)</span>语句的一部分，而是列表解析的一部分。</p>
<p>  同时，我们也可以<strong>只解析序列符合要求的部分</strong>，即原序列的<strong>子集</strong>，下举一例：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> odds <span class="keyword">if</span> <span class="number">25</span> % x == <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure></p>
<p>  列表解析的一般形式为： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&lt;<span class="built_in">map</span> expression&gt; <span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;sequence expression&gt; <span class="keyword">if</span> &lt;<span class="built_in">filter</span> expression&gt;]</span><br></pre></td></tr></table></figure>
  当要表达不同分支时，可如下书写列表解析： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&lt;<span class="built_in">map</span> expression&gt; <span class="keyword">if</span> &lt;expression&gt; <span class="keyword">else</span> &lt;<span class="built_in">map</span> expression&gt; <span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;seq&gt;]</span><br></pre></td></tr></table></figure></p>
<h3><span id="2数据合并">2.数据合并</span></h3>
<p>  数据合并，顾名思义，就是<strong>将序列中的所有数据最终合并成一个数据</strong>。常见的<span class="math inline">\(min\)</span>、<span class="math inline">\(max\)</span>、<span class="math inline">\(sum\)</span>函数都属于数据合并。</p>
<h3><span id="3利用高阶函数抽象序列基本操作">3.利用高阶函数抽象序列基本操作</span></h3>
<p>  上述序列操作可通过高阶函数、以函数为参数的手段来抽象出更普适的模式：</p>
<ul>
<li><p>对序列全体元素的映射： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_to_all</span>(<span class="params">map_f,s</span>):</span><br><span class="line">    <span class="keyword">return</span> [map_f(i) <span class="keyword">for</span> i <span class="keyword">in</span> s]</span><br></pre></td></tr></table></figure></p></li>
<li><p>筛选元素： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">keep_if</span>(<span class="params">filter_f,s</span>):</span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> s <span class="keyword">if</span> filter_f(i)]</span><br></pre></td></tr></table></figure></p></li>
<li><p>数据合并： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reduce</span>(<span class="params">reduce_f,s,init</span>):</span><br><span class="line">    reduced=init</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        reduced=reduce_f(reduced,i)</span><br><span class="line">    <span class="keyword">return</span> reduced</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3><span id="4序列基本处理的应用">4.序列基本处理的应用</span></h3>
<p>  通过使用上述序列基本处理手段，我们可以利用序列处理很多问题。</p>
<p>  <span class="math inline">\(e.g.\)</span>求出<span class="math inline">\(1\sim 1000\)</span>内的所有完全数。</p>
<p>  <span class="math inline">\(solve\)</span>：先利用列表解析写出求某个数因数的函数：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>]+[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n) <span class="keyword">if</span> n%i==<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divisors(<span class="number">12</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>   求出所有因数后，我们将所有因数合并为<span class="math inline">\(sum\)</span>，继续利用列表解析筛选：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">perfect</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>]+[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1000</span>) <span class="keyword">if</span> <span class="built_in">sum</span>(div(i))==i]</span><br><span class="line">&gt;&gt;&gt;[<span class="number">6</span>, <span class="number">28</span>, <span class="number">496</span>]</span><br></pre></td></tr></table></figure></p>
<p>  同时我们的<span class="math inline">\(div\)</span>函数可以复用以解决以下问题：</p>
<p>  <span class="math inline">\(e.g.\)</span>给定矩形面积，求矩形的最小周长。</p>
<p>  <span class="math inline">\(solve\)</span>：矩形的边长只可能是<span class="math inline">\(div(area)\)</span>中的某个数，于是可写出如下程序：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">width</span>(<span class="params">area,hei</span>):</span><br><span class="line">    <span class="keyword">assert</span> area%hei==<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> area//hei</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perimeter</span>(<span class="params">hei,width</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*hei+<span class="number">2</span>*width</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">min_per</span>(<span class="params">area</span>):</span><br><span class="line">    hei=div(area):</span><br><span class="line">    per=[perimeter(h,width(area,h)) <span class="keyword">for</span> h <span class="keyword">in</span> hei]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(per)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>area=<span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>width(area,<span class="number">5</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>perimeter(<span class="number">10</span>, <span class="number">8</span>)</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min_per(area)</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[minimum_perimeter(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">12</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure></p>
<p>  这些操作并不是一定需要序列来实现，但是序列上述基本操作的存在极大地降低了实现的难度。<strong>将问题序列化</strong>不失为一种解题策略。</p>
<h2><span id="四-序列抽象">四、序列抽象</span></h2>
<p>  序列抽象分为以下部分(前两点前文已提及)：</p>
<h3><span id="1序列长度">1.序列长度</span></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(digits)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3><span id="2序列选择">2.序列选择</span></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits[<span class="number">3</span>]</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3><span id="3判断是否为序列成员">3.判断是否为序列成员</span></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="keyword">in</span> digits</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1828</span> <span class="keyword">not</span> <span class="keyword">in</span> digits</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3><span id="4剪切序列片段">4.剪切序列片段</span></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits[<span class="number">1</span>:]</span><br><span class="line">[<span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<h2><span id="五-string">五、<span class="math inline">\(string\)</span></span></h2>
<h2><span id="六-trees">六、<span class="math inline">\(Trees\)</span></span></h2>
<h3><span id="1引入闭包性质">1.引入——闭包性质</span></h3>
<p>  在<span class="math inline">\(list\)</span>中，我们可以使用<span class="math inline">\(list\)</span>作为<span class="math inline">\(list\)</span>的元素，这种数据的组合方式被称为<strong>数据的闭包性质</strong>。</p>
<p>  在任何组合方式中，闭包性质都是组合的关键，因为<strong>它允许我们创造一种组合方式的等级结构</strong>——一种组合由与它相同的子组合构成，而子组合又由更小的子组合构成...如下即为<span class="math inline">\(list\)</span>的等级结构示意图： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">one_two = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    nested = [[<span class="number">1</span>, <span class="number">2</span>], [],</span><br><span class="line">    [[<span class="number">3</span>, <span class="literal">False</span>, <span class="literal">None</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="keyword">lambda</span>: <span class="number">5</span>]]]</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/2.3.%E5%BA%8F%E5%88%97/image-1.png"></p>
<p>  这种嵌套结构会引入复杂性，让我们能更好地处理复杂的数据。<span class="math inline">\(Trees\)</span>和之后的数据结构都是这样的嵌套结构</p>
<h3><span id="2树的概念">2.树的概念</span></h3>
<p>  树是由树根与树枝序列组成的。树的每根树枝也是一棵树。没有树枝的节点被称为叶子结点。每棵树的树根被称作根节点。</p>
<h3><span id="3树的代码实现">3.树的代码实现</span></h3>
<h4><span id="a树的相关概念的实现">  <span class="math inline">\(a.\)</span>树的相关概念的实现</span></h4>
<p>  树这种数据抽象形式的实现由<span class="math inline">\(constructor\)</span><code>tree</code>与<span class="math inline">\(selector\)</span><code>branches，root</code>构成：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">root_label,branches=[]</span>):<span class="comment">#将branches强制转化为list结构</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch),<span class="string">&#x27;branches must be trees&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [root_label]+<span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">branches</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_tree</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(tree)!=<span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(tree)&lt;<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(tree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> branches(tree)</span><br></pre></td></tr></table></figure></p>
<p>  树可以由嵌套表达式构造，如下所示： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = tree(<span class="number">3</span>, [tree(<span class="number">1</span>), tree(<span class="number">2</span>, [tree(<span class="number">1</span>), tree(<span class="number">1</span>)])])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">[<span class="number">3</span>, [<span class="number">1</span>], [<span class="number">2</span>, [<span class="number">1</span>], [<span class="number">1</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label(t)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>branches(t)</span><br><span class="line">[[<span class="number">1</span>], [<span class="number">2</span>, [<span class="number">1</span>], [<span class="number">1</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>label(branches(t)[<span class="number">1</span>])</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_leaf(t)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_leaf(branches(t)[<span class="number">0</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h4><span id="b树形递归的使用">  <span class="math inline">\(b.\)</span>树形递归的使用</span></h4>
<p>  由于树本身的层次性，利用树形递归也可得出树的一些性质。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_leaves</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        branches_count=[count_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(branch_counts)</span><br></pre></td></tr></table></figure>   可以发现我们对树结构的处理是在<span class="math inline">\(list\)</span>的层面上处理，当我们需要读取具体的结果时才利用数据合并的操作<span class="math inline">\(return\)</span>一个整数。</p>
<h4><span id="c限制树的树枝数">  <span class="math inline">\(c.\)</span>限制树的树枝数</span></h4>
<p>  为限制树的树枝数，以构建二叉树为例，当树枝长度超过<span class="math inline">\(2\)</span>时，我们就<strong>将树的第一个元素保持不变，而将其余元素作为右分支的子树。</strong>即可：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">right_binarize</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">        <span class="keyword">return</span> tree</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tree)&gt;<span class="number">2</span>:</span><br><span class="line">        tree=[tree[<span class="number">0</span>],tree[<span class="number">1</span>:]]</span><br><span class="line">    <span class="keyword">return</span> [right_binarize(b) <span class="keyword">for</span> b <span class="keyword">in</span> tree]</span><br></pre></td></tr></table></figure>
  注意该函数的目标是对整棵树进行右分支重建，因此是<code>for b in tree</code>。</p>
<h4><span id="d树的列表化处理">  <span class="math inline">\(d.\)</span>树的列表化处理</span></h4>
<p>  当我们要对树的某一层节点执行一些操作时，可以考虑如下思路：</p>
<ol type="1">
<li>将所有节点装进一个<span class="math inline">\(list\)</span>中</li>
<li>利用序列操作对<span class="math inline">\(list\)</span>进行处理</li>
<li>将<span class="math inline">\(list\)</span>回带到树上</li>
</ol>
<p>  这种<strong>将一种序列类型转化为其他类型的序列</strong>从而简化操作的方法值得学习。</p>
<p>  <span class="math inline">\(e.g.\)</span>Write a function
reverse_other that mutates the tree such that labels on every other
(odd-depth) level are reversed. For example, Tree(1,[Tree(2, [Tree(4)]),
Tree(3)]) becomes Tree(1,[Tree(3, [Tree(4)]), Tree(2)]). Notice that the
nodes themselves are not reversed; only the labels are.
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_other</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">t,index</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t.is_leaf():</span><br><span class="line">            <span class="keyword">if</span> index%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                treelist=[]</span><br><span class="line">                <span class="keyword">for</span> b <span class="keyword">in</span> t.branches:</span><br><span class="line">                    treelist.append(b.label)</span><br><span class="line">                treelist.reverse()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t.branches)):</span><br><span class="line">                    t.branches[i].label=treelist[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> t.branches:</span><br><span class="line">                helper(b,index+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    helper(t,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h3><span id="3树的应用">3.树的应用</span></h3>
<p>  利用树形递归求解的问题都可以转化到树结构上。以之前的<span class="math inline">\(Fib\)</span>数列和数的分解为例：</p>
<h4><span id="afib数列">  <span class="math inline">\(a.\)</span><span class="math inline">\(Fib\)</span>数列</span></h4>
<p>  <span class="math inline">\(Fib\)</span>数列的树结构搭建如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_tree</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left,right=fib_tree(n-<span class="number">1</span>),fib_tree(n-<span class="number">2</span>)</span><br><span class="line">        fib_n=label(left)+label(right)<span class="comment">#根节点为左右根节点的和</span></span><br><span class="line">        <span class="keyword">return</span> tree(fib_n,[left,right])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib_tree(<span class="number">5</span>)</span><br><span class="line">[<span class="number">5</span>, [<span class="number">2</span>, [<span class="number">1</span>], [<span class="number">1</span>, [<span class="number">0</span>], [<span class="number">1</span>]]], [<span class="number">3</span>, [<span class="number">1</span>, [<span class="number">0</span>], [<span class="number">1</span>]], [<span class="number">2</span>, [<span class="number">1</span>], [<span class="number">1</span>, [<span class="number">0</span>], [<span class="number">1</span>]]]]]</span><br></pre></td></tr></table></figure>   这样，每棵树的根节点就表示对应的<span class="math inline">\(Fib\)</span>数列的值了。</p>
<h4><span id="b分解树">  <span class="math inline">\(b.\)</span>分解树</span></h4>
<p>  在先前的分解数字中，我们将数字分解分为两种情况：</p>
<ul>
<li>选一个<span class="math inline">\(m\)</span>，然后对<span class="math inline">\(n-m\)</span>执行相同操作</li>
<li>不选<span class="math inline">\(m\)</span>，此时序列中最大值变为<span class="math inline">\(m-1\)</span>，然后继续执行相同操作</li>
</ul>
<p>  这两种情况分别对应根节点的两个树枝：</p>
<ul>
<li>左树枝：所有至少用一个<span class="math inline">\(m\)</span>的分解<span class="math inline">\(n\)</span>的方法</li>
<li>右树枝：最大为<span class="math inline">\(m-1\)</span>的分解<span class="math inline">\(n\)</span>的方法</li>
<li>根节点：<span class="math inline">\(m\)</span></li>
</ul>
<p>  于是可以写出对应的树的构建： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition_tree</span>(<span class="params">n,m</span>):</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> n&lt;<span class="number">0</span> <span class="keyword">or</span> m&lt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left=partition_tree(n-m,m)</span><br><span class="line">        right=partition_tree(n,m-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> tree(m,[left,right])</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>partition_tree(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">[<span class="number">2</span>, [<span class="literal">True</span>], [<span class="number">1</span>, [<span class="number">1</span>, [<span class="literal">True</span>], [<span class="literal">False</span>]], [<span class="literal">False</span>]]]</span><br></pre></td></tr></table></figure></p>
<p>  若要打印该树，可以将树的根节点转化为<span class="math inline">\(string\)</span>类型，然后递归打印：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_parts</span>(<span class="params">tree,partition=[]</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">        <span class="keyword">if</span> label(tree):<span class="comment">#如果不是空节点</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>.join(partition))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left,right=branches(tree)//序列解包</span><br><span class="line">        m=<span class="built_in">str</span>(label(tree))</span><br><span class="line">        print_parts(left,partition+m)</span><br><span class="line">        print_parts(right,partition+m)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_parts(partition_tree(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"><span class="number">4</span> + <span class="number">2</span></span><br><span class="line"><span class="number">4</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">3</span> + <span class="number">3</span></span><br><span class="line"><span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"><span class="number">3</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">2</span> + <span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="number">2</span> + <span class="number">2</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">2</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2><span id="七-linkedlists">七、<span class="math inline">\(Linked\;lists\)</span></span></h2>
<h3><span id="1链表的概念">1.链表的概念</span></h3>
<p>  如下所示的序列结构就是链表： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">four = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="string">&#x27;empty&#x27;</span>]]]]</span><br></pre></td></tr></table></figure></p>
<p><img src="/2024/05/31/2.3.%E5%BA%8F%E5%88%97/image-2.png"></p>
<p>  链表表示若干个<span class="math inline">\(pair\)</span>，第一个<span class="math inline">\(pair\)</span>包括第一个元素和一个子链表，以此类推；最后一个<span class="math inline">\(pair\)</span>包含最后一个元素和空链表<code>empty</code>。可以看出链表具有<strong>递归的结构</strong>。</p>
<h3><span id="2链表的操作">2.链表的操作</span></h3>
<h4><span id="a链表的基本元素">  <span class="math inline">\(a.\)</span>链表的基本元素</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">first</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rest</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4><span id="b链表的长度与元素访问">  <span class="math inline">\(b.\)</span>链表的长度与元素访问</span></h4>
<p>  作为序列的一种形式，序列抽象的操作在链表中亦可实现：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">len_link</span>(<span class="params">s</span>):</span><br><span class="line">    length=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> s!=empty:</span><br><span class="line">        s,length=rest(s),length+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getitem_link</span>(<span class="params">s,i</span>):</span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">        s,i=rest(s),i-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> first(s)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len_link(four)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getitem_link(four, <span class="number">1</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h4><span id="c链表的序列基本操作">  <span class="math inline">\(c.\)</span>链表的“序列基本操作”</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extend_link</span>(<span class="params">s,t</span>):</span><br><span class="line">    <span class="comment">#Return a list with the elements of s followed by those of t.</span></span><br><span class="line">    <span class="keyword">assert</span> is_link(s) <span class="keyword">and</span> is_link(t)</span><br><span class="line">    <span class="keyword">if</span> s==empty:</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> link(first(s),extend_link(rest(s),t))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extend_link(four, four)</span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="string">&#x27;empty&#x27;</span>]]]]]]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_to_all_link</span>(<span class="params">f,s</span>):</span><br><span class="line">    <span class="keyword">assert</span> is_link(s)</span><br><span class="line">    <span class="keyword">if</span> s==empty:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> link(f(first(s)),apply_to_all_link(f,rest(s)))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apply_to_all_link(<span class="keyword">lambda</span> x: x*x, four)</span><br><span class="line">[<span class="number">1</span>, [<span class="number">4</span>, [<span class="number">9</span>, [<span class="number">16</span>, <span class="string">&#x27;empty&#x27;</span>]]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keep_if_link</span>(<span class="params">f,s</span>):</span><br><span class="line">    <span class="comment">#Return a list with elements of s for which f(e) is true.</span></span><br><span class="line">    <span class="keyword">assert</span> is_link(s)</span><br><span class="line">    <span class="keyword">if</span> s==empty:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        kept=keep_if_link(f,rest(s))</span><br><span class="line">        <span class="keyword">if</span> f(first(s)):</span><br><span class="line">            <span class="keyword">return</span> link(first(s)+kept)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> kept</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keep_if_link(<span class="keyword">lambda</span> x: x%<span class="number">2</span> == <span class="number">0</span>, four)</span><br><span class="line">[<span class="number">2</span>, [<span class="number">4</span>, <span class="string">&#x27;empty&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">join_link</span>(<span class="params">s,separator</span>):</span><br><span class="line">    <span class="comment">#Return a string of all elements in s separated by separator.</span></span><br><span class="line">    <span class="keyword">if</span> s==empty:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> rest(s)==empty:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(first(s))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(first(s))+separator+join_link(rest(s),separator)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join_link(four, <span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="string">&#x27;1, 2, 3, 4&#x27;</span></span><br></pre></td></tr></table></figure>
<h3><span id="3链表的应用">3.链表的应用</span></h3>
<p>  链表在递增构造序列方面非常有用，因为链表允许动态添加元素、而不必一开始知道序列全部内容</p>
<p>  以先前的数的分解为例，可以用列表如下实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">n,m</span>):</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> link(empty,empty)</span><br><span class="line">    <span class="keyword">elif</span> n&lt;<span class="number">0</span> <span class="keyword">or</span> m&lt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> empty</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        using_m=partition(n-m,m)</span><br><span class="line">        with_m = apply_to_all_link(<span class="keyword">lambda</span> s: link(m, s), using_m)</span><br><span class="line">        <span class="comment"># creat a list that starts with m</span></span><br><span class="line">        without_m = partitions(n, m-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> extend_link(with_m, without_m)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>2.5.数组型链表</title>
    <url>/2024/05/31/2.5.ALists/</url>
    <content><![CDATA[<h1><span id="25数组型链表"><span class="math inline">\(2.5\)</span>数组型链表</span></h1>
<h3><span id="1数组型链表的引入与搭建">1.数组型链表的引入与搭建</span></h3>
<p>  在<span class="math inline">\(SLList\)</span>与<span class="math inline">\(DLList\)</span>中，我们可以轻易地实现<code>getFirst</code>和<code>getLast</code>，但只能用线性的时间复杂度实现<code>get(int index)</code>。而数组可以实现常数时间复杂度的访问(参考<span class="math inline">\(cs61a\)</span>的懒惰计算)。</p>
<p>  可以初步搭建出以下的<span class="math inline">\(AList\)</span>框架： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AList &#123;</span><br><span class="line">        items = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这一实现遵循了以下不变量：</p>
<ul>
<li>下一个插入元素的插入位置一直是<span class="math inline">\(size\)</span>。</li>
<li><span class="math inline">\(AList\)</span>中的元素数量永远是<span class="math inline">\(size\)</span>。</li>
<li>最后一个元素的位置永远是<span class="math inline">\(size-1\)</span>。</li>
</ul>
<h3><span id="2对链表的思考">2.对链表的思考</span></h3>
<p>  在实现<code>removeLast</code>操作时，我们先明确一个重要的发现：在我们实现某个方法时，对链表的任何改变都应该导致一个或多个内存盒子(<span class="math inline">\(memory\;box\)</span>)的改变。</p>
<p>  链表是一个抽象的概念用户使用我们提供的抽象(<code>addLast</code>，<code>removeLast</code>)来对列表进行的任何更改，而我们必须将这些更改以符合用户期望的方式反映在这些内存盒子中。中间的过程并不重要，我们只需要让数组型链表的行为与用户所设想的相一致就好了。</p>
<p>  而<span class="math inline">\(size\)</span>，<span class="math inline">\(items\)</span>，<span class="math inline">\(items[i]\)</span>的内存盒子(<span class="math inline">\(memory\;boxes\)</span>)是这个概念的具体表示，是我们已经设计好的事实。我们的目标就是通过操作这些具体的表示形式，来实现用户想要的模型。</p>
<h3><span id="3removelast的实现">3.<code>removeLast</code>的实现</span></h3>
<p>  通过上面对链表的思考，我们可以只通过改变<span class="math inline">\(size\)</span>来实现<code>removeLast</code>：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> getLast();</span><br><span class="line">        size = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>  这种<code>removeLast</code>的实现是基于<span class="math inline">\(AList\)</span>的不变量的。只要我们改变<span class="math inline">\(Size\)</span>，那么下一个元素插入的位置就一定是<span class="math inline">\(size\)</span>，不管<span class="math inline">\(size\)</span>这个位置有没有元素，而最后一个元素的位置是<span class="math inline">\(size-1\)</span>，用户并不能去访问<span class="math inline">\(size\)</span>这个位置。因此可以通过这个手段实现元素的删除。至于<span class="math inline">\(size\)</span>位置的元素，我们想把它改为几都可以。</p>
<p>  不过，与<span class="math inline">\(int\)</span>型的链表不同，当我们链表的存储类型为<span class="math inline">\(generic\)</span>时，我们会将<span class="math inline">\(size\)</span>位置的元素置为<code>null</code>，因为如果对<span class="math inline">\(size\)</span>位置的元素置之不理的话，这个元素就会一直占用内存，导致内存的浪费。而设为<code>null</code>后，由于对它的引用丢失了，<span class="math inline">\(Java\)</span>会在内存中删掉它。</p>
<h3><span id="4数组大小的调整">4.数组大小的调整</span></h3>
<p>  在<span class="math inline">\(Java\)</span>中，数组必须有固定的大小，因此在数组容量不够时，我们需要调整数组的大小(<span class="math inline">\(resize\)</span>)。</p>
<p>  实现调整数组的办法很简单：创建一个具有所需大小的数组，然后把原数组的元素复制过来，最后返回这个新数组即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[size + <span class="number">1</span>];</span><br><span class="line">System.arraycopy(items, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">a[size] = <span class="number">11</span>;</span><br><span class="line">items = a;</span><br><span class="line">size = size + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>  但是，这种在需要扩容时增加一部分的做法过于缓慢。例如我们每次扩容<span class="math inline">\(1\)</span>，则当数组扩容到<span class="math inline">\(n\)</span>时，由于每次扩容都要先创建一个新的数组，一共创建了<span class="math inline">\(\sum_{i=1}^n i ={ {n(n+1)}\over
2}\)</span>个单位大小的数组，时间复杂度为<span class="math inline">\(O(n^2)\)</span>，这样的效率十分低。</p>
<p>  因此，我们一般不采用上面的扩容方式，而是在需要扩容的时候适当地多扩大一些，以减少创建数组的次数。一般的做法如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBack</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">           resize(size * RFACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="5内存使用率">5.内存使用率</span></h3>
<p>  数组中的实际元素个数与数组大小之比的数值是内存利用率。下面的数组的内存使用率为<span class="math inline">\(0.04\)</span>：</p>
<p><img src="/2024/05/31/2.5.ALists/image-14.png"></p>
<p>  当数组的内存使用率较低的时候，我们可以考虑<code>resize(size \ 2)</code>，缩小数组空间来节约内存。这种做法被称为以空间换时间。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>2.List</category>
      </categories>
  </entry>
  <entry>
    <title>2.5.面向对象编程</title>
    <url>/2024/05/31/2.5.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1><span id="25面向对象编程"><span class="math inline">\(2.5\)</span>面向对象编程</span></h1>
<h2><span id="一-面向对象编程概述">一、面向对象编程概述</span></h2>
<p>  在前文的讲述中，对象具有如下的特点：</p>
<ul>
<li>对象间<strong>可以建立抽象屏障</strong></li>
<li>对象<strong>具有无法被全局环境访问的局部状态</strong></li>
<li><span class="math inline">\(\cdots\)</span></li>
</ul>
<p>  <span class="math inline">\(Python\)</span>的对象系统可以利用面向对象编程(<span class="math inline">\(object-oriented\;programme\)</span>)语言来表述。</p>
<p>  对象系统为多个独立代理(<span class="math inline">\(agent\)</span>)在计算机内部的互动提供了新的隐喻方法。每个对象都将局部状态和行为通过抽象的方式进行绑定，从而将两者的复杂性进行抽象。对象间互相交流，而它们交流的结果得出了有用的结论。对象间<strong>不仅传递信息，而且和其它相同类型的对象共享行为、继承相同类型对象的特性</strong>。</p>
<h2><span id="二-类class">二、类(<span class="math inline">\(class\)</span>)</span></h2>
<h3><span id="1类的概念">1.类的概念</span></h3>
<p>  类是作为所有属于该类的对象的模版(<span class="math inline">\(template\)</span>)。每个对象都是类的一个实例(<span class="math inline">\(instance\)</span>)。</p>
<p>  类的声明具体说明了<strong>类的对象间共享的属性与方法</strong>。以之前的银行账户<span class="math inline">\(account\)</span>为例，可以如下声明一个类：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=Account(<span class="string">&#x27;Kirk&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h3><span id="2类的子概念">2.类的子概念</span></h3>
<p>  类的属性(<span class="math inline">\(attribute\)</span>)是一个<strong>与对象相关联的“名字-值”对</strong>，通过“点标记”(<span class="math inline">\(dot-notation\)</span>)能访问类的属性。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.holder</span><br><span class="line"><span class="string">&#x27;Kirk&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.balance</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>   类的方法(<span class="math inline">\(method\)</span>)是<strong>作用于对象及其计算的函数</strong>。方法的返回值与副作用取决于对象的属性、并且能改变对象的一些属性。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.deposit(<span class="number">15</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="3类的声明">3.类的声明</span></h3>
<h4><span id="a初始化声明">  <span class="math inline">\(a.\)</span>初始化声明</span></h4>
<p>  一个声明类的语句有以下的结构： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>&lt;name&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></p>
<p>  一个类为了具体声明实例对象的属性，会<strong>内置一个初始化方法<code>__init__</code>，这称为类的构建(<span class="math inline">\(constructor\)</span>)</strong>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>  <span class="math inline">\(p.s.\)</span>在<span class="math inline">\(Python\)</span>中，方法名以双下划线 __
开头和结尾的形式被称为特殊方法(<span class="math inline">\(special\;methods)\)</span>。<code>__init__</code>是其中一种，它用于初始化对象的状态。当你创建一个新的实例时，<span class="math inline">\(Python\)</span>会自动调用这个方法来初始化对象的属性。</p>
</blockquote>
<p>  这里的参数<code>account_holder</code>是局部名称。但<strong>通过点标记，<code>account_holder</code>被绑定到了赋值语句上</strong>，因为此时<code>account_holder</code>作为<code>self</code>的属性被存储了。</p>
<p>  具体化<span class="math inline">\(Account\)</span>类后，我们就可以创建一个具体的类的实例：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Account(<span class="string">&#x27;Kirk&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>  这个对类的调用创建了一个新的<strong>对象</strong>，这个对象是类的一个<strong>实例(<span class="math inline">\(instance\)</span>)</strong>。<code>__init__</code>的第一个参数<code>self</code>与这个对象绑定了，传入的是第二个参数的值。这样之后我们就可以访问实例的属性了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.balance</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.holder</span><br><span class="line"><span class="string">&#x27;Kirk&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>  每个独立声明的类的实例都有自己的独特身份(<span class="math inline">\(identity\)</span>)，例如以下语句所展示的：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Account(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.balance = <span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[acc.balance <span class="keyword">for</span> acc <span class="keyword">in</span> (a, b)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">200</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> <span class="keyword">not</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h4><span id="b方法的声明">  <span class="math inline">\(b.\)</span>方法的声明</span></h4>
<p>  在<code>class</code>语句内部使用<code>def</code>语句即可声明类的方法：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            self.balance = self.balance + amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">if</span> amount &gt; self.balance:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">            self.balance = self.balance - amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br></pre></td></tr></table></figure></p>
<p>  虽然方法的定义与普通函数的定义没有差别，但它们执行后产生的影响却不一样。在<code>class</code>语句下定义的<code>def</code>语句<strong>作为属性在类中局部绑定</strong>。例如下面对<span class="math inline">\(Account\)</span>方法的调用： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account = Account(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.deposit(<span class="number">100</span>)</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.withdraw(<span class="number">90</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.withdraw(<span class="number">90</span>)</span><br><span class="line"><span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.holder</span><br><span class="line"><span class="string">&#x27;Spock&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>  每个方法的<strong>第一个参数都是<code>self</code>，表示调用该方法的对象</strong>。当一个方法通过点标记被调用后，对象执行了两个功能：</p>
<ul>
<li><strong>决定对应的方法具体是什么</strong>。例如示例中的<code>withdraw</code>，这里的<code>withdraw</code>是类中的局部名称。</li>
<li><strong>作为方法的特殊参数</strong>。</li>
</ul>
<h2><span id="三-信息传递与点表达式">三、信息传递与点表达式</span></h2>
<h3><span id="1类中的信息传递模式">1.类中的信息传递模式</span></h3>
<p>  在类中，对象通过点标记接受信息，但这些信息不再是分派字典中的字符串<code>key</code>了，而是类局部下的名称。同时类也有局部状态的值，我们可以运用点标记来访问与操作它们、而不需要<code>nonlocal</code>语句。</p>
<h3><span id="2类的属性的实现">2.类的属性的实现</span></h3>
<p>  类的属性可以通过简单的赋值语句实现，例如下面对<span class="math inline">\(Account\)</span>类的<code>interest</code>属性的赋值：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        interest = <span class="number">0.02</span>            <span class="comment"># A class attribute</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="comment"># Additional methods would be defined here</span></span><br></pre></td></tr></table></figure></p>
<p>  这个属性可以<strong>被所有该类的实例获取</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account = Account(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account = Account(<span class="string">&#x27;Kirk&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.02</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.02</span></span><br></pre></td></tr></table></figure></p>
<p>  同样地，<strong>当类的属性被改变了，所有该类的实例的这一属性都会改变</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.interest = <span class="number">0.04</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="2点表达式">2.点表达式</span></h3>
<p>  点表达式是形如以下的语句： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;expression&gt;.&lt;name&gt;</span><br></pre></td></tr></table></figure>
  一个点表达式通过一个对象和一个属性的名字(通过<code>&lt;expression&gt;</code>表达式得出)来访问对象的属性、并返回该属性的值。</p>
<p>  同时，通过内置函数<code>getattr</code>也可用字符串访问对象的属性，像分派字典里的那样：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(spock_account, <span class="string">&#x27;balance&#x27;</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>  <code>getattr</code>函数还可以测试对象中有无某种属性：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(spock_account, <span class="string">&#x27;deposit&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="3方法与函数的差异">3.方法与函数的差异</span></h3>
<p>  当某个对象调用了一个方法时，这个对象会直接作为该方法第一个特殊参数。这样方法的特殊参数<code>self</code>与对象就得到了绑定。</p>
<p>  为了实现这种自动绑定，<span class="math inline">\(python\)</span>对方法与函数进行了区分。利用<code>type</code>函数运行如下程序：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(Account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(spock_account.deposit)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;method&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h2><span id="四-类的属性">四、类的属性</span></h2>
<h3><span id="1类的属性的概念">1.类的属性的概念</span></h3>
<p>  有的类中的属性会被所有属于该类的对象共享，这种属性是与类直接连接的、并不是与某个单独的类的实例相连。</p>
<h3><span id="3类的属性的访问">3.类的属性的访问</span></h3>
<p>  类的属性的访问也可通过点表达式实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;expression&gt;.&lt;name&gt;</span><br></pre></td></tr></table></figure></p>
<p>  访问类的属性遵循以下过程：</p>
<ul>
<li>计算<code>&lt;expression&gt;</code>，然后得到对应的对象。</li>
<li><code>&lt;name&gt;</code>随后对应到该对象的属性，如果该对象对应属性存在，就返回该属性。</li>
<li>如果不存在，<code>&lt;name&gt;</code>就会去类中寻找对应属性，并读取对应属性。</li>
<li>如果这个属性是方法，就返回对应函数；否则返回对应值。</li>
</ul>
<p>  在这一流程中，实例自己的属性先于类的属性被查找，这与局部环境对全局环境具有优先级相类似</p>
<h3><span id="4类的属性的赋值规则">4.类的属性的赋值规则</span></h3>
<p>  在类的赋值语句中，如果对象是类的话，赋值语句就会设置一个类的属性；如果对象是实例的话，赋值语句就会设置一个实例的属性。<strong>对实例属性的改变不会影响类的属性</strong>。</p>
<p>  下面的例子中，我们对实例的属性重新赋值： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest = <span class="number">0.08</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest</span><br><span class="line"><span class="number">0.08</span></span><br></pre></td></tr></table></figure>
  但是，类的属性依然不变： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest</span><br><span class="line"><span class="number">0.04</span></span><br></pre></td></tr></table></figure></p>
<p>  <strong>改变类的属性后，该实例的属性也不会被影响</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Account.interest = <span class="number">0.05</span>  <span class="comment"># changing the class attribute</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spock_account.interest     <span class="comment"># changes instances without like-named instance attributes</span></span><br><span class="line"><span class="number">0.05</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kirk_account.interest     <span class="comment"># but the existing instance attribute is unaffected</span></span><br><span class="line"><span class="number">0.08</span></span><br></pre></td></tr></table></figure></p>
<h2><span id="五-继承">五、继承</span></h2>
<h3><span id="1继承的概念">1.继承的概念</span></h3>
<p>  在面向对象的编程中，两个类可能有相似的属性，但一个是另一个的特殊例子。例如，我们想实现一个跟先前的<span class="math inline">\(Account\)</span>不同的<span class="math inline">\(CheckingAccount\)</span>，该类的特殊如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch = CheckingAccount(<span class="string">&#x27;Spock&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.interest     <span class="comment"># Lower interest rate for checking accounts</span></span><br><span class="line"><span class="number">0.01</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.deposit(<span class="number">20</span>)  <span class="comment"># Deposits are the same</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.withdraw(<span class="number">5</span>)  <span class="comment"># withdrawals decrease balance by an extra charge</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(CheckingAccount\)</span>是<span class="math inline">\(Account\)</span>的特殊化。在<span class="math inline">\(OOP\)</span>术语中，<strong>普遍的类<span class="math inline">\(Account\)</span>是<span class="math inline">\(CheckingAccount\)</span>的基准类，而<span class="math inline">\(CheckingAccount\)</span>是<span class="math inline">\(Account\)</span>的子类</strong>。</p>
<p>  子类<strong>会继承基准类的属性，但会覆盖原有的一些属性，包括一些方法</strong>。在继承中，我们只具体说明子类与基准类的差别，剩余的就默认与基准类一致。</p>
<p>  继承在我们的对象隐喻中也有着重要作用，它<strong>揭示了对象间的<code>is-a</code>关系</strong>。例如<span class="math inline">\(CheckingAccount\)</span><code>is-a</code><span class="math inline">\(Account\)</span>的一种特殊形式，那么继承的操作就顺理成章了。而如果两者只是单纯的<code>has-a</code>关系，那么两者不应有继承关系。</p>
<h3><span id="2继承操作的实现">2.继承操作的实现</span></h3>
<p>  首先我们给出基准类的实现作为基础： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A bank account that has a non-negative balance.&quot;&quot;&quot;</span></span><br><span class="line">        interest = <span class="number">0.02</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.balance = <span class="number">0</span></span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Increase the account balance by amount and return the new balance.&quot;&quot;&quot;</span></span><br><span class="line">            self.balance = self.balance + amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Decrease the account balance by amount and return the new balance.&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> amount &gt; self.balance:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Insufficient funds&#x27;</span></span><br><span class="line">            self.balance = self.balance - amount</span><br><span class="line">            <span class="keyword">return</span> self.balance</span><br></pre></td></tr></table></figure></p>
<p>  相应地对<span class="math inline">\(CheckingAccount\)</span>的实现如下，我们通过<code>&lt;name&gt; + &lt;value&gt;/def</code>的形式定义<span class="math inline">\(CheckingAccount\)</span>独有的属性：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">CheckingAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A bank account that charges for withdrawals.&quot;&quot;&quot;</span></span><br><span class="line">        withdraw_charge = <span class="number">1</span></span><br><span class="line">        interest = <span class="number">0.01</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">return</span> Account.withdraw(self, amount + self.withdraw_charge)</span><br></pre></td></tr></table></figure></p>
<p>  下面是该子类对应属性的输出结果： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking = CheckingAccount(<span class="string">&#x27;Sam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.deposit(<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.withdraw(<span class="number">5</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.interest</span><br><span class="line"><span class="number">0.01</span></span><br></pre></td></tr></table></figure></p>
<p>  这里，我们还可以得出在子类中查找<code>&lt;name&gt;</code>的流程： *
如果这个名称<strong>在子类中，就输出对应属性的值</strong>。 *
否则，<strong>在基准类中找这个名称</strong>。</p>
<p>  例如该例中的<code>deposit</code>属性，由于只在基准类中得到定义，因此子类属性的执行与基准类属性的执行相一致。</p>
<p>  <strong>即使子类覆盖了基准类的属性，子类依然可以访问基准类的属性。</strong>例如实现子类的<code>withdraw</code>函数的过程中调用了基准类的<code>withdraw</code>。</p>
<p>  注意到我们调用的是<code>self.withdraw_charge</code>而非<code>CheckingAccount.withdraw_charge</code>，因为我们无法确定此时的<code>self</code>一定是<code>CheckingAccount</code>，这样确保了万无一失。</p>
<h3><span id="3接口">3.接口</span></h3>
<p>  一个对象接口(<span class="math inline">\(object\;interface\)</span>)是<strong>一些被共享的属性的集合</strong>。例如，对于所有的<code>account</code>，都会有<code>deposit</code>与<code>withdraw</code>方法和<code>balance</code>属性。<span class="math inline">\(Account\)</span>类和<span class="math inline">\(CheckingAccount\)</span>类都实现了这一接口。而继承通过这一方式促进了名称的共享。</p>
<h2><span id="六-多重继承">六、多重继承</span></h2>
<h3><span id="1多重继承的概念与实现">1.多重继承的概念与实现</span></h3>
<p>  <span class="math inline">\(python\)</span>支持一个继承不同基准类的子类的实现。</p>
<p>  假设我们已知一个继承<span class="math inline">\(Account\)</span>的<span class="math inline">\(SavingAccount\)</span>，它会在每次<code>deposit</code>时收取一定费用：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">SavingsAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">        deposit_charge = <span class="number">2</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">            <span class="keyword">return</span> Account.deposit(self, amount - self.deposit_charge)</span><br></pre></td></tr></table></figure>   这是，如果我们要实现一个基于<span class="math inline">\(SavingAccount\)</span>与<span class="math inline">\(CheckingAccount\)</span>的新<code>account</code><span class="math inline">\(AsSeenOnTVAccount\)</span>，它同时实现<code>check</code>与<code>save</code>功能，那么我们可以通过<strong>继承两个类</strong>来实现这一个类：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">AsSeenOnTVAccount</span>(CheckingAccount, SavingsAccount):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">            self.balance = <span class="number">1</span>           <span class="comment"># A free dollar!</span></span><br></pre></td></tr></table></figure>
  这样，只需要初始化，该子类的其它部分可借助继承的类来实现：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal = AsSeenOnTVAccount(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.balance</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.deposit(<span class="number">20</span>)            <span class="comment"># $2 fee from SavingsAccount.deposit</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.withdraw(<span class="number">5</span>)            <span class="comment"># $1 fee from CheckingAccount.withdraw</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.deposit_charge</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.withdraw_charge</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="2多重继承的顺序结构">2.多重继承的顺序结构</span></h3>
<p>  在多重继承中，假如某个名为<code>&lt;name&gt;</code>的属性在两个继承类中都有，程序抉择的顺序结构如下：</p>
<p><img src="/2024/05/31/2.5.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/image-4.png"></p>
<p>  对于这种“钻石型”的继承结构，<span class="math inline">\(python\)</span>会采用“<strong>从下往上、从左往右</strong>”的查找顺序，在各个类中查找该属性，直到找到为止。</p>
<h2><span id="七-对对象的总结">七、对对象的总结</span></h2>
<p>  像这节介绍的类、方法、继承、点表达式等特殊语法，让我们能够更好地形象化我们对程序的隐喻。</p>
<p>  在编写程序时，我们希望我们的对象系统推动程序的不同方面关注不同的问题。每个对象封装、解决问题的一个状态，并且每个类的声明实现程序总体逻辑的一部分。而抽象屏障让问题的不同方面的界限更加的鲜明。</p>
<p>  面向对象编程很好地契合了分为独立的模块化系统、每个系统互相交互的程序设计需求。例如我们对社交网络等生活中事物的模拟，当我们想在程序中实现这些模型时，我们可以把<strong>系统中的对象模块化为程序中的对象，同时用类表明它们的类别与联系</strong>。</p>
<p>  同时，对象并不是唯一的实现抽象的方式。<strong>对于输入输出式的抽象，函数抽象显得更为自然</strong>。认识到什么时候该用对象抽象的方式、什么时候该用函数抽象的方式，是编程中关键的问题。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>2.7.对象抽象</title>
    <url>/2024/05/31/2.7.%E5%AF%B9%E8%B1%A1%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<h1><span id="27对象抽象"><span class="math inline">\(2.7\)</span>对象抽象</span></h1>
<h2><span id="一-思想概述">一、思想概述</span></h2>
<p>  对象系统(<span class="math inline">\(object\;system\)</span>)可以实现对抽象数据的不同表达的共存。</p>
<p>  为实现这样的对象系统，我们需要<strong>找到一个普遍函数(<span class="math inline">\(generic\;function\)</span>)，这个函数可以接受某个值的各种表达</strong>，下面将介绍实现这一操作的方法。</p>
<h2><span id="二-前置知识">二、前置知识</span></h2>
<h3><span id="1字符串转换">1.字符串转换</span></h3>
<p>  为更高效地表达数据，我们希望在<span class="math inline">\(python\)</span>的交互式对话中自动显示表达式的字符串表示。</p>
<p>  <span class="math inline">\(python\)</span>规定，每个对象都会产生两种不同的字符串表示：<strong>一种是人类可以阅读(<span class="math inline">\(human-interpretable\)</span>)的文本，一种是<span class="math inline">\(python\)</span>可理解(<span class="math inline">\(python-interpretable\)</span>)的表达式</strong>。字符串的构造函数<code>str</code>返回一个人类可读的字符串。(在可能的情况下)而<code>repr</code>函数返回结果等价的<code>python</code>表达式：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">12e12</span></span><br><span class="line"><span class="number">12000000000000.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(<span class="number">12e12</span>))</span><br><span class="line"><span class="number">12000000000000.0</span></span><br></pre></td></tr></table></figure></p>
<p>  当传入的表达式没有初始值时，<code>repr</code>会返回如下语句：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(<span class="built_in">min</span>)</span><br><span class="line"><span class="string">&#x27;&lt;built-in function min&gt;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>  <code>str</code>的<span class="math inline">\(constructor\)</span>与<code>repr</code>语句经常重合，但前者返回一个人类更易读的文本：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues = date(<span class="number">2011</span>, <span class="number">9</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(tues)</span><br><span class="line"><span class="string">&#x27;datetime.date(2011, 9, 12)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(tues)</span><br><span class="line"><span class="string">&#x27;2011-09-12&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>  对象系统为我们提供了能用于所有数据类型的方法：<code>__repr__</code>与<code>__str__</code>，这让我们可以以点表达式编写程序：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues.__repr__()</span><br><span class="line"><span class="string">&#x27;datetime.date(2011, 9, 12)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues.__str__()</span><br><span class="line"><span class="string">&#x27;2011-09-12&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="2特殊方法">2.特殊方法</span></h3>
<p>  在<span class="math inline">\(python\)</span>中，特殊方法(<span class="math inline">\(special\;method\)</span>)在特定情况被<span class="math inline">\(python\)</span>编译器调用，例如：</p>
<ul>
<li><code>__init__</code>方法会在某个对象被创建后自动调用。</li>
<li><code>__str__</code>方法在打印结果时自动调用。</li>
<li><code>__repr</code>方法在交互式程序展示值(<code>value</code>)时自动调用。</li>
</ul>
<p>  <span class="math inline">\(python\)</span>中还有一些类似的特殊方法。</p>
<h4><span id="a__bool__方法">  <span class="math inline">\(a.\)</span><code>__bool__</code>方法</span></h4>
<p>  一般的<code>bool</code>会默认<span class="math inline">\(0\)</span>为<code>false</code>，其他值为<code>true</code>。对于对象而言，<span class="math inline">\(python\)</span>中默认所有对象都有<code>true</code>值。但<strong>我们可以利用<code>__bool__</code>方法来覆盖这一默认值</strong>。例如我们将值为<span class="math inline">\(0\)</span>的<span class="math inline">\(Account\)</span>为<code>false</code>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;Account.__bool__=<span class="keyword">lambda</span> self:self.balance!= <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>  则对于下面的对象，它会输出<code>false</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(Account(<span class="string">&#x27;Jack&#x27;</span>))</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="keyword">not</span> Account(<span class="string">&#x27;Jack&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Jack has nothing&#x27;</span>)</span><br><span class="line">Jack has nothing</span><br></pre></td></tr></table></figure></p>
<h4><span id="b序列操作">  <span class="math inline">\(b.\)</span>序列操作</span></h4>
<p>  序列中的方法主要如下：</p>
<ul>
<li><p><code>__len__</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Go Bears!&#x27;</span>.__len__()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>__getitem__</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Go Bears!&#x27;</span>[<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Go Bears!&#x27;</span>.__getitem__(<span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3><span id="3可调用的对象">3.可调用的对象</span></h3>
<p>  <strong>通过<code>__call__</code>方法，我们可以让定义的对象像函数一样被调用</strong>，进而实现类似高阶函数的功能。</p>
<p>  考虑下面的高阶函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">make_adder</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">adder</span>(<span class="params">k</span>):</span><br><span class="line">            <span class="keyword">return</span> n + k</span><br><span class="line">        <span class="keyword">return</span> adder</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_three = make_adder(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_three(<span class="number">4</span>)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>  我们可以定义一个<code>Adder</code>类实现类似操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Adder</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">            self.n = n</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, k</span>):</span><br><span class="line">            <span class="keyword">return</span> self.n + k</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_three_obj = Adder(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_three_obj(<span class="number">4</span>)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>  这样，我们就让类和对象表现得像函数一样，这进一步模糊了函数与数据的界限。</p>
<h2><span id="三-多重表示multiplerepresentations">三、多重表示<span class="math inline">\(multiple\;representations\)</span></span></h2>
<p>  在编程中，对于程序中的某个数据对象，可能存在多种表达方式。例如复数(<span class="math inline">\(complex\;number\)</span>)，既可以用“实部+虚部”来表示，又可以用“模长+辐角主值”来表示。这使我们希望设计出<strong>能处理多重表示(<span class="math inline">\(multiple\;representations\)</span>)的系统</strong>。</p>
<p>  下面即以复数系统说明这一功能的实现。</p>
<h3><span id="1对两种表示的初始化">1.对两种表示的初始化</span></h3>
<p>  我们<strong>从最高层次的抽象着手搭建系统，然后慢慢将其中的功能具体化</strong>。所有的复数都属于<span class="math inline">\(Number\)</span>，而数字可以相加与相乘，于是我们可以定义一个基准类<code>Number</code>与方法<code>__add__</code>、<code>__mul__</code>，这里的<code>__add__</code>、<code>__mul__</code>是通过<code>add</code>、<code>mul</code>等更具体的方法实现的：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">            <span class="keyword">return</span> self.add(other)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self,other</span>):</span><br><span class="line">            <span class="keyword">return</span> self.mul(other)</span><br></pre></td></tr></table></figure></p>
<p>  然后考虑在复数中实现<code>add</code>与<code>mul</code>方法，对<code>add</code>我们用复数的标准形式来计算；对于<code>mul</code>我们用复数的辐角形式来计算：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Complex</span>(<span class="title class_ inherited__">Number</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,other</span>):</span><br><span class="line">            <span class="keyword">return</span> ComplexRI(self.real+other.real,self.imag+other.imag)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self,other</span>):</span><br><span class="line">            magnitude=self.magnitude*other.magnitude</span><br><span class="line">            <span class="keyword">return</span> ComplexMA(magnitude,self.angle+other.angle)</span><br></pre></td></tr></table></figure></p>
<p>  这种实现方式假设了复数的两种类表示。</p>
<h3><span id="2接口">2.接口</span></h3>
<p>  <strong>对象的属性作为信息传递(<span class="math inline">\(message\;passing\)</span>)的一种，允许不同的数据类型对相同信息做出不同反应</strong>。这种<strong>在不同的类中引发相似操作的共享信息组(<span class="math inline">\(shared\;set\;of\;messages\)</span>)</strong>
是有力的抽象方式。而<strong>接口(<span class="math inline">\(interface\)</span>)是一系列共享的属性名称与各自行为的详细说明</strong>。对于复数系统，接口需要实现四个属性：<code>real</code>，<code>imag</code>，<code>magnitude</code>，<code>angle</code>。</p>
<p>  为了保证复数算法(<span class="math inline">\(arithmic\)</span>)的正确性，这些属性必须具有一致性。这就是说，<code>(magnitude,angle)</code>表示的复数与<code>(real,imag)</code>表示的复数必须是同一个复数。</p>
<h3><span id="3properties">3.<span class="math inline">\(properties\)</span></span></h3>
<p>  让多个属性维系一个固定的关系是一个新的问题，我们可以通过<strong>只存储某种属性、在需要其他属性时单独计算</strong>的方式解决这个问题。</p>
<p>  <span class="math inline">\(python\)</span>中的<code>@property</code>装饰符允许我们在不调用表达式语法的情况下调用函数，通过零参数的方法计算属性。以复数系统为例，我们存储复数的标准形式：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> atan2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">ComplexRI</span>(<span class="title class_ inherited__">Complex</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, real, imag</span>):</span><br><span class="line">            self.real = real</span><br><span class="line">            self.imag = imag</span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">magnitude</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> (self.real**<span class="number">2</span>+self.imag**<span class="number">2</span>)**<span class="number">0.5</span></span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">angle</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> atan2(self.imag, self.real)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;ComplexRI(&#123;0:g&#125;, &#123;1:g&#125;)&#x27;</span>.<span class="built_in">format</span>(self.real, self.imag)</span><br></pre></td></tr></table></figure></p>
<p>  这样我们就可以通过点表达式直接访问除标准形式外的属性了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri = ComplexRI(<span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri.real</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri.magnitude</span><br><span class="line"><span class="number">13.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri.real = <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri.real</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ri.magnitude</span><br><span class="line"><span class="number">15.0</span></span><br></pre></td></tr></table></figure></p>
<p>  同样地，我们也可以存储辐角形式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sin, cos, pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">ComplexMA</span>(<span class="title class_ inherited__">Complex</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, magnitude, angle</span>):</span><br><span class="line">            self.magnitude = magnitude</span><br><span class="line">            self.angle = angle</span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">real</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> self.magnitude * cos(self.angle)</span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">imag</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> self.magnitude * sin(self.angle)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;ComplexMA(&#123;0:g&#125;, &#123;1:g&#125; * pi)&#x27;</span>.<span class="built_in">format</span>(self.magnitude, self.angle/pi)</span><br></pre></td></tr></table></figure></p>
<p>  并得到以下的输出结果： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ma = ComplexMA(<span class="number">2</span>, pi/<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ma.imag</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ma.angle = pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ma.real</span><br><span class="line">-<span class="number">2.0</span></span><br></pre></td></tr></table></figure></p>
<p>  通过接口方式对多重表示进行编码有优良的性质：<strong>每种表达的类都可以独自定义，它们只需要在共享的属性名称、这些属性的行为条件(<span class="math inline">\(behaviour\;condition\)</span>)上达成一致即可</strong>。当另一个编程者想再加入一个表达时，他只需要再创建一个具有相同属性的类即可。</p>
<h2><span id="四-通用函数">四、通用函数</span></h2>
<h3><span id="1概念amp引入">1.概念&amp;引入</span></h3>
<p>  <strong>通用函数(<span class="math inline">\(generic\;function\)</span>)是一种函数方法，它可以被用于不同类型的变量。</strong>
先前的<code>Complex.add</code>是通用函数，因为它的<code>other</code>变量既可以接受<code>ComplexRI</code>型，也可以接受<code>ComplexMA</code>型。</p>
<p>  这种灵活性的实现是基于
<strong><code>ComeplexRI</code>与<code>ComplexMA</code>共享一个接口</strong>的事实。除了利用接口和信息传递来实现通用函数，还有两种不同方法：类型分派与类型强制。</p>
<p>  现在，我们想将原来的复数系统拓展到实数域，在先前章节中我们已经实现了实数类：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> gcd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Rational</span>(<span class="title class_ inherited__">Number</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,numer,denom</span>):</span><br><span class="line">            g = gcd(numer,denom)</span><br><span class="line">            self.numer=numer // g</span><br><span class="line">            self.denom=denom // g</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Rational(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.numer, self.denom)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self,other</span>):</span><br><span class="line">            nx,dx=self.numer, self.denom</span><br><span class="line">            ny,dy=other.numer, other.denom</span><br><span class="line">            <span class="keyword">return</span> Rational(nx*dy+ny*dx,dx*dy)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self,other</span>):</span><br><span class="line">            numer=self.numer*other.numer</span><br><span class="line">            denom=self.denom*other.denom</span><br><span class="line">            <span class="keyword">return</span> Rational(numer,denom)</span><br></pre></td></tr></table></figure></p>
<p>  我们希望实现一个通用函数<code>__add__</code>实现所有数的加法，同时将实数与复数的概念分离。</p>
<h3><span id="2类型分派">2.类型分派</span></h3>
<p>  一个实现跨类(<span class="math inline">\(cross-type\)</span>)操作的方法是基于参数的数据类型选择适当的行为。而<strong>类型分派(<span class="math inline">\(type\;dispatch\)</span>)正是为了实现一个检查参数数据类型的函数</strong>。</p>
<p>  <span class="math inline">\(python\)</span>内置的<code>isinstance</code>函数可以实现这一功能。它<strong>接收一个对象和一个类，返回这个对象属于该类或属于该类的继承类的真假</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = ComplexRI(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, ComplexRI)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, Complex)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, ComplexMA)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>  可以利用<code>isinstance</code>函数实现对某个数是不是实数的判断：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">is_real</span>(<span class="params">c</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return whether c is a real number with no imaginary part.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(c, ComplexRI):</span><br><span class="line">            <span class="keyword">return</span> c.imag == <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(c, ComplexMA):</span><br><span class="line">            <span class="keyword">return</span> c.angle % pi == <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_real(ComplexRI(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_real(ComplexMA(<span class="number">2</span>, pi))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<p>  当然，我们也可以通过别的方式实现类型分派。我们可以<strong>给每一种数据类型添加一个属性<code>.type_tag</code></strong>，调用该属性会<strong>返回该数据类型的字符串表示</strong>。这样，我们就可以直接比较两个参数的<code>type_tag</code>了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Rational.type_tag = <span class="string">&#x27;rat&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Complex.type_tag = <span class="string">&#x27;com&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Rational(<span class="number">2</span>, <span class="number">5</span>).type_tag == Rational(<span class="number">1</span>, <span class="number">2</span>).type_tag</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ComplexRI(<span class="number">1</span>, <span class="number">1</span>).type_tag == ComplexMA(<span class="number">2</span>, pi/<span class="number">2</span>).type_tag</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Rational(<span class="number">2</span>, <span class="number">5</span>).type_tag == ComplexRI(<span class="number">1</span>, <span class="number">1</span>).type_tag</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>  处理完类型分派问题，我们编写接受实数与复数进行计算的函数操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add_complex_and_rational</span>(<span class="params">c, r</span>):</span><br><span class="line">        <span class="keyword">return</span> ComplexRI(c.real + r.numer/r.denom, c.imag)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">mul_complex_and_rational</span>(<span class="params">c, r</span>):</span><br><span class="line">        r_magnitude, r_angle = r.numer/r.denom, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> r_magnitude &lt; <span class="number">0</span>:</span><br><span class="line">            r_magnitude, r_angle = -r_magnitude, pi</span><br><span class="line">        <span class="keyword">return</span> ComplexMA(c.magnitude * r_magnitude, c.angle + r_angle)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add_rational_and_complex</span>(<span class="params">r, c</span>):</span><br><span class="line">        <span class="keyword">return</span> add_complex_and_rational(c, r)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">mul_rational_and_complex</span>(<span class="params">r, c</span>):</span><br><span class="line">        <span class="keyword">return</span> mul_complex_and_rational(c, r)</span><br></pre></td></tr></table></figure></p>
<p>  利用类型分派，我们可以根据传入参数的类型选择适当的函数操作：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">if</span> self.type_tag == other.type_tag:</span><br><span class="line">                <span class="keyword">return</span> self.add(other)</span><br><span class="line">            <span class="keyword">elif</span> (self.type_tag, other.type_tag) <span class="keyword">in</span> self.adders:</span><br><span class="line">                <span class="keyword">return</span> self.cross_apply(other, self.adders)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">if</span> self.type_tag == other.type_tag:</span><br><span class="line">                <span class="keyword">return</span> self.mul(other)</span><br><span class="line">            <span class="keyword">elif</span> (self.type_tag, other.type_tag) <span class="keyword">in</span> self.multipliers:</span><br><span class="line">                <span class="keyword">return</span> self.cross_apply(other, self.multipliers)</span><br><span class="line">        <span class="comment"># to tackle cross-type requirement</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">cross_apply</span>(<span class="params">self, other, cross_fns</span>):</span><br><span class="line">            cross_fn = cross_fns[(self.type_tag, other.type_tag)]</span><br><span class="line">            <span class="keyword">return</span> cross_fn(self, other)</span><br><span class="line">        <span class="comment"># dispatch dictionary</span></span><br><span class="line">        adders = &#123;(<span class="string">&quot;com&quot;</span>, <span class="string">&quot;rat&quot;</span>): add_complex_and_rational,</span><br><span class="line">                  (<span class="string">&quot;rat&quot;</span>, <span class="string">&quot;com&quot;</span>): add_rational_and_complex&#125;</span><br><span class="line">        multipliers = &#123;(<span class="string">&quot;com&quot;</span>, <span class="string">&quot;rat&quot;</span>): mul_complex_and_rational,</span><br><span class="line">                       (<span class="string">&quot;rat&quot;</span>, <span class="string">&quot;com&quot;</span>): mul_rational_and_complex&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;ComplexRI(<span class="number">1.5</span>,<span class="number">0</span>)+Rational(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">ComplexRI(<span class="number">3</span>,<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt;Rational(-<span class="number">1</span>,<span class="number">2</span>)*ComplexMA(<span class="number">4</span>,pi/<span class="number">2</span>)</span><br><span class="line">ComplexMA(<span class="number">2</span>,<span class="number">1.5</span>*pi)</span><br></pre></td></tr></table></figure></p>
<p>  在新定义的<code>Number</code>类中，所有跨类型函数都作为<code>adders</code>与<code>multipliers</code>的索引。</p>
<p>  在这种基于字典的实现方式是可拓展的，当我们要定义一个<code>Number</code>的新子类时，只需<strong>给它定义一个<code>type_tag</code>，然后把对应的跨类型操作加进<code>Number.adders</code>和<code>Number.multiplier</code>中，同时也可以在子类中定义自己的<code>adders</code>和<code>multipliers</code></strong>
。</p>
<h3><span id="3类型强制">3.类型强制</span></h3>
<p>  在对两种完全不相同的数据类型进行操作时，直接实现跨类型函数是最佳选择。但有时，我们可以利用<strong>类型系统中隐性的附加结构</strong>得到更优解法。</p>
<p>  通常，<strong>不同的数据类型并不是完全独立的，一种数据类型可能是另一种数据类型的子类型</strong>，例如实数就可以被看作虚部为<span class="math inline">\(0\)</span>的复数。这样，我们就可以只用<code>Complex.add</code>与<code>Complex.mul</code>来实现实数虚数的运算了。像这样转换类型的做法被称作<strong>类型强制(<span class="math inline">\(type\;coercion\)</span>)</strong>。</p>
<p>  可以通过以下函数实现类型强制： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">rational_to_complex</span>(<span class="params">r</span>):</span><br><span class="line">        <span class="keyword">return</span> ComplexRI(r.numer/r.denom,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>  包含类型强制的<code>Number</code>类实现如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">            x,y=self.coerce(other)</span><br><span class="line">            <span class="keyword">return</span> x.add(y)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">            x,y=self.coerce(other)</span><br><span class="line">            <span class="keyword">return</span> x.mul(y)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">coerce</span>(<span class="params">self, other</span>):</span><br><span class="line">            <span class="keyword">if</span> self.type_tag==other.type_tag:</span><br><span class="line">                <span class="keyword">return</span> self,other</span><br><span class="line">            <span class="keyword">elif</span> (self.type_tag, other.type_tag) <span class="keyword">in</span> self.coercions:</span><br><span class="line">                <span class="keyword">return</span> (self.coerce_to(other.type_tag), other)</span><br><span class="line">            <span class="keyword">elif</span> (other.type_tag, self.type_tag) <span class="keyword">in</span> self.coercions:</span><br><span class="line">                <span class="keyword">return</span> (self, other.coerce_to(self.type_tag))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">coerce_to</span>(<span class="params">self, other_tag</span>):</span><br><span class="line">            coercion_fn=self.coercions[(self.type_tag, other_tag)]</span><br><span class="line">            <span class="keyword">return</span> coercion_fn(self)</span><br><span class="line">        coercions=&#123;(<span class="string">&#x27;rat&#x27;</span>, <span class="string">&#x27;com&#x27;</span>): rational_to_complex&#125;</span><br></pre></td></tr></table></figure></p>
<p>  类型强制的方法相对于类型分派有新的优势：虽然需要一个<code>coerce_to</code>函数实现类型转换，但<strong>我们只需要写这一个函数，就可以将其他所有的函数归进一个统一的范式中</strong>。这是基于以下思想：类型间的转换<strong>只与类型本身有关、与类型的具体操作无关</strong>。</p>
<p>  类型强制给我们带来了启发：对于两种数据类型，我们可以<strong>设法找到一种中间类型(即前文说的“隐性的附加结构”)，将两种数据类型转换成这个类型</strong>。例如我们可以将矩形和菱形都转化为平行四边形。类似的，不同的中间类型可以转换为新的中间类型<span class="math inline">\(\cdots\)</span>通过这样的链式强制(<span class="math inline">\(chaining\;coercion\)</span>)，我们可以减少程序中需要的<code>coerce</code>函数数量。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>2.9.迭代对象</title>
    <url>/2024/05/31/2.9.%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1><span id="29迭代对象"><span class="math inline">\(2.9\)</span>迭代对象</span></h1>
<p>  对象可以将其他对象作为属性，当一个类中的某个对象的属性是该类的某个成员时，它就是迭代对象(<span class="math inline">\(recursive\;object\)</span>)。</p>
<h3><span id="1链表类">1.链表类</span></h3>
<h4><span id="a链表类定义">  <span class="math inline">\(a.\)</span>链表类定义</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Link</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A linked list with a first element and the rest.&quot;&quot;&quot;</span></span><br><span class="line">        empty = ()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first, rest=empty</span>):</span><br><span class="line">            <span class="keyword">assert</span> rest <span class="keyword">is</span> Link.empty <span class="keyword">or</span> <span class="built_in">isinstance</span>(rest, Link)</span><br><span class="line">            <span class="comment"># if rest is an empty list or is a link instance</span></span><br><span class="line">            self.first = first</span><br><span class="line">            self.rest = rest</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> self.first</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.rest[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">len</span>(self.rest)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4><span id="b字符串表示">  <span class="math inline">\(b.\)</span>字符串表示</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">link_expression</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a string that would evaluate to s.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line">            rest = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rest = <span class="string">&#x27;, &#x27;</span> + link_expression(s.rest)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Link(&#123;0&#125;&#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(s.first, rest)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>link_expression(s)</span><br><span class="line"><span class="string">&#x27;Link(3, Link(4, Link(5)))&#x27;</span></span><br></pre></td></tr></table></figure>
<p>  将这个字符串表示函数与<code>__repr__</code>方法绑定，可以在显示链表实例时自动调用：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Link.__repr__ = link_expression</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>)))</span><br></pre></td></tr></table></figure></p>
<h4><span id="c链表的映射-筛选与字符插入">  <span class="math inline">\(c.\)</span>链表的映射、筛选与字符插入</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">map_link</span>(<span class="params">f, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Link(f(s.first), map_link(f, s.rest))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_link(square, s)</span><br><span class="line">Link(<span class="number">9</span>, Link(<span class="number">16</span>, Link(<span class="number">25</span>)))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">filter_link</span>(<span class="params">f, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            filtered = filter_link(f, s.rest)</span><br><span class="line">            <span class="keyword">if</span> f(s.first):</span><br><span class="line">                <span class="keyword">return</span> Link(s.first, filtered)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> filtered</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>odd = <span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_link(square, filter_link(odd, s))</span><br><span class="line">Link(<span class="number">9</span>, Link(<span class="number">25</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[square(x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="keyword">if</span> odd(x)]</span><br><span class="line">[<span class="number">9</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">join_link</span>(<span class="params">s, separator</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> s.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(s.first)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(s.first) + separator + join_link(s.rest, separator)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join_link(s, <span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="string">&#x27;3, 4, 5&#x27;</span></span><br></pre></td></tr></table></figure>
<h4><span id="d链表的一些其它迭代操作">  <span class="math inline">\(d.\)</span>链表的一些其它迭代操作</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">extend_link</span>(<span class="params">s, t</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">            <span class="keyword">return</span> t</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Link(s.first, extend_link(s.rest, t))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extend_link(s, s)</span><br><span class="line">Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>, Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>))))))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Link.__add__ = extend_link</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s + s</span><br><span class="line">Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>, Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>))))))</span><br></pre></td></tr></table></figure>
<h3><span id="2树类">2.树类</span></h3>
<h4><span id="a树类定义">  <span class="math inline">\(a.\)</span>树类定义</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Tree</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, label, branches=(<span class="params"></span>)</span>):</span><br><span class="line">            self.label = label</span><br><span class="line">            <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(branch, Tree)</span><br><span class="line">            self.branches = branches</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">if</span> self.branches:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Tree(&#123;0&#125;, &#123;1&#125;)&#x27;</span>.<span class="built_in">format</span>(self.label, <span class="built_in">repr</span>(self.branches))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Tree(&#123;0&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">repr</span>(self.label))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> self.branches</span><br></pre></td></tr></table></figure>
<h3><span id="3set">3.<span class="math inline">\(set\)</span></span></h3>
<h4><span id="a概念">  <span class="math inline">\(a.\)</span>概念</span></h4>
<p>  <span class="math inline">\(set\)</span>是<span class="math inline">\(python\)</span>内置的容器，<span class="math inline">\(set\)</span>内部的元素会自动去重与排序。</p>
<h4><span id="b基本操作">  <span class="math inline">\(b.\)</span>基本操作</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.union(&#123;<span class="number">1</span>, <span class="number">5</span>&#125;)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.intersection(&#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;)</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="4set的实现">4.<span class="math inline">\(set\)</span>的实现</span></h3>
<h4><span id="a链表实现非排序set">  <span class="math inline">\(a.\)</span>链表实现非排序<span class="math inline">\(set\)</span></span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">is</span> Link.empty</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return True if and only if set s contains v.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> empty(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> s.first == v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.rest, v)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Link(<span class="number">4</span>, Link(<span class="number">1</span>, Link(<span class="number">5</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(s, <span class="number">2</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(s, <span class="number">5</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">adjoin_set</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a set containing all elements of s and element v.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> set_contains(s, v):</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Link(v, s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = adjoin_set(s, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">Link(<span class="number">2</span>, Link(<span class="number">4</span>, Link(<span class="number">1</span>, Link(<span class="number">5</span>))))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">intersect_set</span>(<span class="params">set1, set2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a set containing all elements common to set1 and set2.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> keep_if_link(set1, <span class="keyword">lambda</span> v: set_contains(set2, v))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>intersect_set(t, apply_to_all_link(s, square))</span><br><span class="line">Link(<span class="number">4</span>, Link(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">union_set</span>(<span class="params">set1, set2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a set containing all elements either in set1 or set2.&quot;&quot;&quot;</span></span><br><span class="line">        set1_not_set2 = keep_if_link(set1, <span class="keyword">lambda</span> v: <span class="keyword">not</span> set_contains(set2, v))</span><br><span class="line">        <span class="keyword">return</span> extend_link(set1_not_set2, set2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>union_set(t, s)</span><br><span class="line">Link(<span class="number">2</span>, Link(<span class="number">4</span>, Link(<span class="number">1</span>, Link(<span class="number">5</span>))))</span><br></pre></td></tr></table></figure>
<h4><span id="b排序对时间复杂度的影响">  <span class="math inline">\(b.\)</span>排序对时间复杂度的影响</span></h4>
<p>  对于查询操作，非排序元素的时间复杂度为<span class="math inline">\(O(n)\)</span>；而对于排序元素，查询最小元素为<span class="math inline">\(1\)</span>，最大元素为<span class="math inline">\(n\)</span>，平均复杂度为<span class="math inline">\(O({n\over 2})=O(n)\)</span>，虽然同阶但较小。</p>
<p>  对于合并操作，非排序元素的时间复杂度是<span class="math inline">\(O(n,m)\)</span>；而对于排序元素，可以利用双指针算法实现<span class="math inline">\(O(m+n)\)</span>的复杂度。</p>
<h4><span id="c列表实现排序set">  <span class="math inline">\(c.\)</span>列表实现排序<span class="math inline">\(set\)</span></span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="keyword">if</span> empty(s) <span class="keyword">or</span> s.first &gt; v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> s.first == v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.rest, v)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = Link(<span class="number">1</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(u, <span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_contains(u, <span class="number">4</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">intersect_set</span>(<span class="params">set1, set2</span>):</span><br><span class="line">        <span class="keyword">if</span> empty(set1) <span class="keyword">or</span> empty(set2):</span><br><span class="line">            <span class="keyword">return</span> Link.empty</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            e1, e2 = set1.first, set2.first</span><br><span class="line">            <span class="keyword">if</span> e1 == e2:</span><br><span class="line">                <span class="keyword">return</span> Link(e1, intersect_set(set1.rest, set2.rest))</span><br><span class="line">            <span class="keyword">elif</span> e1 &lt; e2:</span><br><span class="line">                <span class="keyword">return</span> intersect_set(set1.rest, set2)</span><br><span class="line">            <span class="keyword">elif</span> e2 &lt; e1:</span><br><span class="line">                <span class="keyword">return</span> intersect_set(set1, set2.rest)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>intersect_set(s, s.rest)</span><br><span class="line">Link(<span class="number">4</span>, Link(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h4><span id="d二叉查找树树实现set">  <span class="math inline">\(d.\)</span>二叉查找树树实现<span class="math inline">\(set\)</span></span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> s.entry == v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> s.entry &lt; v:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.right, v)</span><br><span class="line">        <span class="keyword">elif</span> s.entry &gt; v:</span><br><span class="line">            <span class="keyword">return</span> set_contains(s.left, v)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">adjoin_set</span>(<span class="params">s, v</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> Tree(v)</span><br><span class="line">        <span class="keyword">elif</span> s.entry == v:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">elif</span> s.entry &lt; v:</span><br><span class="line">            <span class="keyword">return</span> Tree(s.entry, s.left, adjoin_set(s.right, v))</span><br><span class="line">        <span class="keyword">elif</span> s.entry &gt; v:</span><br><span class="line">            <span class="keyword">return</span> Tree(s.entry, adjoin_set(s.left, v), s.right)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>adjoin_set(adjoin_set(adjoin_set(<span class="literal">None</span>, <span class="number">2</span>), <span class="number">3</span>), <span class="number">1</span>)</span><br><span class="line">Tree(<span class="number">2</span>, Tree(<span class="number">1</span>), Tree(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 2.Building Abstraction with Data</category>
      </categories>
  </entry>
  <entry>
    <title>3.1.Translating &amp; Starting a Program</title>
    <url>/2024/06/03/3-1-Translating-Starting-a-Program/</url>
    <content><![CDATA[<h1><span id="31translating-amp-starting-aprogram"><span class="math inline">\(3.1.\)</span>Translating &amp; Starting a
Program</span></h1>
<h3><span id="1a-complex-example">1.A complex example</span></h3>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image.png"></p>
<p>  When we are going to translate the program, we should follow the
following process:</p>
<ol type="1">
<li><p>Need to decide on what variables go in what registers</p></li>
<li><p>Need to determine which registers we need to save on function
entry (the function preamble/prolog)</p>
<ol type="1">
<li>Decrement the stack</li>
<li>Save all the callee saved registers we will use</li>
<li>Save ra or any other caller saved registers we need to live across
calls to other functions</li>
</ol></li>
<li><p>Translate the code itself</p></li>
<li><p>Restore all the registers necessary (the function
postamble/epilog)</p>
<ol type="1">
<li>Restore the callee saved registers we used</li>
<li>Restore <code>ra</code></li>
<li>Increment the stack</li>
</ol></li>
<li><p>Return using <code>jr</code></p></li>
</ol>
<p>  There are some points in the process:</p>
<ul>
<li>Return <code>null</code>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li a0 0</span><br><span class="line">j postamble</span><br></pre></td></tr></table></figure>
<ul>
<li>When calling function, we can <strong>use the <code>call</code>
pseudo-instruction for <code>jal ra (location)</code></strong>. For
example, <code>call malloc</code>.</li>
</ul>
<h3><span id="2interpretation">2.Interpretation</span></h3>
<ul>
<li><p>Interpreter <strong>directly executes a program in the source
language</strong>.</p></li>
<li><p>Since interpreter <strong>is closer to high-level</strong>, it
can give better error messages during interpreting.</p></li>
<li><p>Because the interpreter executes intermediate representations
rather than direct machine code, <strong>the same source code can be run
from one machine to another without modification of the source
code</strong>.</p></li>
</ul>
<h3><span id="3calling-chain">3.Calling chain</span></h3>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-1.png"></p>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-2.png"></p>
<h3><span id="4compilation">4.Compilation</span></h3>
<h4><span id="aconcepts">  <span class="math inline">\(a.\)</span>Concepts</span></h4>
<p>  The compiler transforms the C program into <strong>an assembly
language program</strong>, a symbolic form of what the machine
understands. High-level language programs take many fewer lines of code
than assembly language, so programmer productivity is much higher.</p>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-3.png"></p>
<h4><span id="bassembler">  <span class="math inline">\(b.\)</span>Assembler</span></h4>
<ul>
<li><p>The assembler <strong>converts the assembly language instruction
into machine language</strong>. It turns the assembly language program
into an <strong>object file, which is a combination of machine language
instructions, data, and information needed to place instructions
properly in memory.</strong></p></li>
<li><p>Assembler will also <strong>accept numbers in a variety of
bases</strong>.</p></li>
</ul>
<p>  To produce the binary version of each instruction in the assembly
language program, the assembler must determine the address corresponding
to all labels. This is done by a <strong>symbol table</strong>.</p>
<ul>
<li><p>The object file for UNIX mainly consists of:</p>
<ul>
<li><p>The object file header describes <strong>the size and position of
the other pieces of the object file</strong>.</p></li>
<li><p>The text segment contains <strong>the machine language
code</strong>.</p></li>
<li><p>The static data segment contains <strong>data allocated for the
life of the program</strong>.</p></li>
<li><p>The relocation information identifies instructions and data words
that <strong>depend on absolute addresses when the program is loaded
into memory</strong>.</p></li>
<li><p>The symbol table contains <strong>the remaining labels that are
not defined</strong>, such as external references.</p>
<ul>
<li>Use <strong>dummy "placeholders"</strong> for unresolved absolute
and external references.</li>
</ul></li>
<li><p>The debugging information contains <strong>a concise description
of how the modules were compiled</strong>.</p></li>
</ul></li>
</ul>
<hr>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-4.png"></p>
<blockquote>
<p><span class="math inline">\(p.s.\)</span> The <code>auipc</code>
instruction <strong>adds an immediate number to the current PC
value</strong>. This means that the generated address <strong>is
relative to the current instruction</strong>. It add an offset to the PC
(upper 20 bits to the left of the instant number by 12 bits), and use
<code>addi</code> to load the lower 12 bits.</p>
<p><code>lui</code> instructions are used to generate absolute
addresses, which are fixed addresses of data in memory. This approach
works for memory addresses that do not move. It loads an instant number
to the upper 20 bits of the register.</p>
</blockquote>
<h4><span id="clinker">  <span class="math inline">\(c.\)</span>Linker</span></h4>
<p>  Linker is used for <strong>compiling and assembling each procedure
independently</strong>, so that a change to one line would require
resolving only one procedure. It's a system that <strong>combines
independently assembled machine language programs</strong> and
<strong>resolves all undefined labels into an executable
file</strong>.</p>
<p>  There are three steps for the linker:</p>
<ol type="1">
<li>Place code and data modules symbolically in memory.</li>
<li>Determine the addresses of data and instruction labels.</li>
<li>Patch both the internal and external references.</li>
</ol>
<p>  The linker uses the relocation information and symbol table in each
object module to <strong>resolve all undefined labels</strong>.</p>
<ul>
<li>For each entry in the relocation table, it replaces it with
<strong>the actual address for the symbol table of the item</strong> we
are linking to.</li>
</ul>
<p>  If all external references are resolved, the linker next
<strong>determines the memory locations each module will
occupy</strong>. Since the files were assembled in isolation,
<strong>the assembler couldn't know where a module's instructions and
data would be placed relative to other modules</strong>. So when the
linker places a module in memory, all <strong>absolute references, that
is, memory addresses that are not relative to a register</strong>, must
<strong>be relocated to reflect its true location</strong>.</p>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-7.png"></p>
<h4><span id="dtype-of-addressing">  <span class="math inline">\(d.\)</span>Type of addressing</span></h4>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-5.png"></p>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-6.png"></p>
<h4><span id="eloader">  <span class="math inline">\(e.\)</span>Loader</span></h4>
<p><img src="/2024/06/03/3-1-Translating-Starting-a-Program/image-8.png"></p>
<h3><span id="5dynamically-linkedlibraries">5.Dynamically linked
libraries</span></h3>
<p>  In tradition, before the program is run, the library has been
linked. Although this static approach is the fastest way to call library
routines,it has a few disadvantages:</p>
<ol type="1">
<li><p>The library routines become <strong>part of the executable
code</strong>. If a new version of the library is released, <strong>the
statically linked program keeps using the old version</strong>.</p></li>
<li><p>It loads <strong>all routines in the library that are called
anywhere in the executable</strong>, even if those calls are not
executed.</p></li>
</ol>
<p>  A replacement of it is called <em>dynamically linked
libraries</em>, where the library routines are not linked and loaded
<strong>until the program is run</strong>.</p>
<ol type="1">
<li><p>The first time the library routine is called, the program
<strong>calls the dummy entry and follows the indirect branch</strong>,
which points to a piece of code.</p></li>
<li><p>The code <strong>puts a number in a register</strong> to
<strong>identify the desired library routine</strong>.</p></li>
<li><p>Then it branches to the dynamic linker/loader.</p></li>
<li><p>The linker/loader finds the wanted routine, <strong>remaps it
into the memory</strong>, and <strong>changes the address in the
indirect branch location to point to that routine</strong>. Then it
branches to it.</p></li>
</ol>
<blockquote>
<p>The dynamic linker loads the library function into memory on the
first call and updates the indirect branch address. In this way, if the
following call to the library function, the program can directly jump to
the correct memory address, avoid repeated symbol parsing and address
calculation, which improves the efficiency of the program.</p>
</blockquote>
<ol start="5" type="1">
<li>When the routine completes, it <strong>returns to the original
calling site</strong>.</li>
</ol>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 3.Program Process</category>
      </categories>
  </entry>
  <entry>
    <title>3.1.时序逻辑</title>
    <url>/2024/04/04/3-1-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1><span id="31sequential-logic"><span class="math inline">\(3.1.\)</span>Sequential Logic</span></h1>
<h3><span id="1background">1.Background</span></h3>
<p>  In the previous chapter, we've completely ignored the issue of
time:</p>
<ul>
<li><p><strong>Everything happened immediately</strong>, there were
inputs and immediately the outputs were some function of them.</p></li>
<li><p><strong>The inputs never change</strong>, we didn't have any
notion of change.</p></li>
<li><p>We didn't have any notion of things <strong>happening one thing
after another</strong>. Just was some kind of logical mapping from
inputs to outputs.</p></li>
</ul>
<p>  So, there are two things that we want to complement:</p>
<ol type="1">
<li><p>Be able to use the same hardware to <strong>compute many things
one time after another</strong>. We need to be able to reuse our
hardware.</p>
<ul>
<li>For example, if we take some kind of loop in a hard, in a, in some
kind of software program, that the loop calls for doing the same thing
many times, we want to be able to use a same hardware to do that.</li>
</ul></li>
<li><p><strong>Remember things from the past</strong>.When we need to
remember intermediate results,we need to remember where we are in a
computation.</p></li>
</ol>
<h3><span id="2the-clock">2.The clock</span></h3>
<p>  What we're going to do is to <strong>convert the continuous
physical time into discrete time</strong>.</p>
<p>  To do this, we're going to have a <em>clock</em>:</p>
<ul>
<li>It is some kind of <em>oscillator going up and down at a certain
fixed rate</em>.</li>
<li>Each cycle of the clock is treated as one <em>digital integer time
unit</em>.</li>
</ul>
<p><img src="/2024/04/04/3-1-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/image.png"></p>
<ul>
<li><p>With each time unit, we are going to deal it as a indivisible
thing. <em>Nothing changes in a time unit</em>.</p></li>
<li><p>In a time unit, it will compute the output from the input <em>in
an instantaneous manner</em>.</p></li>
</ul>
<h3><span id="3delay">3.Delay</span></h3>
<p>  However, for a physical signal, it doesn't change instantaneously
in a number time between time as we suppose. In reality, the little
course current builds slowly, and the voltage may change slowly. That is
to say, the actual analog signal takes time to reach its final stage,
both input and output.</p>
<p><img src="/2024/04/04/3-1-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/image-1.png"></p>
<p>  Therefore, we will give ourselves enough time between consecutive
time units. For example, we will give the logical operations <em>at the
end of the grey area</em> to make sure that <em>all the hardware there
really stabilizes:</em></p>
<p><img src="/2024/04/04/3-1-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/image-2.png"></p>
<p>  And then,we can simply ignore these inconsistencies because
now,whatever happened before the gray area,we don't need to worry about
it because we know it's gone by the end of the clock cycle.</p>
<h3><span id="4combinatorial-logic">4.Combinatorial logic</span></h3>
<ul>
<li>Combinatorial logic: It's a stateless logic, where <em>the output
depends solely on the current input state:</em><span class="math inline">\(out(t)=f(in(t))\)</span>. Our ALU and bool chips
take this logic.</li>
<li>Sequential logic: <span class="math inline">\(out(t)=f(in(t-1))\)</span>.</li>
</ul>
<h3><span id="5state-feedback">5.State feedback</span></h3>
<ul>
<li><p>The sequential logic points out a new way of thinking, which is
to <strong>consider inputs and outputs as the same bits, capable of
being transmitted on the same bus and occupying the same hardware
location</strong>. This design allows us to <strong>feed output values
back to the input</strong>, creating a <strong>state</strong> rather
than simply passing data. Thus, we can use a particular bit in the
circuit to store state information rather than solely transmitting
data.</p></li>
<li><p>This new way of thinking alters our understanding of time.
Instead of viewing time as continuous, we now divide it into discrete
integer time steps and observe the events happening sequentially at each
time step. This approach enables us to <strong>change the state
incrementally</strong>, remembering the result from the previous time
step at each subsequent step and building upon it.</p></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 3.Memory</category>
      </categories>
  </entry>
  <entry>
    <title>3.2.Introduction to Digital System</title>
    <url>/2024/06/04/3-2-Introduction-to-Digital-System/</url>
    <content><![CDATA[<h1><span id="32introduction-to-digital-system"><span class="math inline">\(3.2.\)</span>Introduction to Digital System</span></h1>
<h3><span id="1logic-gate-representation">1.Logic gate representation</span></h3>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-1.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-2.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-3.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-4.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-5.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-6.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-7.png"></p>
<h3><span id="2using-booleanalgebra-to-simplify-circuits">2.Using boolean
algebra to simplify circuits</span></h3>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-8.png"></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-9.png"></p>
<h3><span id="3build-an-adder">3.Build an Adder</span></h3>
<h4><span id="ahalfadder">  <span class="math inline">\(a.\)</span>Half
adder</span></h4>
<p>  A half adder's output consists of:</p>
<ul>
<li>The <em>sum</em>. It can be computed by <code>xor</code>
method.</li>
<li>The <em>carry</em>. It can be computed by <code>and</code>
method.</li>
</ul>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-10.png"></p>
<h4><span id="bfulladder">  <span class="math inline">\(b.\)</span>Full
adder</span></h4>
<p>  To implement full adder, we just need to add <code>A</code>,
<code>B</code> and the carry at the position <span class="math inline">\(C_i\)</span>.</p>
<p>  The output of a full adder is the same as the half adder. Then how
can we calculate each of them?</p>
<ul>
<li><p>For <span class="math inline">\(C_0\)</span>, it's decided by the
sum of <code>A</code> and <code>B</code> &amp; the current carry in the
position. There are two cases that make the carry 1:</p>
<ol type="1">
<li><code>A + B</code> is 1, and current carry is 1.</li>
<li><code>A + B</code> is 2, and current carry can be 0 or 1.</li>
</ol></li>
</ul>
<p>  So we can compute <span class="math inline">\(C_0\)</span> by this
expression:</p>
<p><span class="math display">\[
C_0 = C_i(A+B) + AB
\]</span></p>
<ul>
<li>The sum is easy, it becomes 1 when 1 or 3 of <code>A</code>,
<code>B</code> and current carry is 1:</li>
</ul>
<p><span class="math display">\[
S = A \; xor B \; xor C_i
\]</span></p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-11.png"></p>
<h4><span id="c4-bit-adder">  $c.$4-bit Adder</span></h4>
<p>  To make a multi-bit Adder, we simply <strong>connect full adder
together</strong>:</p>
<p><img src="/2024/06/04/3-2-Introduction-to-Digital-System/image-12.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 3.Program Process</category>
      </categories>
  </entry>
  <entry>
    <title>3.2.触发器</title>
    <url>/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<h1><span id="32flipflops"><span class="math inline">\(3.2.\)</span>Flip
Flops</span></h1>
<h3><span id="1clocked-data-flip-flops">1.Clocked Data Flip Flops</span></h3>
<p>  To implement the sequential logic, we need an element that
<em>remember one bit of information from <span class="math inline">\(t-1\)</span> so that it can be used at time <span class="math inline">\(t\)</span></em>. It remembers by "flipping"
between the possible states. Such gates that can flip between two states
are called <em>Flip Flop</em>:</p>
<p><img src="/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/image.png"></p>
<p>  Take the clock below as example:</p>
<p><img src="/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/image-1.png"></p>
<ul>
<li>At time 1, we don't exactly know what our output will be because we
haven't specified what happened in the previous time unit. So we just
don't know what the output is.</li>
<li>At time 2, the output is exactly what the input was in time 1,
<code>1</code>.</li>
<li>......</li>
</ul>
<h3><span id="2sequential-logicimplementation">2.Sequential logic
implementation</span></h3>
<p>  Here is a generic paradigm of how we're going to build all our
logic in the computer, and it's going to be a combination
of <em>remembering information via this basic D flip flops</em> and then
<em>manipulating them using combinatorial logics</em>:</p>
<p><img src="/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/image-2.png"></p>
<ul>
<li>We have an array of D flip flops which basically compromise all of
our memory in the system.</li>
<li>Their output is going to be fed into some combinatorial
logic together with the new input that you get in this time unit.</li>
<li>All of this is going to change the state that we have in the D flip
flop for the next time unit.</li>
</ul>
<h3><span id="31-bit-register">3.1-bit Register</span></h3>
<p>  The 1-bit Register has these functionalities:</p>
<ul>
<li>Once we take the load bit and put the 1 into it, we want it
<strong>remember the input bit at that time</strong>.</li>
<li>When the load bit goes down to 0 we want it <strong>keep remembering
the last input that was loaded into it for infinity, until a new load
operation is performed</strong>.</li>
</ul>
<p><img src="/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/image-3.png"></p>
<p>  Notice that there are two source into the DFF: one is the output
from the previous stage, the other is the new input. Whether source to
be chosen is decided by <code>load</code>, so we may use a
<code>Mux</code> to solve this:</p>
<p><img src="/2024/04/04/3-2-%E8%A7%A6%E5%8F%91%E5%99%A8/image-4.png"></p>
<ul>
<li>The DFF serves the purpose of storing and maintaining the previous
input value in this process. When the load bit is set to 1, the DFF
<strong>stores the input value and holds it unchanged until the next
load operation</strong>. When the load bit is 0, the DFF
<strong>maintains the value from the previous load and continues to
output this value in the next time</strong> unit until a new load
operation occurs. Therefore, the DFF is essentially used to remember and
sustain the state of the input value.</li>
<li><strong>The final output is determined by the multiplexer
(Mux)</strong>. The DFF is responsible for storing the previously loaded
value and sending it to the multiplexer based on the state of the load
bit. The multiplexer <strong>selects whether to accept the new input
value or the previously loaded value based on the load bit's
status</strong>, and then outputs the selected value.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 3.Memory</category>
      </categories>
  </entry>
  <entry>
    <title>3.3.Synchronous Digital Systems</title>
    <url>/2024/06/05/3-3-Synchronous-Digital-Systems/</url>
    <content><![CDATA[<h1><span id="33synchronous-digital-systems"><span class="math inline">\(3.3.\)</span>Synchronous Digital Systems</span></h1>
<h3><span id="1clock-concepts">1.Clock concepts</span></h3>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image.png"></p>
<h3><span id="2d-flip-flops">2.D Flip-flops</span></h3>
<h4><span id="a-dffconcept">  <span class="math inline">\(a.\)</span> DFF
concept</span></h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-1.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-2.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-3.png"></p>
<blockquote>
<p>The <span class="math inline">\(Q\)</span> is the output of DFF, the
<span class="math inline">\(D\)</span> is the data input.</p>
</blockquote>
<blockquote>
<p>DFF only responds to the input signal on the rising edge of the clock
signal, it captures and latches the value of data input. <strong>It will
hold the value until the next rising edge of the clock
signal</strong>.</p>
</blockquote>
<ul>
<li><p><em>Clock-to-Q delay</em> is <strong>the amount of time that it
take for the input to propagate to the output after the clock
trigger</strong>.</p></li>
<li><p><em>Setup time</em> is the amount of time that the input needs to
be stable BEFORE the clock trigger</p></li>
</ul>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-4.png"></p>
<ul>
<li><em>Hold time</em> is the amount of time that the input needs to be
stable AFTER the clock trigger</li>
</ul>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-6.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-5.png"></p>
<h3><span id="3register">3.Register</span></h3>
<h4><span id="asomeconcept">  <span class="math inline">\(a.\)</span>Some
concept</span></h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-7.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-8.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-9.png"></p>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-10.png"></p>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-11.png"></p>
<blockquote>
<p>Why this? Because the max hold time is to <strong>ensure that data
input D remains stable for a period of time after the rising edge of the
clock arrives</strong>. And the period of time equals to the delay of
<span class="math inline">\(A\)</span> plus the combinational delay.</p>
</blockquote>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-12.png"></p>
<blockquote>
<p>Why this? Because the min clock cycle is to <strong>ensure that the
signal is properly transmitted during the clock cycle and captured by
the next register</strong>. So we must take the longest time into
consideration.</p>
</blockquote>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-13.png"></p>
<h3><span id="4transitor">4.Transitor</span></h3>
<h4><span id="ametal-oxide-semiconductor-field-effecttransistormosfet">  <span class="math inline">\(a.\)</span>Metal-Oxide Semiconductor Field Effect
Transistor(MOSFET)</span></h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-14.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-15.png"></p>
<p>  To know how the result comes from, we can <strong>view the value of
<span class="math inline">\(S\)</span>, <span class="math inline">\(G\)</span> and <span class="math inline">\(D\)</span> as the voltage</strong>. Take this as
an example:</p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-16.png"></p>
<ul>
<li><p>First we need to know <strong>whether the switch is
closed</strong>. <strong>If the switch is closed, then the state of
<span class="math inline">\(D\)</span> is decided by the outside
circuits</strong>.</p></li>
<li><p>When the switch is on, we then judge <strong>if the voltage of
<span class="math inline">\(S\)</span> is higher than that of <span class="math inline">\(G\)</span></strong>. If it's true, then the FET is
conducting, and vice versa.</p></li>
</ul>
<p>  In this example, the voltage of <span class="math inline">\(S\)</span> is lower than <span class="math inline">\(G\)</span>, so the <span class="math inline">\(D\)</span> can't get the electronic, thus it's
0.</p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-17.png"></p>
<h4><span id="bvddand-ground">  <span class="math inline">\(b.\)</span>Vdd
and Ground</span></h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-18.png"></p>
<h4><span id="cbuilding-an-inverter">  <span class="math inline">\(c.\)</span>Building an Inverter</span></h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-19.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-20.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-21.png"></p>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-22.png"></p>
<h4><span id="dbuilding-other-gates">  <span class="math inline">\(d.\)</span>Building other gates</span></h4>
<p>  To build a CMOS, we:</p>
<ol type="1">
<li><p>Implement the pull-up network and pull-down network separately to
fit the truth table.</p>
<ul>
<li>It's OK to get the opposite of truth table. <strong>We can simply
convert it through an invertor</strong>.</li>
</ul></li>
<li><p>Connect the pull-up with Vdd, and the pull-down with
Ground.</p></li>
</ol>
<p>  We take the <code>NAND</code> gate for example:</p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-23.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-24.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-25.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-26.png"></p>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-27.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-28.png"></p>
<hr>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-29.png"></p>
<h4><span id="ethe-use-of-demorgans-law">  <span class="math inline">\(e.\)</span>The use of DeMorgan's Law</span></h4>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-30.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-31.png"></p>
<p><img src="/2024/06/05/3-3-Synchronous-Digital-Systems/image-32.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 3.Program Process</category>
      </categories>
  </entry>
  <entry>
    <title>3.3.存储单元</title>
    <url>/2024/04/04/3-3-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<h1><span id="33memoryunits"><span class="math inline">\(3.3.\)</span>Memory
Units</span></h1>
<h3><span id="1from-1-bit-to-register">1.From 1-bit to register</span></h3>
<p>  the previous unit ended up with a description of how a single bit
register works. And it doesn't take a big stretch of imagination to
understand that you can <strong>take several such one bit register and
put them one next to the other</strong>. And by doing this, you can
create <em>an abstraction of a 16-bit number</em>.</p>
<p><img src="/2024/04/04/3-3-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/image.png"></p>
<ul>
<li>The <strong>width</strong> of the register, in general, is a
parameter called <span class="math inline">\(w\)</span>. In some
computers it's 16-bit, in other computers it may be 32-bits or
64-bit.</li>
<li>The register's <strong>state</strong> refers to the value which is
currently stored in the register.</li>
</ul>
<p>  let's take a user's perspective of this of this device:</p>
<ul>
<li>How do we <strong>read</strong> the value of this register? We
simply probe the output. Because at any given point of time, the output
simply emits the state of the register.</li>
<li>How do we <strong>write</strong> the value of this register? We set
<code>in</code> to the new value <span class="math inline">\(v\)</span>,
and set <code>load</code> to 1, then the register state becomes 1.</li>
<li>And from the next cycle onward, the output of the register will also
start emitting this value <span class="math inline">\(v\)</span>. From
the next cycle onward, the register will effectively store the value
<span class="math inline">\(v\)</span>. And it will keep on storing this
value forever until we decide to change this value in the very same
manner.</li>
</ul>
<h3><span id="2ram">2.RAM</span></h3>
<p>  A RAM can be abstracted as a sequence of n addressable registers,
with addresses from 0 to n-1:</p>
<p><img src="/2024/04/04/3-3-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/image-1.png"></p>
<ul>
<li>There's one thing very important to emphasize: at any given point
of time, <strong>only one register is selected and only one register is
working</strong>, all the other registers don't take any part in the
game.</li>
</ul>
<p>  Given this fact, we have to say <strong>which is the register on
which we want to operate</strong>, <strong>which is the register that we
want to read</strong>, or <strong>which is the register whose value we
want to change</strong>.</p>
<ul>
<li><p>To <strong>read</strong> a particular register, we:</p>
<ol type="1">
<li>Sent the address to RAM.</li>
<li>Probe the output.</li>
</ol></li>
<li><p>To <strong>write</strong> a particular register, we:</p>
<ol type="1">
<li>Sent the address to RAM.</li>
<li>Set the value and <code>load</code>.</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 3.Memory</category>
      </categories>
  </entry>
  <entry>
    <title>3.4.计数器</title>
    <url>/2024/04/05/3-4-%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1><span id="34counter"><span class="math inline">\(3.4.\)</span>Counter</span></h1>
<h3><span id="1counter-intro">1.Counter intro</span></h3>
<p>  A counter is used to direct certain instruction among instructions.
It contains these features:</p>
<ul>
<li><code>Reset</code>: Fetch the first instruction.</li>
<li><code>Next</code>: Fetch the next instruction.</li>
<li><code>Goto</code>: Fetch instruction n.</li>
</ul>
<p>   Its "black box" diagram looks like this:</p>
<p><img src="/2024/04/05/3-4-%E8%AE%A1%E6%95%B0%E5%99%A8/image.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 3.Memory</category>
      </categories>
  </entry>
  <entry>
    <title>3.4.Building a Datapath</title>
    <url>/2024/06/05/3-4-Building-a-Datapath/</url>
    <content><![CDATA[<h1><span id="34building-a-datapath"><span class="math inline">\(3.4.\)</span>Building a Datapath</span></h1>
<h3><span id="1basic-devices">1.Basic devices</span></h3>
<ul>
<li><p><em>Registers</em>: It contains:</p>
<ul>
<li><p>Two data words from the register file, and <strong>write one data
word into the register file</strong> for each instruction.</p></li>
<li><p>An input. It <strong>specifies the register number to be
read</strong>.</p></li>
<li><p>An output. It <strong>carries the value that has been read from
the register</strong>.</p></li>
<li><p>To write a data word, we need two more inputs: one to
<strong>specify the register number to be written</strong> and one to
<strong>supply the data to be written into the
register</strong>.</p></li>
</ul></li>
</ul>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image.png"></p>
<ul>
<li><em>ALU</em></li>
</ul>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-1.png"></p>
<ul>
<li><em>Immediate generation unit</em>: In operations like
<code>addi x1 x2 10</code>, the immediate number <code>10</code> is
written in 12-bit offset in the instruction. So we need to
<strong>sign-extend the number to a 64-bit signed value</strong>. The
Imm-Gen does the job:</li>
</ul>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-4.png"></p>
<h3><span id="2basic-phases-ofinstruction-execution">2.Basic phases of
instruction execution</span></h3>
<p>  The phases of instruction execution can be divided into 5
parts:</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-2.png"></p>
<hr>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-3.png"></p>
<h3><span id="3implementation-ofdifferent-statement">3.Implementation of
different statement</span></h3>
<h4><span id="aaddinstruction">  <span class="math inline">\(a.\)</span>Add
instruction</span></h4>
<p>  The <code>add</code> is simple, we just get value from
<code>DataA</code> and <code>DataB</code>, and calculate the result by
ALU.</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-7.png"></p>
<p>  To perform <code>addi</code>, we get one of out input from Imm-Gen
rather than <code>DataB</code>. The source of Imm-Gen is from
<code>IMEM</code>, from which we can get the instruction, and
<code>inst[31:20]</code> is the immediate we want:</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-8.png"></p>
<h4><span id="bload-ampsave-instruction">  <span class="math inline">\(b.\)</span><code>load</code> &amp;
<code>save</code> instruction</span></h4>
<p>  To implement the instructions, we can add a <code>DMEM</code> to
read or write data.</p>
<ul>
<li><code>DMEM</code>: It's input is <code>Addr</code> and outputs
<code>DataR</code>. When in "read" mode, it gets information from the
address. Else, it writes the information into the address:</li>
</ul>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-10.png"></p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-11.png"></p>
<h4><span id="cbranch-instruction">  <span class="math inline">\(c.\)</span>Branch instruction</span></h4>
<p>  The basic form of branch instruction is
<code>beq x1 x2 offset</code>. To implement this instruction, we must
compute the branch target address by <strong>adding the sign- extended
offset field of the instruction to the PC</strong>. There are two
details in the definition of branch instructions to which we must pay
attention:</p>
<ul>
<li><p>The instruction set architecture specifies that <strong>the base
for the branch address calculation is the address of the branch
instruction</strong>.</p></li>
<li><p>The architecture also states that <strong>the offset field is
shifted left 1 bit so that it is a half word offset</strong>; this shift
<strong>increases the effective range of the offset field by a factor of
2</strong>.</p></li>
</ul>
<p>  If the branch condtion is true, the branch target address becomes
the new PC, and we say the branch is <strong>taken</strong>. Else, we
say the branch is <strong>not taken</strong>.</p>
<p>  We first get the address of <code>PC+4</code> and branch through
this struction:</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-5.png"></p>
<p>  To select from multiple address, we use a multiplexor and control
signal</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-6.png"></p>
<p>  Combined with the previous struction, we get this design:</p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-9.png"></p>
<h4><span id="djal-ampjalr-instructions">  <span class="math inline">\(d.\)</span><code>jal</code> &amp;
<code>jalr</code> instructions</span></h4>
<p>  <code>jalr</code> does the following things:</p>
<ol type="1">
<li><p>Set <code>PC=Reg[rs1]+immediate</code></p>
<ul>
<li>Uses same immediate as arithmetic and loads. <strong>No multiple by
2 bytes!</strong></li>
</ul></li>
<li><p>Set <code>PC=PC+offset</code></p>
<ul>
<li>Since the offset is calculated by ALU, we <strong>connect the output
of ALU with input of PC</strong>.</li>
</ul></li>
</ol>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-12.png"></p>
<p>  <code>jal</code> does the following things:</p>
<ol type="1">
<li>Save <code>PC+4</code> in <code>Reg[rd]</code>(namely
<code>DataD</code>)</li>
<li>Set <code>PC=PC+offset</code></li>
</ol>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-13.png"></p>
<h3><span id="4datapath-control">4.Datapath control</span></h3>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-14.png"></p>
<p><img src="/2024/06/05/3-4-Building-a-Datapath/image-15.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 3.Program Process</category>
      </categories>
  </entry>
  <entry>
    <title>3.2.scheme语言介绍</title>
    <url>/2024/05/31/3.2.scheme%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1><span id="32scheme语言介绍"><span class="math inline">\(3.2\;scheme\)</span>语言介绍</span></h1>
<h3><span id="1基本表达式">1.基本表达式</span></h3>
<h4><span id="a数字">  <span class="math inline">\(a.\)</span>数字</span></h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; 1234    ; integer</span><br><span class="line">1234</span><br><span class="line">scm&gt; 123.4   ; real number</span><br><span class="line">123.4</span><br></pre></td></tr></table></figure>
<h4><span id="b标志symbol">  <span class="math inline">\(b.\)</span>标志<span class="math inline">\(symbol\)</span></span></h4>
<p>  标志是<span class="math inline">\(scheme\)</span>语言特有的类型。在<span class="math inline">\(scheme\)</span>语言中，标志本身可以作为一个值，而在<span class="math inline">\(python\)</span>中的“标志”只是作为表达式的名称存在。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; quotient      ; A name bound to a built-in procedure</span><br><span class="line">#[quotient]</span><br><span class="line">scm&gt; &#x27;quotient     ; An expression that evaluates to a symbol</span><br><span class="line">quotient</span><br><span class="line">scm&gt; &#x27;hello-world!</span><br><span class="line">hello-world!</span><br></pre></td></tr></table></figure></p>
<h4><span id="c布尔值">  <span class="math inline">\(c.\)</span>布尔值</span></h4>
<p>  在<span class="math inline">\(scheme\)</span>语言中，除了<code>#f</code>外的所有值都是<span class="math inline">\(true\)</span>，这和<span class="math inline">\(python\)</span>的零值为<span class="math inline">\(false\)</span>不同。<span class="math inline">\(scheme\)</span>用<code>#t</code>表示<span class="math inline">\(true\)</span>，用<code>#f</code>表示<span class="math inline">\(false\)</span>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; #t</span><br><span class="line">#t</span><br><span class="line">scm&gt; #f</span><br><span class="line">#f</span><br></pre></td></tr></table></figure></p>
<h3><span id="2调用表达式">2.调用表达式</span></h3>
<p>  与<span class="math inline">\(Python\)</span>类似，<span class="math inline">\(Scheme\)</span>调用表达式中的操作符位于所有操作数之前。与
<span class="math inline">\(Python\)</span>不同，操作符包含在括号内，且操作数用空格而不是逗号分隔，计算的具体流程如下：</p>
<ol type="1">
<li>计算操作符，决定运算规则。</li>
<li>从左到右考虑操作数。</li>
<li>将运算规则作用于操作数上。</li>
</ol>
<p>  这也是<span class="math inline">\(scheme\)</span>语句一般地执行方法。但之后讲解的规则与这个不同，被称作“特殊规则”。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (+ 1 2)</span><br><span class="line">3</span><br><span class="line">scm&gt; (- 10 (/ 6 2))</span><br><span class="line">7</span><br><span class="line">scm&gt; (modulo 35 4)</span><br><span class="line">3</span><br><span class="line">scm&gt; (even? (quotient 45 2))</span><br><span class="line">#t</span><br></pre></td></tr></table></figure></p>
<h3><span id="3控制结构">3.控制结构</span></h3>
<h4><span id="aif语句">  <span class="math inline">\(a.\)</span><code>if</code>语句</span></h4>
<p>  <span class="math inline">\(scheme\)</span>中的<code>if</code>语句结构如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if &lt;predicate&gt; &lt;if-true&gt; [if-false])</span><br></pre></td></tr></table></figure></p>
<p>  该结构的<code>&lt;if-true&gt;</code>部分与<code>[if-false]</code>部分只能接受一个表达式，与<span class="math inline">\(python\)</span>不同。该结构的一个运行实例如下：</p>
<p><img src="/2024/05/31/3.2.scheme%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/image.png"></p>
<p>  <span class="math inline">\(scheme\)</span>中没有<code>elif</code>语句，实现该功能只能通过<code>if</code>的嵌套：</p>
<p><img src="/2024/05/31/3.2.scheme%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/image-1.png"></p>
<h4><span id="bcond表达式">  <span class="math inline">\(b.\)</span><code>cond</code>表达式</span></h4>
<p>  <code>cond</code>表达式类似<code>switch</code>语句，其结构如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(cond</span><br><span class="line">    (&lt;p1&gt; &lt;e1&gt;)</span><br><span class="line">    (&lt;p2&gt; &lt;e2&gt;)</span><br><span class="line">    ...</span><br><span class="line">    (&lt;pn&gt; &lt;en&gt;)</span><br><span class="line">    [(else &lt;else-expression&gt;)])</span><br></pre></td></tr></table></figure>
  每个从句中的第一个表达式就相当于<code>&lt;predicate&gt;</code>，当<code>&lt;predicate&gt;</code>为真，就执行后面的语句并终止程序。该表达式的一个具体实例如下：</p>
<p><img src="/2024/05/31/3.2.scheme%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D/image-2.png"></p>
<h3><span id="4数据结构">4.数据结构</span></h3>
<h4><span id="a链表">  <span class="math inline">\(a.\)</span>链表</span></h4>
<p>  <span class="math inline">\(scheme\)</span>中的链表是通过一系列<span class="math inline">\(pair\)</span>构建的，它通过<span class="math inline">\(constructor\)</span><code>cons</code>创建。</p>
<p>  链表的<span class="math inline">\(rest\)</span>元素，即<code>cdr</code>操作，是别的链表或<code>nil</code>，空链表：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (cons 1 (cons 2 (cons 3 nil)))</span><br><span class="line">(1 2 3)</span><br></pre></td></tr></table></figure></p>
<p>  可以通过<code>car</code>与<code>cdr</code>语句获取链表中的元素值：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (define a (cons 1 (cons 2 (cons 3 nil))))  ; Assign the list to the name a</span><br><span class="line">a</span><br><span class="line">scm&gt; a</span><br><span class="line">(1 2 3)</span><br><span class="line">scm&gt; (car a)</span><br><span class="line">1</span><br><span class="line">scm&gt; (cdr a)</span><br><span class="line">(2 3)</span><br><span class="line">scm&gt; (car (cdr (cdr a)))</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>  如果在<span class="math inline">\(pair\)</span>中不传入另一个<span class="math inline">\(pair\)</span>或<code>nil</code>作为<code>cons</code>的第二个参数，程序会报错：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (cons 1 2)</span><br><span class="line">Error</span><br></pre></td></tr></table></figure></p>
<h4><span id="b列表">  <span class="math inline">\(b.\)</span>列表</span></h4>
<p>  创建列表的方法有很多种，可以直接用<code>list</code>创建：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (list 1 2 3)</span><br><span class="line">(1 2 3)</span><br><span class="line">scm&gt; (list 1 (list 2 3) 4)</span><br><span class="line">(1 (2 3) 4)</span><br><span class="line">scm&gt; (list (cons 1 (cons 2 nil)) 3 4)</span><br><span class="line">((1 2) 3 4)</span><br></pre></td></tr></table></figure></p>
<p>  注意<code>cons</code>函数只能接受两个参数，如果要在一个链表里面插入多个元素，可以采用多个<code>cons</code>嵌套的方法：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (interleave first second)</span><br><span class="line">  &#x27;YOUR-CODE-HERE</span><br><span class="line">  (cond</span><br><span class="line">  ((null? first) second)</span><br><span class="line">  ((null? second) first)</span><br><span class="line">  (else (cons (car first)</span><br><span class="line">    (cons (car second)</span><br><span class="line">      (interleave (cdr first) (cdr second))))))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>  还可以通过单引号语句创建，语句中的<code>'</code>不会被读入：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; &#x27;(1 2 3)</span><br><span class="line">(1 2 3)</span><br><span class="line">scm&gt; &#x27;(cons 1 2)           ; Argument to quote is not evaluated</span><br><span class="line">(cons 1 2)</span><br><span class="line">scm&gt; &#x27;(1 (2 3 4))</span><br><span class="line">(1 (2 3 4))</span><br></pre></td></tr></table></figure></p>
<p>  列表有与<span class="math inline">\(python\)</span>类似的操作：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (null? nil)                ; Checks if a value is the empty list</span><br><span class="line">True</span><br><span class="line">scm&gt; (append &#x27;(1 2 3) &#x27;(4 5 6)) ; Concatenates two lists</span><br><span class="line">(1 2 3 4 5 6)</span><br><span class="line">scm&gt; (length &#x27;(1 2 3 4 5))      ; Returns the number of elements in a list</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<h3><span id="5定义语句">5.定义语句</span></h3>
<p>  定义语句用于定义变量与函数。定义语句的结构如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define &lt;name&gt; &lt;expression&gt;)</span><br></pre></td></tr></table></figure>
  该语句通过以下流程实现： 1. 计算<code>&lt;expression&gt;</code>的值 2.
将值与<code>name</code>绑定 3. 返回<code>name</code></p>
<p>  只有在调用<code>define</code>时<code>&lt;body&gt;</code>才会被执行。</p>
<h3><span id="6lambdas">6.<span class="math inline">\(lambdas\)</span></span></h3>
<p>  <span class="math inline">\(scheme\)</span>中的<span class="math inline">\(lambda\)</span>语句如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(lambda (&lt;param1&gt; &lt;param2&gt; ...) &lt;body&gt;)</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(lambda\)</span>的具体实例如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scm&gt; (lambda (x y) (+ x y))        ; Returns a lambda function, but doesn&#x27;t assign it to a name</span><br><span class="line">(lambda (x y) (+ x y))</span><br><span class="line">scm&gt; ((lambda (x y) (+ x y)) 3 4)  ; Create and call a lambda function in one line</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 3.Interpreting Computer Programs</category>
      </categories>
  </entry>
  <entry>
    <title>3.5.Pipelined Datapath and Control</title>
    <url>/2024/06/07/3-5-Pipelined-Datapath-and-Control/</url>
    <content><![CDATA[<h1><span id="35pipelined-datapath-and-control"><span class="math inline">\(3.5.\)</span>Pipelined Datapath and Control</span></h1>
<h3><span id="1some-point">1.Some point</span></h3>
<ul>
<li><p>All the instructions go from left to right through the datapath
except the write-back stage and the selection of the next value of PC,
and they never move backward.</p>
<ul>
<li>So the first right-to-left flow of data can lead to data hazards
while the second leads to control hazards.</li>
</ul></li>
<li><p>One way to show what happens in pipelined execution is to pretend
that each instruction has its own datapath, and then to place these
datapaths on a timeline to show their relationship:</p></li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image.png"></p>
<p>  All instructions advance during each clock cycle from one pipeline
register to the next.</p>
<h3><span id="2pipeline-registers">2.Pipeline registers</span></h3>
<ul>
<li><p>A separate pipeline register is redundant to the state that is
updated. For example, a load instruction will place its result in one of
the 32 registers, and any later instruction that needs that data will
<strong>simply read the appropriate register</strong>.</p>
<ul>
<li>Every instruction updates PC, and the PC can be thought of as a
pipeline register: one <strong>that feeds the IF stage of the
pipeline</strong>.</li>
</ul></li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-1.png"></p>
<p>  We use the command <code>ld</code> to illustrate the pipe stage
that is active in each stage:</p>
<ol type="1">
<li><em>Instruction fetch</em>: The PC is saved in the IF/ID pipeline
register in case it's needed later for an instruction. This stage occurs
<strong>before the instruction is identified</strong>.</li>
</ol>
<blockquote>
<p>The computer cannot know which type of instruction is being fetched,
so it must <strong>prepare for any instruction, passing potentially
needed information down the pipeline</strong>.</p>
</blockquote>
<ol start="2" type="1">
<li><em>Instruction decode and register file read</em>: Both the two
read value and sign-extended immediate are stored in the ID/EX pipeline
register, along with PC address.</li>
</ol>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-2.png"></p>
<ol start="3" type="1">
<li><em>Execute/address calculation</em>: It reads the information from
the ID/EX pipeline register and add then using ALU. The result is placed
in EX/MEM pipeline register.</li>
</ol>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-3.png"></p>
<ol start="4" type="1">
<li><em>Memory access</em>: It uses the data from EX/MEM register and
loads the data into MEM/WB pipeline register.</li>
</ol>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-4.png"></p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-5.png"></p>
<ol start="5" type="1">
<li><em>Write back</em>: There's nothing to do in this stage.</li>
</ol>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-6.png"></p>
<p>  From the analysis above, we can get some key point:</p>
<ul>
<li><p>The information must be placed in a pipeline register, otherwise,
<strong>the information is lost when the next instruction enters that
pipeline stage</strong>.</p></li>
<li><p>Each logical component of the datapath(ALU, data memory, etc),
can be used <strong>only within a single pipeline stage</strong>. That
is, <strong>each pipeline register can only be used by one phase in one
clock cycle</strong>, which ensures that <strong>no more than one
instruction can access the same hardware resources simultaneously in one
clock cycle</strong>, thus avoiding structural dangers.</p></li>
</ul>
<p>  We know that the instruction in IF/ID pipeline register supplies
the writer register number, but the instruction fetch procedure occurs
after the <code>ld</code> instruction(because it is conducted before an
instruction is identified, so only when we complete the <code>ld</code>
instruction will this step be done)! Hence, we need to <strong>preserve
the distination register number in the <code>ld</code>
instruction</strong>. The <code>ld</code> must pass the register number
from ID/EX through EX/MEM to the MEM/WB pipeline register for use in the
WB stage.</p>
<h3><span id="3data-hazards-amp-forwarding">3.Data hazards &amp; forwarding</span></h3>
<h4><span id="adatahazards">  <span class="math inline">\(a.\)</span>Data
hazards</span></h4>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-7.png"></p>
<h4><span id="bdetact-hazards">  <span class="math inline">\(b.\)</span>Detact hazards</span></h4>
<p>  We first introduce a notation: we use "ID/EX.RegisterRs1" to refer
to the number of 1 register whose value is found in the pipeline
register ID/EX.</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-8.png"></p>
<p>  Using this notation, the two pairs of hazard conditions are:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-9.png"></p>
<ul>
<li>The <code>sub-and</code> is a type 1a hazard:</li>
</ul>
<p><span class="math display">\[
MEM/WB.RegisterRd=ID/EX.RegisterRs2=x2
\]</span></p>
<ul>
<li><p>The <code>sub-or</code> is a type 2a hazard.</p></li>
<li><p>There's no data hazard between <code>sub</code> and
<code>sd</code> because <strong><code>sd</code> reads <code>x2</code>
the clock cycle after <code>sub</code> writes
<code>x2</code></strong>.</p></li>
</ul>
<blockquote>
<p>Pay attention to the clock cycle, not the name!!!</p>
</blockquote>
<p>  One way to detact the hazards is simple <strong>check if the
<code>RegWrite</code> signal is active</strong>. This can be done by
<strong>examing the <code>WB</code> control field of the pipeline
register during the <code>EX</code> and <code>MEM</code>
stages</strong>.</p>
<blockquote>
<p>Recall that RISC-V requires that <code>x0</code> is taken as an
oprand value of 0, if an instruction in the pipeline has <code>x0</code>
as its destination, we want to <strong>avoid forwarding its possibly
nonzero value</strong>.</p>
</blockquote>
<h4><span id="csolution">  <span class="math inline">\(c.\)</span>Solution</span></h4>
<p>  If we can take the inputs to the ALU <strong>from any pipeline
register rather than just ID/EX</strong>, then we can forward the
correct data.</p>
<p>  By <strong>adding multiplexors to the input of the ALU, and with
the proper controls</strong>, we can run the pipeline at full speed in
the presence of these data hazards:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-10.png"></p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-11.png"></p>
<blockquote>
<p>Before forwarding, the ID/EX register has no need to include space to
hold the rs1 and rs2 fields, so they are added to ID/EX.</p>
</blockquote>
<h4><span id="ddetailed-detection-ampresolution">  <span class="math inline">\(d.\)</span>Detailed detection &amp;
resolution</span></h4>
<ul>
<li><p>EX hazard:</p>
<ul>
<li>If there's a write operation and a load operation at the same time,
and the loaded object is under writting, then there's an EX hazard:</li>
</ul></li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-12.png"></p>
<p>  This case forwards the result from the previous instruction to
either input of the ALU instead of the pipeline register EX/MEM</p>
<ul>
<li><p>MEM hazard</p>
<ul>
<li>If the writting part is just loaded.</li>
</ul></li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-13.png"> <img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-14.png"></p>
<blockquote>
<p>What happens when a register is read and written in the same clock
cycle? We assume that <strong>the write is in the first half of the
clock cycle and the read is in the second half</strong>, so the read
delivers what is written. As is the case for many implementations of
register files, we have no data hazard in this case.</p>
<p>As mentioned above, there is no hazard in the WB stage, because
<strong>we assume that the register file supplies the correct
result</strong> if the instruction in the ID stage reads the same
register written by the instruction in the WB stage.</p>
</blockquote>
<p>  One complication occurs when we all read and write to a same
register:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add x1 x1 x2</span><br><span class="line">add x1 x1 x3</span><br><span class="line">add x1 x1 x4</span><br></pre></td></tr></table></figure>
<p>  In this case, <strong>the result should be forwarded from the MEM
stage, because the MEM stage is the more recent result</strong>. Thus,
the control for the MEM should be:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-15.png"></p>
<blockquote>
<p>Why <code>not EX/MEM.RegisterRd = ID/EX.RegisterRs1</code>? Because
if this is true, then <strong>the instruction of EX/MEM should be
written back into the register</strong>(because it's the most current),
and it will cover the result of MEM/WB. So we take EX/MEM first.</p>
</blockquote>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-16.png"></p>
<h4><span id="estalls">  <span class="math inline">\(e.\)</span>Stalls</span></h4>
<p>  One case where forwarding cannot help is when <strong>an
instruction tries to read a register following a load instruction that
writes the same register</strong>:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-17.png"></p>
<blockquote>
<p>The RAM is used by <code>add</code> before it's updated, and it won't
be updated until the <code>lw</code> ends. Since it must be used in the
first step, forwarding cannot help.</p>
</blockquote>
<p>  Hence, we also need a <em>hazard detection unit</em>. It operates
during the ID stage so that it can insert the stall between the load and
the instruction depentent on it:</p>
<ul>
<li>If it's in a load process, and the being-loaded object involves in
other process.</li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-18.png"></p>
<p>  If the instruction in the ID stage is stalled, then the instruction
in the IF stage must also be stalled, or we will lose the fetch of
instruction. Therefore, <strong>the instruction in the IF stage will
continue to be read using the same PC</strong>. The EX stage must also
be doing something, so we let it <strong>execute instructions that have
no effect: nops</strong>.</p>
<p>  <strong>Deasserting all seven control signals(setting them to 0) in
the EX, MEM, WB stages</strong> will create a nop instruction:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-19.png"></p>
<ul>
<li><p>The forwarding unit controls the ALU multiplexor s to replace the
value from a general-purpose register with that in the pipeline
register.</p></li>
<li><p>The hazard detection unit controls the writing of the PC and
IF/ID registers plus the multiplexor that choose between the real
control values and all 0s.</p></li>
</ul>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-20.png"></p>
<h3><span id="4control-hazards">4.Control hazards</span></h3>
<h4><span id="aassume-branch-not-taken">  <span class="math inline">\(a.\)</span>Assume branch not taken</span></h4>
<p>  We can assume the branch is not taken. If the condition branch is
taken instead, <strong>the instructions that are being fetched and
decoded must be discarded</strong>.</p>
<p>  To discard instructions, we merely change the original control
values to 0s. Notice that we must also change the three instructions in
the IF, ID and EX stages when the branch reaches the MEM stage, which is
called <em>flush</em>.</p>
<p>  To flush instructions in the IF, we <strong>add a control line
called IF.Flush</strong>, it zeros the instruction field of the IF/ID
pipeline register.</p>
<h4><span id="breducing-the-delay-of-branches">  <span class="math inline">\(b.\)</span>Reducing the delay of branches</span></h4>
<p>  One way to improve conditional branch performance is to reduce the
cost of taken branch. We have assumed that the next PC for a branch is
selected in the MEM stage, but <strong>if we move the conditional branch
execution earlier in the pipeline, then fewer instructions need be
flushed</strong>.</p>
<p>  Moving the branch decision up requires two actions to occur
earlier: computing the branch target address and evaluating the branch
decision.</p>
<p>  Moving up the address calculation is easy, we can <strong>move the
branch adder from EX stage to ID stage</strong>.</p>
<p>  The harder part is branch decision itself. We must deal with two
complicate factors:</p>
<ol type="1">
<li><p>The introduction of equlity test unit.</p></li>
<li><p>Because <strong>the value in a branch comparison is needed during
ID but may be produced later in time</strong>, it is possible that a
data hazard can occur and a stall will be needed.</p></li>
</ol>
<h3><span id="5dynamic-branch-prediction">5.Dynamic branch prediction</span></h3>
<ul>
<li>This method looks up the address of the instruction to see
<strong>if the conditional branch was taken the last time this
instruction was executed</strong>, and, if so, to <strong>begin fetching
new instructions from the same place as the last time</strong>.</li>
</ul>
<p>  One implementation of this approach is a <em>branch prediction
buffer</em> or <em>branch history table</em>. A branch prediction buffer
is a small memory indexed by the lower portion of the address of the
branch instruction. The memory contains <strong>a bit that says whether
the branch was recently taken or not</strong>.</p>
<ul>
<li>Fetching begins in the predicted direction. If the predition turns
out to be wrong, the incorrectly predicted instructions are deleted, the
predition bit is inverted and stored back, and the proper sequence is
fetched and executed.</li>
</ul>
<blockquote>
<p>  To improve the accuracy, the <em>2-bit prediction schemes</em> are
often used. In a 2-bit scheme, <strong>a prediction must be wrong twive
before it is changed</strong>:</p>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-21.png"></p>
</blockquote>
<hr>
<p><img src="/2024/06/07/3-5-Pipelined-Datapath-and-Control/image-22.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 3.Program Process</category>
      </categories>
  </entry>
  <entry>
    <title>3.4.带有组合的语言的解释器</title>
    <url>/2024/05/31/3.4.%E5%B8%A6%E6%9C%89%E7%BB%84%E5%90%88%E7%9A%84%E8%AF%AD%E8%A8%80%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
    <content><![CDATA[<h1><span id="34带有组合的语言的解释器interpretersforlanguageswithcombination">3.4
带有组合的语言的解释器(<span class="math inline">\(Interpreters\;for\;Languages\;with\;Combination\)</span>)</span></h1>
<h2><span id="一-概述">一、概述</span></h2>
<p>  在程序中，我们不仅可以定义一个新语言，还可以通过<strong>构建解释器(<span class="math inline">\(interpreter\)</span>)</strong>
来实现这些语言。而<strong>编程语言的解释器就是一个函数，这个函数在用在表达式或语言上时，可以表现出相应的行为来执行它们</strong>。</p>
<p>  <span class="math inline">\(scheme\)</span>语言计算器(<span class="math inline">\(Scheme-Syntax\;Calculator\)</span>)是用于加减乘除操作的表达式语言。它使用<span class="math inline">\(scheme\)</span>的句法规则与<span class="math inline">\(operator\)</span>行为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (+ 1 2 3 4)</span><br><span class="line">10</span><br><span class="line">&gt; (+)</span><br><span class="line">0</span><br><span class="line">&gt; (* 1 2 3 4)</span><br><span class="line">24</span><br><span class="line">&gt; (*)</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">&gt; (- 10 1 2 3)</span><br><span class="line">4</span><br><span class="line">&gt; (- 3)</span><br><span class="line">-3</span><br><span class="line">&gt; (/ 15 12)</span><br><span class="line">1.25</span><br><span class="line">&gt; (/ 30 5 2)</span><br><span class="line">3</span><br><span class="line">&gt; (/ 10)</span><br><span class="line">0.1</span><br></pre></td></tr></table></figure></p>
<p>  调用表达式(<span class="math inline">\(call\;expression\)</span>)的计算方法是<strong>计算它的子表达式，然后将运算符用于计算后的结果</strong>：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (- 100 (* 7 (+ 8 (/ -12 -3))))</span><br><span class="line">16.0</span><br></pre></td></tr></table></figure></p>
<h2><span id="二-表达式树expressiontrees">二、表达式树<span class="math inline">\(Expression\;Trees\)</span></span></h2>
<p>  一个<strong>最原始的表达式是一个单独的数字或字符串</strong>，其数据类型为<code>int</code>或<code>float</code>或<code>operator symbol</code>.而<strong>一个调用表达式是一个<span class="math inline">\(scheme\;list\)</span></strong>，表达式的<strong>第一个元素是操作符<span class="math inline">\(operator\)</span></strong>，后面<strong>是<span class="math inline">\(0\)</span>或者更多的操作元表达式(<span class="math inline">\(operand\;expression\)</span>)</strong>。<strong>所有的组合表达式都是调用表达式</strong>。</p>
<h3><span id="1pair">1.<code>Pair</code></span></h3>
<p>  <code>List</code>是嵌套的<code>Pair</code>，反之则不然。因此有必要定义一个单独的<code>Pair</code>型。</p>
<p>  在<span class="math inline">\(scheme\)</span>中，<code>Pair</code>类是用<span class="math inline">\(python\)</span>表示的<span class="math inline">\(scheme\)</span>值，它们有<code>repr</code>的<span class="math inline">\(python\)</span>表达式和<code>str</code>的<span class="math inline">\(scheme\)</span>表达式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Pair(1, Pair(2, nil))</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">Pair(1, Pair(2, nil))</span><br><span class="line">&gt;&gt;&gt; print(s)</span><br><span class="line">(1 2)</span><br></pre></td></tr></table></figure></p>
<p>  它们实现了长度、元素选择等基本的<span class="math inline">\(python\)</span>序列接口，其中的<code>map</code>方法会<strong>返回一个映射后的<span class="math inline">\(scheme\)</span>列表</strong>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x+<span class="number">4</span>))</span><br><span class="line">(<span class="number">5</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
<h3><span id="2嵌套列表">2.嵌套列表</span></h3>
<p>  嵌套<code>Pair</code>能够表达<code>List</code>，而<code>List</code>自身也可以通过嵌套得到新的<code>List</code>。因此，<code>Pair</code>足够表示所有的<code>List</code>型数据，也因此足够表示所有的<span class="math inline">\(Scheme\)</span>表达式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; expr = Pair(&#x27;+&#x27;, Pair(Pair(&#x27;*&#x27;, Pair(3, Pair(4, nil))), Pair(5, nil)))</span><br><span class="line">&gt;&gt;&gt; print(expr)</span><br><span class="line">(+ (* 3 4) 5)</span><br><span class="line">&gt;&gt;&gt; print(expr.second.first)</span><br><span class="line">(* 3 4)</span><br><span class="line">&gt;&gt;&gt; expr.second.first.second.first</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
  上述例子说明了<strong>所有的计算表达式都是嵌套的<span class="math inline">\(Scheme\)</span><code>List</code></strong>。我们的计算器解释器将会<strong>读入这些嵌套的<span class="math inline">\(Scheme\)</span><code>List</code>，将它们转化为用嵌套<code>Pair</code>实例代表的表达式树，然后通过计算表达式树来产生值</strong>。</p>
<h2><span id="三-对表达式的语法分析">三、对表达式的语法分析</span></h2>
<h3><span id="1概述">1.概述</span></h3>
<p>  语法分析(<span class="math inline">\(parsing\)</span>)是<strong>从原始文本输入产生表达式</strong>的过程。</p>
<p>  语法翻译器由两部分构成：<strong>词法分析器(<span class="math inline">\(lexical\;analyzer\)</span>)</strong>
和<strong>句法分析器(<span class="math inline">\(syntactic\;analyzer\)</span>)</strong>。首先，词法分析器<strong>将输入文本分成标记(<span class="math inline">\(tokens\)</span>)</strong>。标记是<strong>最小的句法单元</strong>，如<code>name</code>、<code>symbol</code>类型。然后，句法分析器<strong>通过标记序列(<span class="math inline">\(tokens\;sequence\)</span>)搭建表达式树</strong>，消耗掉词法分析器产生的标记序列。</p>
<h3><span id="2词法分析">2.词法分析</span></h3>
<p>  <strong>将字符串解释为标记序列</strong>的部分称为标记器(<span class="math inline">\(tokenizer\)</span>)或词法分析器。在我们的实现中，标记器是<code>tokenize_line</code>函数。</p>
<p>  <span class="math inline">\(scheme\)</span>的标记间由空格、逗号、点等符号相隔。<strong>标记器一个字符一个字符地分析句子，验证其中符号(<span class="math inline">\(symbol\)</span>)与数字(<span class="math inline">\(numeral\)</span>)的格式</strong>。下面是一个标记器的分析结果：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokenize_line(<span class="string">&#x27;(+ 1 (* 2.3 45))&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="number">2.3</span>, <span class="number">45</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;)&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<p>  词法分析是一个迭代的过程，它可以独立地用于一个输入程序的每一行。</p>
<h3><span id="3句法分析">3.句法分析</span></h3>
<p>  将<strong>标记序列转化为表达式树</strong>的部分被称为句法分析器。句法分析是一个树形递归(<span class="math inline">\(tree-recursive\)</span>)的过程，它不仅要考虑行内表达式，还要考虑扩张到多个行的表达式。</p>
<p>  句法分析是通过<code>scheme_read</code>函数实现的。它是树形递归的，因为<strong>分析一个标记序列经常需要将它的一些子列分析进一个子表达式中，子表达式本身充当较大表达式树的分支</strong>。递归生成了<strong>计算器使用的层次结构(<span class="math inline">\(hierarchical\;structure\)</span>)</strong>。</p>
<p>  <code>scheme_read</code>函数希望它的<code>src</code>输入是一个允许访问标记序列的<span class="math inline">\(Buffer\)</span>实例。<span class="math inline">\(Buffer\)</span>会<strong>将扩展到很多行的标记收集为一个单独的对象</strong>，这个对象可以被进行句法分析：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = [<span class="string">&#x27;(+ 1&#x27;</span>, <span class="string">&#x27;   (* 2.3 45))&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expression = scheme_read(Buffer(tokenize_lines(lines)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expression</span><br><span class="line">Pair(<span class="string">&#x27;+&#x27;</span>, Pair(<span class="number">1</span>, Pair(Pair(<span class="string">&#x27;*&#x27;</span>, Pair(<span class="number">2.3</span>, Pair(<span class="number">45</span>, nil))), nil)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(expression)</span><br><span class="line">(+ <span class="number">1</span> (* <span class="number">2.3</span> <span class="number">45</span>))</span><br></pre></td></tr></table></figure></p>
<p>  <code>scheme_read</code>函数先检查众多基础的情况，包括空的输入(<span class="math inline">\(empty\;input\)</span>)(这会导致<span class="math inline">\(end-of-file\)</span>错误，即<code>EOFError</code>)和基本表达式。<strong>只要<code>(</code>标记了列表的开头，<code>read_tail</code>就被递归地调用</strong>。</p>
<p>  <code>read_tail</code>函数也从同样的<code>src</code>中读取，但它希望<strong>在<code>List</code>的开头被调用</strong>。它的基本情况(<span class="math inline">\(base\;cases\)</span>)是一个<strong>空输入(<code>EOF</code>)或者一个结束括号(<code>)</code>)终止列表</strong>。它的递归调用会<strong>先使用<code>scheme_read</code>读取<code>List</code>中的第一个元素，再用<code>read_tail</code>读入<code>List</code>中的剩余元素，然后返回一个用<code>Pair</code>表示的列表</strong>。</p>
<p>  提供信息的句法错误大大提高了解释器的可用性，它引发的<code>SyntaxError</code>异常包括了所遇到问题的声明。</p>
<h2><span id="四-计算器的计算">四、计算器的计算</span></h2>
<h3><span id="1计算器表达式的转换">1.计算器表达式的转换</span></h3>
<p>  对于计算器，<strong>唯一的两个合法的句法形式是数字(<span class="math inline">\(numbers\)</span>)和调用表达式(<span class="math inline">\(call\;expressions\)</span>)</strong>，即经过良好组织的<span class="math inline">\(scheme\)</span><code>List</code>，它们是以<code>Pair</code>形式存在的。数字自己就可以计算出一个值，它们可以直接被<code>calc_eval</code>返回。而<strong>调用表达式需要对其应用函数(<span class="math inline">\(function\;application\)</span>)才可返回值</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_eval</span>(<span class="params">exp</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Evaluate a Calculator expression.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># number type</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(exp) <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>):</span><br><span class="line">            <span class="keyword">return</span> simplify(exp)</span><br><span class="line">        <span class="comment"># list type as pair instance</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(exp, Pair):</span><br><span class="line">            arguments = exp.second.<span class="built_in">map</span>(calc_eval)</span><br><span class="line">            <span class="keyword">return</span> simplify(calc_apply(exp.first, arguments))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(exp + <span class="string">&#x27; is not a number or call expression&#x27;</span>)</span><br></pre></td></tr></table></figure>   这里，当传入的参数为<span class="math inline">\(call\;expression\)</span>时，<code>argument</code>对<code>Pair</code>除了第一个元素外的所有元素<strong>调用<code>calc_eval</code>函数，并通过<code>map</code>操作将结果映射到原来的<code>Pair</code>中</strong>，最后对只有两个元素的<code>Pair</code>进行最后的化简。</p>
<p>  <code>calc_eval</code>的结构是根<strong>据类型分派的典型例子：根据表达式形式分派</strong>。</p>
<p>  这里引入一个新的概念：不需要多余计算步骤的原始表达式叫作“自我计算式”(<span class="math inline">\(self-evaluating\)</span>)，除了数字，字符串、布尔值都是自我计算式。</p>
<h3><span id="2计算器的计算">2.计算器的计算</span></h3>
<p>  可以通过如下程序实现表达式的计算，其中的每一个条件语句分别作用于一个操作符：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_apply</span>(<span class="params">operator, args</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Apply the named operator to a list of args.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(operator, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="built_in">str</span>(operator) + <span class="string">&#x27; is not a symbol&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> operator == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> reduce(add, args, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> operator == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> TypeError(operator + <span class="string">&#x27; requires at least 1 argument&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(args) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -args.first</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> reduce(sub, args.second, args.first)</span><br><span class="line">        <span class="keyword">elif</span> operator == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> reduce(mul, args, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> operator == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> TypeError(operator + <span class="string">&#x27; requires at least 1 argument&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(args) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>/args.first</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> reduce(truediv, args.second, args.first)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(operator + <span class="string">&#x27; is an unknown operator&#x27;</span>)</span><br></pre></td></tr></table></figure>
  <code>calc_apply</code>函数可以直接调用，但传入的参数<strong>必须是值的列表</strong>而不是操作数表达式(<span class="math inline">\(a\;list\;of\;operand\;expressions\)</span>)：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_apply(<span class="string">&#x27;+&#x27;</span>, as_scheme_list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_apply(<span class="string">&#x27;-&#x27;</span>, as_scheme_list(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_apply(<span class="string">&#x27;*&#x27;</span>, nil)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_apply(<span class="string">&#x27;*&#x27;</span>, as_scheme_list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_apply(<span class="string">&#x27;/&#x27;</span>, as_scheme_list(<span class="number">40</span>, <span class="number">5</span>))</span><br><span class="line"><span class="number">8.0</span></span><br></pre></td></tr></table></figure></p>
<p>  先前的<code>calc_eval</code>的作用是<strong>先计算操作数子表达式的值，然后决定合适的<code>calc_apply</code>调用</strong>。因此，<code>calc_eval</code><strong>可以接受嵌套表达式</strong>作为参数：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(exp)</span><br><span class="line">(+ (* <span class="number">3</span> <span class="number">4</span>) <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc_eval(exp)</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="3读取-计算-打印流程">3.“读取-计算-打印”流程</span></h3>
<h4><span id="a解释器的一般范式">  <span class="math inline">\(a.\)</span>解释器的一般范式</span></h4>
<p>  与解释器交互的一般流程是
<strong>“读取-计算-打印”流程</strong>，即：先读入表达式，再计算表达式，最后打印计算出的值。</p>
<p>  下面展示这一流程的一般实现。<code>read_eval_print_loop</code>函数先将用户的输入<span class="math inline">\(buffer\)</span>化，然后用特定语言函数(<span class="math inline">\(language-specific\)</span>)构建表达式，最后打印通过<code>calc_eval</code>计算出的结果：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_eval_print_loop</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run a read-eval-print loop for calculator.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            src = buffer_input()</span><br><span class="line">            <span class="keyword">while</span> src.more_on_line:</span><br><span class="line">                expression = scheme_read(src)</span><br><span class="line">                <span class="built_in">print</span>(calc_eval(expression))</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; (* <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; (+)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt; (+ <span class="number">2</span> (/ <span class="number">4</span> <span class="number">8</span>))</span><br><span class="line"><span class="number">2.5</span></span><br><span class="line">&gt; (+ <span class="number">2</span> <span class="number">2</span>) (* <span class="number">3</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">&gt; (+ <span class="number">1</span></span><br><span class="line">     (- <span class="number">23</span>)</span><br><span class="line">     (* <span class="number">4</span> <span class="number">2.5</span>))</span><br><span class="line">-<span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<h4><span id="b优化">  <span class="math inline">\(b.\)</span>优化</span></h4>
<p>  上述交互接口包含所有接口必须的要素，但是缺少终止与错误处理机制。我们可以通过将错误报告给用户对其进行优化：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_eval_print_loop</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run a read-eval-print loop for calculator.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                src = buffer_input()</span><br><span class="line">                <span class="keyword">while</span> src.more_on_line:</span><br><span class="line">                    expression = scheme_read(src)</span><br><span class="line">                    <span class="built_in">print</span>(calc_eval(expression))</span><br><span class="line">            <span class="keyword">except</span> (SyntaxError, TypeError, ValueError, ZeroDivisionError) <span class="keyword">as</span> err:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">type</span>(err).__name__ + <span class="string">&#x27;:&#x27;</span>, err)</span><br><span class="line">            <span class="keyword">except</span> (KeyboardInterrupt, EOFError):  <span class="comment"># &lt;Control&gt;-D, etc.</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Calculation completed.&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure>   这一流程实现报告用户的错误，但不退出流程：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; )</span><br><span class="line">SyntaxError: unexpected token: )</span><br><span class="line">&gt; <span class="number">2.3</span><span class="number">.4</span></span><br><span class="line">ValueError: invalid numeral: <span class="number">2.3</span><span class="number">.4</span></span><br><span class="line">&gt; +</span><br><span class="line">TypeError: + <span class="keyword">is</span> <span class="keyword">not</span> a number <span class="keyword">or</span> call expression</span><br><span class="line">&gt; (/ <span class="number">5</span>)</span><br><span class="line">TypeError: / requires exactly <span class="number">2</span> arguments</span><br><span class="line">&gt; (/ <span class="number">1</span> <span class="number">0</span>)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure></p>
<h2><span id="五-总结">五、总结</span></h2>
<p>  当我们将我们的解释器用于新的语言时，我们会发现<code>read_eval_print_loop</code><strong>被解析函数、计算函数、错误输出语句参数化</strong>了。除了这些差别，所有的<span class="math inline">\(REPLs\)</span>都可以用相同的框架实现。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 3.Interpreting Computer Programs</category>
      </categories>
  </entry>
  <entry>
    <title>3.5.包含抽象的语言的解释器</title>
    <url>/2024/05/31/3.5.%E5%8C%85%E5%90%AB%E6%8A%BD%E8%B1%A1%E7%9A%84%E8%AF%AD%E8%A8%80%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
    <content><![CDATA[<h1><span id="35包含抽象的语言的解释器interpretersforlanguageswithabstraction"><span class="math inline">\(3.5\)</span>包含抽象的语言的解释器(<span class="math inline">\(Interpreters\;for\;Languages\;with\;Abstraction\)</span>)</span></h1>
<p>  先前<code>Calcualtor</code>的实现并未给出定义新操作、给变量命名、表达计算的一般方法等的实现。下面给出描述性的实现方法：</p>
<h3><span id="1结构">1.结构</span></h3>
<p>  一个<span class="math inline">\(scheme\)</span>解释器和先前的计算器解释器有很多相似的结构：</p>
<ul>
<li><strong>分析器</strong>通过计算器解释(<span class="math inline">\(evaluator\;interpretation\)</span>)来<strong>产生一个表达式</strong>。</li>
<li><strong>计算函数侦测表达式的形式</strong>；对于<strong>调用表达式，它会调用一个函数用于处理某些参数</strong>。</li>
</ul>
<p>  两者的计算器(<span class="math inline">\(evaluator\)</span>)的区别存在于特殊的形式(<span class="math inline">\(special\;form\)</span>)，用户定义函数(<span class="math inline">\(user-defined\;function\)</span>)和实现计算所需的环境模型(<span class="math inline">\(the\;environment\;model\;of\;computation\)</span>)。</p>
<h4><span id="a解析parsing">  <span class="math inline">\(a.\)</span>解析(<span class="math inline">\(Parsing\)</span>)</span></h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; read_line(&quot;(car &#x27;(1 . 2))&quot;)</span><br><span class="line">Pair(&#x27;car&#x27;, Pair(Pair(&#x27;quote&#x27;, Pair(Pair(1, 2), nil)), nil))</span><br></pre></td></tr></table></figure>
<h4><span id="b计算evaluation">  <span class="math inline">\(b.\)</span>计算(<span class="math inline">\(evaluation\)</span>)</span></h4>
<p>  <span class="math inline">\(Scheme\)</span>每次计算一个表达式。每个<strong>通过<code>scheme_read</code>返回的表达式</strong>都<strong>传递给<code>scheme_eval</code>函数</strong>，它会在当前环境<code>env</code>中计算表达式<code>expr</code>。</p>
<p>  <code>scheme_eval</code>函数会计算<span class="math inline">\(Scheme\)</span>中的不同表达式类型：初始型(<span class="math inline">\(primitive\)</span>)，特殊型(<span class="math inline">\(special\;form\)</span>)和调用表达式(<span class="math inline">\(call\;expression\)</span>)。每种形式都有它们对应的计算法则：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scheme_eval</span>(<span class="params">expr, env</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Evaluate Scheme expression expr in environment env.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> scheme_symbolp(expr):</span><br><span class="line">            <span class="keyword">return</span> env[expr]</span><br><span class="line">        <span class="keyword">elif</span> scheme_atomp(expr):</span><br><span class="line">            <span class="keyword">return</span> expr</span><br><span class="line">        first, rest = expr.first, expr.second</span><br><span class="line">        <span class="keyword">if</span> first == <span class="string">&quot;lambda&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> do_lambda_form(rest, env)</span><br><span class="line">        <span class="keyword">elif</span> first == <span class="string">&quot;define&quot;</span>:</span><br><span class="line">            do_define_form(rest, env)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            procedure = scheme_eval(first, env)</span><br><span class="line">            args = rest.<span class="built_in">map</span>(<span class="keyword">lambda</span> operand: scheme_eval(operand, env))</span><br><span class="line">            <span class="keyword">return</span> scheme_apply(procedure, args, env)</span><br></pre></td></tr></table></figure></p>
<h4><span id="c过程调用procedureapplication">  <span class="math inline">\(c.\)</span>过程调用(<span class="math inline">\(Procedure\;application\)</span>)</span></h4>
<p>  过程调用通过<code>scheme_apply</code>实现。它比起先前的<code>calc_apply</code>更具普遍性。它接受两类参数：<code>PrimitiveProcedure</code>或<code>LambdaProcedure</code>。</p>
<p>  <code>PrimitiveProcedure</code>是在<span class="math inline">\(python\)</span>中实现的，它有一个<code>fn</code>的实例属性(<span class="math inline">\(instance\;attribute\)</span>)，<strong>每当过程被调用，这个函数就被调用</strong>。</p>
<p>  <code>LambdaProcedure</code>是在<span class="math inline">\(scheme\)</span>中实现的。它有一个<code>body</code>属性，这是一个<span class="math inline">\(scheme\)</span>表达式，<strong>每当过程被调用它就被调用</strong>。为了将该过程用于一系列参数，<code>body</code>表达式<strong>会在一个新环境里被调用</strong>。为了搭建环境，<strong>一个新的框架被加入进环境中，在这个框架中，过程的形式参数(<span class="math inline">\(formal\;parameters\)</span>)与变量(<span class="math inline">\(argument\)</span>)绑定</strong>。<code>body</code><strong>通过<code>scheme_eval</code>计算</strong>。</p>
<h4><span id="d递归调用与计算evalapplyrecursion">  <span class="math inline">\(d.\)</span>递归调用与计算(<span class="math inline">\(Eval/apply\;recursion\)</span>)</span></h4>
<p>  实现计算过程的<code>scheme_eval</code>和<code>scheme_apply</code>是<strong>相互递归</strong>的(<span class="math inline">\(mutually\;recursive\)</span>)。<strong>每当一个调用表达式被计算，计算函数都需要被调用</strong>。而<strong>应用函数使用计算函数将操作元表达式作为参数，并计算用户定义的过程这一部分(<span class="math inline">\(user-defined\;procedures\)</span>)</strong>。这一相互递归的过程是由下面这个过程决定的：计算函数是通过(<span class="math inline">\(in\;terms\;of\)</span>)应用函数定义的，而应用函数又是通过计算函数定义的。</p>
<p>  递归的循环<strong>以语言原语(<span class="math inline">\(language\;primitive\)</span>)结束</strong>。计算函数<strong>有一个用于计算基本表达式的基本情况</strong>。一些特殊形式(<span class="math inline">\(special\;form\)</span>)也是不需要递归调用的基本情况。</p>
<p>  这种<strong>处理表达式形式(<span class="math inline">\(expression\;form\)</span>)</strong> 的<span class="math inline">\(eval\)</span>函数与<strong>处理函数及其参数</strong>的<span class="math inline">\(apply\)</span>函数相互递归调用的结构组成了计算过程的核心。</p>
<h3><span id="2环境">2.环境</span></h3>
<h4><span id="a基本结构">  <span class="math inline">\(a.\)</span>基本结构</span></h4>
<p>  我们希望实现一个<code>Frame</code>类来构建环境。<strong>每个<code>Frame</code>的实例都代表一个环境</strong>，在这个实例中，<strong>标记(<span class="math inline">\(symbol\)</span>)与值(<span class="math inline">\(value\)</span>)相绑定</strong>。</p>
<p>  <code>Frame</code>实例由<strong>一个<code>binding</code>字典和<code>parant</code>框架</strong>构成。对于<span class="math inline">\(Global\)</span>框架，<code>parent=None</code>。</p>
<h4><span id="bbinding和define">  <span class="math inline">\(b.\)</span><code>binding</code>和<code>define</code></span></h4>
<p>  <code>binding</code>并不是直接访问的，它通过两个<code>Frame</code>方法访问：<code>lookup</code>和<code>define</code>。<code>lookup</code>过程会在<strong>我们的环境模型中执行<span class="math inline">\(lookup\)</span>过程</strong>。然后<strong>符号与当前<code>frame</code>的<code>binding</code>相匹配</strong>。如果它<strong>找到了，它相关联的值就被返回</strong>；否则，<code>lookup</code>过程会<strong>在<code>parent frame</code>继续该过程</strong>。而<code>define</code>方法<strong>在当前<code>frame</code>中将标记与值相绑定</strong>。</p>
<p>  考虑下面的程序： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (factorial n)</span><br><span class="line">  (if (= n 0) 1 (* n (factorial (- n 1)))))</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(factorial 5)</span><br><span class="line">120</span><br></pre></td></tr></table></figure></p>
<p>  定义这样一个函数有以下步骤：</p>
<ol type="1">
<li><strong>检查表达式的格式(<span class="math inline">\(format\)</span>)</strong>，确保<strong>它是一个完备的<span class="math inline">\(Scheme\)</span>列表，至少有两个元素与关键字<span class="math inline">\(define\)</span></strong>。</li>
<li><strong>分析第一个元素</strong>。在本例中，寻找函数名称<span class="math inline">\(factorial\)</span>和形式参数<span class="math inline">\(list(n)\)</span>。</li>
<li><strong>用提供的形式参数创造一个<code>LambdaProcedure</code>，<code>body</code>和<code>parent</code>环境</strong>。</li>
<li><strong>在当前环境的第一个<code>frame</code>中，将<span class="math inline">\(factorial\)</span>标志与这个函数绑定</strong>。</li>
</ol>
<p>  第二个输入是一个调用表达式。传给<code>scheme_apply</code>的过程是与<span class="math inline">\(factorial\)</span>相绑定的<code>LambdaProcedure</code>。<strong>为了应用这一过程，一个新的框架创建了，扩展了原来的父框架</strong>。在这个框架中，标志<span class="math inline">\(n\)</span>与值<span class="math inline">\(5\)</span>绑定。然后，<span class="math inline">\(factorial\)</span>的<code>body</code>部分在这个环境中被计算，它的值也被返回。</p>
<h3><span id="3作为程序的数据">3.作为程序的数据</span></h3>
<p>  我们可以从模拟(<span class="math inline">\(analogy\)</span>)的角度来看待程序。对程序含义的操作观点(<span class="math inline">\(optional\;view\)</span>)认为：<strong>程序是对一个抽象机器的描述</strong>。以先前的函数为例：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (factorial n)</span><br><span class="line">  (if (= n 0) 1 (* n (factorial (- n 1)))))</span><br></pre></td></tr></table></figure></p>
<p>  我们可以将这个程序看作对一个机器的描述，这个机器包括减法、乘法、相等性测试、双向开关和另一个<span class="math inline">\(factorial\)</span>机器(由于一个机器内部可以嵌套另一个机器，这个机器是<strong>无限的</strong>)：</p>
<p><img src="/2024/05/31/3.5.%E5%8C%85%E5%90%AB%E6%8A%BD%E8%B1%A1%E7%9A%84%E8%AF%AD%E8%A8%80%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8/image-3.png"></p>
<p>  相似地，我们可以将<span class="math inline">\(Scheme\)</span>解释器视为一个特别的机器，<strong>它将一个对机器的描述作为输入。对于这个输入，解释器配置好自己来模拟这个描述的机器</strong>。</p>
<p>  从这个角度，我们的<span class="math inline">\(Scheme\)</span>解释器是一种具有普遍性的机器。<strong>当其它机器在<span class="math inline">\(Scheme\)</span>程序中被描述时，解释器会模拟这些机器。它扮演着被编程语言操纵的数据对象和编程语言本身之间的桥梁</strong>。对于用户的输入，解释器将其视为一个简单的句子，并通过一系列完备规则操作它们。</p>
<p>  计算作为执行过程一部分的表达式是一个有活力的编程语言所具的特点。在程序的执行过程中创建并计算表达式的能力是一个有力的工具。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 3.Interpreting Computer Programs</category>
      </categories>
  </entry>
  <entry>
    <title>4.2.机器语言组成元素</title>
    <url>/2024/04/04/4-2-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1><span id="42the-elements-of-machine-language"><span class="math inline">\(4.2.\)</span>The Elements of Machine Language</span></h1>
<h3><span id="1machine-language">1.Machine language</span></h3>
<ul>
<li><p>The machine language is a most important <em>interface between
hardware and software</em>. It's exactly the way software can control
hardware.</p>
<ul>
<li>What are the supported operations?</li>
<li>What do they operate on?</li>
<li>How is the program controlled?</li>
</ul></li>
<li><p>This kind of interface is done in a almost one-to-one
correspondence with the actual hardware implementation. The idea is that
the hardware is built in a way that directly corresponds to <em>the type
of functionality that is provided by the software layer above
it</em>.</p></li>
<li><p>When we actually go to design a machine language, the basic
element is a <em>cost-performance tradeoff</em>. The more sophisticated
operations that we want to give our machine language, the more <em>large
or sophisticated data types</em> it operates on, the more
<em>costly</em> it will be to actually build this.</p></li>
<li><p>Each machine language defines a set of operations which fall into
several categories:</p>
<ul>
<li><strong>Arithmetic Operations</strong>: add, subtract, ...</li>
<li><strong>Logical Operations</strong>: <code>And</code>,
<code>Or</code>, ...</li>
<li><strong>Flow Control</strong>: <code>goto instructionX</code>,
<code>if C then goto instruction Y</code></li>
</ul></li>
</ul>
<h3><span id="2memory">2.Memory</span></h3>
<ul>
<li><p>accessing memory is an expensive operation in at least two
related points of view :</p>
<ol type="1">
<li>If you have a large memory, specifying what part of memory you want
to work with requires a large amount of bits.</li>
<li>It's going to be wasteful in terms of instruction, for accessing a
value from a large memory takes relatively long time.</li>
</ol></li>
</ul>
<p>  To solve this, we introduce memory hierarchy*:</p>
<ul>
<li><p>The basic idea is instead of having just one large block of
memory, we're going to have a whole sequence of memories that
<strong>are getting bigger and bigger</strong>.</p>
<ul>
<li><p>The smallest memories are going to be very easy to access.
Because:</p>
<ol type="1">
<li>We don't have to specify large address space because there are only
going to be a very few of them.</li>
<li>The amount of them is small, so we can get information from them
very quickly.</li>
</ol></li>
<li><p>Then, there is going to be slight larger memories called
<em>cache</em>.</p></li>
<li><p>And even big memory, called <em>main memory</em>.</p></li>
<li><p>And maybe even even larger memory called <em>disk</em>.</p></li>
</ul></li>
</ul>
<p><img src="/2024/04/04/4-2-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0/image.png"></p>
<ul>
<li>At each time we get farther away from the arithmetic unit itself,
our memory gets bigger, accessing it becomes harder both in terms of
giving a larger, wider address, and in terms of the time we need to wait
until we get the value. But we have more information there.</li>
</ul>
<h3><span id="3registers">3.Registers</span></h3>
<ul>
<li><p>Almost every CPU has a few <em>easy-accessed registers</em> that
are located inside the CPU. Since there are so few of them and
everything requires very few bits, getting the information of them is
extremely quickly.</p></li>
<li><p>There are two kinds of register:</p>
<ol type="1">
<li><p><em>Data Registers</em>: We can put numbers, etc, in the
register. And when we are saying something like add the register 1 to
register 2, what will happen is <strong>the contents of register
1</strong> will be added to <strong>the contents of register
2</strong>.</p></li>
<li><p><em>Address Register</em>: We can put into the register an
address into main memory. It allow us to specify at which part of the
bigger memory we want to access for operations.</p>
<ul>
<li>For example, say we have a operation like storing the contents of
register 1 into memory address that is specified by that register called
A. Once we actually perform this operation in the hardware, the number
77 will be written into the main memory.</li>
</ul></li>
</ol></li>
</ul>
<p><img src="/2024/04/04/4-2-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0/image-1.png"></p>
<h3><span id="4addressing-modes">4.Addressing modes</span></h3>
<ul>
<li><em>Register</em>: <span class="math inline">\(e.g.\)</span><code>Add R1 R2</code> means adding
R2 to R1.</li>
<li><em>Direct</em>: We can have direct access to memory.<span class="math inline">\(e.g.\)</span> <code>Add R1 M[200]</code> means
adding R1 to memory location <code>200</code>.</li>
<li><em>Indirect</em>: This is a example we had previously for using the
A register where the <code>@A</code> memory address that we access is
not specified as part of instruction, but rather is already written
inside <em>the address register</em> that <strong>was previously loaded
inside the CPU with some correct value</strong>.<span class="math inline">\(e.g.\)</span> <code>Add R1 @A</code></li>
<li><em>Immediate</em>: <span class="math inline">\(e.g.\)</span>
<code>Add R1 73</code></li>
</ul>
<h3><span id="5dealing-with-input-andoutput">5.Dealing with input and
output</span></h3>
<ul>
<li><p>One way to actually access these input or output
devices(keyboard, for example) is to actually <strong>connect the
registers which control these output devices as part of your
memory</strong>.</p>
<ul>
<li>For example, we may have a mouse that is connected in a way that
whenever the user moves the mouse, the last movement is written into
some kind of a register. And that register is accessible by the computer
in a certain address as part of the memory. This gives us access to
input and output as though we are accessing the memory itself.</li>
</ul></li>
<li><p>Software are usually part of the <strong>drivers</strong> in an
operating system. It must know exactly not only <strong>what are the
addresses to which this input or output device is connected</strong>,but
also <strong>how to speak with it</strong>.</p></li>
</ul>
<h3><span id="6flow-control">6.Flow control</span></h3>
<ul>
<li>Sometimes we need to "jump" unconditionally to another location, for
example:</li>
</ul>
<p><img src="/2024/04/04/4-2-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0/image-2.png"></p>
<ul>
<li>Sometimes we need to jump only if some condition is met, for
example:</li>
</ul>
<p><img src="/2024/04/04/4-2-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0/image-3.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>4.3.机器语言</title>
    <url>/2024/04/04/4-3-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1><span id="43machine-language"><span class="math inline">\(4.3.\)</span>Machine Language</span></h1>
<h3><span id="1background-knowledge-ofhack-computer">1.Background knowledge of
Hack Computer</span></h3>
<h4><span id="ahardware">  <span class="math inline">\(a.\)</span>Hardware</span></h4>
<p><img src="/2024/04/04/4-3-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/image.png"></p>
<ul>
<li><em>Data memory</em>(RAM): It is a sequence of 16-bit values.And
each of these values is going to be stored in a memory register</li>
<li><em>Instruction memory(ROM)</em>: It is a separate memory space that
is also a sequence of 16 bit values.</li>
<li><em>CPU</em>: It is a device which is capable of
<strong>manipulating 16 bit values</strong> using mostly the ALU which
resides inside the CPU.</li>
<li><em>Instruction buses, data buses, address buses</em>: It enables us
to move data from one place to another.</li>
</ul>
<p>  The Hack machine language recognizes three registers:</p>
<ul>
<li>D holds a 16-bit value</li>
<li>A holds a 16-bit value</li>
<li>M represents the 16-bit RAM register addressed by A</li>
</ul>
<h4><span id="blanguage">  <span class="math inline">\(b.\)</span>Language</span></h4>
<ul>
<li><p>The Hack machine language includes:</p>
<ul>
<li>16-bit A-instructions</li>
<li>16-bit C-instructions</li>
</ul></li>
</ul>
<h4><span id="cregister">  <span class="math inline">\(c.\)</span>Register</span></h4>
<p>  The hack computer recognizes three registers:</p>
<ol type="1">
<li><em>D register</em>: It holds a 16-bit data which represent a piece
of <strong>data</strong>.</li>
<li><em>A register</em>: It holds a 16-bit data which represent either a
<strong>data value</strong> or an <strong>address</strong>.</li>
<li><em>M register</em>. It is called <strong>selected memory
register</strong>.</li>
</ol>
<h3><span id="2syntax">2.Syntax</span></h3>
<h4><span id="aainstruction">  <span class="math inline">\(a.\)</span>A
instruction</span></h4>
<ul>
<li><p>Syntax: <code>@value</code>, value is either:</p>
<ul>
<li>a non-negative decimal constant or</li>
<li>a symbol referring to such a constant</li>
</ul></li>
<li><p>Semantics:</p>
<ol type="1">
<li>Sets the A register to value</li>
<li>Side effect: RAM[A]becomes the selected RAM register.</li>
</ol></li>
<li><p>We always need A instruction before we operate on the
memory.</p></li>
</ul>
<p>  <span class="math inline">\(e.g.\)</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//set RAM[100] to -1</span><br><span class="line">@100 //A = 100</span><br><span class="line">M = -1 //RAM[100] = -1, M denotes register number 100 in the memory unit</span><br></pre></td></tr></table></figure> ####
  <span class="math inline">\(b.\)</span>C instruction</p>
<ul>
<li><p>syntax:`dest=comp; jump.</p></li>
<li><p><code>comp</code> contains:<code>0</code>, <code>1</code>,
<code>-1</code>, <code>D</code>, <code>A</code>, <code>-D</code>,
<code>!A</code>, <code>D-A</code>, <code>D+1</code>, <code>D-M</code>,
etc.</p></li>
<li><p><code>dest</code>: We have 8 possible
destination:<code>null</code>, <code>D</code>, <code>M</code>,
<code>MD</code>, <code>A</code>, <code>AM</code>, <code>AD</code>,
<code>AMD</code>(<code>M</code> refers to RAM)</p>
<ul>
<li><code>null</code> means we don't want to to store the results of a
computation at all.</li>
<li>We can store the result in RAM register or D-register and
simultaneously both in M and in D. That is, we can simultaneously in
more than one containers, and the programmer is free to use any he
wants.</li>
<li><code>jump</code>: <code>null</code>, <code>JGT</code>,
<code>JEQ</code>, <code>JGE</code>, <code>JLT</code>, <code>JNE</code>,
<code>JLE</code>,<code>JMP</code>. They always compare the result of the
computation to 0. And <code>if (comp jump 0)</code> jumps to execute the
instruction in RAM[A].<br>
</li>
<li>If we want to do unconditional jump, we do <code>0; JMP</code>.</li>
</ul></li>
<li><p>Semantics:</p>
<ol type="1">
<li>Compute the value of comp</li>
<li>Stores the result in dest:</li>
<li>If the Boolean expression (comp jump B)is true,</li>
<li>jumps to execute the instruction stored in ROM[A].</li>
</ol></li>
</ul>
<p>  <span class="math inline">\(e.g.\)</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//if (D-1==0) jump to execute the instruction stored in ROM[56]</span><br><span class="line">@56</span><br><span class="line">D-1; JEQ</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>4.1.Caches</title>
    <url>/2024/06/14/4-1-Caches/</url>
    <content><![CDATA[<h1><span id="41caches"><span class="math inline">\(4.1.\)</span>Caches</span></h1>
<h3><span id="1-some-concepts-amp-libraryanalogy">1. Some concepts &amp; Library
analogy</span></h3>
<blockquote>
<p>Suppose you were a student writing a term paper on important
historical developments in computer hardware. You are sitting at a desk
in a library with a collection of books that you have pulled from the
shelves and are examining. You find that several of the important
computers that you need to write about are described in the books you
have, but there is nothing about the EDSAC. Therefore, you go back to
the shelves and look for an additional book. You find a book on early
British computers that covers the EDSAC. Once you have a good selection
of books on the desk in front of you, there is a high probability that
<strong>many of the topics you need can be found in them, and you may
spend most of your time just using the books on the desk without
returning to the shelves</strong>. Having several books on the desk in
front of you saves time compared to having only one book there and
constantly having to go back to the shelves to return it and take out
another.</p>
<p>The same principle allows us to create the illusion of a large memory
that we can access as fast as a very small memory. Just as you did not
need to access all the books in the library at once with equal
probability, <strong>a program does not access all of its code or data
at once with equal probability</strong>. Otherwise,it would be
impossible to make most memory accesses fast and still have large memory
in computers, just as it would be impossible for you to fit all the
library books on your desk and still find what you wanted quickly.</p>
</blockquote>
<p>  The above line illustrates the <em>principel of locality</em>.
There are two kinds of localities:</p>
<ul>
<li><p>Temporal locality(locality in time): <strong>If an item is
referenced, it will tend to be referenced again soon.</strong> (If you
recently brought a book to your desk to look at, you will probably need
to look at it again soon.)</p></li>
<li><p>Spatial locality (locality in space): <strong>If an item is
referenced, items whose addresses are close by will tend to be
referenced soon.</strong> (For example, when you brought out the book on
early English computers to learn about the EDSAC, you also noticed that
there was another book shelved next to it about early mechanical
computers, so you likewise brought back that book and, later on, found
something useful in that book.)</p></li>
</ul>
<p>  We take advantage of the principle of locality by implementing the
memory as a <em>memory hierarchy</em>. It contains multiple levels, but
<strong>data are copied between only two adjacent levels at a
time</strong>.</p>
<p><img src="/2024/06/14/4-1-Caches/image.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-1.png"></p>
<blockquote>
<p>The faster memories are <strong>more expensive per bit</strong> than
the slower and thus are <strong>smaller</strong>.</p>
</blockquote>
<p><img src="/2024/06/14/4-1-Caches/image-2.png"></p>
<ul>
<li>If <strong>the data requested by the processor appear in some block
in the upper level</strong>, it's called a <em>hit</em>(like you find a
book on your desk). Else it's called a <em>miss</em>.</li>
</ul>
<p><img src="/2024/06/14/4-1-Caches/image-28.png"></p>
<h3><span id="2memory-technologies">2.Memory technologies</span></h3>
<p><img src="/2024/06/14/4-1-Caches/image-3.png"></p>
<h3><span id="3caches-basics">3.Caches basics</span></h3>
<h4><span id="adirect-mapped-structure">  <span class="math inline">\(a.\)</span>Direct-mapped structure</span></h4>
<p>  For each word, we can assign a location in cache based on the
<em>address</em> of the word in memory, and this is called
<strong>direct-mapped</strong>.</p>
<p>  The struction uses this mapping to find a block:</p>
<p><span class="math display">\[
(blockAddress)\mod (numberOfBlockInCache)
\]</span></p>
<ul>
<li>We add a set of <em>tags</em> to the cache to judge if the data in
the cache corresponds to a requested word. The tag needs to contain
<strong>the upper portion of the address</strong>:</li>
</ul>
<p><img src="/2024/06/14/4-1-Caches/image-4.png"></p>
<ul>
<li><p>We add a <em>valid bit</em> to <strong>indicate whether an entry
contains a valid address</strong>. If the bit isn's set, there cannot be
a match for this block.</p></li>
<li><p>A <em>cache index</em> is used to <strong>select the
block</strong>.</p></li>
</ul>
<p><img src="/2024/06/14/4-1-Caches/image-5.png"></p>
<p>  The digit capacity of tage field and the total number of bits in
the struction can be calculated by the following steps:</p>
<p><img src="/2024/06/14/4-1-Caches/image-6.png"></p>
<h4><span id="bdealing-with-missing-rate">  <span class="math inline">\(b.\)</span>Dealing with missing rate</span></h4>
<ul>
<li><p><strong>Larger blocks exploit spatial locality to lower miss
rates</strong>. This is because larger blocks <strong>contain more
adjacent data</strong>, taking advantage of locality of reference,
making it more likely that programs will hit the cache when they access
the data.</p></li>
<li><p>However, the miss rate may go up eventually if <strong>the block
size becomes a significant fraction of the cache size</strong>, for
<strong>there will be a great deal of competition for those
blocks</strong>. As a result, a block will be bumped out of the cache
before its words are accessed.</p></li>
<li><p>Also, enlarging the block size makes the <em>miss penalty</em>
larger.</p>
<ul>
<li><p>The miss penalty is determined by <strong>the time required to
fetch the block from the next lower level of the hierarchy and load it
into the cache</strong>.</p></li>
<li><p>The time to fetch the block has two parts: <strong>the latency to
the first word</strong> and <strong>the transfer time for the rest of
the block</strong>.</p></li>
</ul></li>
</ul>
<h3><span id="4handling-cache-misses">4.Handling cache misses</span></h3>
<p>  The cache miss handling is done in collaboration with the
<em>process control unit</em> and with a separate <em>controller</em>
that initiates the memory access and refills the cache.</p>
<ul>
<li>The control unit in cache must detect a miss and process the miss by
fetching the requested data from memory. If the cache reports a hit, it
uses the data as usual.</li>
</ul>
<p>  To handle the <em>instruction misses</em>, we need to:</p>
<ol type="1">
<li><p>Send the original PC value to the memory. It equals to
<code>PC-4</code>.</p></li>
<li><p>Instruct main memory to perform a read and wait for the memory to
complete its access.</p></li>
<li><p>Write the cache entry, putting the data from memory in the data
portion of the entry, writing the upper bits of the address(from the
ALU)into the tag field, and turning the valid bit on.</p></li>
<li><p><strong>Restart the instruction execution at the first
step</strong>, which will refetch the instruction, this time
<strong>finding it in the cache</strong>.</p></li>
</ol>
<h3><span id="5handling-writes">5.Handling writes</span></h3>
<h4><span id="awrite-through">  <span class="math inline">\(a.\)</span>Write-through</span></h4>
<p>  One simple way to deal with write hit is <strong>always to write
the data into both the memory and the cache</strong>. However, the write
to main memory takes a long time, thus reduce the performance.</p>
<p>  One solution is to use a <em>write buffer</em>. It <strong>stores
the data while they are waiting to be written to memory</strong>.</p>
<ul>
<li><p>After writing the data into the cache and the write buffer, the
processor continues execution.</p></li>
<li><p>When a write to main memory completes, the entry in the write
buffer is freed.</p></li>
<li><p>If the write buffer is full when the processor reaches a write,
the processor must <strong>stall until there's an empty position in the
buffer</strong>.</p></li>
</ul>
<h4><span id="bwrite-back">  <span class="math inline">\(b.\)</span>Write-back</span></h4>
<p>  When a write occurs, the new value is written only to the block in
the cache. The modified block is written to the lower level of the
hierarchy when <strong>it's replaced</strong>. This scheme is called
<em>write-back</em>. It can improve performance especially if
<strong>processors can generate writes faster than writes can be handled
by the main memory</strong>.</p>
<ul>
<li><p>In the write-through process, we can simply overwrite the block.
But in a write-back process, if we overwrite a block <strong>before we
knew whether the store had hit the cache</strong>, we may destroy the
contents of the block which isn't backed up. To avoid this, we take the
two methods:</p>
<ul>
<li><p>We use two cycles, one to <strong>check for hit</strong> and one
to <strong>perform the write</strong>.</p></li>
<li><p>Or we can use a <em>store buffer</em> to hold the data. When it's
used, the processor does the cache lookup and <strong>places the data in
the store buffer during the normal cache access cycle</strong>. The new
data <strong>are written from the store buffer into the cache on the
next unused cache access cycle</strong>.</p></li>
</ul></li>
</ul>
<blockquote>
<p>By comparison, we can always use one cycle to do writing in
write-through process. We read the tag and write the data portion of the
selected block. If the tag matches the address of the current block, the
processor continues normally, since the correct block has been updated.
Otherwise, the processor <strong>generates a write miss to fetch the
rest of the block corresponding to that address</strong>.</p>
</blockquote>
<p>  Many write-back caches also include <em>write buffers</em> that are
used to <strong>reduce the miss penalty when a miss replaces a modified
block</strong>. In such a case, <strong>the modified block is moved to a
write-back buffer associated with the cache</strong> while the requested
block is read from memory. The write-back buffer is later written back
to memory.</p>
<blockquote>
<p>The main idea is not to touch the main memory as much as
possible.</p>
</blockquote>
<p><img src="/2024/06/14/4-1-Caches/image-11.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-20.png"></p>
<h4><span id="cwrite-allocate-amp-nowrite-allocate">  <span class="math inline">\(c.\)</span>Write-allocate &amp; No
write-allocate</span></h4>
<p>  In write-through process, to deal with the write miss, we
<strong>allocate a block in the cache called write allocate</strong>.
The block is fetched from memory and then the appropriate portion of the
block is overwritten.</p>
<blockquote>
<p>This reduces the number of accesses to main memory and increases the
speed of access.</p>
</blockquote>
<p>  Another strategy is to update the portion of the block <strong>in
memory but not put it in the cache</strong>. This is because sometimes
we need to write in the entire blocks of data, and in such situation
writing in cache is unnecessary.</p>
<p><img src="/2024/06/14/4-1-Caches/image-21.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-22.png"></p>
<blockquote>
<p>Since write-through strategy ensures the consistence between memory
and cache, if we use write-allocate strategy, the cache will contain
reduntant data block, which makes cache management more difficult.</p>
<p>And for write-back, this ensures the data consistence.</p>
</blockquote>
<h4><span id="danexample">  <span class="math inline">\(d.\)</span>An
example</span></h4>
<p><img src="/2024/06/14/4-1-Caches/image-7.png"></p>
<p>  In this design, the steps for reading request are as follows:</p>
<ol type="1">
<li><p>Send the address to the appropriate cache.</p></li>
<li><p>If the cache signal hit, the requested word is available on the
data lines. A <em>block index</em> field is used to control the
multiplexor to select the required word from the 16 words in the indexed
block.</p></li>
<li><p>If the cache signals miss, <strong>we send the address to the
main memory. When the memory returns with the data</strong>, we write it
into the cache and then read it to fulfill the request.</p></li>
</ol>
<h3><span id="6cache-performanceimprovement">6.Cache performance
improvement</span></h3>
<p>  There are two different techniques to improve cache performance.
One focuses on reducing the miss rate by <strong>reducing the
probability that two distinct memory blocks will contend for the same
cache location</strong>. The other reduces the miss penalty by
<strong>adding an additional level to the hierarchy</strong>. The second
technique is called <em>multilevel caching</em>.</p>
<h4><span id="amore-flexible-placement-of-blocks">  <span class="math inline">\(a.\)</span>More flexible placement of blocks</span></h4>
<ul>
<li><p><em>Fully associative</em>: In this scheme, a block can be placed
in <strong>any location in the cache</strong>, that is, <strong>the
block may be associated with any entry in the cache</strong>.</p>
<ul>
<li><p>To find a given block in a fully-associative cache, <strong>all
the entries in the cache must be searched</strong>.</p></li>
<li><p>This process is done <strong>in parallel with a comparator
associated with each cache entry</strong>. This comparators
significantly increase the hardware cost, so the scheme only suits for
caches with small numbers of blocks.</p></li>
</ul></li>
<li><p><em>Set associative</em>: In this scheme, there are a fixed
number of locations where each block can be placed. An <em>n-way set
associative</em> cache consists of a number of sets, each of which has
<span class="math inline">\(n\)</span> blocks.</p></li>
</ul>
<p><img src="/2024/06/14/4-1-Caches/image-8.png"></p>
<p>  The advantage of increasing the degree of associativity is that
<strong>it usually decrease the miss rate</strong>. However, there's
little further improvement in going to rather higher associativity.</p>
<h4><span id="blocating-a-block-in-the-cache">  <span class="math inline">\(b.\)</span>Locating a block in the cache</span></h4>
<p>  Let's first take a block in a set-associative cache for
example:</p>
<p><img src="/2024/06/14/4-1-Caches/image-9.png"></p>
<ul>
<li><p>The <em>tag</em> is checked to see <strong>if it matches the
block address from the processor</strong>.</p></li>
<li><p>The <em>index</em> is used to <strong>select the set containing
the address of interest</strong>.</p></li>
<li><p>All the tags in the selected set are searched <strong>in
parallel</strong>.</p></li>
</ul>
<p>  In a direct-mapped cache, only a single comparator is needed, and
we access the cache simply by indexing. In a <em>four-way
set-associative</em> cache, four comparators are needed, together with a
<strong>4-to-1 multiplexor to choose among the four potential
sets</strong>. The cache access consists of indexing the appropriate set
and then searching the tags of the set.</p>
<p><img src="/2024/06/14/4-1-Caches/image-10.png"></p>
<p>  The choice among these three scheme depends on <strong>the cost of
a miss</strong> versus <strong>the cost of implementing
associativity</strong>.</p>
<h4><span id="cchoosing-which-block-to-replace">  <span class="math inline">\(c.\)</span>Choosing which block to replace</span></h4>
<p>  There are two primary strategies for replacement in set-associative
or fully associative caches:</p>
<ul>
<li><p><em>Random</em>: Candidate blocks are randomly selected, possibly
using some hardware assistance.</p></li>
<li><p><em>Least recently used</em>(LRU): The block replaced is the one
that has been unused for the longest time.</p></li>
</ul>
<p>  In practice, LRU is too costly to implement for hierarchies with
more than a small degree of associativity, since <strong>tracking the
usage information is expensive</strong>.</p>
<h5><span id="iapproximate-lru">  <span class="math inline">\(i.\)</span>Approximate LRU</span></h5>
<p><img src="/2024/06/14/4-1-Caches/image-23.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-24.png"></p>
<h4><span id="dmultilevel-caches">  <span class="math inline">\(d.\)</span>Multilevel caches</span></h4>
<p>  To close the gap between the fast clock rates of processors and the
long time to access DRAMs, most microprocessors support <strong>an
addition level of caching</strong>.</p>
<ul>
<li><p>The second-level cache is normally on the chip, and is access
<strong>whenever a miss occurs in the primary cache</strong>.</p></li>
<li><p>If the second-level cache contains the desired data, the miss
penalty for the first-level cache will be <strong>the access time of the
second-level cache</strong>, which is much less time.</p></li>
</ul>
<p>  The design considerations for a primary and secondary cache are
different. This two-level structure allows the primary cache to focus on
<strong>minimizing hit time</strong> to yield a shorter clock cycle or
fewer pipeline stages, while allowing the second cache to focus on
<strong>miss rate</strong> to reduce the penalty of long memory access
times.</p>
<ul>
<li><p>The primary cache is <strong>smaller</strong>, and may use
<strong>a smaller block size</strong> to go with the smaller cache size
and reduce miss penalty.</p></li>
<li><p>The second cache will be <strong>much larger than in a
single-level cache</strong>. It also use higher associativity than the
primary cache, both for reducing the miss rates.</p></li>
</ul>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-41.png"></p>
<h3><span id="7three-cs">7.Three Cs</span></h3>
<p>  In the hierarchy model, all misses are classified into one of three
categories:</p>
<ul>
<li><p>Compulsory misses: These are cache misses caused by <strong>the
first access to a block that has never been in the cache</strong>. These
are also called cold-start misses.</p></li>
<li><p>Capacity misses: These are cache misses caused when <strong>the
cache cannot contain all the blocks needed during execution of a
program</strong>. Capacity misses occur <strong>when blocks are replaced
and then later retrieved</strong>.</p></li>
<li><p>Conflict misses: These are cache misses that occur in
set-associative or direct-mapped caches when <strong>multiple blocks
compete for the same set</strong>. These cache misses are also called
collision misses.</p></li>
</ul>
<hr>
<ul>
<li><p>Increasing associativity reduces conflict misses, but
associativity may <strong>slow access time</strong>, leading to lower
overall performance.</p></li>
<li><p>Capacity misses can be reduced by enlarging the cache(so
second-level caches is large). Meanwhile, when we make the cache larger,
we must also be careful about <strong>increasing the access
time</strong>(so the first-level caches is small).</p></li>
<li><p>Since compulsory misses are generated by the first reference to a
block, we can simple increase the block size to reduce the block
number.</p></li>
</ul>
<h3><span id="8using-fsm-to-control-acache">8.Using FSM to control a
cache</span></h3>
<h4><span id="afinite-state-machines">  <span class="math inline">\(a.\)</span>Finite-State Machines</span></h4>
<p>  A FSM consists of a set of states and directions on how to change
states.</p>
<ul>
<li><p>The directions are defined by a <em>next-state function</em>,
which maps the current state and the inputs to a new state.</p></li>
<li><p>Each state of FSM specifies a set of outputs that are asserted
when the machine is in this state.</p></li>
<li><p>A FSM can be implemented with a temporary register that
<strong>holds the current state</strong> and <strong>a block of
combinatinoal logic</strong> that determines both the data-path signals
to be asserted and the next state.</p></li>
</ul>
<p><img src="/2024/06/14/4-1-Caches/image-12.png"></p>
<h4><span id="bcontroller">  <span class="math inline">\(b.\)</span>Controller</span></h4>
<p><img src="/2024/06/14/4-1-Caches/image-13.png"></p>
<ul>
<li><p><em>Ideal</em>: This state <strong>waits for a valid read or
write request from the processor</strong>, which <strong>moves the FSM
to the Compare Tag state</strong>.</p></li>
<li><p><em>Compare Tag</em>: This state tests to see <strong>if the
requested read or write is a hit or a miss</strong>. The index portion
of the address <strong>selects the tag to be compared</strong>. If the
data in the cache block referred to by the index portion of the address
are valid, and the tag portion of the address matches the tag, then it
is a hit. Either the data are read from the selected word if it is a
load or written to the selected word if it is a store. The Cache Ready
signal is then set. <strong>If it is a write,the dirty bit is set to
1</strong>. Note that a write hit also sets the valid bit and the tag
field; while it seems unnecessary, it is included because the tag is a
single memory, so <strong>to change the dirty bit we likewise need to
change the valid and tag fields</strong>. If it is a hit and the block
is valid, the FSM <strong>returns to the idle state</strong>. A miss
<strong>first updates the cache tag</strong> and then goes either to the
Write-Back state, if the block at this location has dirty bit value of
1, or to the Allocate state if it is 0.</p></li>
<li><p><em>Write-Back</em>: This state writes the 128-bit block to
memory using <strong>the address composed from the tag and cache
index</strong>. We remain in this state waiting for the Ready signal
from memory. When the memory write is complete, the FSM <strong>goes to
the Allocate state</strong>.</p></li>
<li><p><em>Allocate</em>: The new block <strong>is fetched from
memory</strong>. We <strong>remain in this state waiting for the Ready
signal from memory</strong>. When the memory read is complete, the FSM
goes to the Compare Tag state.</p></li>
</ul>
<h3><span id="9fully-associative-cacheintroduction">9.Fully associative cache
introduction</span></h3>
<p><img src="/2024/06/14/4-1-Caches/image-14.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-15.png"></p>
<h3><span id="10direct-mapped-cacheintroduction">10.Direct-mapped cache
introduction</span></h3>
<p><img src="/2024/06/14/4-1-Caches/image-16.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-17.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-29.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-30.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-31.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-32.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-33.png"></p>
<h3><span id="11set-associativeintroduction">11.Set-associative
introduction</span></h3>
<p><img src="/2024/06/14/4-1-Caches/image-18.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-19.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-34.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-35.png"></p>
<h3><span id="12fully-associativeintroduction">12.Fully-associative
introduction</span></h3>
<p><img src="/2024/06/14/4-1-Caches/image-25.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-26.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-27.png"></p>
<h3><span id="13analyzing-cache-performance">13.Analyzing cache performance</span></h3>
<p><img src="/2024/06/14/4-1-Caches/image-36.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-37.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-38.png"></p>
<hr>
<p><img src="/2024/06/14/4-1-Caches/image-39.png"></p>
<p><img src="/2024/06/14/4-1-Caches/image-40.png"></p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 4.Cache</category>
      </categories>
  </entry>
  <entry>
    <title>4.4.Hack语言规范</title>
    <url>/2024/04/05/4-4-Hack%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1><span id="44hack-language-specification"><span class="math inline">\(4.4.\)</span>Hack Language Specification</span></h1>
<h3><span id="1the-binary-syntax-for-ainstruction">1.The binary syntax for A
instruction</span></h3>
<ul>
<li><p>The first zero of a binary number is called <em>operate code</em>
in HL.</p></li>
<li><p>Syntax: Starts with <code>0</code>, and the <code>value</code> is
less or equal than <span class="math inline">\(2^{15}-1\)</span>.</p>
<ul>
<li>For example: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//set A register to 21</span><br><span class="line">0000000000010101</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3><span id="2the-binary-syntax-for-cinstruction">2.The binary syntax for C
instruction</span></h3>
<p>  The binary syntax correspond to symbolic syntax is as below:</p>
<p><img src="/2024/04/05/4-4-Hack%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/image.png"></p>
<ul>
<li>The <code>comp</code> mapping table from symbolic to binary is as
below:</li>
</ul>
<p><img src="/2024/04/05/4-4-Hack%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/image-1.png"></p>
<ul>
<li>The <code>dest</code> mapping table from symbolic to binary is as
below:</li>
</ul>
<p><img src="/2024/04/05/4-4-Hack%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/image-2.png"></p>
<ul>
<li>The <code>jump</code> mapping table from symbolic to binary is as
below:</li>
</ul>
<p><img src="/2024/04/05/4-4-Hack%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83/image-3.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>4.5.输入与输出</title>
    <url>/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1><span id="45inputand-output"><span class="math inline">\(4.5.\)</span>Input
and Output</span></h1>
<h3><span id="1-output">1. Output</span></h3>
<h4><span id="adisplay">  <span class="math inline">\(a.\)</span>Display</span></h4>
<ul>
<li>The most important player in manipulating the display element is
called <em>screen memory map</em>.</li>
<li>It is a designated area which is part of the data memory(RAM).</li>
<li>The physical display unit is continuously refreshed from the
contents of the memory map, and this happens many times each second. in
the next refresh cycle,what is changed in the memory is going to be
reflected on the screen.</li>
</ul>
<p><img src="/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/image.png"></p>
<h4><span id="bscreen-memory-map">  <span class="math inline">\(b.\)</span>Screen memory map</span></h4>
<p>  Our display unit looks like this:</p>
<p><img src="/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/image-1.png"></p>
<p>  It's a <em>table</em>, or a <em>matrix</em>, consisting of 256 rows
and 512 columns. And in each intersection of a row and a column, we have
what is known as a <em>pixel</em>. This is a black and white screen, so
we can either turn the pixel on or we can turn it off.</p>
<p>  We can use out screen memory map to manipulate it, which looks like
this:</p>
<p><img src="/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/image-2.png"></p>
<ul>
<li><p>It's a sequense of 16-bit values. Each one of these values is
called <em>word</em>.</p></li>
<li><p>For every pixel on the physical display unit, we have a bit that
represents this pixel in the screen memory map. If I want to turn on
this pixel, I put 1 in this bit, if I want to turn it off,I put 0 in
this bit.</p></li>
<li><p>To set <code>pixel(row, col)</code>on/off:</p>
<ol type="1">
<li><p><code>word = Screen[row*32 + col/16]</code></p>
<ul>
<li><strong>We cannot access individual bits</strong>.If we want to
access an individual bit, we have to first figure out <strong>in which
word this bit resides</strong>. And then I have to retrieve the entire
word, manipulate this particular bit and finally write it back into
memory.</li>
</ul></li>
<li><p><code>word = RAM[16384 + row*32 + col/16]</code></p>
<ul>
<li>If we access the <strong>screen chip</strong>, we simply use <span class="math inline">\(row\times 32+{col\over 16}\)</span>. But if we
access the <strong>OVERALL RAM</strong>, we have to take this
<strong>relative address</strong> and add it to the <strong>base
address</strong> of the memory of the memory map in the overall memory,
which happens to be 16384.</li>
</ul></li>
<li><p>Set <code>col%16</code> bit of <code>word</code> to 0 or
1</p></li>
<li><p>Commit <code>word</code> to the RAM</p></li>
<li><ol type="1">
<li>and (4) are done using 16-bit RAM access operations.</li>
</ol></li>
</ol></li>
</ul>
<h3><span id="2input">2.Input</span></h3>
<h4><span id="akeyboard">  <span class="math inline">\(a.\)</span>Keyboard</span></h4>
<ul>
<li>The physical keyboard is connected to the computer using a cable. If
you will trace this cable, you will see that it goes into <strong>an
area in the RAM</strong> which is called <em>keyboard memory
map</em>.</li>
</ul>
<h4><span id="bkeyboard-memory-map">  <span class="math inline">\(b.\)</span>Keyboard memory map</span></h4>
<ul>
<li>Keyboard memory map is a single 16-bit register:</li>
</ul>
<p><img src="/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/image-3.png"></p>
<ul>
<li><p>When a key is pressed on the keyboard, the key's
<strong>scan-code</strong>, which is an agreed-upon value, travels
through the cable and appears in the keyboard memory map.</p>
<ul>
<li><span class="math inline">\(e.g.\)</span> If I press 'K', 75 is
going to appear in its binary manifestation in the in the keyboard
chip.</li>
</ul></li>
</ul>
<p><img src="/2024/04/05/4-5-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/image-4.png"></p>
<ul>
<li><p>if you want to check if which key is currently pressed, all we
have to do is <strong>probe the contents of the keyboard
chip</strong>.</p>
<ul>
<li>In Hack computer, We probe the contents of RAM in address 24576, for
this is where the keyboard memory map happens to reside.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>4.6.寄存器与内存</title>
    <url>/2024/04/05/4-6-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1><span id="46working-with-register-and-memory"><span class="math inline">\(4.6.\)</span>Working with register and memory</span></h1>
<h3><span id="1operations-towards-d">1.Operations towards D</span></h3>
<ul>
<li><p>Storing value: It turns out that there's no direct way to do it,
we have to do it indirectly. For example, if we want to store 10 in
register D: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@10</span><br><span class="line">D = A</span><br></pre></td></tr></table></figure></p></li>
<li><p>Incresing value: We can use C instructions directly:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D = D + 1</span><br></pre></td></tr></table></figure></p></li>
<li><p>Setting D to RAM value: It's similar to storing value:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@10</span><br><span class="line">D = M</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3><span id="2usage-of-d-register">2.Usage of D register</span></h3>
<p>  D register is of great importance in assignment operations:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//set RAM[10] to 5</span><br><span class="line">@5</span><br><span class="line">D = A</span><br><span class="line">@10</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">//set RAM[10] to RAM[5]</span><br><span class="line">@ 5</span><br><span class="line">D = M</span><br><span class="line">@10</span><br><span class="line">M = D</span><br></pre></td></tr></table></figure></p>
<h3><span id="3built-in-symbol">3.Built-in symbol</span></h3>
<p><img src="/2024/04/05/4-6-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98/image.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>4.7.分支，变量与迭代</title>
    <url>/2024/04/05/4-7-%E5%88%86%E6%94%AF%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<h1><span id="47branchingvarables-and-iteration"><span class="math inline">\(4.7.\)</span>Branching,Varables and Iteration</span></h1>
<h3><span id="1branching">1.Branching</span></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Computes:if R0&gt;0</span><br><span class="line">//            R1=1</span><br><span class="line">//         else</span><br><span class="line">//            R1=0</span><br><span class="line">@R0</span><br><span class="line">D=M</span><br><span class="line"></span><br><span class="line">@8</span><br><span class="line">D;JGT</span><br><span class="line"></span><br><span class="line">//if D isn&#x27;t greater than 0, do this block</span><br><span class="line">@R1</span><br><span class="line">M = 0</span><br><span class="line">@10</span><br><span class="line">0;JMP</span><br><span class="line"></span><br><span class="line">//else, do this</span><br><span class="line">@R1</span><br><span class="line">M = 1</span><br><span class="line"></span><br><span class="line">@10</span><br><span class="line">0;JMP</span><br></pre></td></tr></table></figure>
<ul>
<li><em>Symbolic reference</em>: The above code is correct but
unreadable. Fortunately, we have a nice feature called <em>symbolic
reference</em>. For example, the above code can be rewrited like
this:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@R0</span><br><span class="line">D=M</span><br><span class="line"></span><br><span class="line">@POSITIVE</span><br><span class="line">D;JGT</span><br><span class="line"></span><br><span class="line">@R1</span><br><span class="line">M = 0</span><br><span class="line">@END</span><br><span class="line">@10</span><br><span class="line">0;JMP</span><br><span class="line"></span><br><span class="line">(POSITIVE)</span><br><span class="line">@R1</span><br><span class="line">M = 1</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">@10</span><br><span class="line">0;JMP</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The <code>POSITIVE</code> label appears twice in the code: In the
first place we declare this label, and what we are saying is
<strong>"here is a piece of code that I want to jump to some other place
in the code called <code>POSITIVE</code>"</strong>.</p>
<ul>
<li>LABEL translates to n, where n is the instruction number following
the (LABEL) declaration, in the assembler.</li>
</ul></li>
</ul>
<h3><span id="2varables">2.Varables</span></h3>
<p>  In machine language, besides <code>R0</code> and symbolic
reference, we can also set out own <em>varables</em>. For example:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@R0</span><br><span class="line">D = M</span><br><span class="line">@temp</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">@R1</span><br><span class="line">D = M</span><br><span class="line">@R0</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">@temp</span><br><span class="line">D = M</span><br><span class="line">@R1</span><br><span class="line">M = D</span><br></pre></td></tr></table></figure></p>
<p>  The <code>temp</code> is a varable set by ourselves, and we
represent it by using <code>@temp</code>. This kind of naming improve
the readability of our code.</p>
<blockquote>
<p>  However, assembly language does not inherently support variables.
Therefore, when we write "<span class="citation" data-cites="temp">@temp</span>", we are essentially <strong>requesting
the computer to find an available memory register in the memory
unit</strong> and <strong>assume its number to be "n"</strong>, and
then, from now on, <strong>use it to represent what we call the
"variable temp"</strong>.</p>
</blockquote>
<h3><span id="3iteration">3.Iteration</span></h3>
<p>  Considering this question: Compute RAM[1] = 1+2+...+RAM[0]. We have
the following pseudo code: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = RO</span><br><span class="line">i = 1</span><br><span class="line">sum = 0</span><br><span class="line">LOOP:</span><br><span class="line">if i&gt;n goto STOP</span><br><span class="line">sum = sum + i</span><br><span class="line">i = i + 1</span><br><span class="line">goto LOOP</span><br><span class="line">STOP:</span><br><span class="line">R1 = sum</span><br></pre></td></tr></table></figure></p>
<p>  We can implement the pseudo code as below: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//initialize</span><br><span class="line">@R0</span><br><span class="line">D = M</span><br><span class="line">@n</span><br><span class="line">M = D</span><br><span class="line">@i</span><br><span class="line">M = 1</span><br><span class="line">@sum</span><br><span class="line">M = 0</span><br><span class="line"></span><br><span class="line">//computing</span><br><span class="line">(LOOP)</span><br><span class="line">	@i</span><br><span class="line">	D = M</span><br><span class="line">	@n</span><br><span class="line">	M = M - D</span><br><span class="line">	//the if clause</span><br><span class="line">	@STOP</span><br><span class="line">	D;JGT</span><br><span class="line"></span><br><span class="line">	@sum </span><br><span class="line">	D = M</span><br><span class="line">	@i</span><br><span class="line">	D = D + M</span><br><span class="line">	@sum</span><br><span class="line">	M = D</span><br><span class="line">	@i</span><br><span class="line">	M = M + 1</span><br><span class="line">	@LOOP</span><br><span class="line">	0;JMP</span><br><span class="line"></span><br><span class="line">(STOP)</span><br><span class="line">	@sum</span><br><span class="line">	D = M</span><br><span class="line">	@R1</span><br><span class="line">	M = D</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">	@END</span><br><span class="line">	0;JMP</span><br></pre></td></tr></table></figure></p>
<p>  We may take the process to lessen our burden with writing loop:</p>
<ol type="1">
<li>First write in pseudo code.</li>
<li>Debug your pseudo code.</li>
<li>Translating the pseudo code into machine language.</li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>4.8.指针，输入与输出控制</title>
    <url>/2024/04/05/4-8-%E6%8C%87%E9%92%88%E3%80%81%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1><span id="48pointer-and-input-outputcontrol"><span class="math inline">\(4.8.\)</span>Pointer and Input, Output
Control</span></h1>
<h3><span id="1pointer">1.Pointer</span></h3>
<p>  We use <strong>A-instruction</strong> to point to a certain
address. For example: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//   for(i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">//      arr[i] = -1</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   suppose arr = 100 and n = 10</span><br><span class="line"></span><br><span class="line">//initialize</span><br><span class="line">	@100</span><br><span class="line">	D = A</span><br><span class="line">	@arr</span><br><span class="line">	M = D</span><br><span class="line"></span><br><span class="line">	@10</span><br><span class="line">	D = A</span><br><span class="line">	@n</span><br><span class="line">	M = D</span><br><span class="line"></span><br><span class="line">	@i</span><br><span class="line">	M = 0</span><br><span class="line"></span><br><span class="line">//iteration</span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">	@i</span><br><span class="line">	D = M</span><br><span class="line">	@n </span><br><span class="line">	D = D - M</span><br><span class="line">	@END</span><br><span class="line">	D;JEQ</span><br><span class="line"></span><br><span class="line">	//RAM[arr + i] = -1</span><br><span class="line">	@i</span><br><span class="line">	D = M</span><br><span class="line">	@arr</span><br><span class="line">	A = D + M</span><br><span class="line">	M = -1</span><br><span class="line">	@i</span><br><span class="line">	M = M + 1</span><br><span class="line">	</span><br><span class="line">	@LOOP</span><br><span class="line">	0;JMP</span><br><span class="line"></span><br><span class="line">	(END)</span><br><span class="line">	@END</span><br><span class="line">	0;JMP</span><br></pre></td></tr></table></figure></p>
<p>  The key step in the program is <code>A = D + M, M = -1</code>:</p>
<ul>
<li><p>The <code>A = D + M</code> point the address of <code>arr</code>
to the <strong>base address</strong> of <code>arr</code>(the initial
address, 100) plus i, which match the expression
<code>arr + i</code>.</p></li>
<li><p>By the time we say M equals -1, the register that will be
affected is the register in A address.</p></li>
<li><p>Variables that store memory addresses like <code>arr + i</code>
are called <em>pointers</em>.</p></li>
<li><p>Typical pointer semantics:"set the address register to the
contents of some <strong>memory register</strong>"</p></li>
</ul>
<h3><span id="2screen-input">2.Screen input</span></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//for (i = 0; i &lt; n; i ++)</span><br><span class="line">//    draw 16 black pixels at the </span><br><span class="line">//    beginning of row i</span><br><span class="line"></span><br><span class="line">//    addr = SCREEN</span><br><span class="line">//    n = RAM[0]</span><br><span class="line">//    i = 0</span><br><span class="line">//    LOOP:</span><br><span class="line">//    if i &gt; n goto END</span><br><span class="line">//    RAM[addr] = -1 1111111111111111</span><br><span class="line">//    addr = addr + 32</span><br><span class="line">//    i = i + 1</span><br><span class="line">//    goto LOOP</span><br><span class="line"></span><br><span class="line">@SCREEN</span><br><span class="line">D = A</span><br><span class="line">@addr</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">@R0</span><br><span class="line">D = M</span><br><span class="line">@n</span><br><span class="line">M = D</span><br><span class="line"></span><br><span class="line">@i</span><br><span class="line">M = 0</span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">	@i</span><br><span class="line">	D = M</span><br><span class="line">	@n</span><br><span class="line">	D = D - M</span><br><span class="line">	@END</span><br><span class="line">	D; JGT</span><br><span class="line"></span><br><span class="line">	@addr</span><br><span class="line">	A = M</span><br><span class="line">	M = -1</span><br><span class="line"></span><br><span class="line">	@i</span><br><span class="line">	M = M + 1</span><br><span class="line">	@32</span><br><span class="line">	D = A</span><br><span class="line">	@addr</span><br><span class="line">	M = M + D</span><br><span class="line">	(LOOP)</span><br><span class="line">	0; JMP</span><br><span class="line">	</span><br><span class="line">(END)</span><br><span class="line">	@END</span><br><span class="line">	0; JMP</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 4.Machine Language</category>
      </categories>
  </entry>
  <entry>
    <title>4.1.接口</title>
    <url>/2024/05/31/4.1.interface/</url>
    <content><![CDATA[<h1><span id="41接口"><span class="math inline">\(4.1\)</span>接口</span></h1>
<h3><span id="1上位词-下位词">1.上位词、下位词</span></h3>
<p>  在日常语言中，词语、对象之间具有逻辑上的层次性，例如：狗(<span class="math inline">\(dog\)</span>)是贵宾犬、哈士奇等的上位词(<span class="math inline">\(hypernym\)</span>)，而贵宾犬、哈士奇等是狗的下位词(<span class="math inline">\(hyponyms\)</span>)。</p>
<p>  上位词与下位词描述的是一种<span class="math inline">\(is-a\)</span>的层次关系：</p>
<ul>
<li>贵宾犬<span class="math inline">\(is-a\)</span>狗</li>
<li>狗<span class="math inline">\(is-a\)</span>动物</li>
</ul>
<p><img src="/2024/05/31/4.1.interface/image.png"></p>
<p>  同样地，我们前面讲解的<span class="math inline">\(SLList\)</span>与<span class="math inline">\(AList\)</span>也是链表的下位词。在<span class="math inline">\(Java\)</span>中，<span class="math inline">\(SLList\)</span>是<span class="math inline">\(List61B\)</span>的子类(<span class="math inline">\(subclass\)</span>)，<span class="math inline">\(List61B\)</span>是<span class="math inline">\(SLList\)</span>的主类(<span class="math inline">\(superclass\)</span>)。</p>
<p><img src="/2024/05/31/4.1.interface/image-1.png"></p>
<h3><span id="2接口">2.接口</span></h3>
<p>  在<span class="math inline">\(Java\)</span>中，为了表达上述的层次结构，我们会进行以下操作：</p>
<ul>
<li>为通用列表(<span class="math inline">\(hypernym\)</span>)定义一个类型——我们将选择名称<span class="math inline">\(List61B\)</span>。</li>
<li>指定<span class="math inline">\(SLList\)</span>与<span class="math inline">\(ALList\)</span>是<span class="math inline">\(List61B\)</span>的下位词。</li>
</ul>
<p>  这里的<span class="math inline">\(List61B\)</span>被称为接口(<span class="math inline">\(interface\)</span>)。它本质上是一个契约(<span class="math inline">\(contract\)</span>)，记录了一个链表必须能够做的方法，但它不提供任何方法的实现。下面是<span class="math inline">\(List61B\)</span>的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List61B</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> add <span class="title function_">Last</span><span class="params">(Item y)</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item x, <span class="type">int</span> position)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <span class="math inline">\(AList\)</span>等可以如下定义：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">List61B</span>&lt;Item&gt;&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这里的<code>implements List61B&lt;Item&gt;</code>实际上是一种承诺(<span class="math inline">\(promise\)</span>)，保证<span class="math inline">\(AList\)</span>实现了接口要求实现的方法。</p>
<h3><span id="3覆盖">3.覆盖</span></h3>
<p>  在实现接口所需的方法时，在方法前面涵盖一个<code>@Override</code>的标记是很有用的：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">    insert(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="4接口的继承">4.接口的继承</span></h3>
<p>  接口的继承(<span class="math inline">\(inheritance\)</span>)指代了一种关系，即子类继承了主类的所有的方法与行为。在我们定义的<span class="math inline">\(List61B\)</span>中，接口继承了所有的方法签名(<span class="math inline">\(signature\)</span>)，但不包括实现。</p>
<h3><span id="5groe">5.<span class="math inline">\(GRoE\)</span></span></h3>
<p>  在定义了<span class="math inline">\(is-a\)</span>关系后，我们就可以实现以下语句了：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SLList&lt;String&gt; someList = <span class="keyword">new</span> <span class="title class_">List61B</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure></p>
<p>  这是因为<span class="math inline">\(SLList\)</span><span class="math inline">\(is-a\)</span><span class="math inline">\(List61B\)</span>，这说明<span class="math inline">\(SLList\)</span>可以放进<span class="math inline">\(List61B\)</span>的内存盒子中，因此可以这么写。但反过来则不对。</p>
<h3><span id="5实现的继承">5.实现的继承</span></h3>
<p>  之前对接口的讲解中，我们说<span class="math inline">\(List61B\)</span>中只有标识<span class="math inline">\(List61B\)</span>做什么(<span class="math inline">\(what\)</span>)的方法名称(<span class="math inline">\(method\;header\)</span>)。接下来我们在<span class="math inline">\(List61B\)</span>中实现具体的方法。</p>
<p>  如果我们在<span class="math inline">\(List61B\)</span>中加入如下方法： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  那么，所有对<span class="math inline">\(List61B\)</span>的实现(<span class="math inline">\(implements\)</span>)都可以使用这个方法。</p>
<p>  但是，该方法中的<span class="math inline">\(get(i)\)</span>函数对<span class="math inline">\(SLList\)</span>来说效率过低，于是我们可以在<span class="math inline">\(SLList\)</span>子类中覆盖这一方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">        System.out.print(p.item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样，在对<span class="math inline">\(SLList\)</span>调用<span class="math inline">\(print()\)</span>时，<span class="math inline">\(SLList\)</span>就会使用覆盖后的方法了。</p>
<h3><span id="6动态方法选择">6.动态方法选择</span></h3>
<p>  我们知道，<span class="math inline">\(Java\)</span>中的每一个变量都有一个类型：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List61B&lt;String&gt; lst = new SLList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p>
<p>  在上面实例化的声明中，<span class="math inline">\(lst\)</span>的类型是<span class="math inline">\(List61B\)</span>，这叫作静态类型(<span class="math inline">\(static\;type\)</span>)。</p>
<p>  然而，对象自己也有类型。<span class="math inline">\(lst\)</span>指向的对象具有<span class="math inline">\(SLList\)</span>类型，同时它也是<span class="math inline">\(List61B\)</span>类型，这是由于两者的<span class="math inline">\(is-a\)</span>关系。我们称它的<span class="math inline">\(List61B\)</span>类型为动态类型(<span class="math inline">\(dynamic\;type\)</span>)。</p>
<blockquote>
<p>  Aside: the name “dynamic type” is actually quite semantic in its
origin! Should lst be reassigned to point to an object of another type,
say a AList object, lst’s dynamic type would now be AList and not
SLList! It’s dynamic because it changes based on the type of the object
it’s currently referring to.</p>
</blockquote>
<p>  考虑下面的例子： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">peek</span><span class="params">(List61B&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(list.getLast());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">peek</span><span class="params">(SLList&lt;String&gt; list)</span> &#123;</span><br><span class="line">    System.out.println(list.getFirst());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SLList&lt;String&gt; SP = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;String&gt;();</span><br><span class="line">List61B&lt;String&gt; LP = SP;</span><br><span class="line">SP.addLast(<span class="string">&quot;elk&quot;</span>);</span><br><span class="line">SP.addLast(<span class="string">&quot;are&quot;</span>);</span><br><span class="line">SP.addLast(<span class="string">&quot;cool&quot;</span>);</span><br><span class="line">peek(SP);</span><br><span class="line">peek(LP);</span><br></pre></td></tr></table></figure></p>
<p>  第一个<span class="math inline">\(peek\)</span>调用的是第一个，而第二个<span class="math inline">\(peek\)</span>调用的是第二个。<span class="math inline">\(Java\)</span>在相同名称的方法间选择时，会检查与静态变量类型相同的方法，然后调用它。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>4.inheritance &amp; inplements</category>
      </categories>
  </entry>
  <entry>
    <title>4.2.扩展</title>
    <url>/2024/05/31/4.2.extends/</url>
    <content><![CDATA[<h1><span id="42扩展"><span class="math inline">\(4.2\)</span>扩展</span></h1>
<h3><span id="1扩展的引入">1.扩展的引入</span></h3>
<p>  假设我们想实现<span class="math inline">\(RotatingSLList\)</span>，它具有和<span class="math inline">\(SLList\)</span>完全相同的方法，但增添了一个方法<code>rotateRight</code>，这个方法将链表的最后一个元素添加到链表前端。</p>
<p>  为了继承<span class="math inline">\(SLList\)</span>的方法，我们可以使用<span class="math inline">\(extend\)</span>关键词： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RotatingSLList</span>&lt;Item&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;Item&gt;</span><br></pre></td></tr></table></figure></p>
<p>  这里，<span class="math inline">\(RotatingSLList\)</span>和<span class="math inline">\(SLList\)</span>间也是<span class="math inline">\(is-a\)</span>关系，<span class="math inline">\(extends\)</span>关键词允许我们保留<span class="math inline">\(SLList\)</span>的原始功能，同时允许我们进行修改并添加其他的功能(<span class="math inline">\(functionality\)</span>)。</p>
<p><img src="/2024/05/31/4.2.extends/image-2.png"></p>
<p>  使用<span class="math inline">\(extends\)</span>语句后，我们便可以借助<span class="math inline">\(SLList\)</span>中的方法来实现<code>rotateRight</code>：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotateRight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Item</span> <span class="variable">x</span> <span class="operator">=</span> removeLast();</span><br><span class="line">    addFirst(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  在<span class="math inline">\(extend\)</span>关键词下，子类继承了父类的大部分成员：</p>
<ul>
<li>所有的实例和静态变量</li>
<li>所有的方法</li>
<li>所有的嵌套类</li>
</ul>
<p>  当我们要覆盖所继承的方法时，使用<code>@Override</code>即可。例如下面<span class="math inline">\(VengefulSLList\)</span>的实现：它的<code>removeLast</code>方法在删去末尾元素后会将其添加到前端：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VengefulSLList</span>&lt;Item&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;Item&gt; &#123;</span><br><span class="line">    SLList&lt;Item&gt; deletedItems;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> &#123;</span><br><span class="line">        deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Item</span> <span class="variable">x</span> <span class="operator">=</span> <span class="built_in">super</span>.removeLast();</span><br><span class="line">        deletedItems.addLast(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Prints deleted items. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLostItems</span><span class="params">()</span> &#123;</span><br><span class="line">        deletedItems.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="2关于构造方法的继承">2.关于构造方法的继承</span></h3>
<p>  虽然子类会继承父类的大部分成员，但是子类无法继承父类的构造方法(<span class="math inline">\(constructor\)</span>)。同时，<span class="math inline">\(Java\)</span>要求所有的构造函数必须从对一个主类(<span class="math inline">\(superclass\)</span>)的构造方式的调用开始。</p>
<p>  以下面的两个类为例： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Human &#123;...&#125;</span><br><span class="line">public class TA extends Human &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>  由<span class="math inline">\(extends\)</span>语句，<span class="math inline">\(TA\)</span>会继承<span class="math inline">\(Human\)</span>的属性与行为。</p>
<p>  如果我们运行下面的代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TA</span> <span class="variable">Christine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TA</span>();</span><br></pre></td></tr></table></figure></p>
<p>  那么首先，一个<span class="math inline">\(Human\)</span>要先被创建，这样<span class="math inline">\(Human\)</span>才能把自己的特性传递给<span class="math inline">\(TA\)</span>，如果没有创建<span class="math inline">\(Human\)</span>就创建<span class="math inline">\(TA\)</span>显然是错误的。</p>
<p>  因此，在创建一个子类时，我们可以直接先用<span class="math inline">\(super\)</span>关键词，调用主类的构造方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  或者，如果我们不这么做，<span class="math inline">\(Java\)</span>会自动调用主类的无参数(<span class="math inline">\(non-argument\)</span>)构造方法。</p>
<p>  但有时候，如果不直接调用父类的构造方法，<span class="math inline">\(Java\)</span>的自动调用的方法可能不是我们想要的。例如我们有一个包含一个参数的单参数构造方法，<span class="math inline">\(Java\)</span>自动调用的无参数构造方法会让我们传入的参数无效！这时，我们就必须直接调用我们需要的构造方式：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(x);</span><br><span class="line">    deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="3对象类">3.对象类</span></h3>
<p>  <span class="math inline">\(Java\)</span>中的所有类都是对象类(<span class="math inline">\(object\;class\)</span>)的子类(<span class="math inline">\(descendant\)</span>)，或者对象类的<span class="math inline">\(extends\)</span>。不管一个类有没有显性的<span class="math inline">\(extends\)</span>关键词，它都隐性地继承了对象类。以前面为例：</p>
<ul>
<li><span class="math inline">\(VengefulSLList\)</span>是<span class="math inline">\(SLList\)</span>的显式<span class="math inline">\(extends\)</span>。</li>
<li><span class="math inline">\(SLList\)</span>隐性继承了对象类。</li>
</ul>
<p>  对象类提供了很多所有对象都应遵循的操作，如<code>.equal(Object obj)</code>、<code>.hashCode()</code>等。</p>
<h3><span id="4封装">4.封装</span></h3>
<p>  我们可以通过阶层抽象(抽象屏障)来减小程序的复杂性(<span class="math inline">\(complexity\)</span>)，以及“为准备修改而编程”的概念。这是围绕着程序应该被建造为模块化的、可内部改变(<span class="math inline">\(interchangeable\)</span>)的片段，它们可以互相交换、并且不会破坏原有的系统。同时，把他人不需要的信息隐藏起来也是减小程序复杂性的重要手段。</p>
<p>  封装的根源即存在于将信息对外隐藏的概念。在计算机科学中，一个模块可以被定义为一系列方法，它们作为一个整体工作来解决问题。当这个模块的实现细节都被隐藏起来、只能通过接口与其进行交互，这样的模块就是已封装的(<span class="math inline">\(encapsulated\)</span>)。</p>
<p>  在理想状态下，用户不应观察到它们所使用的数据结构的内部工作原理。而<span class="math inline">\(Java\)</span>的<span class="math inline">\(private\)</span>关键词就很好地建立了抽象屏障。</p>
<h3><span id="5类型错误-编译时类型">5.类型错误、编译时类型</span></h3>
<p>  我们考虑下面的程序： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    VengefulSLList&lt;Integer&gt; vsl = <span class="keyword">new</span> <span class="title class_">VengefulSLList</span>&lt;Integer&gt;(<span class="number">9</span>);</span><br><span class="line">    SLList&lt;Integer&gt; sl = vsl;</span><br><span class="line"></span><br><span class="line">    sl.addLast(<span class="number">50</span>);</span><br><span class="line">    sl.removeLast();</span><br><span class="line"></span><br><span class="line">    sl.printLostItems();</span><br><span class="line">    VengefulSLList&lt;Integer&gt; vsl2 = sl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VengefulSLList&lt;Integer&gt; vsl = <span class="keyword">new</span> <span class="title class_">VengefulSLList</span>&lt;Integer&gt;(<span class="number">9</span>);</span><br><span class="line">SLList&lt;Integer&gt; sl = vsl;</span><br></pre></td></tr></table></figure>
<p>  程序的前两行没有问题，因为<span class="math inline">\(VengefulSLList\)</span><span class="math inline">\(is-a\)</span><span class="math inline">\(SLList\)</span>，我们可以把<span class="math inline">\(VengefulSLList\)</span>放入<span class="math inline">\(SLList\)</span>的内存盒子中。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sl.addLast(<span class="number">50</span>);</span><br><span class="line">sl.removeLast();</span><br></pre></td></tr></table></figure></p>
<p>  这两行也没有问题，根据前面的讲解，第一个<code>addLast</code>会调用<span class="math inline">\(SLList\)</span>的方法，而第二个<code>removeLast</code>会调用<span class="math inline">\(VengefulSLList\)</span>的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sl.printLostItems();</span><br></pre></td></tr></table></figure>
<p>  但是这一行程序无法编译，因为<span class="math inline">\(SLList\)</span>及其主类都没有<code>printLostItems</code>这一方法，即使<span class="math inline">\(sl\)</span>的运行类型是<span class="math inline">\(VengefulSLList\)</span>依然不行。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VengefulSLList&lt;Integer&gt; vsl2 = sl;</span><br></pre></td></tr></table></figure></p>
<p>  同样地，这一行程序也会编译错误。因为<span class="math inline">\(SLList\)</span>并不<span class="math inline">\(is-a\;\)</span><span class="math inline">\(VengefulSLList\)</span>。</p>
<p>  这两例说明，编译器只支持编译时(<span class="math inline">\(compile-time\)</span>)的类型所包含的方法。</p>
<p>  除了表达式，对方法的调用也会有编译时类型，即该方法声明时的类型。例如下面的程序：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">frank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poodle</span>(<span class="string">&quot;Frank&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Poodle</span> <span class="variable">frankJr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poodle</span>(<span class="string">&quot;Frank Jr.&quot;</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Dog</span> <span class="variable">largerDog</span> <span class="operator">=</span> maxDog(frank, frankJr);</span><br><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> maxDog(frank, frankJr); </span><br><span class="line"><span class="comment">//does not compile! RHS has compile-time type Dog</span></span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> maxDog(frank, frankJr); </span><br><span class="line"><span class="comment">//does not compile! RHS has compile-time type Dog</span></span><br></pre></td></tr></table></figure></p>
<p>  该行代码也会编译错误，因为<code>maxDog</code>的编译时类型为<span class="math inline">\(Dog\)</span>。</p>
<h3><span id="6类型铸造casting">6.类型铸造<span class="math inline">\(casting\)</span></span></h3>
<p>  在<span class="math inline">\(Java\)</span>中，我们可以告诉编译器某个表达式有特定的编译时类型，这样可以实现类型的“转换”。</p>
<p>  例如，我们可以对上面的代码进行如下更改： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> (Poodle) maxDog(frank, frankJr); </span><br><span class="line"><span class="comment">// compiles! Right hand side has compile-time type Poodle after casting</span></span><br></pre></td></tr></table></figure></p>
<p>  但是，对两个毫不相干的类进行类型铸造，会导致<code>ClassCastException</code>的错误。</p>
<h3><span id="7高阶函数">7.高阶函数</span></h3>
<p>  在<span class="math inline">\(Java\)</span>中，我们可以利用接口实现高阶函数。</p>
<p>  先在接口中定义一个函数： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  然后我们写一个类来实现接口中指定的函数： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TenX</span> <span class="keyword">implements</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">    <span class="comment">/* Returns ten times the argument. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  然后，我们就可以写出高阶函数的表达式了： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">do_twice</span><span class="params">(IntUnaryFunction f, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(f.apply(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  在调用时，我们创造一个新的<span class="math inline">\(tenX\)</span>实例，然后传入参数<span class="math inline">\(x\)</span>即可： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(do_twice(<span class="keyword">new</span> <span class="title class_">TenX</span>(), <span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>  函数式接口允许我们以优雅的方式传递函数，我们可以通过接口定义函数的签名与行为，然后通过实现接口的类来提供具体的函数。</p>
<h3><span id="8summarcopy-by-origin-text">8.summar(copy by origin text)</span></h3>
<p>  VengefulSLList extends SLList means VengefulSLList "is-an" SLList,
and inherits all of SLList's members:</p>
<ul>
<li>Variables, methods nested classes</li>
<li>Not constructors Subclass constructors must invoke superclass
constructor first. The super keyword can be used to invoke overridden
superclass methods and constructors.</li>
</ul>
<p>  Invocation of overridden methods follows two simple rules:</p>
<ul>
<li>Compiler plays it safe and only allows us to do things according to
the static type.</li>
<li>For overridden methods (not overloaded methods), the actual method
invoked is based on the dynamic type of the invoking expression</li>
<li>Can use casting to overrule compiler type checking.</li>
</ul>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>4.inheritance &amp; inplements</category>
      </categories>
  </entry>
  <entry>
    <title>4.2.隐性序列</title>
    <url>/2024/05/31/4.2.%E9%9A%90%E6%80%A7%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1><span id="42隐性序列implicitsequences"><span class="math inline">\(4.2\)</span>隐性序列<span class="math inline">\(Implicit\;Sequences\)</span></span></h1>
<h2><span id="一-概述">一、概述</span></h2>
<h3><span id="1懒惰计算">1.懒惰计算</span></h3>
<p>  一个序列可以在不直接存储在电脑内存的情况下被代表(<span class="math inline">\(represent\)</span>)。这就是说，我们可以创建一个对象，它<strong>能够访问序列型数据集(<span class="math inline">\(sequential\;dataset\)</span>)的所有元素，并且不用预先计算存储所有的元素</strong>。作为替代，我们<strong>只在需要访问某元素的时候进行计算</strong>。</p>
<p>  一个简单的例子是序列类型<span class="math inline">\(range\)</span>。在<span class="math inline">\(range\)</span>中，当一个元素被要求计算出来时，<span class="math inline">\(range\)</span>才会着手计算它。因此，我们可以在不消耗大量内存的情况下表示很大区间范围的整数。只有<span class="math inline">\(range\)</span>的结尾作为<span class="math inline">\(range\)</span>对象的一部分被存储了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">range</span>(<span class="number">10000</span>, <span class="number">1000000000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="number">45006230</span>]</span><br><span class="line"><span class="number">45016230</span></span><br></pre></td></tr></table></figure></p>
<p>  在这个例子中，<code>r[45006230]</code>是通过第一个元素<span class="math inline">\(10000\)</span>加上索引(<span class="math inline">\(index\)</span>)<span class="math inline">\(45006230\)</span>计算出来的。这种<strong>在需要某个值的时候才计算它的行为</strong>被称作懒惰计算(<span class="math inline">\(lazy\;computation\)</span>)。</p>
<h3><span id="2迭代器">2.迭代器</span></h3>
<p>  迭代器(iterator)是一个对象，它为底层的序列型数据集提供循序存取。迭代器抽象有两个组成部分：</p>
<ul>
<li><strong>在序列元素中检索下一个元素<span class="math inline">\(next\)</span></strong> 的机制。</li>
<li><strong>发出结束信号</strong>：已经到达序列结束处、没有其他元素存在的信号的机制。</li>
</ul>
<p>  迭代器的有用之处基于底层的一系列信息(<span class="math inline">\(series\;of\;data\)</span>)可能不会在内存中直接被表示。而迭代器提供了一个<strong>依次考虑一系列值的机制</strong>，而<strong>其他未被考虑的值不需要同时存储在内存中，而是在迭代器访问到它的时候才被计算</strong>。</p>
<p>  <span class="math inline">\(range\)</span>之所以可以对元素进行懒惰计算，是因为<strong>序列内部的元素形式是统一的，并且任意一个值都可以容易地通过头元素与尾元素计算出来</strong>。而迭代器将懒惰计算的适用类型扩大了，因为这些序列类型不需要自己提供一种计算任意值的方法。相反，它们<strong>只需要能依次计算出下一个元素<span class="math inline">\(next\)</span>即可</strong>。</p>
<h2><span id="二-python的迭代器">二、<span class="math inline">\(python\)</span>的迭代器</span></h2>
<h3><span id="1迭代器的功能与性质">1.迭代器的功能与性质</span></h3>
<p>  <span class="math inline">\(python\)</span>迭代器包含<code>__next__</code>信息：询问迭代器序列的下一个元素是什么。对<code>__next__</code>的调用<strong>会导致迭代器的改变</strong>：它<strong>更新当前迭代器的位置</strong>。<span class="math inline">\(python\)</span>在迭代器到达序列末端时会产生<code>StopIteration</code>的异常(<span class="math inline">\(exception\)</span>)。</p>
<p>  下面的$ LetterIter$迭代了一系列字母： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LetterIter</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;An iterator over letters of the alphabet in ASCII order.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="string">&#x27;a&#x27;</span>, end=<span class="string">&#x27;e&#x27;</span></span>):</span><br><span class="line">            self.next_letter = start</span><br><span class="line">            self.end = end</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">if</span> self.next_letter == self.end:</span><br><span class="line">                <span class="keyword">raise</span> StopIteration</span><br><span class="line">            letter = self.next_letter</span><br><span class="line">            self.next_letter = <span class="built_in">chr</span>(<span class="built_in">ord</span>(letter)+<span class="number">1</span>)<span class="comment">#iterate to the next number</span></span><br><span class="line">            <span class="keyword">return</span> letter</span><br></pre></td></tr></table></figure>
  通过这个类，我们可以用<code>__next__</code>方法或<code>next</code>函数来访问字母：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letter_iter = LetterIter()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letter_iter.__next__()</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letter_iter.__next__()</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(letter_iter)</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letter_iter.__next__()</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letter_iter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">12</span>, <span class="keyword">in</span> <span class="built_in">next</span></span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<p>  迭代器是<strong>可改变的(<span class="math inline">\(mutable\)</span>)</strong>。当迭代器到达序列的末尾时，它就被耗尽了。<span class="math inline">\(LetterIter\)</span><strong>只能被迭代一次，当它的<code>__next__</code>方法产生<code>StopIteration</code>的异常后，从这以后的所有迭代都会产生这个异常</strong>。一般地，<strong>迭代器不会重置</strong>。<strong>当一个新的实例被创建时，一个新的迭代器也被创建了</strong>。</p>
<p>  迭代器也可以通过实现<strong>一个不产生异常的<code>__next__</code>方法</strong>来表示无限序列，例如下面表示正整数序列的迭代器：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Positives</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">            self.next_positive = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">            result = self.next_positive</span><br><span class="line">            self.next_positive += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Positives()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(p)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(p)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(p)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="2可迭代性">2.可迭代性</span></h3>
<p>  一个对象<strong>是可迭代的(<span class="math inline">\(iterable\)</span>)，当它的<code>iter</code>方法被调用</strong>。可迭代值代表数据集合，并且它们提供了产生一个或多个迭代器的固定表达。</p>
<p>  以下面这个代表一系列有序字母序列的类为例。每次当其<code>__iter__</code>方法被调用，<strong>一个新的<span class="math inline">\(LetterIter\)</span>实例就被创建，这允许了对序列内容的有序访问</strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Letters</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="string">&#x27;a&#x27;</span>, end=<span class="string">&#x27;e&#x27;</span></span>):</span><br><span class="line">            self.start = start</span><br><span class="line">            self.end = end</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> LetterIter(self.start, self.end)</span><br></pre></td></tr></table></figure></p>
<p>  在下面的表达式中，两个源自同一个可迭代序列的迭代器<strong>独立地</strong>产生各自的单词序列：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b_to_k = Letters(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first_iterator = b_to_k.__iter__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(first_iterator)</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(first_iterator)</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second_iterator = <span class="built_in">iter</span>(b_to_k)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second_iterator.__next__()</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first_iterator.__next__()</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first_iterator.__next__()</span><br><span class="line"><span class="string">&#x27;e&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second_iterator.__next__()</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second_iterator.__next__()</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="3for语句">3.<span class="math inline">\(for\)</span>语句</span></h3>
<p>  <span class="math inline">\(for\)</span>语句对迭代器进行操作。可迭代对象可以作为<span class="math inline">\(for\)</span>语句<code>&lt;expression&gt;</code>结构的值：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure></p>
<p>  为了执行<span class="math inline">\(for\)</span>语句，<span class="math inline">\(python\)</span>会<strong>计算<code>&lt;expression&gt;</code>，它提供一个可迭代的值</strong>。然后，<strong><code>__iter__</code>方法在该值上调用</strong>，直到异常被提出。这个过程中，<span class="math inline">\(python\)</span><strong>将迭代器产生的结果与<code>&lt;name&gt;</code>绑定，然后执行<code>&lt;suite&gt;</code></strong>：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> counts:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>  通过先前对迭代器的讲解，我们可以用<span class="math inline">\(while\)</span>语句实现该<span class="math inline">\(for\)</span>语句： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items = counts.__iter__()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = items.__next__()</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2><span id="三-生成器与yield语句">三、生成器与<code>yield</code>语句</span></h2>
<h3><span id="1引入">1.引入</span></h3>
<p>  当我们在处理复杂序列、并且需要在计算过程中保存<code>__next__</code>的位置时，单独依靠迭代器显得难以为继。生成器(<span class="math inline">\(genarator\)</span>)允许我们利用<span class="math inline">\(python\)</span>的特性定义更为复杂的迭代器。</p>
<h3><span id="2生成器与yield语句的声明与执行">2.生成器与<code>yield</code>语句的声明与执行</span></h3>
<p>  生成器是由被称为生成器函数(<span class="math inline">\(genarator\;function\)</span>)的特殊类函数(<span class="math inline">\(class\;of\;function\)</span>)返回的迭代器。生成器函数与一般函数的区别在于：生成器函数<strong>通过<code>yield</code>语句返回元素而不是<code>return</code>语句</strong>。</p>
<p>  生成器并不用对象的属性来跟踪序列的过程。相反，他<strong>控制生成器函数的执行过程</strong>，这个函数会<strong>在生成器调用<code>__next__</code>方法后一直运行直到下个<code>yield</code>被执行</strong>。<span class="math inline">\(Letter\)</span>迭代器可以利用生成器更加紧凑地实现：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">letters_generator</span>():</span><br><span class="line">        current = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> current &lt;= <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">yield</span> current</span><br><span class="line">            current = <span class="built_in">chr</span>(<span class="built_in">ord</span>(current)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> letter <span class="keyword">in</span> letters_generator():</span><br><span class="line">        <span class="built_in">print</span>(letter)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure></p>
<p>  尽管我们没有直接地定义<code>__iter__</code>与<code>__next__</code>方法，程序中的<code>yield</code>语句表明我们在定义一个生成器函数。<strong>当被调用，生成器函数不会返回一个特定的生成值(<span class="math inline">\(yielded\;value\)</span>)，而是一个生成器(迭代器的一种)，生成器自己会返回生成值</strong>。生成器对象有<code>__iter__</code>和<code>__next__</code>方法。</p>
<p>  第一次<code>__next__</code>被调用时，程序执行<code>&lt;body&gt;</code>内语句，即<code>letters_generator</code>，直到<strong>遇到<code>yield</code>语句。然后，它暂停执行并返回<span class="math inline">\(current\)</span>的值</strong>。<code>yield</code>语句并不会破坏新创建的环境，<strong>它会保存这个环境留着之后计算使用</strong>。<strong>当<code>__next__</code>被再次调用时，程序从之前停下来的地方开始执行</strong>。在对<code>__next__</code>的后续调用中，<code>letters_generator</code>作用域中的<span class="math inline">\(current\)</span>值和其他绑定名称被保存下来：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = letters_generator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(letters)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;generator&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line"><span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<h3><span id="3利用yield语句创建可迭代对象">3.利用<code>yield</code>语句创建可迭代对象</span></h3>
<p>  在<span class="math inline">\(python\)</span>中，迭代器只会对底层序列的元素进行一次传递，<strong>当这次传递结束后，再次调用<code>__next__</code>方法，迭代器将一直产生<code>StopIteration</code>异常</strong>。而许多程序需要<strong>多次迭代</strong>元素，例如我们想要枚举一个列表的所有<span class="math inline">\(pair\)</span>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">all_pairs</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="keyword">for</span> item1 <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">for</span> item2 <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">yield</span> (item1, item2)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(all_pairs([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure></p>
<p>  序列本身<strong>不是迭代器，而是可迭代对象</strong>。当<strong>序列的<code>__iter__</code>方法被调用后，序列会返回一个新的迭代器实例</strong>。如果一个可迭代对象<strong>在每次调用<code>__iter__</code>后都会返回一个新的新的迭代器实例，它就可以被多次迭代</strong>。</p>
<p>  可以通过实现一个可迭代接口来定义新的可迭代类，例如下面<span class="math inline">\(LettersWithYield\)</span>类就在每次调用<code>__iter__</code>后返回一个新的迭代器：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#create an iterable object</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LettersWithYield</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="string">&#x27;a&#x27;</span>, end=<span class="string">&#x27;e&#x27;</span></span>):</span><br><span class="line">            self.start = start</span><br><span class="line">            self.end = end</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">            next_letter = self.start</span><br><span class="line">            <span class="keyword">while</span> next_letter &lt; self.end:</span><br><span class="line">                <span class="keyword">yield</span> next_letter</span><br><span class="line">                next_letter = <span class="built_in">chr</span>(<span class="built_in">ord</span>(next_letter)+<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>  该类的<code>__iter__</code>方法是一个生成器函数，它<strong>返回一个生成器对象，这个生成器对象生成从<code>a</code>到<code>d</code>的序列后停下</strong>。每次我们调用这个方法，一个新的生成器会开始对序列型数据的新的传递：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = LettersWithYield()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(all_pairs(letters))[:<span class="number">5</span>]</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)]</span><br></pre></td></tr></table></figure></p>
<h2><span id="四-流">四、流</span></h2>
<h3><span id="1流的概念">1.流的概念</span></h3>
<p>  流(<span class="math inline">\(stream\)</span>)提供了隐性表示序列型数据的另一种方法。流是<strong>懒惰计算的递归列表(<span class="math inline">\(recusive\;list\)</span>)</strong>，与链表结构类似。但与链表不同，<strong>流的<span class="math inline">\(rest\)</span>部分只有在被调用的时候才会被计算</strong>。</p>
<h3><span id="2流的实现与调用">2.流的实现与调用</span></h3>
<p>  为了实现懒惰计算的操作，流会<strong>存储一个计算<span class="math inline">\(rest\)</span>部分的函数</strong>。当这个函数被调用时，<strong>它的返回值作为流的属性<code>_rest</code>存储在流的一部分</strong>，名称前面的下划线说明<strong>它不应该被直接访问</strong>。而<strong>可访问的<code>rest</code>属性是一个返回流的<span class="math inline">\(rest\)</span>部分的属性方法</strong>。流的基本设计如下：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;A lazily computed recursive list.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">empty</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Stream.empty&#x27;</span></span><br><span class="line">        empty = empty()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first, compute_rest=<span class="keyword">lambda</span>: empty</span>):</span><br><span class="line">            <span class="keyword">assert</span> <span class="built_in">callable</span>(compute_rest), <span class="string">&#x27;compute_rest must be callable.&#x27;</span></span><br><span class="line">            self.first = first</span><br><span class="line">            self._compute_rest = compute_rest</span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">rest</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Return the rest of the stream, computing it if necessary.&quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> self._compute_rest <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self._rest = self._compute_rest()</span><br><span class="line">                self._compute_rest = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> self._rest</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Stream(&#123;0&#125;, &lt;...&gt;)&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">repr</span>(self.first))</span><br></pre></td></tr></table></figure></p>
<p>  流可以像链表一样利用嵌套表达式创建。为了实现懒惰计算，我们采用匿名函数的方法：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = Stream(<span class="number">1</span>, <span class="keyword">lambda</span>: Stream(<span class="number">2</span>+<span class="number">3</span>, <span class="keyword">lambda</span>: Stream(<span class="number">9</span>)))</span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(lambda\)</span>表达式返回<strong>计算流剩余部分的方法</strong>。可以通过下面的操作访问流中的元素：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.first</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.first</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.rest.first</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rest.first</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.rest</span><br><span class="line">Rlist(<span class="number">5</span>, Rlist(<span class="number">9</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rest</span><br><span class="line">Stream(<span class="number">5</span>, &lt;...&gt;)</span><br><span class="line"><span class="comment">#the fact that it will return the empty stream are undiscovered</span></span><br></pre></td></tr></table></figure></p>
<p>  当一个<span class="math inline">\(stream\)</span>实例被创建时，<code>self._rest</code>是<span class="math inline">\(None\)</span>，这表明实例的<span class="math inline">\(rest\)</span>部分尚未被计算；<strong>当<code>rest</code>属性通过点表达式被访问后，<code>rest</code>的属性方法被调用，触发了<code>self._rest = self._compute_rest()</code>的计算</strong>。</p>
<p>  <code>compute_rest</code>函数的关键属性是：它<strong>不接受参数，并且返回<span class="math inline">\(stream\)</span>或<span class="math inline">\(stream.empty\)</span></strong>。</p>
<p>  懒惰计算允许我们用流表示无限的序列型数据集。例如，可以用以下语句表示正整数集：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">integer_stream</span>(<span class="params">first</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute_rest</span>():</span><br><span class="line">        <span class="keyword">return</span> integer_stream(first+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> Stream(first, compute_rest)</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>positives = integer_stream(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>positives</span><br><span class="line">Stream(<span class="number">1</span>, &lt;...&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>positives.first</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="3利用流实现序列基本操作">3.利用流实现序列基本操作</span></h3>
<p>  上述<strong>利用高阶函数改变<span class="math inline">\(compute_rest\)</span>函数</strong>的方法可以用于其他序列操作：</p>
<h4><span id="amap映射">  <span class="math inline">\(a.\)</span><span class="math inline">\(map\)</span>映射</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">map_stream</span>(<span class="params">fn, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Stream.empty:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">compute_rest</span>():</span><br><span class="line">            <span class="keyword">return</span> map_stream(fn, s.rest)</span><br><span class="line">        <span class="keyword">return</span> Stream(fn(s.first), compute_rest)</span><br></pre></td></tr></table></figure>
<h4><span id="b筛选指定元素">  <span class="math inline">\(b.\)</span>筛选指定元素</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">filter_stream</span>(<span class="params">fn, s</span>):</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> Stream.empty:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">compute_rest</span>():</span><br><span class="line">            <span class="keyword">return</span> filter_stream(fn, s.rest)</span><br><span class="line">        <span class="keyword">if</span> fn(s.first):</span><br><span class="line">            <span class="keyword">return</span> Stream(s.first, compute_rest)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> compute_rest()</span><br></pre></td></tr></table></figure>
<h4><span id="c筛选前k个元素">  <span class="math inline">\(c.\)</span>筛选前<span class="math inline">\(k\)</span>个元素</span></h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">first_k_as_list</span>(<span class="params">s, k</span>):</span><br><span class="line">        first_k = []</span><br><span class="line">        <span class="keyword">while</span> s <span class="keyword">is</span> <span class="keyword">not</span> Stream.empty <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            first_k.append(s.first)</span><br><span class="line">            s, k = s.rest, k-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> first_k</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = integer_stream(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Stream(<span class="number">3</span>, &lt;...&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = map_stream(<span class="keyword">lambda</span> x: x*x, s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">Stream(<span class="number">9</span>, &lt;...&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first_k_as_list(m, <span class="number">5</span>)</span><br><span class="line">[<span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>]</span><br></pre></td></tr></table></figure>
<p>  正如链表提供的简单的数据抽象的实现，流也提供了一个简单的函数化递归数据结构，通过高阶函数实现懒惰计算。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 4.Data Processing</category>
      </categories>
  </entry>
  <entry>
    <title>4.3.子类多态性</title>
    <url>/2024/05/31/4.3.subtype%20polymorphism/</url>
    <content><![CDATA[<h1><span id="43子类多态性"><span class="math inline">\(4.3\)</span>子类多态性</span></h1>
<h3><span id="1多态性的概念">1.多态性的概念</span></h3>
<p>  在前面，我们学习了如何运用继承来重复利用已有的代码。继承也可以用于设计具有多态性的通用数据结构与方法。</p>
<p>  在<span class="math inline">\(Java\)</span>中，多态性(<span class="math inline">\(polymorphism\)</span>)代指对象具有不同形式的类型(<span class="math inline">\(types\)</span>)的性质；在面向对象编程中，多态性代指对象具有的不同身份：自己类中的一个实例、主类的一个实例...</p>
<p>  考虑下面的问题：我们要实现一个比较函数，用于比较两个对象的大小。我们可以用高阶函数实现：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_larger</span>(<span class="params">x, y, compare, stringify</span>):</span><br><span class="line">    <span class="keyword">if</span> compare(x, y):</span><br><span class="line">        <span class="keyword">return</span> stringify(x)</span><br><span class="line">    <span class="keyword">return</span> stringify(y)</span><br></pre></td></tr></table></figure></p>
<p>  还可以用子类多态性实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_larger</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> x.largerThan(y):</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">return</span> y.<span class="built_in">str</span>()</span><br></pre></td></tr></table></figure></p>
<p>  高阶函数给出的是普适的方法，对任何对象都适用。而在子类多态性的方法中，需要对象自己做出决定，执行相应的方法，<code>x.largerThan</code>方法是由<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>来决定的。</p>
<h3><span id="2子类多态性的应用">2.子类多态性的应用</span></h3>
<p>  假设我们想要实现一个普适的<code>max</code>函数，这个函数接受任意类型的数组，并返回数组中的最大元素。</p>
<p>  一个简单的想法是用<code>&gt;</code>比较： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">max</span><span class="params">(Object[] items)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (items[i] &gt; items[maxDex]) &#123;</span><br><span class="line">            maxDex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items[maxDex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  我们默认<code>&gt;</code>可以比较任意类型的对象，但是实际上不行。因为<code>&gt;</code>只能用于确定类型的对象。</p>
<p>  于是问题转为实现能比较任意类型对象的<code>&gt;</code>。我们可以为此创建一个方法接口<code>compareTo</code>，来确保每个对象都可以调用该方法来比较大小:
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样，我们对每个子类逐一实现对应的<span class="math inline">\(implements\)</span>即可。以<span class="math inline">\(Dog\)</span>类为例： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">OurComparable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">        <span class="comment">// notice that compartTo takes in any object,we need to cast o.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - d.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  实现<code>compareTo</code>后，便可自然地实现<code>max</code>了：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> OurComparable <span class="title function_">max</span><span class="params">(OurComparable[] items)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> items[i].compareTo(items[maxDex]);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxDex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items[maxDex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  利用继承，我们优雅地实现了通用的<code>max</code>函数。</p>
<h3><span id="3comparable接口">3.<code>comparable</code>接口</span></h3>
<p>  <span class="math inline">\(Java\)</span>中已有的<code>comparable</code>接口可以更好地实现<code>max</code>，它的形式如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  与<span class="math inline">\(OurComparable\)</span>相比，该接口接受一个通用类型，这使得我们不需要使用类型铸造，同时即使一个类没有继承接口，它也可以调用<code>max</code>。这样，我们的<span class="math inline">\(Dog\)</span>类可以如此实现： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog d)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - d.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  通过内置(<span class="math inline">\(built-in\)</span>)的接口，我们得以利用已有的库(<span class="math inline">\(libraries\)</span>)和<span class="math inline">\(Comparable\)</span>接口。</p>
<h3><span id="4comparator接口">4.<code>comparator</code>接口</span></h3>
<p>  考虑下面的问题：假如我们不想让<span class="math inline">\(Dog\)</span>以<span class="math inline">\(size\)</span>排列，该怎么写<code>max</code>呢？</p>
<p>  <span class="math inline">\(Java\)</span>的内置接口<code>comparator</code>内部如下：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这说明<code>comparator</code>需要子类实现<code>compare</code>方法，它和<code>compareTo</code>的规则相似。我们可以如下实现<span class="math inline">\(Dog\)</span>的<code>compare</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog uddaDog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - uddaDog.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NameComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Dog&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Dog a, Dog b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.name.compareTo(b.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//declared it as static,for it doesn&#x27;t use any other methods  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Dog&gt; <span class="title function_">getNameComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NameComparator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(Dog\)</span>类通过<code>Comparator</code>的内部接口实现了继承的层次性：我们可以在<span class="math inline">\(Dog\)</span>内部定义自己需要的比较方法：<code>NameComparator</code>、<code>SizeComparator</code>...</p>
<h3><span id="5接口的功能">5.接口的功能</span></h3>
<p>  <span class="math inline">\(Java\)</span>中的接口为我们提供了函数回调(<span class="math inline">\(callback\)</span>)的能力。有时，一个函数需要其他还未实现的函数的帮助，如<code>max</code>需要<code>compareTo</code>。而回调函数就是辅助函数(<span class="math inline">\(helper\;function\)</span>)，如<code>compareTo</code>。在<span class="math inline">\(Java\)</span>中，我们把需要的函数封装在接口内。</p>
<blockquote>
<p>  A Comparable says, "I want to compare myself to another object". It
is imbedded within the object itself, and it defines the natural
ordering of a type. A Comparator, on the other hand, is more like a
third party machine that compares two objects to each other. Since
there's only room for one compareTo method, if we want multiple ways to
compare, we must turn to Comparator.</p>
</blockquote>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>4.inheritance &amp; inplements</category>
      </categories>
  </entry>
  <entry>
    <title>4.3.声明式编程</title>
    <url>/2024/05/31/4.3.%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1><span id="43声明式编程declarativeprogramming"><span class="math inline">\(4.3\)</span>声明式编程(<span class="math inline">\(declarative\;programming\)</span>)</span></h1>
<h2><span id="一-概述">一、概述</span></h2>
<p>  除了流(<span class="math inline">\(streams\)</span>)，数据的值也经常存储在一个叫作数据库(<span class="math inline">\(database\)</span>)的仓库里。</p>
<p>  数据库由存入其中的数据和检索、转换这些数据的接口组成。每个存储在数据库中的值称作记录(<span class="math inline">\(record\)</span>)，有着相似结构的记录被归类为表格(<span class="math inline">\(tables\)</span>)。可以通过询问语言中的询问语句(<span class="math inline">\(queries\)</span>)来检索、转换记录。目前最普遍的询问语言被称作<span class="math inline">\(Structure\;Query\;Language(SQL)\)</span>。</p>
<p>  <span class="math inline">\(SQL\)</span>是声明式编程语言的一种。在这种语言中，声明并不直接描述计算，而是描述计算想要得到的结果。而设计和运行一个计算过程来得到这个结果是询问解释器(<span class="math inline">\(query\;interpreter\)</span>)的工作。这种语言经常将过程性的细节(<span class="math inline">\(procedural\;details\)</span>)抽象，而专注于结果的形式(<span class="math inline">\(form\)</span>)。</p>
<h2><span id="二-sql">二、<span class="math inline">\(SQL\)</span></span></h2>
<h3><span id="1表格">1.表格</span></h3>
<p>  表格(<span class="math inline">\(table\)</span>)具有固定数量的命名列(<span class="math inline">\(named\;column\)</span>)和类型列(<span class="math inline">\(typed\;column\)</span>)。表的每一行表示一个数据记录，行中的每一列表示一个值。例如下面这个关于城市的表格：</p>
<p><img src="/2024/05/31/4.3.%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B/image.png"></p>
<p>  一个只有一行的表格可以通过<span class="math inline">\(select\)</span>语句创建。该行的每个值间用逗号隔开，列名称跟在关键词<span class="math inline">\(as\)</span>后面。所有的<span class="math inline">\(SQL\)</span>语句都以分号结尾： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select 38 as latitude, 122 as longitude, &quot;Berkeley&quot; as name;</span><br><span class="line">38|122|Berkeley</span><br></pre></td></tr></table></figure></p>
<p>  多行的表格可以通过<span class="math inline">\(union\)</span>语句创建： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select 38 as latitude, 122 as longitude, &quot;Berkeley&quot; as name union</span><br><span class="line">   ...&gt; select 42,             71,               &quot;Cambridge&quot;        union</span><br><span class="line">   ...&gt; select 45,             93,               &quot;Minneapolis&quot;;</span><br><span class="line">38|122|Berkeley</span><br><span class="line">42|71|Cambridge</span><br><span class="line">45|93|Minneapolis</span><br></pre></td></tr></table></figure></p>
<p>  可以通过<span class="math inline">\(create\;table\)</span>语句来给表格命名：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table cities as</span><br><span class="line">   ...&gt;    select 38 as latitude, 122 as longitude, &quot;Berkeley&quot; as name union</span><br><span class="line">   ...&gt;    select 42,             71,               &quot;Cambridge&quot;        union</span><br><span class="line">   ...&gt;    select 45,             93,               &quot;Minneapolis&quot;;</span><br></pre></td></tr></table></figure></p>
<p>  当一个表格被命名后，可以通过<span class="math inline">\(from\)</span>语句调用这个名字。表格中的所有列可以通过<code>select *</code>形式访问：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select * from cities;</span><br><span class="line">38|122|Berkeley</span><br><span class="line">42|71|Cambridge</span><br><span class="line">45|93|Minneapolis</span><br></pre></td></tr></table></figure></p>
<h3><span id="2select语句">2.<span class="math inline">\(select\)</span>语句</span></h3>
<p>  <span class="math inline">\(select\)</span>语句通过列举(<span class="math inline">\(listing\)</span>)某一行的值，或者(更普遍地)从一个已存在的表格中，利用<span class="math inline">\(from\)</span>句式投射(<span class="math inline">\(project\)</span>)来定义一个表格。该语句的一般格式如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select [column description] from [existing table name]</span><br></pre></td></tr></table></figure>   这里的<span class="math inline">\(column\;expression\)</span>表示对原来表格的列的操作，如加减乘除等。</p>
<p>  例如，我们可以用如下方法来创造一个两列的表格，这个表格描述了每个城市到<span class="math inline">\(Berkeley\)</span>的距离： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select name, 60*abs(latitude-38) from cities;</span><br><span class="line">Berkeley|0</span><br><span class="line">Cambridge|240</span><br><span class="line">Minneapolis|420</span><br></pre></td></tr></table></figure></p>
<p>  为了方便后续被其它<span class="math inline">\(select\)</span>语句所引用，在定义表格时给每一个列一个名字往往是必须的：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table distances as</span><br><span class="line">   ...&gt;   select name, 60*abs(latitude-38) as distance from cities;</span><br><span class="line">sqlite&gt; select distance/5, name from distances;</span><br><span class="line">0|Berkeley</span><br><span class="line">48|Cambridge</span><br><span class="line">84|Minneapolis</span><br></pre></td></tr></table></figure></p>
<h4><span id="awhere语句">  <span class="math inline">\(a.\)</span><span class="math inline">\(Where\)</span>语句</span></h4>
<p>  <span class="math inline">\(select\)</span>语句也可以穿插一个表示过滤元素(<span class="math inline">\(filering\)</span>)的<span class="math inline">\(where\)</span>语句。这个表达式将不符合<span class="math inline">\(where\)</span>语句的行给筛序掉。只有符合筛选条件的行才会被用于构成一个新的表格：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table cold as</span><br><span class="line">   ...&gt;   select name from cities where latitude &gt; 43;</span><br><span class="line">sqlite&gt; select name, &quot;is cold!&quot; from cold;</span><br><span class="line">Minneapolis|is cold!</span><br></pre></td></tr></table></figure></p>
<h4><span id="b顺序语句">  <span class="math inline">\(b.\)</span>顺序语句</span></h4>
<p>  顺序语句(<span class="math inline">\(order\;clause\)</span>)包括一个排序表达式，所有未被过滤的行都会按照这个语句进行排序：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select distance, name from distances order by -distance;</span><br><span class="line">84|Minneapolis</span><br><span class="line">48|Cambridge</span><br><span class="line">0|Berkeley</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(select\)</span>的这些特性功能使得<span class="math inline">\(select\)</span>能够表示很多种类的行输入表格到输出表格的映射。</p>
<h3><span id="3合并">3.合并</span></h3>
<h4><span id="a合并的基本操作">  <span class="math inline">\(a.\)</span>合并的基本操作</span></h4>
<p>  众多数据可以通过合并(<span class="math inline">\(joining\)</span>)表格变成一个，这是数据库系统中一个基础的操作。</p>
<p>  当表格被合并后，对于输入表格的每一个行，合并后的表格都会包括一个新的行。如果有两个表格进行合并操作，它们分别有<span class="math inline">\(m\)</span>行与<span class="math inline">\(n\)</span>行，那么合并后的表格就会有<span class="math inline">\(m\times n\)</span>行。在<span class="math inline">\(SQL\)</span>语言中，合并两个表格是通过<span class="math inline">\(from\)</span>语句加上逗号隔开的表格名称实现的：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table temps as</span><br><span class="line">   ...&gt;   select &quot;Berkeley&quot; as city, 68 as temp union</span><br><span class="line">   ...&gt;   select &quot;Chicago&quot;         , 59         union</span><br><span class="line">   ...&gt;   select &quot;Minneapolis&quot;     , 55;</span><br><span class="line"></span><br><span class="line">sqlite&gt; select * from cities, temps;</span><br><span class="line">38|122|Berkeley|Berkeley|68</span><br><span class="line">38|122|Berkeley|Chicago|59</span><br><span class="line">38|122|Berkeley|Minneapolis|55</span><br><span class="line">42|71|Cambridge|Berkeley|68</span><br><span class="line">42|71|Cambridge|Chicago|59</span><br><span class="line">42|71|Cambridge|Minneapolis|55</span><br><span class="line">45|93|Minneapolis|Berkeley|68</span><br><span class="line">45|93|Minneapolis|Chicago|59</span><br><span class="line">45|93|Minneapolis|Minneapolis|55</span><br></pre></td></tr></table></figure></p>
<h4><span id="b不同表格的关系">  <span class="math inline">\(b.\)</span>不同表格的关系</span></h4>
<p>  同样地，合并也可以通过<span class="math inline">\(where\)</span>语句，表示两个表格间的关系。例如，我们希望将数据收集到一个表中，以获得每个城市自己的<span class="math inline">\(temp\)</span>和<span class="math inline">\(lati\)</span>。可以通过以下语句实现这个想法：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select name, latitude, temp from cities, temps where name = city;</span><br><span class="line">Berkeley|38|68</span><br><span class="line">Minneapolis|45|55</span><br></pre></td></tr></table></figure></p>
<h4><span id="c消除歧义">  <span class="math inline">\(c.\)</span>消除歧义</span></h4>
<p>  为了消除名称相同的表格间的歧义，<span class="math inline">\(SQL\)</span>允许我们使用关键字<span class="math inline">\(as\)</span>为<span class="math inline">\(form\)</span>语句提供别名，并利用点表达式来引用特定的表中的列。在下面计算不同城市温差的例子中，<span class="math inline">\(where\)</span>语句的字母顺序约束确保了每个对在结果中只出现一次：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select a.city, b.city, a.temp - b.temp</span><br><span class="line">   ...&gt;        from temps as a, temps as b where a.city &lt; b.city;</span><br><span class="line">Berkeley|Chicago|10</span><br><span class="line">Berkeley|Minneapolis|15</span><br><span class="line">Chicago|Minneapolis|5</span><br></pre></td></tr></table></figure></p>
<h2><span id="三-sql解释器">三、<span class="math inline">\(SQL\)</span>解释器</span></h2>
<h3><span id="1概括">1.概括</span></h3>
<p>  为了创建一个<span class="math inline">\(SQL\)</span>解释器，我们需要创造一个对表格的表示、对<span class="math inline">\(SQL\)</span>语句的分析器，和对分析后语句的计算器。</p>
<p>  在这个实现中，每个表格有自己的一个类，并且表格中的每行都由该类的一个实例来代表。一行的每一列都有一个属性，并且表格是列的序列。</p>
<h3><span id="2table的创建">2.<span class="math inline">\(table\)</span>的创建</span></h3>
<p>  在<span class="math inline">\(python\)</span>中，可以用<span class="math inline">\(namedtuple\)</span>函数实现表格的类，它会返回一个新的<span class="math inline">\(tuple\)</span>子类，这个子类会为元组中的每个元素给予名称。例如，先前的<span class="math inline">\(cities\)</span>表格可以用如下<span class="math inline">\(python\)</span>语句实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">CitiesRow = namedtuple(<span class="string">&quot;Row&quot;</span>, [<span class="string">&quot;latitude&quot;</span>, <span class="string">&quot;longitude&quot;</span>, <span class="string">&quot;name&quot;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cities = [CitiesRow(<span class="number">38</span>, <span class="number">122</span>, <span class="string">&quot;Berkeley&quot;</span>),</span><br><span class="line">              CitiesRow(<span class="number">42</span>,  <span class="number">71</span>, <span class="string">&quot;Cambridge&quot;</span>),</span><br><span class="line">              CitiesRow(<span class="number">43</span>,  <span class="number">93</span>, <span class="string">&quot;Minneapolis&quot;</span>)]</span><br></pre></td></tr></table></figure></p>
<h3><span id="3select的实现">3.<span class="math inline">\(select\)</span>的实现</span></h3>
<p>  可以通过序列操作来实现<span class="math inline">\(select\)</span>语句，例如先前生成的<span class="math inline">\(cities\)</span>的<span class="math inline">\(distances\)</span>的表格： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table distances as</span><br><span class="line">   ...&gt;   select name, 60*abs(latitude-38) as distance from cities;</span><br><span class="line">sqlite&gt; select distance/5, name from distances;</span><br><span class="line">0|Berkeley</span><br><span class="line">48|Cambridge</span><br><span class="line">84|Minneapolis</span><br></pre></td></tr></table></figure></p>
<p>  这个表格是由<span class="math inline">\(cities\)</span>的<span class="math inline">\(name\)</span>列和<span class="math inline">\(latitude\)</span>列生成的。该过程可以通过对输入表格的行用一个函数映射(<span class="math inline">\(mapping\;a\;function\)</span>)、然后返回一个新的行来实现：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>DistancesRow = namedtuple(<span class="string">&quot;Row&quot;</span>, [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;distance&quot;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">cities_row</span>):</span><br><span class="line">        latitude, longitude, name = cities_row</span><br><span class="line">        <span class="keyword">return</span> DistancesRow(name, <span class="number">60</span>*<span class="built_in">abs</span>(latitude-<span class="number">38</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>distances = <span class="built_in">list</span>(<span class="built_in">map</span>(select, cities))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> distances:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">Row(name=<span class="string">&#x27;Berkeley&#x27;</span>, distance=<span class="number">0</span>)</span><br><span class="line">Row(name=<span class="string">&#x27;Cambridge&#x27;</span>, distance=<span class="number">240</span>)</span><br><span class="line">Row(name=<span class="string">&#x27;Minneapolis&#x27;</span>, distance=<span class="number">300</span>)</span><br></pre></td></tr></table></figure></p>
<h3><span id="4解释器的整体实现">4.解释器的整体实现</span></h3>
<p>  <span class="math inline">\(SQL\)</span>解释器的设计将上述方法普遍化了：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Select</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;select [columns] from [tables] where [condition] order by [order].&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, columns, tables, condition, order</span>):</span><br><span class="line">            self.columns = columns</span><br><span class="line">            self.tables = tables</span><br><span class="line">            self.condition = condition</span><br><span class="line">            self.order = order</span><br><span class="line">            self.make_row = create_make_row(self.columns)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, env</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;Join, filter, sort, and map rows from tables to columns.&quot;&quot;&quot;</span></span><br><span class="line">            from_rows = join(self.tables, env)</span><br><span class="line">            filtered_rows = <span class="built_in">filter</span>(self.<span class="built_in">filter</span>, from_rows)</span><br><span class="line">            ordered_rows = self.sort(filtered_rows)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>(self.make_row, ordered_rows)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">self, row</span>):</span><br><span class="line">            <span class="keyword">if</span> self.condition:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">eval</span>(self.condition, row)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">self, rows</span>):</span><br><span class="line">            <span class="keyword">if</span> self.order:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sorted</span>(rows, key=<span class="keyword">lambda</span> r: <span class="built_in">eval</span>(self.order, r))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> rows</span><br></pre></td></tr></table></figure></p>
<p>  <code>execute</code>方法将输入的表格进行合并、过滤和排序。最后输出行调用的函数<code>make_row</code>是一个高阶函数，它为生成的表格创建了一个新的类，并且定义了如何从一个输入行(<span class="math inline">\(input\;row\)</span>)到一个输出行(<span class="math inline">\(output\;row\)</span>)： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_make_row</span>(<span class="params">description</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a function from an input environment (dict) to an output row.</span></span><br><span class="line"><span class="string">        description -- a comma-separated list of [expression] as [column name]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#seperate the string by commas and space</span></span><br><span class="line">        columns = description.split(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">        expressions, names = [], []</span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> columns:</span><br><span class="line">        <span class="comment">#if an &#x27;as&#x27; is contained in the coloum,then divide it into expression and column name</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot; as &quot;</span> <span class="keyword">in</span> column:</span><br><span class="line">                expression, name = column.split(<span class="string">&quot; as &quot;</span>)</span><br><span class="line">         <span class="comment">#else,view expression and name as the same</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                expression, name = column, column</span><br><span class="line">            expressions.append(expression)</span><br><span class="line">            names.append(name)</span><br><span class="line">        row = namedtuple(<span class="string">&quot;Row&quot;</span>, names)</span><br><span class="line">        <span class="comment">#the lambda function output a named tuple,its value is received by calculating the expression in the current environment</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> env: row(*[<span class="built_in">eval</span>(e, env) <span class="keyword">for</span> e <span class="keyword">in</span> expressions])</span><br></pre></td></tr></table></figure></p>
<p>  最后，我们需要定义<span class="math inline">\(join\)</span>函数。在提供<code>env</code>，包括由名字键(<span class="math inline">\(keyed\;by\;name\)</span>)控制的现有表格(以行列表的形式存在)，的情况下，<span class="math inline">\(join\)</span>函数通过<span class="math inline">\(python\)</span>的<span class="math inline">\(product\)</span>函数，将这些行列表进行合并。对被合并的输出行，它用<code>make_env</code>函数映射，来得出对应字段的计算值：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">tables, env</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return an iterator over dictionaries from names to values in a row.</span></span><br><span class="line"><span class="string">        tables -- a comma-separate sequences of table names</span></span><br><span class="line"><span class="string">        env    -- a dictionary from global names to tables</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        names = tables.split(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">        joined_rows = product(*[env[name] <span class="keyword">for</span> name <span class="keyword">in</span> names])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> rows: make_env(rows, names), joined_rows)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">make_env</span>(<span class="params">rows, names</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create an environment of names bound to values.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#transform a tuple into a dictionary</span></span><br><span class="line">        env = <span class="built_in">dict</span>(<span class="built_in">zip</span>(names, rows))</span><br><span class="line">        <span class="comment"># add the name and its value into the dictionary</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> row._fields:</span><br><span class="line">                env[name] = <span class="built_in">getattr</span>(row, name)</span><br><span class="line">        <span class="keyword">return</span> env</span><br></pre></td></tr></table></figure></p>
<p>  上述的<span class="math inline">\(SQL\)</span>解释器能够实现大部分<span class="math inline">\(SQL\)</span>语句： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select name, 60*abs(latitude-38) as distance</span><br><span class="line">   ...&gt;        from cities where name != &quot;Berkeley&quot; order by -longitude;</span><br><span class="line">Minneapolis|420</span><br><span class="line">Cambridge|240</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>env = &#123;<span class="string">&quot;cities&quot;</span>: cities&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select = Select(<span class="string">&quot;name, 60*abs(latitude-38) as distance&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;cities&quot;</span>, <span class="string">&quot;name != &#x27;Berkeley&#x27;&quot;</span>, <span class="string">&quot;-longitude&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> select.execute(env):</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">Row(name=<span class="string">&#x27;Minneapolis&#x27;</span>, distance=<span class="number">300</span>)</span><br><span class="line">Row(name=<span class="string">&#x27;Cambridge&#x27;</span>, distance=<span class="number">240</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select cities.name as name, distance, longitude</span><br><span class="line">   ...&gt;        from cities, distances where cities.name = distances.name;</span><br><span class="line">Cambridge|240|71</span><br><span class="line">Minneapolis|420|93</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>env[<span class="string">&quot;distances&quot;</span>] = <span class="built_in">list</span>(select.execute(env))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joined = Select(<span class="string">&quot;cities.name as name, distance, longitude&quot;</span>, <span class="string">&quot;cities, distances&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;cities.name == distances.name&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> joined.execute(env):</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">Row(name=<span class="string">&#x27;Cambridge&#x27;</span>, distance=<span class="number">240</span>, longitude=<span class="number">71</span>)</span><br><span class="line">Row(name=<span class="string">&#x27;Minneapolis&#x27;</span>, distance=<span class="number">300</span>, longitude=<span class="number">93</span>)</span><br></pre></td></tr></table></figure></p>
<h2><span id="四-递归select语句">四、递归<span class="math inline">\(select\)</span>语句</span></h2>
<h3><span id="1with语句">1.<span class="math inline">\(with\)</span>语句</span></h3>
<p>  <span class="math inline">\(with\)</span>语句的格式如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with [tables] select [columns] from [names] where [condition] order by [order]</span><br></pre></td></tr></table></figure></p>
<p>  这里的<span class="math inline">\(tables\)</span>部分是一个用逗号分隔开的列表，列表内是对表格的描述：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[table name]([column names]) as ([select statement])</span><br></pre></td></tr></table></figure></p>
<p>  任何<span class="math inline">\(select\)</span>语句都可以用于描述表格。</p>
<p>  下面的例子展示了<span class="math inline">\(with\)</span>语句的使用： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; with</span><br><span class="line">   ...&gt;   states(city, state) as (</span><br><span class="line">   ...&gt;     select &quot;Berkeley&quot;,  &quot;California&quot;    union</span><br><span class="line">   ...&gt;     select &quot;Boston&quot;,    &quot;Massachusetts&quot; union</span><br><span class="line">   ...&gt;     select &quot;Cambridge&quot;, &quot;Massachusetts&quot; union</span><br><span class="line">   ...&gt;     select &quot;Chicago&quot;,   &quot;Illinois&quot;      union</span><br><span class="line">   ...&gt;     select &quot;Pasadena&quot;,  &quot;California&quot;</span><br><span class="line">   ...&gt;   )</span><br><span class="line">   ...&gt; select a.city, b.city, a.state from states as a, states as b</span><br><span class="line">   ...&gt;        where a.state = b.state and a.city &lt; b.city;</span><br><span class="line">Berkeley|Pasadena|California</span><br><span class="line">Boston|Cambridge|Massachusetts</span><br></pre></td></tr></table></figure></p>
<p>  在<span class="math inline">\(with\)</span>语句中定义的表格可以包含一个简单的递归结构，通过其他的输出行来得出当前输出行。例如下面定义一个<span class="math inline">\(5\)</span>到<span class="math inline">\(15\)</span>间整数的表格： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; with</span><br><span class="line">   ...&gt;   ints(n) as (</span><br><span class="line">   ...&gt;     select 5 union</span><br><span class="line">   ...&gt;     select n+1 from ints where n &lt; 15</span><br><span class="line">   ...&gt;   )</span><br><span class="line">   ...&gt; select n, n*n from ints where n % 2 = 1;</span><br><span class="line">5|25</span><br><span class="line">7|49</span><br><span class="line">9|81</span><br><span class="line">11|121</span><br><span class="line">13|169</span><br><span class="line">15|225</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(with\)</span>语句还可以定义多重表格，表格间用逗号隔开。例如下面求解勾股数的表格：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; with</span><br><span class="line">   ...&gt;   ints(n) as (</span><br><span class="line">   ...&gt;     select 1 union </span><br><span class="line">            select n+1 from ints where n &lt; 20</span><br><span class="line">   ...&gt;   ),</span><br><span class="line">   ...&gt;   squares(x, xx) as (</span><br><span class="line">   ...&gt;     select n, n*n from ints</span><br><span class="line">   ...&gt;   ),</span><br><span class="line">   ...&gt;   sum_of_squares(a, b, sum) as (</span><br><span class="line">   ...&gt;     select a.x, b.x, a.xx + b.xx</span><br><span class="line">   ...&gt;            from squares as a, squares as b where a.x &lt; b.x</span><br><span class="line">   ...&gt;   )</span><br><span class="line">   ...&gt; select a, b, x from squares, sum_of_squares where sum = xx;</span><br><span class="line">3|4|5</span><br><span class="line">6|8|10</span><br><span class="line">5|12|13</span><br><span class="line">9|12|15</span><br><span class="line">8|15|17</span><br><span class="line">12|16|20</span><br></pre></td></tr></table></figure></p>
<p>  设计递归询问需要确保每个输入行都有足够的信息来计算结果行。例如下面求解斐波那契数的表格：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; with</span><br><span class="line">   ...&gt;   fib(previous, current) as (</span><br><span class="line">   ...&gt;     select 0, 1 union</span><br><span class="line">   ...&gt;     select current, previous+current from fib</span><br><span class="line">   ...&gt;     where current &lt;= 100</span><br><span class="line">   ...&gt;   )</span><br><span class="line">   ...&gt; select previous from fib;</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">55</span><br><span class="line">89</span><br></pre></td></tr></table></figure></p>
<h3><span id="2搭建字符串">2.搭建字符串</span></h3>
<p>  两个字符串可以通过<code>||</code>操作符合并成一个更长的字符串：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; with wall(n) as (</span><br><span class="line">  ....&gt;   select 99 union select 98 union select 97</span><br><span class="line">  ....&gt; )</span><br><span class="line">  ....&gt; select n || &quot; bottles&quot; from wall;</span><br><span class="line">99 bottles</span><br><span class="line">98 bottles</span><br><span class="line">97 bottles</span><br></pre></td></tr></table></figure></p>
<p>  这个操作可以用来通过短语来构建句子。例如，构建英语句子的一个方式是用主语、动词和宾语进行组合：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table nouns as</span><br><span class="line">  ....&gt;   select &quot;the dog&quot; as phrase union</span><br><span class="line">  ....&gt;   select &quot;the cat&quot;           union</span><br><span class="line">  ....&gt;   select &quot;the bird&quot;;</span><br><span class="line">sqlite&gt; select subject.phrase || &quot; chased &quot; || object.phrase</span><br><span class="line">  ....&gt;        from nouns as subject, nouns as object</span><br><span class="line">  ....&gt;        where subject.phrase != object.phrase;</span><br><span class="line">the bird chased the cat</span><br><span class="line">the bird chased the dog</span><br><span class="line">the cat chased the bird</span><br><span class="line">the cat chased the dog</span><br><span class="line">the dog chased the bird</span><br><span class="line">the dog chased the cat</span><br></pre></td></tr></table></figure></p>
<h2><span id="五-归并与分组">五、归并与分组</span></h2>
<h3><span id="1归并操作">1.归并操作</span></h3>
<p>  <span class="math inline">\(select\)</span>语句可以实现如<span class="math inline">\(max\)</span>、<span class="math inline">\(min\)</span>、<span class="math inline">\(count\)</span>、<span class="math inline">\(sum\)</span>等归并操作，它们分别返回行的最大最小值、行的数量和行内值的和：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; create table animals as</span><br><span class="line">  ....&gt;   select &quot;dog&quot; as name, 4 as legs, 20 as weight union</span><br><span class="line">  ....&gt;   select &quot;cat&quot;        , 4        , 10           union</span><br><span class="line">  ....&gt;   select &quot;ferret&quot;     , 4        , 10           union</span><br><span class="line">  ....&gt;   select &quot;t-rex&quot;      , 2        , 12000        union</span><br><span class="line">  ....&gt;   select &quot;penguin&quot;    , 2        , 10           union</span><br><span class="line">  ....&gt;   select &quot;bird&quot;       , 2        , 6;</span><br><span class="line">sqlite&gt; select max(legs) from animals;</span><br><span class="line">4</span><br><span class="line">sqlite&gt; select sum(weight) from animals;</span><br><span class="line">12056</span><br><span class="line">sqlite&gt; select min(legs), max(weight) from animals where name &lt;&gt; &quot;t-rex&quot;;</span><br><span class="line">2|20</span><br></pre></td></tr></table></figure></p>
<p>  <code>count(*)</code>语句用于计算对应量的行的数量：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select count(legs) from animals;</span><br><span class="line">6</span><br><span class="line">sqlite&gt; select count(*) from animals;</span><br><span class="line">6</span><br><span class="line">sqlite&gt; select count(distinct legs) from animals;</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h3><span id="2groupby和having语句">2.<span class="math inline">\(group\;by\)</span>和<span class="math inline">\(having\)</span>语句</span></h3>
<p>  <span class="math inline">\(group\;by\)</span>和<span class="math inline">\(having\)</span>语句用于将表格的行分割为组的一个子集(<span class="math inline">\(subset\;of\;groups\)</span>)并只从这些子集中挑选一个。任何在<span class="math inline">\(having\)</span>语句中的归并语句都会应用到表格的每一行，而不是一次性用于表格的所有行。例如下面的例子：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select legs, max(weight) from animals group by legs;</span><br><span class="line">2|12000</span><br><span class="line">4|20</span><br><span class="line">sqlite&gt; select weight from animals group by weight having count(*)&gt;1;</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(group\;by\)</span>语句可以接受多个列，并将原来的表格按照这些列分组：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select max(name) from animals group by legs, weight order by name;</span><br><span class="line">bird</span><br><span class="line">dog</span><br><span class="line">ferret</span><br><span class="line">penguin</span><br><span class="line">t-rex</span><br><span class="line">sqlite&gt; select max(name), legs, weight from animals group by legs, weight</span><br><span class="line">  ....&gt;   having max(weight) &lt; 100;</span><br><span class="line">bird|2|6</span><br><span class="line">penguin|2|10</span><br><span class="line">ferret|4|10</span><br><span class="line">dog|4|20</span><br><span class="line">sqlite&gt; select count(*), weight/legs from animals group by weight/legs;</span><br><span class="line">2|2</span><br><span class="line">1|3</span><br><span class="line">2|5</span><br><span class="line">1|6000</span><br><span class="line"></span><br><span class="line">sqlite&gt; select name, legs, max(weight) from animals group by legs;</span><br><span class="line">t-rex|2|12000</span><br><span class="line">dog|4|20</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(having\)</span>语句可以和<span class="math inline">\(where\)</span>语句一样过滤表格元素，还可以包含对归并元素的引用。可以按照如下原则选择两种语句：当过滤条件是对单一的行执行时使用<span class="math inline">\(where\)</span>语句；当过滤条件设计归并操作时使用<span class="math inline">\(having\)</span>语句。</p>
]]></content>
      <categories>
        <category>SICP in python</category>
        <category>Chapter 4.Data Processing</category>
      </categories>
  </entry>
  <entry>
    <title>4.1.Caches</title>
    <url>/2024/06/29/5-1-Parallelism-via-Instructions/</url>
    <content><![CDATA[<h1><span id="51parallelism-via-instructions"><span class="math inline">\(5.1.\)</span>Parallelism via Instructions</span></h1>
<h3><span id="1pipelining">1.Pipelining</span></h3>
<p>  Exploiting the potential parallelism among instructions is called
<em>instruction-level parallelism</em>.</p>
<ul>
<li><p>The first is <strong>increasing the depth of the pipeline to
overlap more instructions</strong>.</p></li>
<li><p>We also need to <strong>reblance the remaining steps so they are
the same length</strong>.</p></li>
<li><p>Another approach is to <strong>replicate the internal components
so that it can launch multiple instruction in every pipeline
stage</strong>. The general name of this approach is <em>multiple
issue</em>.</p></li>
</ul>
<h3><span id="2multiple-issue-processor">2.Multiple issue processor</span></h3>
<p>  There are two main ways to implement a multiple-issue processor,
with the major difference being <strong>the division of work between the
compiler and the hardware</strong>. One is called <em>static multiple
issue</em> and the other <em>dynamic multiple issue</em>.</p>
<p>  There are two primary distinct responsibilities within a
multiple-issue pipeline:</p>
<ol type="1">
<li><p>Packaging instructions into <em>issue slots</em>. It refers to
<strong>the position from which instructions could issue in a given
clock cycle</strong>. In dynamic multiple issue, it is normally dealt
with <strong>at runtime by processor</strong>.</p></li>
<li><p>Dealing with data and control hazards. The compiler handles it
statically. In contrast, most dynamic issue processors attempt to
alleviate them <strong>using hardware techniques operation at execution
time</strong>.</p></li>
</ol>
<h3><span id="3speculationconceptsextracted-from-textbook">3.Speculation
concepts(extracted from textbook)</span></h3>
<p>  Speculation is an approach that <strong>allows the
compilator/processor to "guess" about the properties of an
instruction</strong>. Any speculation mechanism must include both a
method to <strong>check if the guess was right</strong> and a method to
<strong>unroll or back out the effects of the instructions that were
executed speculatively</strong>.</p>
<p>  Speculation may be done in the compiler or by the hardware. For
example,the compiler can use speculation to <strong>reorder
instructions, moving an instruction across a branch or a load across a
store</strong>. The processor hardware can perform the same
transformation at runtime using techniques we discuss later in this
section.</p>
<p>  The recovery mechanisms used for incorrect speculation are rather
different. In the case of speculation in software, the compiler usually
<strong>inserts additional instructions that check the accuracy of the
speculation and provide a fix-up routine to use when the speculation is
wrong</strong>. In hardware speculation, the processor usually
<strong>buffers the speculative results until it knows they are no
longer speculative</strong>. If the speculation is correct, the
instructions are completed by <strong>allowing the contents of the
buffers to be written to the registers or memory</strong>. If the
speculation is incorrect, the hardware flushes the buffers and
re-executes the correct instruction sequence. Misspeculation typically
requires the pipeline to be flushed, or at least stalled, and thus
further reduces performance.</p>
<p>  Speculation introduces one other possible problem: speculating on
certain instructions may <strong>introduce exceptions that were formerly
not present</strong>. For example, suppose a load instruction is moved
in a speculative manner, but the address it uses is not within bounds
when the speculation is incorrect. The result would be that an exception
that should not have occurred would occur. The problem is complicated by
the fact that if the load instruction were not speculative, then the
exception must occur! In compiler-based speculation, such problems are
avoided by <strong>adding special speculation support that allows such
exceptions to be ignored until it is clear that they really should
occur</strong>. In hardware-based speculation, <strong>exceptions are
simply buffered until it is clear that the instruction causing them is
no longer speculative and is ready to complete;</strong> at that point,
the exception is raised,and normal exception handling proceeds.</p>
<h3><span id="4static-multiple-issue">4.Static multiple issue</span></h3>
<p>  Static multiple-issue processors all use the compiler to assist
with packaging instructions and handling hazards. In a static issue
processor, we can think of the set of instructions issued in a given
clock cycle called <em>issue packet</em>. And it's useful to think of
the issue packet as a single instuction allowing weveral operations in
certain predefined fields.</p>
<p>  When it comes to the certain instructions:</p>
<ul>
<li><p>We require that the instructions <strong>be paired and aligned on
a 64-bit boundary</strong>.</p></li>
<li><p>If on instruction of the pair cannot be used, we require that
<strong>it be replaced with nop</strong>.</p></li>
</ul>
<p>  However, the overlapping of instructions <strong>increase the
relative performance loss from data and control hazards</strong>.</p>
<blockquote>
<p>For example, in our simple five-stage pipeline, loads have a use
latency of one clock cycle, which <strong>prevents one instruction from
using the result without stalling</strong>. In the two-issue, five-stage
pipeline the result of a load instruction <strong>cannot be used on the
next clock cycle</strong>. This means that the next two instructions
cannot use the load result without stalling.</p>
</blockquote>
<p>  An important compiler technique to get more performance from loops
is <em>loop unrolling</em>:</p>
<ul>
<li>Say we are going to deal with this program:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    A[i] = B[i] + C[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loop:</span><br><span class="line">    ld  x1, 0(xA)       ; Load A[i]</span><br><span class="line">    ld  x2, 0(xB)       ; Load B[i]</span><br><span class="line">    ld  x3, 0(xC)       ; Load C[i]</span><br><span class="line">    add x4, x2, x3      ; A[i] = B[i] + C[i]</span><br><span class="line">    sd  0(xA), x4       ; Store A[i]</span><br><span class="line">    addi xA, xA, 8      ; Increment A pointer</span><br><span class="line">    addi xB, xB, 8      ; Increment B pointer</span><br><span class="line">    addi xC, xC, 8      ; Increment C pointer</span><br><span class="line">    addi xI, xI, 1      ; Increment loop counter</span><br><span class="line">    blt  xI, 8, Loop    ; Branch if loop counter &lt; 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  We can do this iteration part for more times:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    A[i]   = B[i]   + C[i];</span><br><span class="line">    A[i+<span class="number">1</span>] = B[i+<span class="number">1</span>] + C[i+<span class="number">1</span>];</span><br><span class="line">    A[i+<span class="number">2</span>] = B[i+<span class="number">2</span>] + C[i+<span class="number">2</span>];</span><br><span class="line">    A[i+<span class="number">3</span>] = B[i+<span class="number">3</span>] + C[i+<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loop:</span><br><span class="line">    ld  x1, 0(xA)       ; Load A[i]</span><br><span class="line">    ld  x2, 0(xB)       ; Load B[i]</span><br><span class="line">    ld  x3, 0(xC)       ; Load C[i]</span><br><span class="line">    add x4, x2, x3      ; A[i] = B[i] + C[i]</span><br><span class="line">    sd  0(xA), x4       ; Store A[i]</span><br><span class="line"></span><br><span class="line">    ld  x5, 8(xA)       ; Load A[i+1]</span><br><span class="line">    ld  x6, 8(xB)       ; Load B[i+1]</span><br><span class="line">    ld  x7, 8(xC)       ; Load C[i+1]</span><br><span class="line">    add x8, x6, x7      ; A[i+1] = B[i+1] + C[i+1]</span><br><span class="line">    sd  8(xA), x8       ; Store A[i+1]</span><br><span class="line"></span><br><span class="line">    ld  x9, 16(xA)      ; Load A[i+2]</span><br><span class="line">    ld  x10, 16(xB)     ; Load B[i+2]</span><br><span class="line">    ld  x11, 16(xC)     ; Load C[i+2]</span><br><span class="line">    add x12, x10, x11   ; A[i+2] = B[i+2] + C[i+2]</span><br><span class="line">    sd  16(xA), x12     ; Store A[i+2]</span><br><span class="line"></span><br><span class="line">    ld  x13, 24(xA)     ; Load A[i+3]</span><br><span class="line">    ld  x14, 24(xB)     ; Load B[i+3]</span><br><span class="line">    ld  x15, 24(xC)     ; Load C[i+3]</span><br><span class="line">    add x16, x14, x15   ; A[i+3] = B[i+3] + C[i+3]</span><br><span class="line">    sd  24(xA), x16     ; Store A[i+3]</span><br><span class="line"></span><br><span class="line">    addi xA, xA, 32     ; Increment A pointer by 4</span><br><span class="line">    addi xB, xB, 32     ; Increment B pointer by 4</span><br><span class="line">    addi xC, xC, 32     ; Increment C pointer by 4</span><br><span class="line">    addi xI, xI, 4      ; Increment loop counter by 4</span><br><span class="line">    blt  xI, 8, Loop    ; Branch if loop counter &lt; 8</span><br></pre></td></tr></table></figure>
<p>  This operation has the following advantages:</p>
<ol type="1">
<li><p><strong>Reduce cycle control overhead</strong>: cycle control
operations are less frequent when the cycle is expanded. In the above
example, the loop control operation is reduced from one generation per
generation to one generation per four.</p></li>
<li><p><strong>Increase instruction level parallelism</strong>: the more
instructions expanded, the compiler can better schedule these
instructions, improve parallelism.</p></li>
<li><p><strong>Reduced branch prediction failure</strong>: the
probability of branch prediction failure is reduced due to the reduction
in the number of branch instructions and the frequency of loop control
operations.</p></li>
</ol>
<p>  During the unrolling process, the compiler introduce additional
registers. The goal of the process, called <em>register renaming</em>,
it to <strong>eliminate dependences that are not true data
dependences</strong>, but could either lead to potential hazards or
prevent the compiler from flexibly scheduling the code.</p>
<h3><span id="5dynamic-multiple-issueprocessor">5.Dynamic multiple-issue
processor</span></h3>
<p>  Dynamic multiple-issue processors are also known as <em>superscalar
processors</em>.</p>
<p>  Many superscalars extend the basic framework of dynamic issue
decisions to include <em>dynamic pipeline scheduling</em>. Dynamic
pipeline scheduling <strong>chooses which instructions to execute in a
given clock cycle while trying to avoid hazards and stalls</strong>.</p>
<ul>
<li><p><em>Dynamic pipeline scheduling</em> <strong>chooses which
instructions to execute next, possibly reordering them to avoid
stalls</strong>. The pipeline is divided into three major units: an
instruction fetch and issue unit, multiple functional units, and a
commit unit.</p>
<ul>
<li><p>The first unit fetch instructions, decodes them and sends them to
corresponding function unit for execution.</p></li>
<li><p>Each function unit has <em>buffers</em> called <em>reservation
stations</em>, which <strong>hold the operands and the
operation</strong>. As soon as the buffer contains all its operands and
the functional unit is ready to execute, the result calculated. The
result is sent to <strong>any reservation stations waiting for this
particular result</strong> and <strong>the commit
unit</strong>.</p></li>
<li><p>The commit unit <strong>buffers the result until it's safe to put
the result into the register file/memory</strong>. The buffer in the
commit unit, often called the <em>reorder buffer</em>, is also used to
supply operands.</p></li>
<li><p>Once a result is committed to the register file, it can be
fetched directly from there like in a normal pipeline.</p></li>
</ul></li>
</ul>
<p><img src="/2024/06/29/5-1-Parallelism-via-Instructions/image-23.png"></p>
<blockquote>
<p>If an operand is not in the register file or reorder buffer, it must
<strong>be waiting to be produced by a functional unit</strong>.
<strong>The name of the functional unit that will produce the result is
tracked</strong>. When that unit eventually produces the result,
<strong>it is copied directly into the waiting reservation
statio</strong>n from the functional unit bypassing the registers.</p>
</blockquote>
<p>  We may think of a dynamically scheduled pipeline as an
<em>out-of-order execution</em>. To make programs behave as if they were
running on a simple in-order pipeline, the instruction fetch and decode
unit is required to <strong>issue instructions in order</strong>, which
allows dependences to be tracked, and the commit unit is required to
<strong>write results to registers and memory in program fetch
order</strong>. This conservative mode is called <em>in-order
commit</em>. Hence, if an exception occurs, the computer can point to
the last instruction executed.</p>
]]></content>
      <categories>
        <category>CS61C Great Ideas in Computer Architecture</category>
        <category>Module 5.Parallelism</category>
      </categories>
  </entry>
  <entry>
    <title>5.2.获取-执行循环</title>
    <url>/2024/04/06/5-2-%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1><span id="52the-fetch-execute-cycle"><span class="math inline">\(5.2.\)</span>The Fetch-Execute Cycle</span></h1>
<ul>
<li><em>Fetch an instruction from the program memory</em></li>
<li><em>Execute</em> it</li>
</ul>
<h3><span id="1fetching">1.Fetching</span></h3>
<ul>
<li><p>The next instruction is located at the <em>program memory</em>,
the program memory is in the <em>memory</em>, and its address is
specified by the <em>program counter</em>.</p></li>
<li><p>We need to basically <strong>put the location of the next
instruction into the "address" of the program memory</strong>. Then we
need to read the contents at that location and then will get the basic
instructions we need to execute.</p></li>
<li><p>We usually put the address of the next instruction into the
address input of the program memory by <em>program
counter</em>.</p></li>
</ul>
<p>  The hardware cycle of executing the fetch operation is as
below:</p>
<p><img src="/2024/04/06/5-2-%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF/image.png"></p>
<ul>
<li>When we need to jump into a new location, we <strong>manipulate the
program counter</strong> so that it will have the address of the next
instruction.</li>
<li>The output of the program counter feeds into the address
specification of program memory.</li>
<li>The program memory output comes the actual instruction code that we
need to execute.</li>
</ul>
<h3><span id="2execute">2.Execute</span></h3>
<ul>
<li><p>The instruction code specifies "what to do"</p>
<ul>
<li>Which arithmetie or logical instruction.</li>
<li>What memory to access (read/write).</li>
<li>If/where to jump.</li>
</ul></li>
<li><p><em>Bit aspect</em>: Execute current instruction means
<strong>taking the bits from the instruction code that specifies what to
do</strong>, and do what needs to be done.</p>
<ul>
<li>Often, different subsets of the bits control different aspects of
the operation</li>
</ul></li>
<li><p><em>Hardware aspect</em>:</p></li>
</ul>
<p><img src="/2024/04/06/5-2-%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF/image-1.png"></p>
<ul>
<li><p><em>control bus</em>:</p>
<ul>
<li><p>tells the ALU what instruction to compute,</p></li>
<li><p>tells where do the data pieces come from,</p></li>
</ul></li>
</ul>
<h3><span id="2the-clash">2.The clash</span></h3>
<p>  There's a clash in the cycle above:</p>
<ul>
<li>For <em>fetch</em>, we need to put into the address of the memory
<strong>the address of the next instruction</strong> to get the
instruction output.</li>
<li>For <em>execute</em>, we need to put into the address of the memory
<strong>the address of the data pieces</strong> that we want to operate
on to access data.</li>
<li>But we only have a single memory, so <strong>should we put into the
memory the address of data or instructions</strong>?</li>
</ul>
<p><img src="/2024/04/06/5-2-%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF/image-2.png"></p>
<p>  To solve this problem, we will do <strong>one after
another</strong>. We will achieve this through a
<em>Multiplexer</em>:</p>
<ul>
<li>In the first part, the <em>fetch cycle</em>, the multiplexer set the
memory to point into <strong>the program counter that is the location of
the next instruction</strong>.</li>
<li>While in the <em>execute cycle</em>, the multiplexer will set the
memory to point into <strong>the data address that we need to
access</strong>.</li>
</ul>
<p>  So how do we do this together?</p>
<p><img src="/2024/04/06/5-2-%E8%8E%B7%E5%8F%96-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF/image-3.png"></p>
<ul>
<li>When we are in a <em>fetch cycle</em>, we get the next instruction,
and then we need to <strong>remember it inside an instruction
register</strong>.</li>
<li><strong>That instruction register is exactly what is remains holding
the value of the instruction that we are now executing in the execute
cycle.</strong> Then in the <em>execute cycle</em> we have the
instruction already stored in this register, so we can work with all the
information we need for the cycle.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 5.Computer Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>5.3.CPU</title>
    <url>/2024/04/06/5-3-CPU/</url>
    <content><![CDATA[<h1><span id="53central-processing-unit"><span class="math inline">\(5.3.\)</span>Central Processing Unit</span></h1>
<h3><span id="1abstraction">1.Abstraction</span></h3>
<p>  We can view CPU as <strong>a 16-bit</strong> processor, designed
to:</p>
<ul>
<li><p>Execute the current instruction.</p>
<ul>
<li>This turns the static code into reality.</li>
</ul></li>
<li><p>Figure out which instruction to execute next.</p></li>
</ul>
<h3><span id="2hack-cpu-interface">2.Hack CPU interface</span></h3>
<p><img src="/2024/04/06/5-3-CPU/image.png"></p>
<ul>
<li>CPU is connected both to the <em>instruction memory</em> and to the
<em>data memory</em>.</li>
</ul>
<p>  here is the specific input and output connections of the CPU:</p>
<p><img src="/2024/04/06/5-3-CPU/image-1.png"></p>
<ul>
<li><p>We have three inputs coming from three completely different
sources.</p>
<ul>
<li><p>A 16-bit <em>data value</em>, which is the value of <strong>the
currently selected data memory register</strong>. This is the value CPU
is going to operate on.</p></li>
<li><p>A 16-bit <em>instruction value</em>, which is the value of
<strong>the selected instruction memory register</strong>.</p>
<ul>
<li>Remember that at any given point of time, there is always <strong>a
selected register in the instruction memory</strong>, and a
<strong>selected memory register in the data memory</strong>. So always
something comes into the CPU.</li>
</ul></li>
<li><p>A 1-bit <em>input</em>, which we <strong>decide to call the
reset</strong>.</p></li>
</ul></li>
<li><p>On the right hand side we see the outputs of ALU:</p>
<ul>
<li><p>The ALU specifies 3 different things to write something to the
data memory:</p>
<ol type="1">
<li><em>outM</em>: What we want to write.</li>
<li><em>writeM</em>: A <strong>load bit</strong> that enables the data
memory to write operations.</li>
<li><em>address</em>: Where do we want to write it.</li>
<li><em>pc</em>: It holds the <strong>address of the next
instruction</strong> that has to be fetched and executed in the next
cycle of this computer.</li>
</ol></li>
</ul></li>
</ul>
<h3><span id="3cpu-implementation">3.CPU implementation</span></h3>
<p>  The whole CPU hardware diagram is as below:</p>
<p><img src="/2024/04/06/5-3-CPU/image-2.png"></p>
<h4><span id="aainstruction">  <span class="math inline">\(a.\)</span>A
instruction</span></h4>
<p><img src="/2024/04/06/5-3-CPU/image-3.png"></p>
<p>  This section contains:</p>
<ul>
<li><em>A register</em> called A.</li>
<li><em>An A-instruction input</em> that connects to this register
through a <em>multiplexer</em>.</li>
</ul>
<p>  We see that this instruction seeks to load the value
<code>3001</code> into a register. In order to carry out this
instruction, the CPU do:</p>
<ol type="1">
<li>Decode the instruction into <strong>op-code + 15-bit
value</strong>.</li>
<li>Noticing that it is a A instruction, CPU <strong>stores the 15-bit
value in the A-register</strong>.</li>
<li>Take the output of A register and admit it outside.</li>
</ol>
<h4><span id="b-cinstruction">  <span class="math inline">\(b.\)</span> C
instruction</span></h4>
<p><img src="/2024/04/06/5-3-CPU/image-4.png"></p>
<p>  This section contains:</p>
<ul>
<li>A register.</li>
<li>C instruction.</li>
</ul>
<p>  Others is the same as above.</p>
<ul>
<li><p>Say we want to gain an A instruction, we can use the
<em>Mux16</em>:</p>
<ul>
<li>If the instruction input is with an op-code <code>0</code>, we
choose the instruction input.</li>
<li>Otherwise, we choose the ALU input.</li>
</ul></li>
</ul>
<h4><span id="caluoperation">  <span class="math inline">\(c.\)</span>ALU
Operation</span></h4>
<p><img src="/2024/04/06/5-3-CPU/image-5.png"></p>
<ul>
<li><p>The inputs of ALU come from:</p>
<ol type="1">
<li><p><em>D register</em></p></li>
<li><p>Either the value of <em>A register</em> or <em>selected memory
register</em>.</p></li>
<li><p><em>Multiplexer</em> takes care of this decision, and the control
bit of it is <strong>one of the bits in the instruction</strong>.</p>
<ul>
<li>The CPU designer has to <strong>choose this bit</strong>, and then
ALU gets the correct input.</li>
</ul></li>
</ol></li>
<li><p>ALU also has <em>6 control bits taken together</em> to
<strong>tell or specify the ALU which operation we want to carry
out</strong>.</p></li>
</ul>
<p><img src="/2024/04/06/5-3-CPU/image-6.png"></p>
<ul>
<li><p>The output of ALU is <strong>simultaneously</strong> fed
into:</p>
<ol type="1">
<li><p><em>D register</em></p></li>
<li><p><em>A register</em></p></li>
<li><p><em>M register</em></p>
<ul>
<li>It goes through a <em>Multiplexer</em>.</li>
</ul></li>
</ol></li>
</ul>
<p>  The same ALU is fanned out into 3 different places, so we have the
same ALU output knocking on three different doors. The programmer has to
decide which door to be opened. The decision is made by next field of
bits —— <em>destination bits</em>:</p>
<ul>
<li>We have 3 destination bits, which decide whether or not open the
<em>D register</em>, <em>A register</em>, <em>M register</em> and the
<em>data memory</em> to accept the ALU output.</li>
</ul>
<h4><span id="dcontrol-abstraction">  <span class="math inline">\(d.\)</span>Control abstraction</span></h4>
<p>  The computer is loaded with some program, when you push
<code>reset</code>, <strong>the program starts running</strong>.</p>
<p>  In our previous chapter, we know that the last three bits of the
instruction is <em>jump bits</em>, which a <code>1</code> represents
unconditional <code>goto</code>. CPU realizes this functionality by
<em>program counter</em></p>
<h5><span id="ipcabstraction">  <span class="math inline">\(i.\)</span>PC
abstraction</span></h5>
<ul>
<li><p>Emits <strong>the address of the next instruction</strong>:</p>
<ul>
<li>To start / restart the program's execution: <code>PC = 0</code>(for
we want to execute the first instruction of the program).</li>
<li>no jump: <code>PC++</code></li>
<li>unconditional <code>goto</code>: <code>PC = A</code></li>
<li>conditional <code>goto</code>: if true <code>PC = A</code> else
<code>PC++</code></li>
</ul></li>
</ul>
<h5><span id="iicontrol-implementation">  <span class="math inline">\(ii.\)</span>Control implementation</span></h5>
<p><img src="/2024/04/06/5-3-CPU/image-7.png"></p>
<p><img src="/2024/04/06/5-3-CPU/image-8.png"></p>
<ul>
<li><p>if <code>reset == 1</code>, <code>PC=0</code></p></li>
<li><p>else</p>
<ul>
<li><p>We have to look at the <strong>jump bits</strong> and
simultaneously look at the <strong>ALU output</strong> to decide if we
want to carry out the jump.</p></li>
<li><p><code>load = f(jump bits, ALU control outputs)</code></p>
<ul>
<li>if <code>load == 1</code>, <code>PC = A</code></li>
<li>else <code>PC++</code></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 5.Computer Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>5.4.Hack计算机</title>
    <url>/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
    <content><![CDATA[<h1><span id="54hackcomputer"><span class="math inline">\(5.4.\)</span>Hack
Computer</span></h1>
<h3><span id="1hack-computer-abstraction">1.Hack computer abstraction</span></h3>
<ul>
<li>A computer capable of running programs written in the Hack machine
language.</li>
</ul>
<h3><span id="2cpu-operations">2.CPU operations</span></h3>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image.png"></p>
<figure>
<img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-1.png" alt="Alt text">
<figcaption aria-hidden="true">Alt text</figcaption>
</figure>
<ul>
<li><p>If the instruction includes <code>D And A</code>, CPU is going to
<strong>manipulate the respective D and A registers</strong>.</p></li>
<li><p>If the instruction ia an A instruction like <code>@17</code>, CPU
is going to <strong>take the 15-bit data value and store them inside the
A register</strong>. This value is <strong>emitted by
<code>addressM</code></strong>.</p></li>
<li><p>If the instruction's <em>right hand side</em> includes
<code>M</code> like <code>M = M + 1</code>, this value is <strong>read
from <code>inM</code> interface</strong>.</p></li>
<li><p>If the instruction's <em>left hand side</em> includes
<code>M</code>, then the value output should be stored in the data
memory of the selected memory register.</p>
<ul>
<li>As we discuss in the CPU, we have to provide <strong>what things we
want to write, where to write and the control bits</strong> to write
something to the data memory. As a result, <strong>the ALU output is
emitted by <code>outM</code>, and the <code>writeM</code> is
asserted</strong>.</li>
</ul></li>
<li><p>If we have a jump situation <code>@100, D = D - 1; JEQ</code>. ,
we want to jump to the address that was specified before(100, in this
case):</p>
<ul>
<li>If <code>reset == 0</code>, CPU logic uses <strong>the jump bits and
the ALU output</strong> to decide whether or not there should be a
jump.</li>
<li>If there is a jump, <code>PC = A</code></li>
<li>Else, <code>PC++</code></li>
<li>The updated <code>PC</code> value <strong>is emitted by
<em>pc</em></strong>.</li>
<li>If <code>reset == 1</code>, <em>pc</em> emits <code>0</code>,
causing a program restart</li>
</ul></li>
</ul>
<h3><span id="3memory-abstraction">3.Memory abstraction</span></h3>
<figure>
<img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-2.png" alt="Alt text">
<figcaption aria-hidden="true">Alt text</figcaption>
</figure>
<ul>
<li><p>Three different segments:</p>
<ul>
<li>Address 0 to 16383(16k): <em>data memory</em></li>
<li>Address 16384 to 24575(next 8k): <em>screen memory map</em></li>
<li>Address 24576: <em>keyboard memory map</em></li>
</ul></li>
</ul>
<h3><span id="4memory-implementation">4.Memory implementation</span></h3>
<p>  We bulid our memory from three different sub-chips:</p>
<ul>
<li><em>RAM:</em> 16-bit 16K RAM chip</li>
<li><em>Screen</em>: 16-bit/8K memory chip with a raster display
side-effect.</li>
<li><em>Keyboard</em>: 16-bit register with a keyboard side-effect.</li>
</ul>
<h4><span id="aram">  <span class="math inline">\(a.\)</span>RAM</span></h4>
<p>![[Pasted image 20240406103441.png]]</p>
<ul>
<li>The inputs and outputs of RAM16 are identical to the inputs and
outputs of the overall memory chip.</li>
<li>So whoever builds the chip has to make sure to take the outside
inputs and outputs and <strong>make connections that will funnel these
value into the inner chip box, such as RAM 16K</strong>.</li>
</ul>
<h4><span id="bscreen">  <span class="math inline">\(b.\)</span>Screen</span></h4>
<p>![[Pasted image 20240406104348.png]]</p>
<ul>
<li>We use a special built-in <em>8K screen chip</em> that knows how to
automatically refresh a connected display unit.
<ul>
<li>It's a RAM chip, which has a nice side effect of refreshing a
connected display unit.</li>
</ul></li>
</ul>
<h4><span id="ckeyboard">  <span class="math inline">\(c.\)</span>Keyboard</span></h4>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-3.png"></p>
<ul>
<li>We use a built-in Keyboard chip featuring a keyboard capture
side-effect, which is that it always reflects what the user is pressing
on the keyboard.</li>
</ul>
<h3><span id="5instruction-memory">5.Instruction memory</span></h3>
<h4><span id="aintro">  <span class="math inline">\(a.\)</span>Intro</span></h4>
<ul>
<li>We implement this instruction memory using a chip called <em>ROM
32K</em>.</li>
</ul>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-4.png"></p>
<ul>
<li><p>We can <strong>loading a program</strong> in this way:</p>
<ul>
<li><p>Hardware inplementation: <em>plug-and-play ROM chips</em>: We put
our machine instruction code into a ROM chip. We take this RAM chip,
plug it into the computer. We press the <code>reset</code> button, and
the computer will start executing this particular program.</p>
<ul>
<li>If we want to run another program, we take the chip out and plug in
another chip.</li>
</ul></li>
</ul></li>
</ul>
<h4><span id="brominterface">  <span class="math inline">\(b.\)</span>ROM
interface</span></h4>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-5.png"></p>
<ul>
<li>It's a <strong>read-only</strong> device.</li>
<li>Contains a sequence of Hack instructions (program).</li>
<li>The <em>output</em> of of the ROM is always <strong>the contents of
the register that is selected by the address input</strong>.</li>
<li>Since the <em>pc</em> always emits the address of next instruction,
if we feed this address into ROM, we are guaranteed that ROM will always
admit a 16-bit value that we can treat as the current instruction.</li>
</ul>
<h3><span id="6hack-computerimplementation">6.Hack computer
implementation</span></h3>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-6.png"></p>
<ul>
<li>We first connect to the CPU <strong>the instruction memory which we
call ROM</strong>. The instruction input of the CPU is taken from the
output of instruction memory.</li>
<li>In the process of executing this instuction, we are going to compute
the address of the next instruction. This address is emitted by
<em>pc</em>.</li>
<li>The address goes all the way into the address of the instruction
unit, and the unit will emit the next instruction that has to be
executed in the next cycle.</li>
</ul>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-7.png"></p>
<ul>
<li>To do something useful with the outputs, we connect outputs to
<em>memory unit</em>.</li>
<li>We take the output of the memory, and connect it back into the
CPU</li>
</ul>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-8.png"></p>
<ul>
<li>The input and output units are the only two things the computer
users sees when he works.</li>
<li>With this computer is a display unit, a keyboard and the reset
button.</li>
</ul>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-9.png"></p>
<p><img src="/2024/04/06/5-4-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA/image-10.png"></p>
<ul>
<li>This is the overall computer architect!!!</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 5.Computer Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>5.1.冯·诺伊曼结构</title>
    <url>/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1><span id="51von-neumman-architect"><span class="math inline">\(5.1.\)</span>Von Neumman Architect</span></h1>
<h3><span id="1stored-program-computer">1.Stored program computer</span></h3>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image.png"></p>
<ul>
<li><p><em>Memory</em>: It's used to do two things:</p>
<ol type="1">
<li>Store all the kind of the data that we're going to use in the
computation</li>
<li>Hold the program as a sequence of instructions that are going to be
executed one by one.</li>
</ol></li>
<li><p><em>CPU</em>: Carry out these instructions, run them and control
everything.</p></li>
</ul>
<p>  The detailed CPU instrcture is as below:</p>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-1.png"></p>
<ul>
<li><em>ALU</em>: A piece of <strong>hardware</strong> that is able to
add numbers and subtract numbers maybe do logical operations and so
on.</li>
<li>A bunch of <em>Register</em>: <strong>Store data</strong> that we're
going to use for the rest of computation.</li>
</ul>
<h3><span id="2information-flow">2.Information flow</span></h3>
<h4><span id="aintro">  <span class="math inline">\(a.\)</span>Intro</span></h4>
<ul>
<li>The memory itself has two part: the part that <strong>stores the
program</strong> and the part that <strong>stores the
data</strong>.</li>
<li>We can consider these things as <strong>a flow of
data</strong>.</li>
</ul>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-2.png"></p>
<p>  There are three types of information passed around the system:</p>
<ol type="1">
<li><em>Data</em>: When we do addition, for example, the number needs to
be moved from the data in memory to the other systematic logic unit that
is going to do something with them, and send them back.</li>
<li><em>Address</em>: The data we need to access now lies in
address.</li>
<li><em>Control</em>: It tells each part of the system what to do at
this particular point.</li>
</ol>
<ul>
<li><em>Data bus, address bus and control bus</em>.</li>
</ul>
<h4><span id="baluinfo-flow">  <span class="math inline">\(b.\)</span>ALU
info flow</span></h4>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-3.png"></p>
<ul>
<li><p><em>Data bus</em>: ALU needs to <strong>have some information
from the data bus</strong>, and then <strong>feeds the output value
back</strong> into the data bus. It's going to go to other places that
also connect to the data bus, such as memory.</p></li>
<li><p><em>Control bus</em>: ALU needs to know what kind of operation it
dose every time, so it has to get information from the control bus
<strong>specifying the type of operation it does</strong>. On the other
hand, according to the results of the operations it did, it should be
able to <strong>tell other part of the system what to do</strong>.</p>
<ul>
<li>For example, if it sees that a certain number is greater than 0, it
can control the jump to the next instruction.</li>
</ul></li>
</ul>
<h4><span id="cregisters">  <span class="math inline">\(c.\)</span>Registers</span></h4>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-4.png"></p>
<ul>
<li><p><em>Data bus</em>: The same as ALU.</p></li>
<li><p><em>Address bus</em>: The way we achieve indirect addressing into
a RAM or ROM is <strong>putting number address into a register</strong>
that specifies where we want to access. So we are going to have
registers control a connection to the address bus which controls
memories, and feeds into memory.</p>
<ul>
<li>We'll have registers either exclusively or both address and data
registers.</li>
</ul></li>
</ul>
<h4><span id="dmemory">  <span class="math inline">\(d.\)</span>Memory</span></h4>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-5.png"></p>
<ul>
<li>The memory needs to specify what address we are going to work
with.</li>
</ul>
<p><img src="/2024/04/05/5-1-%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84/image-6.png"></p>
<ul>
<li><p>Once we actually work with a certain address, we are going to be
needed to be able to read it or write into it, get information from it
or put information into it. This means we need to be connected to
<em>data bus</em>.</p>
<ul>
<li><p><em>Data memory</em> gets an address of a data piece that needs
to be operated on.</p></li>
<li><p><em>Program memory</em> requires us to <strong>put the address of
the next program instruction into the memory</strong>. We need to be
able to put an address into the program memory, and get instructions
from there.</p>
<ul>
<li>The instructions we get from the program memory may have data as
well. But it's of great importance that <strong>they tell the rest of
the system what to do</strong>.</li>
<li>We need to be able to take information from the next instruction
from the data output of the program memory and <strong>feed it into the
control bus</strong>.</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 5.Computer Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>5.5.Hack计算机实现</title>
    <url>/2024/04/07/5-5-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1><span id="55hack计算机实现笔记"><span class="math inline">\(5.5.\)</span>Hack计算机实现笔记</span></h1>
<h3><span id="1cpu实现">1.CPU实现</span></h3>
<p><img src="/2024/04/07/5-5-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E7%8E%B0/image.png"></p>
<h4><span id="a指令识别">  <span class="math inline">\(a.\)</span>指令识别</span></h4>
<ul>
<li><code>instruction[15]</code>:用于<strong>判断是否为<code>A</code>指令</strong>。</li>
<li><code>instruction[12]</code>用于<strong>选择ALU的第二个输入来源</strong>。当<code>instruction[12] = 0</code>时，ALU的第二个输入为<code>A</code>寄存器；否则为存储器的输入数据<code>inM</code>。</li>
<li><code>instruction[6:11]</code>:用于<strong>控制ALU的操作</strong>。</li>
<li><code>instruction[5]</code>:当<code>instruction[15] = 0</code>时，<code>instruction[5]</code><strong>就是<code>A</code>指令的一部分</strong>；否则，它就是<code>C</code>指令的一部分。</li>
<li><code>instruction[4]</code>:用于<strong>选择ALU的第二个输入</strong>。当<code>instruction[4] = 1</code>时，我们<strong>将内存中读取的数据作为ALU的第二个输入(即<code>inM</code>)</strong>；否则<strong>将<code>A</code>寄存器中的数据作为ALU的第二个输入</strong>。</li>
<li><code>instruction[3]</code>:用于<strong>指示是否要向数据内存写入数据</strong>。当<code>instruction[3] = 1</code>时，表示要向数据内存中写入数据(即<code>writeM = 1</code>)；否则不对数据内存进行写入操作。</li>
<li><code>C</code>指令对应的16位指令：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 c1 c2 c3 c4 c5 c6 d1 d2 d3 j1 j2 j3</span><br></pre></td></tr></table></figure>
<ul>
<li><code>A</code>指令对应的16位指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 address[14:0]</span><br></pre></td></tr></table></figure>
<h4><span id="ba寄存器处理">  <span class="math inline">\(b.\)</span><code>A</code>寄存器处理</span></h4>
<figure>
<img src="/2024/04/07/5-5-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E7%8E%B0/image-1.png" alt="Alt text">
<figcaption aria-hidden="true">Alt text</figcaption>
</figure>
<ol type="1">
<li>输入的16位指令和ALU的输出经过<code>Mux16</code>作为<code>A</code>寄存器的输入：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mux16(a = instruction, b = ALUOut, sel = instruction[15], out = Ain);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>在后面的过程中，我们需要知道指令是否为<code>A</code>指令，因此我们用一个pin来记录：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Not(in = instruction[15], out = NotA);</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><p>判断是否需要将指令加载到<code>A</code>寄存器中。此时有两种情况：</p>
<ol type="1">
<li>当前指令不是<code>A</code>指令，则选择加载。</li>
<li>当前指令为<code>A</code>指令，但是<code>instruction[5] = 1</code>(该位置用于存储<code>A</code>指令有关信息)，则选择加载：</li>
</ol></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Or(a = NotA, b = instruction[5] , out=loadA);</span><br><span class="line">ARegister(in = Ain, load = loadA, out = Aout, out[0..14] = addressM);</span><br></pre></td></tr></table></figure>
<h4><span id="calu运算">  <span class="math inline">\(c.\)</span>ALU运算</span></h4>
<p><img src="/2024/04/07/5-5-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E7%8E%B0/image-2.png"></p>
<ol type="1">
<li>我们先处理ALU的两个输入源，其中第二个输入源由<code>C</code>指令集的<code>instruction[12]</code>控制：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mux16(a = Aout, b = inM, sel = instruction[12], out = AMout);</span><br><span class="line">And(a = instruction[15], b = instruction[4], out = loadD);</span><br><span class="line">DRegister(in = ALUOut, load = loadD, out = Dout);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>然后我们根据先前的指令识别进行ALU运算并输出：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">And(a = instruction[11], b = instruction[15], out = zx);</span><br><span class="line">And(a = instruction[10], b = instruction[15], out = nx);</span><br><span class="line">Or(a = instruction[9], b = NotA, out = zy);</span><br><span class="line">Or(a = instruction[8], b = NotA, out = ny);</span><br><span class="line">And(a = instruction[7], b = instruction[15], out = f);</span><br><span class="line">And(a = instruction[6], b = instruction[15], out = no);</span><br><span class="line"></span><br><span class="line">ALU(x = Dout, y = AMout, zx = zx, nx = nx, zy = zy, ny = ny, f = f, no = no, out = outM, out = ALUOut, zr = zero, ng = nega);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>zy</code>和<code>ny</code>控制信号在<code>A</code>指令时被强制为1是为了<strong>确保ALU的输入在处理<code>A</code>指令时被简化与固定，不受<code>C</code>指令控制位的影响</strong>，从而避免不必要的计算。</p>
</blockquote>
<ol start="3" type="1">
<li>之后我们需要执行<code>C</code>指令集的跳转逻辑。我们根据<strong>ALU计算结果和指令中的跳转位</strong>来决定是否跳转。</li>
</ol>
<p>  首先对<code>C</code>指令集的跳转位进行明晰：</p>
<ul>
<li><code>instruction[0]</code>对应<code>JGT</code>，当ALU输出为正数时跳转。</li>
<li><code>instruction[1]</code>对应<code>JEQ</code>，当ALU输出为0时跳转。</li>
<li><code>instruction[2]</code>对应<code>JLT</code>，当ALU输出为负数时跳转。</li>
</ul>
<p>  于是我们可以写出以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Or(a = zero, b = nega, out = notpos);</span><br><span class="line">Not(in = notpos, out = pos);</span><br><span class="line">    </span><br><span class="line">And(a = instruction[0], b = pos, out = out3);</span><br><span class="line">And(a = instruction[1], b = zero, out = out2);</span><br><span class="line">And(a = instruction[2], b = nega, out = out1);</span><br><span class="line"></span><br><span class="line">Or(a = out1, b = out2, out = out12);</span><br><span class="line">Or(a = out12, b = out3, out = out123);</span><br><span class="line"></span><br><span class="line">And(a = out123, b = instruction[15], out = jump);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>pos</code>, <code>nega</code>,
<code>zero</code>分别代表正数、负数和恰好为0。并且注意除了满足跳转条件外，还需要<strong>确保当前是<code>C</code>指令</strong>。</p>
</blockquote>
<ol start="4" type="1">
<li>最后我们调用<code>PC</code>以存储并更新当前指令的地址：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PC(in = Aout, load = jump, reset = reset, inc = true, out[0..14] = pc);</span><br></pre></td></tr></table></figure>
<h3><span id="2内存实现">2.内存实现</span></h3>
<p>  内存实现较为简单，根据传入的15位地址<code>address</code>的后两位以及<code>load</code>来调控RAM、屏幕以及键盘即可。</p>
<ul>
<li><code>01 and load: RAMLoad</code></li>
<li><code>10 and load: SCRLoad</code></li>
<li><code>11 and load and other digit 0: KEYLoad</code></li>
</ul>
<h3><span id="3hack计算机实现">3.Hack计算机实现</span></h3>
<p><img src="/2024/04/07/5-5-Hack%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E7%8E%B0/image-3.png"></p>
<p>  我们根据计算机的结构，对已有芯片进行接线即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU(inM = MemoryOut, instruction = Rominstruction, reset = reset, outM = CPUoutM, writeM = CPUload, addressM = CPUaddress, pc = CPUpc);</span><br><span class="line">Memory(in = CPUoutM, load = CPUload, address = CPUaddress, out = MemoryOut);</span><br><span class="line">ROM32K(address = CPUpc, out = Rominstruction);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 5.Computer Architecture</category>
      </categories>
  </entry>
  <entry>
    <title>5.3.泛类的创建</title>
    <url>/2024/05/31/5.3.Creating%20Another%20Generic%20Class/</url>
    <content><![CDATA[<h1><span id="53泛类的创建"><span class="math inline">\(5.3\)</span>泛类的创建</span></h1>
<h3><span id="1泛型方法的创建">1.泛型方法的创建</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; V <span class="title function_">get</span><span class="params">(Map61B&lt;K,V&gt; map, K key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> map.containsKey(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//why &lt;K,V&gt;?because the parameters takes two different</span></span><br><span class="line"><span class="comment">//genetic types,so we alse use two. </span></span><br></pre></td></tr></table></figure>
<h3><span id="2gt运算符的泛型化">2.<code>&gt;</code>运算符的泛型化</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; K <span class="title function_">maxKey</span><span class="params">(Map61B&lt;K, V&gt; map)</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// the &quot;extends&quot; assure that the object has a &quot;compareTo&quot; method.</span></span><br></pre></td></tr></table></figure>
<p>  此处的<span class="math inline">\(extends\)</span>关键词，可以理解为“<span class="math inline">\(K\)</span>必须是可比的”的声明。<span class="math inline">\(extends\)</span>会对对象施加一个约束、而非赋予它新的能力。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>5.Generics and Autoboxing</category>
      </categories>
  </entry>
  <entry>
    <title>5.1.自动装箱</title>
    <url>/2024/05/31/5.1.Autoboxing/</url>
    <content><![CDATA[<h1><span id="51自动装箱"><span class="math inline">\(5.1\)</span>自动装箱</span></h1>
<h3><span id="1自动装箱与解包">1.自动装箱与解包</span></h3>
<p>  当我们实例化一个泛型对象时，我们需要指定其具体的类型，例如<code>LinkedListDeque&lt;Integer&gt;</code>。对于<span class="math inline">\(Java\)</span>的<span class="math inline">\(8\)</span>种基本类型，我们使用相应的引用类型，这些引用类型被称为包装类(<span class="math inline">\(wrapper\;classes\)</span>)：</p>
<p><img src="/2024/05/31/5.1.Autoboxing/image.png"></p>
<p>  由引用类型转换到基本类型，我们不需要执行额外的操作。例如，我们可以直接写如下程序：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; L = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">      L.add(<span class="number">5</span>);</span><br><span class="line">      L.add(<span class="number">6</span>);</span><br><span class="line">      <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> L.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  而不必写成如下繁琐的形式： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; L = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">      L.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>));</span><br><span class="line">      L.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Use the Integer.valueOf method to convert to int */</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> L.get(<span class="number">0</span>).valueOf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这是因为<span class="math inline">\(Java\)</span>会自动“装箱”(<span class="math inline">\(autobox\)</span>)与“解包”(<span class="math inline">\(unbox\)</span>)基本类型与引用类型。因此，下面的程序都是正确的：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blah</span><span class="params">(Integer x)</span> &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">blah(x);</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blahPrimitive</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">20</span>);</span><br><span class="line">blahPrimitive(x);</span><br></pre></td></tr></table></figure></p>
<p>  不过需要注意，数组不能自动装箱或解包。</p>
<h3><span id="2类型扩展">2.类型扩展</span></h3>
<p>  当需要的时候，<span class="math inline">\(Java\)</span>会自动扩展一个初始类型的范围，例如：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blahDouble</span><span class="params">(<span class="type">double</span> x)</span> &#123;</span><br><span class="line">    System.out.println(“<span class="type">double</span>: “ + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">blahDouble(x);</span><br></pre></td></tr></table></figure></p>
<p>  是正确的，但： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blahInt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    System.out.println(“<span class="type">int</span>: “ + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">blahInt(x);</span><br></pre></td></tr></table></figure></p>
<p>  是错误的，因为<span class="math inline">\(int\)</span>的范围小于<span class="math inline">\(double\)</span>，不能扩展到比自己更大的集合中。此时必须使用类型铸造：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">blahInt((<span class="type">int</span>) x);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>5.Generics and Autoboxing</category>
      </categories>
  </entry>
  <entry>
    <title>6.1.汇编语言与程序</title>
    <url>/2024/04/07/6-1-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1><span id="61assemble-program-and-assembler"><span class="math inline">\(6.1.\)</span>Assemble Program and Assembler</span></h1>
<h3><span id="1basic-assembler-logic">1.Basic assembler logic</span></h3>
<ul>
<li><p>Repeat:</p>
<ul>
<li>Read the next Assembly language command.</li>
<li>Break it into the different fields it is composed of.</li>
<li>Lookup the binary code for each field.</li>
<li>Combine these codes into a single machine language command.</li>
<li>Output this machine language command.</li>
</ul></li>
<li><p>One thing we need to worry about: <em>Symbols</em>:</p>
<ul>
<li><p>Two cases:</p>
<ul>
<li><em>Labels</em>: When jumping into a certain part, you give it a
name instead of hard core the address. <code>JMP loop</code></li>
<li><em>Variables</em>: You give a variable name rather than always
refer to its exact address in memory. <code>load R1, weight</code></li>
</ul></li>
<li><p>To convert it into concrete address, we use a <em>symbol
table</em>:</p></li>
</ul></li>
</ul>
<p><img src="/2024/04/07/6-1-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%A8%8B%E5%BA%8F/image.png"></p>
<ul>
<li><p>To maintain such table:</p>
<ul>
<li>When we first meet a symbol, we need to <strong>allocate a new
memory location</strong> to hold it. For the assembler, it will find the
<strong>next memory location that's available</strong>.</li>
<li>When we meet it again, we simply refer to its address in the
table.</li>
</ul></li>
<li><p>One special case: <em>Forward references</em>: We can jump into a
label before where it was defined. There are two ways to handle it:</p>
<ol type="1">
<li>Use a little bit to remember that we've set the labels but don't
know where it is yet. We leave it blank until label appears.(more
complicated)</li>
<li>In first pass just figure out all address.</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 6.Assembler</category>
      </categories>
  </entry>
  <entry>
    <title>6.4.符号的处理</title>
    <url>/2024/04/07/6-4-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1><span id="64handling-the-symbol"><span class="math inline">\(6.4.\)</span>Handling the Symbol</span></h1>
<h3><span id="1type-of-symbol">1.Type of symbol</span></h3>
<p>  Generally there are three types of symbol:</p>
<ul>
<li><em>Variable symbols</em>: Which represents memory locations where
the programmer wants to maintain values.</li>
<li><em>Label symbols</em>: Which represents destinations of goto
instructions.</li>
<li><em>Pre-defined symbols</em>: Which represents special memory
lorations.</li>
</ul>
<h3><span id="2pre-define-symbolstranslation">2.Pre-define symbols
translation</span></h3>
<ul>
<li>These symbols exist only <strong>in the context of A
instructions</strong>. So they will only be seen in expression like
<code>@preDefinedSymbol</code></li>
<li>Translating <code>@preDefinedSymbol</code>: Replace
<code>preDefineSymbol</code> with its corresponding value:</li>
</ul>
<p><img src="/2024/04/07/6-4-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/image.png"></p>
<h3><span id="3label-symbols-translation">3.Label symbols translation</span></h3>
<p>  To begin with, there are two sorts of label:</p>
<ul>
<li>Used to label destination of <code>goto</code> commands. For
example, <code>@STOP, 0;JMP</code></li>
<li>Declared by the <em>pseudo-command</em>. For example,
<code>(STOP)</code></li>
</ul>
<blockquote>
<p>This is called pseudo-commands because <strong>it doesn't generate
any code</strong>. When we translate the program into binary. we don't
translate the label declaration instructions.</p>
</blockquote>
<p>  To allocate a specific location to each label, we
<strong>number</strong> the instruction one by one, like the left hand
side:</p>
<p><img src="/2024/04/07/6-4-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/image-1.png"></p>
<ul>
<li>We ignore <strong>white space and pseudo-commands</strong> when
numbering.</li>
</ul>
<p>  Once we complete the numbering, we can <strong>refer the label to
its corresponding line number</strong>. For example, <code>LOOP</code>
relates to 4 and <code>STOP</code> relates to 18. And when we see the
instruction <code>@LOOP</code>, we actually mean <code>@4</code>.</p>
<p>  After this pre-work, the translating is plain: * Translating
<code>@labelSymbol</code>: Replace <code>labelSymbol</code> with its
value.</p>
<h3><span id="4varables-translation">4.Varables translation</span></h3>
<ul>
<li>Any symbol xx appearing in an assembly program which <strong>is not
pre-defined</strong> and <strong>is not defined elsewhere using the
(xxx) directive</strong> is treated as a variable</li>
<li>if a variable appears in the program for the first time, we allocate
it to a memory address <strong>starting from address 16</strong> . If we
see this varable popping up later in the program, we simply <strong>look
up the value that you assigned to it before</strong>.</li>
</ul>
<h3><span id="5symbol-table-construction">5.Symbol table construction</span></h3>
<h4><span id="afirstpass">  <span class="math inline">\(a.\)</span>First
pass</span></h4>
<p>  In the <em>first pass</em>, we extract from the program <strong>all
the label symbols</strong>.</p>
<ul>
<li><p>Before starting any translation, create an empty table and add
all the predefined symbos one by one.</p></li>
<li><p>March through the entire text file that constitutes the source
assembly program:</p>
<ul>
<li><p>Only <strong>look for label declarations</strong></p>
<ul>
<li>Line of code that begins with left parenthesis.</li>
</ul></li>
<li><p>Meanwhile keep track of how many lines you've read so far (only
count real instructions).</p></li>
</ul></li>
</ul>
<p><img src="/2024/04/07/6-4-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/image-2.png"></p>
<h4><span id="bsecondpass">  <span class="math inline">\(b.\)</span>Second
pass</span></h4>
<ul>
<li>We start once again to scan the entire program.</li>
<li>Whenever we see a symbol <strong>which doesn't appear in the symbol
table</strong>, we add it to the table, assign to it <code>16</code> or
larger number (for it must be a varable).</li>
<li>If we find them in the symbol table, then they've been declared and
we can use them.</li>
</ul>
<h4><span id="cmore-about-the-table">  <span class="math inline">\(c.\)</span>More about the table</span></h4>
<ul>
<li>When resolving a symbol, we look it up in the table, retrieve its
value, and put it into the instruction. What you get is <strong>the
meaning of this symbol</strong> according to the symbol table.</li>
<li>We maintain the table as long as the assembler is processing the
program, and then we can toss it away.</li>
</ul>
<h3><span id="6summary-the-assemblyprocess">6.Summary: The assembly
process</span></h3>
<ul>
<li><p><em>Initialization</em>:</p>
<ul>
<li>Construct an empty symbol table,</li>
<li>Add the pre-defined symbols to the symbol table,</li>
</ul></li>
<li><p><em>First pass</em>:</p>
<ul>
<li><p>Scan the entire program;</p></li>
<li><p>For each "instruction" of the form <code>(xxx)</code>:</p>
<ul>
<li>Add the pair (xxx, address) to the symbol table, where
<em>address</em> is <strong>the number of the instruction following
<code>(xxx)</code></strong>.</li>
</ul></li>
</ul></li>
<li><p><em>Second pass</em>:</p>
<ul>
<li><p>Set n to 16</p></li>
<li><p>Scan the entire program again, for each instruction:</p>
<ul>
<li><p>If the instruction is <code>@symbol</code>, look up symbol in the
symbol table:</p>
<ul>
<li><p>If (symbol, value) is found, use value to complete the
instruction's translation;</p></li>
<li><p>If not found:</p>
<ul>
<li>Add (symbol, n) to the symbol table,</li>
<li>Use n to complete the instruction's translation,</li>
<li>n++</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>If the instruction is a C-instruction, complete the instruction's
translation.</p></li>
<li><p>Write the translated instruction to the output file.</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 6.Assembler</category>
      </categories>
  </entry>
  <entry>
    <title>6.5.Hack汇编器开发</title>
    <url>/2024/04/07/6-5-Hack%E6%B1%87%E7%BC%96%E5%99%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1><span id="65developing-a-hack-assembler"><span class="math inline">\(6.5.\)</span>Developing a Hack Assembler</span></h1>
<h3><span id="1start-reding-a-file">1.Start reding a file</span></h3>
<p>  In general, this part:</p>
<ul>
<li>Need to be able to read the input and break it into parts.</li>
<li>Doesn't need to understand what the command means or how it will be
translated into machine language.</li>
<li>Need to understand the format of the input language and how it
breaks into different components.</li>
</ul>
<p>  In detail, we may divide it into several parts:</p>
<ol type="1">
<li><p>Read a file with a given name.</p>
<ul>
<li>You may want a constructor to be able to accept the file name and
then open the file for reading.</li>
</ul></li>
<li><p>Move to next command in the file:</p>
<ol type="1">
<li>Are we finished? <code>boolean hasMoreCommands()</code></li>
<li>Get the next command: <code>void advance()</code></li>
<li>Read into one line into some kind of string.</li>
<li>Skip white space including comments.</li>
</ol></li>
<li><p>Get the fields of the current command</p>
<ul>
<li>Type of command (A, C, or label)</li>
</ul></li>
</ol>
<p><img src="/2024/04/07/6-5-Hack%E6%B1%87%E7%BC%96%E5%99%A8%E5%BC%80%E5%8F%91/image.png"></p>
<h3><span id="2translating-mnemonic-tocode">2.Translating mnemonic to
code</span></h3>
<p>  In general, this part:</p>
<ul>
<li><p>Don't need to worry about how the mnemonic fields were
obtained.</p>
<ul>
<li>No need to know what part of input line it is, etc.</li>
</ul></li>
</ul>
<p>  In detail, we:</p>
<ol type="1">
<li>Ask the parser to give us the string that corresponds to each part
of the field.</li>
<li>Once we get the three string, we go to the code object to translate
each one of them separately according to the known table.</li>
<li>Concatenate the output together.</li>
</ol>
<p><img src="/2024/04/07/6-5-Hack%E6%B1%87%E7%BC%96%E5%99%A8%E5%BC%80%E5%8F%91/image-1.png"></p>
<h3><span id="3the-symbol-table">3.The symbol table</span></h3>
<p>  In general, this part:</p>
<ul>
<li>Don't need to know what the symbols mean.</li>
<li>Need to maintain the association between a symbol and a memory
address.</li>
</ul>
<p>  In detail, we need to be able to:</p>
<ol type="1">
<li>Create an new empty table</li>
<li>Add a (symbol, address) pair to the table</li>
<li>Does the table contain a given symbol?</li>
<li>What is the address associated with a given symbol?</li>
</ol>
<p>  And do the following things:</p>
<ol type="1">
<li><p>Create a new empty table</p></li>
<li><p>Add all the pre-defined symbols to the table</p></li>
<li><p>While reading the input, add labels and new variables to the
table</p>
<ul>
<li><p>Labels: when you see a <code>"(xxx)"</code> command,add
<code>"xxx"</code> and the address of the next machine language
command</p>
<ul>
<li>Comment 1: this requires maintaining this running address (line
number).</li>
<li>Comment 2: this may need to be done in a first pass</li>
</ul></li>
<li><p>Variables: when you see an <code>"@xxx"</code> command, where
<code>"xxx"</code> is not a number and not already in the table, add
<code>"xxx"</code> and the next free address for variable
allocation</p></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 6.Assembler</category>
      </categories>
  </entry>
  <entry>
    <title>6.2.异常引发</title>
    <url>/2024/05/31/6.2.Throwing%20Exceptions/</url>
    <content><![CDATA[<h1><span id="62异常引发"><span class="math inline">\(6.2\)</span>异常引发</span></h1>
<h3><span id="1throw语句">1.<span class="math inline">\(throw\)</span>语句</span></h3>
<p>  考虑下面这个实现<span class="math inline">\(ArraySet\)</span>的程序： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// the next item to be added will be at position size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns true if this map contains a mapping for the specified key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (items[i].equals(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Associates the specified value with the specified key in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the number of key-value mappings in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这个程序有一个小问题：当我们向<span class="math inline">\(ArraySet\)</span>中加入<span class="math inline">\(null\)</span>时，会产生<code>NullPointerException</code>的错误。这是因为：在<code>contains</code>方法中，由于加入了<span class="math inline">\(null\)</span>，调用<span class="math inline">\(items[i]\)</span>时会产生这种错误。</p>
<p>  我们可以选择抛出自己的异常(<span class="math inline">\(exceptions\)</span>)。在<span class="math inline">\(python\)</span>中我们使用<span class="math inline">\(raise\)</span>语句，而在<span class="math inline">\(Java\)</span>中，我们可以用如下语句声明错误：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionObject</span>(parameter1, ...)</span><br></pre></td></tr></table></figure></p>
<p>  于是，我们可以如下编写我们的异常抛弃(<span class="math inline">\(throwing\;exception\)</span>)语句：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">   Throws an IllegalArgumentException if the key is null. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;can&#x27;t add null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  虽然不管有没有<span class="math inline">\(throw\)</span>语句，程序都会在该处中断。但是，通过<span class="math inline">\(throw\)</span>语句，我们对程序有了更高的掌控力：我们可以自己决定程序应该在何处中断。同时，我们也可以将<span class="math inline">\(Java\)</span>中的报错更改为更具体的语句。</p>
<h3><span id="2catch语句">2.<span class="math inline">\(catch\)</span>语句</span></h3>
<p>  利用先前的<span class="math inline">\(throw\)</span>，我们可以将<span class="math inline">\(Java\)</span>中的隐性错误(<span class="math inline">\(implicit\;exceptions\)</span>)显式化，例如：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ayyy lmao&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;For no reason.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ java Alien</span><br><span class="line">ayyy lmao</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.RuntimeException: For no reason.</span><br><span class="line">at Alien.main(Alien.java:<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>  这里，我们发现了构造方法<code>new</code>，这看起来和类的实例化非常相似——事实上就是如此。<span class="math inline">\(RuntimeException\)</span>也是一个普通的<span class="math inline">\(Java\)</span>实例。</p>
<p>  因此，我们可以<span class="math inline">\(catch\)</span>每个异常实例，如下面的例子：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="string">&quot;Retriever&quot;</span>, <span class="number">80</span>);</span><br><span class="line">d.becomeAngry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    d.receivePat();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Tried to pat: &quot;</span> + e);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure></p>
<p>  其对应输出可能为： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java ExceptionDemo</span><br><span class="line">Tried to pat: java.lang.RuntimeException: grrr... snarl snarl</span><br><span class="line">Lucy is a displeased Retriever weighing <span class="number">80.0</span> standard lb units.</span><br></pre></td></tr></table></figure></p>
<p>  可以看到，我们在<span class="math inline">\(catch\)</span>到<code>RuntimeException</code>后，依然执行到了最后一行。</p>
<p>  我们还可以用<span class="math inline">\(catch\)</span>语句来执行修正措施：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="string">&quot;Retriever&quot;</span>, <span class="number">80</span>);</span><br><span class="line">d.becomeAngry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    d.receivePat();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">    <span class="string">&quot;Tried to pat: &quot;</span> + e);</span><br><span class="line">    d.eatTreat(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line">d.receivePat();</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure></p>
<p>  在这个程序中，我们在发现异常时用<span class="math inline">\(treat\)</span>来慰抚<span class="math inline">\(Dog\)</span>，这样，程序的异常就解决了：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java ExceptionDemo</span><br><span class="line">Tried to pat: java.lang.RuntimeException: grrr... snarl snarl</span><br><span class="line">Lucy munches the banana</span><br><span class="line"></span><br><span class="line">Lucy enjoys the pat.</span><br><span class="line"></span><br><span class="line">Lucy is a happy Retriever weighing <span class="number">80.0</span> standard lb units.</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>  In the real world, this corrective action might be extending an
antenna on a robot when an exception is thrown by an operation expecting
a ready antenna. Or perhaps we simply want to write the error to a log
file for later analysis.</p>
</blockquote>
<h3><span id="3异常处理的哲学">3.异常处理的哲学</span></h3>
<p>  异常处理使得我们在概念上将错误处理(<span class="math inline">\(error\;handling\)</span>)与剩余部分的程序分离开来。例如，考虑下面的程序：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func readFile: &#123;</span><br><span class="line">    open the file;</span><br><span class="line">    determine its size;</span><br><span class="line">    allocate that much memory;</span><br><span class="line">    read the file into memory;</span><br><span class="line">    close the file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  如果不进行异常处理，我们可能会对程序进行如下改写：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func readFile: &#123;</span><br><span class="line">    open the file;</span><br><span class="line">    <span class="keyword">if</span> (theFileIsOpen) &#123;</span><br><span class="line">        determine its size;</span><br><span class="line">        <span class="keyword">if</span> (gotTheFileLength) &#123;</span><br><span class="line">            allocate that much memory;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;fileLengthError&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span> (gotEnoughMemory) &#123;</span><br><span class="line">                read the file into memory;</span><br><span class="line">            <span class="keyword">if</span> (readFailed) &#123;</span><br><span class="line">                <span class="keyword">return</span> error(<span class="string">&quot;readError&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;memoryError&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> error(<span class="string">&quot;fileOpenError&quot;</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样的代码十分冗杂。我们可以用异常处理如下书写： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">func readFile: &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        open the file;</span><br><span class="line">        determine its size;</span><br><span class="line">        allocate that much memory;</span><br><span class="line">        read the file into memory;</span><br><span class="line">        close the file;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (fileOpenFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (sizeDeterminationFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (memoryAllocationFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (readFailed) &#123;</span><br><span class="line">        doSomething;    </span><br><span class="line">    &#125; <span class="keyword">catch</span> (fileCloseFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  异常处理的方法让代码十分整洁：首先，程序先尝试执行所需的操作；然后，程序开始捕捉所有的错误。</p>
<blockquote>
<p>  Good code feels like a story; it has a certain beauty to its
construction. That clarity makes it easier to both write and maintain
over time.</p>
</blockquote>
<h3><span id="4未被捕捉的异常">4.未被捕捉的异常</span></h3>
<p>  当一个异常被引发时，它会向下历经如下的栈：</p>
<p><img src="/2024/05/31/6.2.Throwing%20Exceptions/image.png"></p>
<p>  如果三个方法都没有捕捉到异常，程序就会中断，<span class="math inline">\(Java\)</span>会给用户发送信息，并打印堆栈跟踪的信息：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException in thread “main”: </span><br><span class="line">at ArrayRingBuffer.peek:<span class="number">63</span> </span><br><span class="line">at GuitarString.sample:<span class="number">48</span> </span><br><span class="line">at GuitarHeroLite.java:<span class="number">110</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>6.Exception &amp; Iterator &amp; Iterables &amp; Object Methods</category>
      </categories>
  </entry>
  <entry>
    <title>6.3.迭代</title>
    <url>/2024/05/31/6.3.Iteration/</url>
    <content><![CDATA[<h1><span id="63迭代"><span class="math inline">\(6.3\)</span>迭代</span></h1>
<h3><span id="1增强型for循环">1.增强型<span class="math inline">\(for\)</span>循环</span></h3>
<p>  我们知道，可以用以下<span class="math inline">\(for\)</span>语句实现对数组元素的遍历：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (String city : s) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这与下面的程序等价： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">Iterator&lt;String&gt; seer = s.iterator();</span><br><span class="line"><span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> seer.next();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这个程序的关键在于被称作迭代器(<span class="math inline">\(iterator\)</span>)的对象。我们可以使用如下方法返回一个迭代器对象：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>  例如，我们可以通过如下语句实现对<span class="math inline">\(List\)</span>的迭代遍历： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; friends = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">...</span><br><span class="line">Iterator&lt;Integer&gt; seer = friends.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">System.out.println(seer.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这个迭代器有三个关键方法：</p>
<ol type="1">
<li>获得迭代器对象：<code>Iterator&lt;Integer&gt; seer = friends.iterator();</code>。</li>
<li>检测是否有对象剩余：<code>seer.hasNext()</code>。</li>
<li>返回当前对象、并使迭代器前进一个对象：<code>seer.next()</code>。</li>
</ol>
<h3><span id="2迭代器的实现">2.迭代器的实现</span></h3>
<h4><span id="a迭代器要素">  <span class="math inline">\(a.\)</span>迭代器要素</span></h4>
<p>  首先，我们考虑编译器需要知道哪些可迭代对象的信息。首先，<code>iterator()</code>被调用了，于是我们需要知道：</p>
<ul>
<li>该接口具有<code>iterator()</code>方法。</li>
</ul>
<p>  其次，<span class="math inline">\(seer\)</span>的<code>.next()</code>与<code>.hasNext()</code>方法被调用了，于是：
*
迭代器接口是否有<code>.next()</code>与<code>.hasNext()</code>方法。</p>
<h4><span id="b迭代器的实现">  <span class="math inline">\(b.\)</span>迭代器的实现</span></h4>
<ol type="1">
<li><p>我们的<span class="math inline">\(List\)</span>接口需要扩展迭代器接口，继承迭代器的抽象方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>编译器检查迭代器接口是否具有<code>.next()</code>与<code>.hasNext()</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>  特定的类需要实现自己的迭代器方法与行为。例如，我们想给<span class="math inline">\(ArrarMap\)</span>添加一个迭代器。可以先如下实现迭代器接口所需方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ArraySetIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> wizPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySetIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        wizPos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wizPos &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">returnItem</span> <span class="operator">=</span> items[wizPos];</span><br><span class="line">        wizPos += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> returnItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样，我们就可以利用<span class="math inline">\(ArraySetIterator\)</span>来实现对<span class="math inline">\(ArrayMap\)</span>的迭代： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArraySet&lt;Integer&gt; aset = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">aset.add(<span class="number">5</span>);</span><br><span class="line">aset.add(<span class="number">23</span>);</span><br><span class="line">aset.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iter = aset.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="c增强型for循环的实现">  <span class="math inline">\(c.\)</span>增强型<span class="math inline">\(for\)</span>循环的实现</span></h4>
<p>  为了实现增强型<span class="math inline">\(for\)</span>循环，我们需要让<span class="math inline">\(ArrayMap\)</span>类实现可迭代接口。可迭代接口的关键方法是<code>iterator</code>，我们只需要如下实现：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArraySetIterator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这样以后，我们就可以使用增强型<span class="math inline">\(for\)</span>循环了： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArraySet&lt;Integer&gt; aset = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : aset) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="d关键概念辨析">  <span class="math inline">\(d.\)</span>关键概念辨析</span></h4>
<ul>
<li><p>可迭代对象(<span class="math inline">\(iterable\)</span>)：使得一个类可以被迭代的接口，需要方法<code>iterator()</code>。</p></li>
<li><p>迭代器(<span class="math inline">\(iterator\)</span>)：定义某些方法的接口，这些方法用于实现真正的迭代。</p></li>
</ul>
<blockquote>
<p>   You can think of an Iterator as a machine that you put onto an
iterable that facilitates the iteration. Any iterable is the object on
which the iterator is performing.</p>
</blockquote>
<h3><span id="3可迭代arrayset的完整实现">3.可迭代<span class="math inline">\(ArraySet\)</span>的完整实现</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// the next item to be added will be at position size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns true if this map contains a mapping for the specified key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (items[i].equals(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">       Throws an IllegalArgumentException if the key is null. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;can&#x27;t add null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[size] = x;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns the number of key-value mappings in this map. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** returns an iterator (a.k.a. seer) into ME */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArraySetIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ArraySetIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> wizPos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ArraySetIterator</span><span class="params">()</span> &#123;</span><br><span class="line">            wizPos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> wizPos &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">returnItem</span> <span class="operator">=</span> items[wizPos];</span><br><span class="line">            wizPos += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> returnItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArraySet&lt;Integer&gt; aset = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">        aset.add(<span class="number">5</span>);</span><br><span class="line">        aset.add(<span class="number">23</span>);</span><br><span class="line">        aset.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//iteration</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : aset) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>6.Exception &amp; Iterator &amp; Iterables &amp; Object Methods</category>
      </categories>
  </entry>
  <entry>
    <title>7.1.程序编译前瞻</title>
    <url>/2024/04/08/7-1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%89%8D%E7%9E%BB/</url>
    <content><![CDATA[<h1><span id="71program-compilation-preview"><span class="math inline">\(7.1.\)</span>Program Compilation Preview</span></h1>
<h3><span id="1problem-in-compilation">1.Problem in compilation</span></h3>
<p>  To start with an abstract program and end with something actually
runs on the computer, we need</p>
<ul>
<li>A computer that can run machine language code.</li>
<li>Translating the high level language into machine language.</li>
</ul>
<p><img src="/2024/04/08/7-1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%89%8D%E7%9E%BB/image.png"></p>
<p>  However, there are so many kinds of computers in the world, and
many of them <strong>use different processes, which take different
machine languages</strong>. It seems that we have to develop many
compilers, one for each processor. This is very annoying.</p>
<p>  Luckily, this "write once fix everywhere" can be replaced by a
"write once run everywhere" process.</p>
<h3><span id="2-2-tier-compilation">2. 2-Tier compilation</span></h3>
<p>  Let's take Java as example:</p>
<ul>
<li><p>The first tier: also called <em>the top tier</em></p>
<ul>
<li><p>Java compiler translates the Java program into VM code.</p>
<ul>
<li>The VM code is designed to run on an abstract artifact called
<em>virtual machine</em>.</li>
<li>It's not a real computer, so if we want to execute the code, we have
to translate it further into machine language and realize it on real
hardware (computer, for example).</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2024/04/08/7-1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%89%8D%E7%9E%BB/image-1.png"></p>
<ul>
<li><p>The second tier:</p>
<ul>
<li>We equip the target device with <em>JVM</em>, the Java machine
implementation.</li>
<li>The JVM is a program that takes VM code and translates it into the
target code of the target platform.</li>
<li>We need such translator <strong>for every platform on which we want
to execute VM program</strong>.</li>
</ul></li>
</ul>
<p><img src="/2024/04/08/7-1-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%89%8D%E7%9E%BB/image-2.png"></p>
<p>  The gap between high-level language (Java, for example) and
low-level language is huge. But by <strong>introducing an intermediate
level</strong>, we <strong>decouple this process into two separate
standalone sub-processes</strong>: the compiler of <em>VM compiler</em>
and <em>VM implementation</em>.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>6.4.对象方法</title>
    <url>/2024/05/31/6.4.Object%20Methods/</url>
    <content><![CDATA[<h1><span id="64对象方法"><span class="math inline">\(6.4\)</span>对象方法</span></h1>
<h3><span id="1对象方法概述">1.对象方法概述</span></h3>
<p>  所有的类都继承了<span class="math inline">\(Object\)</span>类。它们继承的方法如下：</p>
<ul>
<li>String toString()</li>
<li>boolean equals(Object obj)</li>
<li>Class &lt;?&gt; getClass()</li>
<li>int hashCode()</li>
<li>protected Objectclone()</li>
<li>protected void finalize()</li>
<li>void notify()</li>
<li>void notifyAll()</li>
<li>void wait()</li>
<li>void wait(long timeout)</li>
<li>void wait(long timeout, int nanos)</li>
</ul>
<p>  下面我们重点讨论前两个。</p>
<h3><span id="2tostring">2.<code>toString()</code></span></h3>
<p>  <code>toString</code>方法返回一个对象的字符串表示。对于特定的类，我们可以覆盖对象原有的方法。考虑下面的问题：</p>
<p>  Exercise 6.4.1: Write the toString() method so that when we print
an ArraySet, it prints the elements separated by commas inside of curly
braces. i.e {1, 2, 3, 4}. Remember, the toString() method should return
a string: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* hmmm */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  <span class="math inline">\(solution\)</span>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">returnString</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i += <span class="number">1</span>) &#123;</span><br><span class="line">        returnString += keys[i];</span><br><span class="line">        returnString += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    returnString += <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> returnString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  这种写法看似简洁优雅，但每次使用<code>+=</code>运算符后，都需要创建一个新的字符串，这样的时间复杂度为<span class="math inline">\(O(n^2)\)</span>。为了优化该方法，<span class="math inline">\(Java\)</span>内置了<code>StringBuilder</code>方法。这个方法创造一个<span class="math inline">\(String\)</span>的可变对象，我们可以向对象内添加其它<span class="math inline">\(String\)</span>： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">returnSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            returnSB.append(items[i].toString());</span><br><span class="line">            returnSB.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        returnSB.append(items[size - <span class="number">1</span>]);</span><br><span class="line">        returnSB.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnSB.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="3equals">3.<code>equals()</code></span></h3>
<h4><span id="aequals的实现">  <span class="math inline">\(a.\)</span><code>equals()</code>的实现</span></h4>
<p>  在<span class="math inline">\(Java\)</span>中，<code>==</code>检查两个对象在内存中的是否为同一个对象。由之前<span class="math inline">\(pass-by-value\)</span>原则，<code>==</code>会检查两个盒子放的是不是同一个东西：</p>
<ul>
<li>对于基本类型的变量，这表示比较它们的值是否相等。</li>
<li>对于对象(<span class="math inline">\(objects\)</span>)，这表示比较两个对象的地址或指针是否相等。</li>
</ul>
<p>  而<code>equals()</code>方法在比较对象时，只会比较两者的值是否相等，这便是我们实现它的目的。我们可以如下实现<span class="math inline">\(ArraySet\)</span>的<code>equals()</code>方法：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == other) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (other == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (other.getClass() != <span class="built_in">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArraySet&lt;T&gt; o = (ArraySet&lt;T&gt;) other;</span><br><span class="line">        <span class="keyword">if</span> (o.size() != <span class="built_in">this</span>.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (T item : <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!o.contains(item)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>   在上面的<code>equals()</code>方法中，我们加入了对<span class="math inline">\(null\)</span>与跨类对象的比较的判断。我们也通过预先判断<code>==</code>的情况优化了方法。</p>
<h4><span id="bequals方法的规则">  <span class="math inline">\(b.\)</span><code>equals()</code>方法的规则</span></h4>
<p>  <code>equals()</code>方法要符合以下规则：</p>
<ol type="1">
<li>反身性(<span class="math inline">\(reflexive\)</span>)：<code>x.equals(x) == true</code>。</li>
<li>对称性(<span class="math inline">\(symmetric\)</span>)：<code>x.equals(y) == true</code>当且仅当<code>y.equals(x) == true</code>。</li>
<li>传递性(<span class="math inline">\(transitive\)</span>)：<code>x.equals(y), y.equals(z) == true</code>，则<code>x.equals(z) == true</code>。</li>
<li><code>x.equals(null) == false</code>，不论<span class="math inline">\(x\)</span>是什么。</li>
<li><code>equals()</code>方法的参数必须是<span class="math inline">\(object\)</span>型的，这样才能覆盖原有的<code>.equals()</code>方法。</li>
</ol>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>6.Exception &amp; Iterator &amp; Iterables &amp; Object Methods</category>
      </categories>
  </entry>
  <entry>
    <title>7.10.函数运行实现</title>
    <url>/2024/04/11/7-10-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1><span id="710function-call-and-returnimplementation"><span class="math inline">\(7.10.\)</span>Function Call and Return
Implementation</span></h1>
<h3><span id="1the-callers-view">1.The caller's view</span></h3>
<p>  In the calling function's view:</p>
<ul>
<li>Before calling another function, I must <strong>push as many
arguments as the function expects to get</strong>;</li>
<li>Next, I invoke the function using
<code>call functionName nArgs</code>;</li>
<li>After the called function returns, the argument values that I pushed
before the call have disappeared from the stack, and <strong>a return
value (that always exists) appears at the top of the
stack</strong>;</li>
<li>After the called function returns, <strong>all my memory segments
are exactly the same as they were before the call</strong> (except that
temp is undefined and some values of my static segment may have
changed).</li>
</ul>
<h3><span id="2the-callees-view">2.The callee's view</span></h3>
<p>  In the called function's view:</p>
<ul>
<li>Before I start executing, <strong>my<code>argument</code> segment
has been initialized with the argument values passed by the
caller</strong>.</li>
<li>My <strong><code>local</code> variables segment has been allocated
and initialized to zeros</strong>.</li>
<li>My <code>static</code> segment has been set to <strong>the
<code>static</code> segment of the VM file to which I belong</strong>
(memory segments <code>this</code>, <code>that</code>,
<code>pointer</code>, and <code>temp</code> are undefined upon
entry).</li>
<li>My working stack is empty.</li>
<li>Before returning, I must <strong>push a value onto the
stack</strong>.</li>
</ul>
<h3><span id="3handling-call">3.Handling <code>call</code></span></h3>
<p>  We can implement the VM code by these steps:</p>
<p><img src="/2024/04/11/7-10-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E5%AE%9E%E7%8E%B0/image.png"></p>
<p>  In terms of <code>call</code>, we do these steps:</p>
<ol type="1">
<li><p>Push a label onto the stack, and use the same label when we are
going to return after the called function terminates.
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push returnAddress</span><br></pre></td></tr></table></figure></p></li>
<li><p>Push some label that we generate to <strong>save the memory
segment of the caller</strong>: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push LCL</span><br><span class="line">push ARG</span><br><span class="line">push THIS</span><br><span class="line">push THAT</span><br></pre></td></tr></table></figure></p></li>
<li><p>The <code>argument</code> should <strong>be repositioned for the
called function</strong>, and we should reposition it at the beginning
of the <code>ARG</code> segment:</p>
<ul>
<li>We can calculate the address, because we know how many values we
pushed. Say we push 5 values the we do : <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARG = SP - 5</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Push the <code>local</code> segment to insure that the function
can visit its local variables correctly : <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LCL = SP</span><br></pre></td></tr></table></figure></p></li>
<li><p>We execute the called function by simply writing the command
<code>goto nameOfFunction</code>: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goto functionName</span><br></pre></td></tr></table></figure></p></li>
<li><p>We insert the <code>returnAddress</code> label, so that when the
function has been executed, we can get back to the place we invoke it :
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(returnAddress) //Declares a label for the return-address</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><img src="/2024/04/11/7-10-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E5%AE%9E%E7%8E%B0/image-1.png"></p>
<h3><span id="4handling-function">4.Handling <code>function</code></span></h3>
<p>  The big picture of handling <code>function</code> is that:</p>
<ul>
<li>The first thing translator does is <strong>it takes the function
name and generates a label</strong>, and the label will serve as
<strong>the entry point to the translated assembly code of the
function</strong>.</li>
<li>We simply write some assembly code that <strong>handles the setting
up of the function's execution</strong>.</li>
</ul>
<ol type="1">
<li>We take the function name and generate its label:</li>
<li>Since we know how many local variables we have to create, we do
<code>push 0</code> <code>nVars</code> times. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(functionName)</span><br><span class="line">	//repeat nVars times</span><br><span class="line">	push 0</span><br></pre></td></tr></table></figure></li>
</ol>
<h3><span id="4handling-return">4.Handling <code>return</code></span></h3>
<p>  After setting up, the function can start doing its thing. We need
to generate assembly code that <strong>moves the return value to the
caller, reinstates the caller's state, and finally <code>goto</code> the
return address</strong>.</p>
<ol type="1">
<li>Create some temporary variable (called <code>endFrame</code>) and
assign the value of <code>LCL</code> to it: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">endFrame = LCL</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  If you look at the stack diagram, you will see that
<code>endFrame</code> indeed <strong>points at the end of the frame in
the host RAM</strong>.</p>
<p><img src="/2024/04/11/7-10-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E5%AE%9E%E7%8E%B0/image-2.png"></p>
<ol start="2" type="1">
<li><p>Since we should put the return value at the top of the stack, say
we have 5 values, the <code>endFrame - 5</code> will be the exact return
address.</p>
<ul>
<li>We need to use <code>*</code> to look inside and get the address.
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">retaddr = *(endFrame - 5)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Reposition the return value for the caller.</p>
<ul>
<li>The value should be copied to <code>argument 0</code>, and we
already have a pointer <code>ARG</code> located in the position</li>
<li><code>pop</code> is going to retrieve the return value off the
stack. We take this value and put it in <code>ARG</code>.
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*ARG = pop()</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>The caller expects to see a return value and continue to do its
work, so the stack pointer should <strong>be just after
<code>ARG</code></strong>.<br>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SP = ARG + 1</span><br></pre></td></tr></table></figure></p></li>
<li><p>Then we can begin to recover the various segments that we saved
on the stack before. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">THAT = *(endFrame - 1)</span><br><span class="line">THIS = *(endFrame - 2)</span><br><span class="line">ARG = *(endFrame - 3)</span><br><span class="line">LCL = *(endFrame - 4)</span><br></pre></td></tr></table></figure></p></li>
<li><p>Finally we can jump to the return address we copied before:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goto retAddr</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><img src="/2024/04/11/7-10-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E5%AE%9E%E7%8E%B0/image-3.png"></p>
<ul>
<li>Every thing below <code>SP</code> is recycled. <strong>The next push
is going to override the memory location where <code>SP</code>
shows</strong>.</li>
<li>The caller will see the return value at the top of its working
stack.</li>
<li>The stack pointer will point at the next world in the memory.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.12.翻译器实现笔记</title>
    <url>/2024/04/13/7-12-%E7%BF%BB%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1><span id="712翻译器实现笔记"><span class="math inline">\(7.12.\)</span>翻译器实现笔记</span></h1>
<h3><span id="1localargumentthisthattemp的实现">1.
<code>local,argument,this,that,temp</code>的实现</span></h3>
<p>  这几个内存段的<code>push</code>实现都遵循<code>*sp=*addr</code>的过程。我们可以将该过程拆分为下面的子过程：</p>
<ul>
<li><code>D=*addr</code>.</li>
<li><code>*sp=D</code>.</li>
<li><code>sp++</code></li>
</ul>
<p>  同时，根据先前的讨论，<code>push</code>操作中的<code>addr</code>可以通过<code>baseAddr+index</code>来计算。<code>index</code>的值很容易获取，假设我们的操作为<code>push local x</code>,
则： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//get index</span><br><span class="line">@x</span><br><span class="line">D=A</span><br></pre></td></tr></table></figure></p>
<p>  但接下来，如果要获取<code>baseAddr</code>，因为此时的D寄存器已经存储了<code>x</code>的序号，
我们会想通过A寄存器获得<code>baseAddr</code>,
然后将<code>baseAddr+index</code>的地址存入A寄存器中： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//get base addr</span><br><span class="line">@LCL</span><br><span class="line">A=M</span><br><span class="line">A=A+D</span><br></pre></td></tr></table></figure></p>
<p>  顺利完成<code>LCL</code>内存段的地址读入后，我们接着用D寄存器读入<code>baseAddr+index</code>对应的数据。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D=A+D</span><br></pre></td></tr></table></figure>
  但是，此时的<code>A</code>储存的已不是原先的<code>baseAddr</code>了，通过这种方式更新<code>D</code>的值是不行的。这时，我们可以考虑<strong>同时更新<code>A</code>与<code>D</code>的值</strong>，这样就可以利用未改变的<code>A</code>成功更新<code>A</code>与<code>D</code>:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@x</span><br><span class="line">D=A</span><br><span class="line">@LCL</span><br><span class="line">A=M //pointer</span><br><span class="line">AD=A+D</span><br></pre></td></tr></table></figure></p>
<p>  然后，我们需要<code>D=*addr</code>，由前面讲解的指针的表示，只需补上<code>D=M</code>语句即可。</p>
<p>  接下来就是较为简单的<code>*sp=D</code>操作了： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+1</span><br></pre></td></tr></table></figure></p>
<h3><span id="2loop实现">2.<code>Loop</code>实现</span></h3>
<p>  对于<code>if-goto</code>语句，我们只需根据栈顶元素是否为<code>0</code>来判断是否需要跳转到所需分支。因为在栈中，我们用<code>0</code>表示<code>false</code>：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">M=M-1</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@LABEL</span><br><span class="line">D;JNE</span><br></pre></td></tr></table></figure></p>
<p>  而对于无条件的<code>goto</code>语句，利用<code>0,JMP</code>即可实现：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@LABEL</span><br><span class="line">0;JMP</span><br></pre></td></tr></table></figure></p>
<h3><span id="3function实现">3.<code>function</code>实现</span></h3>
<p>  在<code>Hack</code>中，我们只需为<code>function</code>创建对应标签即可：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(LABEL)</span><br></pre></td></tr></table></figure></p>
<h3><span id="4call实现">4.<code>Call</code>实现</span></h3>
<p>  我们按照<span class="math inline">\(8.6.\)</span>节所讲逐步实现<code>call</code>功能：</p>
<ol type="1">
<li><p>在栈中放入<code>returnAddress</code>的标签，这标志着我们在调用函数后将返回的地址：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@return_address1</span><br></pre></td></tr></table></figure>   该地址亦是栈指针的初始位置所在之处：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D=A</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
<li><p>然后，我们依次放入<code>LCL</code>, <code>ARG</code>,
<code>THIS</code>,
<code>THAT</code>，以保存调用者(caller)的内存段。</p></li>
</ol>
<p>  对于每一个内存段，我们像普通的<code>push</code>操作一样，将其放入栈指针所指位置，然后移动栈指针：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SP = memorySegment</span><br><span class="line">SP = SP + 1</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@LCL</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+1</span><br><span class="line"></span><br><span class="line">@SRG</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+1</span><br><span class="line"></span><br><span class="line">@THIS</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+1</span><br><span class="line"></span><br><span class="line">@THAT</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br><span class="line">@SP</span><br><span class="line">M=M+1</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>接下来我们要重定向<code>ARG</code>的位置，我们需要把它定向至<code>ARG[0]</code>的位置，而该位置可以通过计算得出：</li>
</ol>
<p>  假设我们调用的函数为<code>call func x</code>，则在<code>ARG</code>内存段前有4(前四个内存段)+x(<code>LCL</code>需要的位置个数)，对应代码为：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@5+x</span><br><span class="line">D=A</span><br></pre></td></tr></table></figure></p>
<p>  然后我们需要将栈指针移到对应位置，并将<code>ARG</code>的初始位置设置在这里：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">A=M</span><br><span class="line">AD=A-D</span><br><span class="line">@ARG</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p>
<ol start="4" type="1">
<li><p>为了能够正确访问<code>LCL</code>的位置，我们将<code>LCL</code>
<code>push</code>到栈指针所在位置： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">D=M</span><br><span class="line">@LCL</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
<li><p>然后，我们<code>goto</code>需要执行的函数以执行函数：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@func</span><br><span class="line">0;JMP</span><br></pre></td></tr></table></figure></p></li>
<li><p>最后我们插入<code>returnAddress</code>的标签，这样当函数被执行完，我们可以回到最初调用它的地方：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(return_address1)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3><span id="5return实现">5.<code>return</code>实现</span></h3>
<p>  我们按照<span class="math inline">\(8.6.\)</span>节所讲逐步实现<code>call</code>功能：</p>
<ol type="1">
<li><p>创建一个临时变量<code>frame</code>，并把<code>LCL</code>的值赋给它。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@LCL</span><br><span class="line">D=M</span><br><span class="line">@frame</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
<li><p>我们将<code>return</code>的值放在栈顶。由于有四个占据主内存的内存段，因此我们需要上移4+1=5个，<code>frame-5</code>即为<code>return</code>的地址：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@5</span><br><span class="line">A=D-A</span><br><span class="line">D=M</span><br><span class="line">@ret</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
</ol>
<blockquote>
<p>为什么此时不考虑每个内存段中的原有元素了呢？因为<strong>在<code>return</code>的过程中，我们需要覆盖所有的已有元素，这要求我们将这些元素当作不存在</strong>。而如果我们考虑这些元素并将<code>ret</code>上移，<strong>在之后的步骤中就无法覆盖一些原有的旧数据和清空调用函数的栈了</strong>。</p>
</blockquote>
<ol start="3" type="1">
<li><p>由于我们需要将待<code>return</code>的值复制到<code>ARG[0]</code>的位置，而该值就在栈顶，我们可以轻易地通过操纵栈指针读取该值：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SP</span><br><span class="line">M=M-1</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@ARG</span><br><span class="line">A=M</span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
<li><p>调用者需要能够获取该值，因此栈指针应与<code>ARG</code>相邻：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ARG</span><br><span class="line">D=M</span><br><span class="line">@SP</span><br><span class="line">M=D+1</span><br></pre></td></tr></table></figure></p></li>
<li><p>然后，我们就可以着手覆盖原有的内存段了。我们从先前设置的<code>frame</code>地址往下，依次设置新的内存段地址：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@frame</span><br><span class="line">M=M-1</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@THAT </span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line">@frame</span><br><span class="line">M=M-1</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@THIS </span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line">@frame</span><br><span class="line">M=M-1</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@ARG </span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line">@frame</span><br><span class="line">M=M-1</span><br><span class="line">A=M</span><br><span class="line">D=M</span><br><span class="line">@LCL </span><br><span class="line">M=D</span><br></pre></td></tr></table></figure></p></li>
<li><p>最后，我们回到最初设置的<code>ret</code>位置。由于<code>ret</code>并非标签，要跳转到其地址，我们需要指针操作：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ret</span><br><span class="line">A=M</span><br><span class="line">0;JMP</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3><span id="6initial实现">6.<code>Initial</code>实现</span></h3>
<p>  当我们需要翻译的VM代码是有效的时，我们就需要对我们的硬件系统进行初始化：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@256</span><br><span class="line">D=A</span><br><span class="line">@SP</span><br><span class="line">M=D</span><br><span class="line"></span><br><span class="line">call Sys.init// same as other call statements before.</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.2.VM结构</title>
    <url>/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1><span id="72vm-abstractionthe-stack"><span class="math inline">\(7.2.\)</span>VM Abstraction——the Stack</span></h1>
<h3><span id="1-the-stack-machine">1. The stack machine</span></h3>
<ul>
<li>The stack machine is an <em>abstraction</em> that consists of
<strong>an architecture, a stack and a set of operation which we can
apply to the architecture</strong>.</li>
</ul>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image.png"></p>
<ul>
<li>It can be considered an <em>array</em> which offers direct access to
every element in the memory, as oppose to the traditional stack which
only offers a stack pointer.</li>
<li>When we do <code>push x</code>, <strong>the address of
<code>x</code></strong> will be push into the stack:</li>
</ul>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-1.png"></p>
<ul>
<li><p>When we do <code>pop y</code>:</p>
<ul>
<li>the <strong>current top value in the stack</strong> will be
removed,</li>
<li>the <strong>popped value</strong> will override <code>y</code> (in
this example, when 7 is popped, 3 becomes the new top value).</li>
</ul></li>
</ul>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-2.png"></p>
<h3><span id="2stack-arithmetic">2.Stack arithmetic</span></h3>
<p>  If we want to apply a certain function on the stack, we have to do
three different things:</p>
<ol type="1">
<li>Pop as many required operands in the stack as possible.</li>
<li>Apply the function to these operands in a separate process and get
the result.</li>
<li>Push the result back into the stack.</li>
</ol>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-3.png"></p>
<p>  The obstruction supports all these operations inherently, all we
have to do it to call <code>add</code> or <code>neg</code>, and these
things will take place.</p>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-4.png"></p>
<h3><span id="3vm-commands">3.VM commands</span></h3>
<ul>
<li>Arithmetic commands:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// d = (2 - x) + (y + 9)</span><br><span class="line">push 2</span><br><span class="line">push x</span><br><span class="line">sub</span><br><span class="line">push y</span><br><span class="line">push 9</span><br><span class="line">add</span><br><span class="line">add </span><br><span class="line">pop d</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-5.png"></p>
<ul>
<li>Logic commands: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// (x &lt; 7) or (y == 8)</span><br><span class="line">push x </span><br><span class="line">push 7</span><br><span class="line">lt</span><br><span class="line">push y</span><br><span class="line">push 8</span><br><span class="line">eq </span><br><span class="line">or</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-6.png"></p>
<p>  Where do these commands come from? It's compiled from the
high-level language:</p>
<p><img src="/2024/04/08/7-2-VM%E7%BB%93%E6%9E%84/image-7.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.3.内存段</title>
    <url>/2024/04/08/7-3-%E5%86%85%E5%AD%98%E6%AE%B5/</url>
    <content><![CDATA[<h1><span id="73memorysegments"><span class="math inline">\(7.3.\)</span>Memory
Segments</span></h1>
<h3><span id="1memory-segments-intro">1.Memory segments intro</span></h3>
<p>  There are different variable kinds in the high-level language, such
as:</p>
<ul>
<li>Argument variables</li>
<li>Local variables</li>
<li>Static variables</li>
</ul>
<p>  Since different kind of variables <strong>play different
role</strong>, we need some mechanism to <strong>record the different
roles of different variables</strong>. We can achieve this by the notion
of <em>memory segments</em>:</p>
<p><img src="/2024/04/08/7-3-%E5%86%85%E5%AD%98%E6%AE%B5/image.png"></p>
<p>  So the program below can be translated into two ways: without
<em>memory segments</em>:</p>
<p><img src="/2024/04/08/7-3-%E5%86%85%E5%AD%98%E6%AE%B5/image-1.png"></p>
<p>  And with <em>memory segments</em>:</p>
<p><img src="/2024/04/08/7-3-%E5%86%85%E5%AD%98%E6%AE%B5/image-2.png"></p>
<p>  In this way, we will be able to preserve the role semantics of
these variables.</p>
<p>  But it seems that we lost the variable names in the process. It's
not a big deal, however, for <strong>the VM obstruction doesn't
recognize symbolic variable names</strong>, all the variables are
replaced by references to memory segments.</p>
<p>  Through memory segments, we now interact with several different
segments:</p>
<p><img src="/2024/04/08/7-3-%E5%86%85%E5%AD%98%E6%AE%B5/image-3.png"></p>
<p>  And the syntax of the command is:
<code>push / pop segment i</code></p>
<ul>
<li><em>segment</em> is the segment you want to operate on.</li>
<li><em>i</em> is the index of the command in that segment.</li>
<li><span class="math inline">\(e.g.\)</span>
:<code>push constant 17</code></li>
<li><span class="math inline">\(e.g.\)</span> : translation of
<code>let static 2 = argument 1</code>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push argument 1</span><br><span class="line">pop static 2</span><br></pre></td></tr></table></figure>
<h3><span id="2the-usage-of-segment">2.The usage of segment</span></h3>
<ul>
<li><p>There's a lot of semantics going on in the high-level
language:</p>
<ul>
<li>static variables, local variables, argument variables, ...</li>
<li>the <em>object</em> consisting a bundle of variables</li>
</ul></li>
<li><p>We can handle all the semantics using the eight virtual
segments.</p></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.4.堆栈结构实现</title>
    <url>/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1><span id="74implementation-of-stack"><span class="math inline">\(7.4.\)</span>Implementation of Stack</span></h1>
<h3><span id="1pointer-manipulation">1.Pointer manipulation</span></h3>
<p>  We first introduce <em>pointer notation</em>: <code>*p</code>
represents <strong>the value stores in the address that <code>p</code>
points to</strong>.</p>
<p><img src="/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/image.png"></p>
<p>  In <em>Hack</em>, the pointer statement:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D = *p // D becomes 23</span><br></pre></td></tr></table></figure>
<p>  can be translated into:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@p</span><br><span class="line">A = M</span><br><span class="line">D = M</span><br></pre></td></tr></table></figure>
<ul>
<li><code>A = M</code> points the pointer to the address of register
M.</li>
<li><code>D = M</code> gets the value of the RAM.</li>
</ul>
<p>  The calculation of pointer, such as:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p--</span><br><span class="line">D = *p</span><br></pre></td></tr></table></figure>
<p>  When <code>p--</code>, <code>*p</code> refers to
<code>RAM[256]</code>. After than when we invoke <code>D = *p</code>, it
will get the value stored in <code>RAM[256]</code>, namely 19.</p>
<p>  When we assign a number to pointer, such as: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*q = 9</span><br><span class="line">q++</span><br></pre></td></tr></table></figure></p>
<p>  The <code>*q</code> refers to <code>RAM[1024]</code>, which stores
value 5. After the assignment, <code>RAM[1024]</code>stores 9
instead.</p>
<h3><span id="2stack-machine-operation">2.Stack machine operation</span></h3>
<p>  Before implementation, we make two assumption:</p>
<ol type="1">
<li>The stack pointer will be stored in <code>RAM[0]</code>.</li>
<li>Stack base address will be <code>addr = 256</code>.</li>
</ol>
<p>  Let's <code>push</code> two value first:</p>
<p><img src="/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/image-1.png"></p>
<p>  After the <code>push</code>, the stack pointer will point to 258,
and our RAM looks like this:</p>
<p><img src="/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/image-2.png"></p>
<p>  And we push <code>12 + 5</code> into the stack, then 17 will be in
the previous available space, and stack pointer moves forward:</p>
<p><img src="/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/image-3.png"></p>
<p>  So we can write the VM code: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//push x</span><br><span class="line">*sp = x</span><br><span class="line">sp++</span><br></pre></td></tr></table></figure></p>
<p>  This can be translated into this Hack assembly: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//push x</span><br><span class="line">@x</span><br><span class="line">D = A // D = x</span><br><span class="line">@SP</span><br><span class="line">A = M // *sp = D</span><br><span class="line">M = D</span><br><span class="line">@SP //increase the location</span><br><span class="line">M = M + 1</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>  In this program, the A register plays two roles:   <em>Data
register</em> which stores x   <em>Address register</em> as usual</p>
</blockquote>
<h3><span id="3vm-translator-perspective">3.VM translator perspective</span></h3>
<p><img src="/2024/04/08/7-4-%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/image-4.png"></p>
<ul>
<li><p>VM translator is:</p>
<ul>
<li>A program that translates VM code into machine language.</li>
<li>Each VM command generates several assembly commands.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.11.Hack平台上的VM实现</title>
    <url>/2024/04/11/7-11-Hack%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84VM%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1><span id="711vm-implementation-on-the-hackplatform"><span class="math inline">\(7.11.\)</span>VM Implementation on the Hack
Platform</span></h1>
<h3><span id="1program-compilation-andtranslation">1.Program compilation and
translation</span></h3>
<p><img src="/2024/04/11/7-11-Hack%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84VM%E5%AE%9E%E7%8E%B0/image.png"></p>
<ul>
<li>When we translate from Jack to VM, we lost <em>the notion of
constructors, methods</em>, because everything becomes functions.</li>
<li>When we translate from VM to assembly, we lost <em>the notion of
functions</em>, because we just have a long stream of assembly
commands.</li>
</ul>
<h3><span id="2vm-convention">2.VM convention</span></h3>
<p>  In order to tranlate the VM code into assembly code, we need to
comply to certain conventions:</p>
<ol type="1">
<li><p><em>VM programming convention</em>: One file in any VM program is
expected to be named <code>Main.vm</code>; one VM function in this file
is expected to be named <code>main</code>.</p></li>
<li><p><em>VM implementation convention</em>: When the VM implementation
starts running, or is reset, it starts executing the argument-less OS
function <code>Sys.init</code>.<code>Sys.init</code> then calls
<code>Main.main</code>, and enters an infinite loop.</p></li>
<li><p><em>Hardware platform convention</em>:</p>
<ul>
<li>We request that the code you see here <strong>will be stored in the
target computer's instruction memory beginning in address
<code>0</code></strong>, for our Hack computer is programmed to start
executing the program beginning with address <code>0</code>.</li>
<li>So we first set <code>SP = 256</code>. By doing this, it will
determined that the stack should begin in this address in the whole
stream.</li>
<li>Then we <code>call Sys.init</code>.</li>
</ul></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SP = 256</span><br><span class="line">Call Sys.init</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.5.内存段的实现</title>
    <url>/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1><span id="75memory-segment-implementation"><span class="math inline">\(7.5.\)</span>Memory Segment implementation</span></h1>
<h3><span id="1local-implementation">1.<code>local</code> implementation</span></h3>
<p>  The <code>local</code> segment can be placed <strong>anywhere we
want in the host RAM</strong>, for we just need to <strong>remember the
base address of the block</strong>.</p>
<ul>
<li>We place the <strong>base address of the <code>local</code>
segment</strong> in a pointer called <em>LCL</em>.</li>
<li><em>LCL</em> will refer to <code>RAM 1</code>.</li>
</ul>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image.png"></p>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-1.png"></p>
<p>  Then we can <code>push</code> or <code>pop</code> a value easily.
Say we want to accomplish <code>pop local 2</code>:</p>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-2.png"></p>
<p>  We can do this by putting the stack-top value into
<code>RAM[1015]</code>.</p>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-3.png"></p>
<ul>
<li>How do we know which <code>RAM</code> to add to? We get it by
<code>base addr + index</code></li>
</ul>
<p>  This process can be translated into this VM code: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//get the place to be added</span><br><span class="line">addr = addr + index</span><br><span class="line">//get the value, and put it into correct place</span><br><span class="line">sp--</span><br><span class="line">*addr = *sp</span><br><span class="line">// D = *sp, *addr = D</span><br></pre></td></tr></table></figure></p>
<p>  Notice that 5 is still in <code>RAM[257]</code>, it hasn't been
removed. It's common to have these wasted data in the stack, and it's
not big deal, for <strong>the pointer indicates exactly which part of
the stack are in play, not the data</strong>.</p>
<h3><span id="2argumentthisthatimplementation">2.<code>argument,this,that</code>
implementation</span></h3>
<ul>
<li><p>When translating the high-level code of some method into VM
code:</p>
<ul>
<li>Maps the method's local and argument variables onto the
<code>local</code> and <code>argument</code> segments</li>
<li>Maps the object fields and the array entries that the method is
currently processing onto the <code>this</code> and <code>that</code>
segments</li>
</ul></li>
</ul>
<p>  The process of <code>argument</code>, <code>this</code> and
<code>that</code> is nearly the same as <code>local</code>:</p>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-4.png"></p>
<p>  The process can be translated into this VM code: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//push</span><br><span class="line">addr = segmentPointer + index</span><br><span class="line">*sp = *addr</span><br><span class="line">sp++</span><br><span class="line"></span><br><span class="line">//pop</span><br><span class="line">addr = segmentPointer + index</span><br><span class="line">sp--</span><br><span class="line">*addr = *sp</span><br></pre></td></tr></table></figure></p>
<h3><span id="3constant">3.<code>Constant</code></span></h3>
<ul>
<li><p>When the compiler translates the high-level code of some method
into VM,</p>
<ul>
<li>it translates high-level operations involving constant into VM
operations involving the constant segment.</li>
</ul></li>
<li><p>When we implement <code>constant</code>, we simply <strong>supply
the specified constant</strong>.</p></li>
<li><p>Since we won't store things where a <code>constant</code>
resides, there's no <code>pop</code> in <code>constant</code>.</p></li>
<li><p>The <code>constant</code> segment is a <strong>truly virtual
segment</strong>. So whenever we see a <code>push constant i</code>
command, we simply supply the specified constant
<code>i</code>.</p></li>
</ul>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-5.png"></p>
<h3><span id="4static">4.<code>Static</code></span></h3>
<ul>
<li><p>When translating the high-level code of some method into VM code,
the compiler:</p>
<ul>
<li>Maps the static variables that the method sees onto the
<code>static</code> segment.</li>
</ul></li>
<li><p>The <code>static</code> variables should <strong>be seen by all
the methods in a program</strong>.   To complement this, we store the
variables in a <em>"global space"</em>:</p></li>
<li><p>Have the VM translator translate each VM reference
<code>static i</code>(in file <code>Foo.vm</code>)into an <em>assembly
reference</em> <code>Foo.i</code>.</p>
<ul>
<li><code>Foo</code> is the name of the file, and <code>i</code> is the
index of VM command.</li>
</ul></li>
<li><p>Following assembly, the Hack assembler will map these references
onto <code>RAM[16]</code>,<code>RAM[17]</code>,<code>RAM[18]</code>,
...</p></li>
</ul>
<p>  For example, the statement <code>pop static 5</code> can be
translated into: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Foo.5</span><br><span class="line">M = D</span><br><span class="line">//the register stores this data</span><br><span class="line"></span><br><span class="line">@Foo.2</span><br><span class="line">M = D</span><br></pre></td></tr></table></figure> * The entries of <code>static</code>
segment will end up being mapped onto <code>RAM[16]</code>,
<code>RAM[17]</code>, ... , in the order <strong>in which they appear in
the program</strong> (not their names!!!).</p>
<figure>
<img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-6.png" alt="Alt text">
<figcaption aria-hidden="true">Alt text</figcaption>
</figure>
<blockquote>
<p>Static variables are stored <strong>in a section of memory called the
static data segment</strong>, which is allocated when the program is
loaded and has fixed memory addresses. When we want to retrieve the
value of a static variable, we need to read the value stored <strong>at
the memory location</strong> where the static variable is stored, rather
than directly accessing the value of the static variable itself. This is
why we need to use <code>D=M</code> instead of <code>D=A</code> to get a
<code>static</code> value.</p>
</blockquote>
<h3><span id="5temp">5.<code>Temp</code></span></h3>
<p>  When the compiler translates the Jack program into VM code, it
sometimes has to use temporary variables.</p>
<ul>
<li>We let the 8 place segment called <code>temp</code> to contain and
serve these variables when needed.</li>
<li><code>temp</code> is going to be a <strong>fixed 8-place memory
segment</strong>.</li>
<li>The variables will be mapped on <code>RAM</code> locations 5 to
12.</li>
</ul>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-7.png"></p>
<h3><span id="6pointer">6.Pointer</span></h3>
<ul>
<li><p>When translating a high-level method code into VM code,the
compiler:</p>
<ul>
<li>Has to remember the base addresses of <code>this</code>, which
represents <em>the current object</em>, and <code>that</code>, which
represents <em>the current array of method be processing</em>.</li>
<li>Generates code that <strong>keeps track of the base addresses of the
this and that segments</strong> using the pointer segment.</li>
</ul></li>
<li><p><code>pointer</code> is a fixed memory segment. It has only two
entries, <code>0</code> and <code>1</code>.</p>
<ul>
<li>So we can only <code>push</code> and <code>pop</code> <code>0</code>
and <code>1</code></li>
</ul></li>
<li><p>Accessing <code>pointer 0</code> should result in
<strong>accessing <code>THIS</code></strong>.</p></li>
<li><p>Accessing <code>pointer 1</code> should result in
<strong>accessing <code>THAT</code></strong>.</p></li>
</ul>
<p><img src="/2024/04/09/7-5-%E5%86%85%E5%AD%98%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/image-8.png"></p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.7.函数抽象</title>
    <url>/2024/04/10/7-7-%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<h1><span id="77function-abstraction"><span class="math inline">\(7.7.\)</span>Function: Abstraction</span></h1>
<h3><span id="1function-in-vm-language">1.Function in VM language</span></h3>
<ul>
<li><p>The VM language features:</p>
<ul>
<li><em>primitive operation</em>(fixed): <code>add</code>,
<code>sub</code></li>
<li><em>abstract operation</em>(extensible): <code>mutiple</code></li>
</ul></li>
</ul>
<p>  When we want to call a function, we:</p>
<ul>
<li>push the required argument onto the stack.</li>
<li>call the function. Then <strong>the result of function will replace
the argument you push earlier</strong>.</li>
</ul>
<p>  Take this simple funtion call <code>sqrt(x-17+x*5)</code> as
example, it can be translated into: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push x</span><br><span class="line">push 17</span><br><span class="line">sub</span><br><span class="line">push x </span><br><span class="line">push 5</span><br><span class="line">call Math.multiply</span><br><span class="line">add </span><br><span class="line">call Math.sqrt</span><br></pre></td></tr></table></figure></p>
<h3><span id="2function-definition">2.Function definition</span></h3>
<p>  Take the previous function as example: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// returns x&quot;y</span><br><span class="line">int mult(int x, int y) &#123;</span><br><span class="line">	int sum = 0;</span><br><span class="line">	int n = 1;</span><br><span class="line">	while !(n&gt;y) &#123;</span><br><span class="line">		sum += x;</span><br><span class="line">		x ++;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  As is discussed before, it's pseudo VM code is as below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mult(x,y)</span><br><span class="line">	push 0</span><br><span class="line">	pop sum</span><br><span class="line">	push 1</span><br><span class="line">	pop n</span><br><span class="line">label LOOP</span><br><span class="line">	push n</span><br><span class="line">	push y</span><br><span class="line">	gt</span><br><span class="line">	if-goto ENDLOOP</span><br><span class="line">	push sum</span><br><span class="line">	push x</span><br><span class="line">	add</span><br><span class="line">	pop sum</span><br><span class="line">	push n</span><br><span class="line">	push 1</span><br><span class="line">	add</span><br><span class="line">	pop n</span><br><span class="line">	goto LOOP</span><br><span class="line">label ENDLOOP</span><br><span class="line">	push sum</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>
<p>  In fact, it can be translated into this VM code:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mult 2</span><br><span class="line">	push constant 0 //sum = 0</span><br><span class="line">	pop local 0</span><br><span class="line">	push constant 1 //n = 1</span><br><span class="line">	pop local 1</span><br><span class="line">label LOOP</span><br><span class="line">	push local 1 //if clause</span><br><span class="line">	push argument 1</span><br><span class="line">	gt</span><br><span class="line">	if-goto ENDLOOP</span><br><span class="line">	push local 0 // sum += x</span><br><span class="line">	push argument 0</span><br><span class="line">	add</span><br><span class="line">	pop local 0</span><br><span class="line">	pop local 1 // n ++</span><br><span class="line">	push constant 1</span><br><span class="line">	add</span><br><span class="line">	pop local 1</span><br><span class="line">	goto LOOP</span><br><span class="line">label ENDLOOP</span><br><span class="line">	push local 0 // return sum</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>
<p>  Let's discuss the implementation in detail:</p>
<ol type="1">
<li><p><em>Function declaration</em>:</p>
<ul>
<li><code>Function</code>: function declaration.</li>
<li><code>mult</code>: the name of the function.</li>
<li><code>2</code>: use 2 <em>local variables</em> in the function.</li>
</ul></li>
<li><p><em>Function body</em>:</p>
<ul>
<li>branching.</li>
<li>the variable declared within the body should be stored in
<code>local</code>.</li>
<li>the assignment of variables can be done through
<code>push constant</code> and <code>pop local</code>.</li>
</ul></li>
<li><p><em>Return value</em></p>
<ul>
<li><code>push</code> the to-return value in the stack.</li>
<li><code>return</code> statement at the end of program.</li>
</ul></li>
</ol>
<h3><span id="3function-execution">3.Function execution</span></h3>
<p>  We can execute a function in a <code>Main</code> function:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function main 0</span><br><span class="line">	push constant 3</span><br><span class="line">	push constant 5</span><br><span class="line">	push constant 8</span><br><span class="line">	call mult 2</span><br><span class="line">	add </span><br><span class="line">	return </span><br></pre></td></tr></table></figure></p>
<ul>
<li>the <code>2</code> next to <code>mult</code> indicates that
<strong>the funtion takes in 2 arguments</strong>.</li>
<li>the whole process can be described through these diagrams:</li>
</ul>
<p><img src="/2024/04/10/7-7-%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1/image.png"></p>
<p><img src="/2024/04/10/7-7-%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1/image-1.png"></p>
<p><img src="/2024/04/10/7-7-%E5%87%BD%E6%95%B0%E6%8A%BD%E8%B1%A1/image-2.png"></p>
<p>  for each function <code>call</code> during run-time, the
implementation of the <code>call</code> command should :</p>
<ul>
<li><p><strong>Pass parameters</strong> from the calling function to the
called function;</p></li>
<li><p><strong>Determine the return address</strong> within the caller's
code;</p></li>
<li><p><strong>Save the caller's return address, stack and memory
segments</strong>;</p>
<ul>
<li>so that when we return to the <code>main</code>, we will be able to
<strong>recreate the private world of <code>main</code></strong>.</li>
</ul></li>
<li><p>Jump to <strong>execute the called fiunction</strong>:</p></li>
</ul>
<p>  And for each function <code>return</code> during run-time, the
impletation has to:</p>
<ul>
<li><p>Return to the caller <em>the value computed by the called
function</em>;</p>
<ul>
<li>The implementation knows that the topmost value on the stack must be
the return value, so it returns the value.</li>
</ul></li>
<li><p><strong>Recycle the memory resources</strong> used by the called
funetion;</p></li>
<li><p><strong>Reinstate the caller's stack and memory
segments</strong>;</p></li>
<li><p>Jump to the <strong>return address in the caller's
code</strong>.</p></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.6.分支</title>
    <url>/2024/04/10/7-7-%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<h1><span id="76branching"><span class="math inline">\(7.6.\)</span>Branching</span></h1>
<h3><span id="1branching-implementation">1.Branching implementation</span></h3>
<p>  Take the following program as example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//return x * y</span><br><span class="line">int mult (int x, int y) &#123;</span><br><span class="line">	int sum = 0;</span><br><span class="line">	int n = 1;</span><br><span class="line"></span><br><span class="line">	while !(n&gt;y) &#123;</span><br><span class="line">		sum += x;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  This program can be translated into pseudo VM code as below:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mult(x,y)</span><br><span class="line">	push 0</span><br><span class="line">	pop sum</span><br><span class="line">	push 1</span><br><span class="line">	pop n</span><br><span class="line">label LOOP</span><br><span class="line">	push n</span><br><span class="line">	push y</span><br><span class="line">	gt</span><br><span class="line">	if-goto ENDLOOP</span><br><span class="line">	push sum</span><br><span class="line">	push x</span><br><span class="line">	add</span><br><span class="line">	pop sum</span><br><span class="line">	push n</span><br><span class="line">	push 1</span><br><span class="line">	add</span><br><span class="line">	pop n</span><br><span class="line">	goto LOOP</span><br><span class="line">label ENDLOOP</span><br><span class="line">	push sum</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>
<p>  Notice that we have three new symbols: <code>label</code>,
<code>if-goto</code>, <code>goto</code>:</p>
<ul>
<li><code>label LABEL</code> declare the label.</li>
<li><code>if-goto LABEL</code>: if the statement is true, then jump to
<code>LABEL</code>.</li>
<li><code>goto LABEL</code>: jump to <code>LABEL</code> with no
condition.</li>
</ul>
<p>  With these three statement, we can translate the branching
expression into VM code.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.8.函数实现前瞻</title>
    <url>/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/</url>
    <content><![CDATA[<h1><span id="78function-impletation-preview"><span class="math inline">\(7.8.\)</span>Function Impletation Preview</span></h1>
<h3><span id="1program-execution">1.Program execution</span></h3>
<ul>
<li><p>When a function enters its execution, we need to create a
<em>state</em> for this function.</p>
<ul>
<li>Give it an <em>empty working stack</em>, its <em>memory
segment</em>.</li>
</ul></li>
<li><p>The working stack and some of the segments should be:</p>
<ul>
<li>Created <strong>when the function starts running</strong>.</li>
<li><strong>Maintained as long as the function is
executing</strong>.</li>
<li><strong>Recycled</strong> when the function retums.</li>
</ul></li>
<li><p>When we call a function, we will have two states: the state of
<em>caller</em> and the state of <em>callee</em>. Once the callee starts
running, <strong>the state of the caller has to be saved
somewhere</strong>. And when the callee terminates, we can
<strong>reinstate the caller state and continue its
execution</strong>.</p></li>
</ul>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image.png"></p>
<h3><span id="2function-call-and-return">2.Function call and return</span></h3>
<p>  However, a <em>calling chain</em> may be several functions deep,
and how can we maintain all the states of these functions?</p>
<p>  To deal with this, we can use the <em>FILO</em> (first in last out)
pattern. The only function to be return is the function which is
currently running, and which is also <strong>the end of the calling
chain</strong>. Once this function returns, the calling chain shortens,
so on and so forth.</p>
<p>  This pattern is similiar to <em>stack</em>, this implies that we
may use a stack in order to save and retrieve all these function
states.</p>
<p>  Take this simple function as example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mult(17, 212)</span><br></pre></td></tr></table></figure>
<p>  In the view of the caller, the effect of the procedure is that
<strong>the function's arguements has been replaced with the function
value</strong>:</p>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image-1.png"></p>
<p> And the details are as follows:</p>
<ul>
<li><p>We push some values in the stack, and nothing happens. And then
we <code>call foo nArgs</code>.</p></li>
<li><p>By the information <code>nArgs</code>, we know where to
<strong>set <code>arg</code> pointer</strong>.</p>
<ul>
<li>From now on, we know what's above the <code>arg</code> is
<strong>the working stack of the caller</strong>, and what's below the
<code>arg</code> are <strong>the arguments to be use by
callee</strong>.</li>
</ul></li>
<li><p>Before we jump to the called function, we have to save the state
of the caller:</p>
<ul>
<li>The working stack is safe, it is already on the stack, so we can
leave it alone.</li>
<li>We have to save the <em>segment</em> and the <em>return
address</em>. Taken together, we call these thing <em>frame</em>.</li>
<li>The VM implementation simply <strong>push these memory segments into
stack</strong>. In this way we save the frame, and will be able to
return to them later on.</li>
</ul></li>
</ul>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image-2.png"></p>
<ul>
<li>Jump to <strong>execute foo</strong>.</li>
</ul>
<p>  After the called function is entered, it:</p>
<ul>
<li><p>Create a <em>local segment</em>.</p></li>
<li><p>Having known that we need n variables, we need to
<strong>initialize them to 0</strong></p>
<ul>
<li>From now on, we can refer to these values as <code>local 0</code>,
<code>local 1</code> and so on.</li>
</ul></li>
</ul>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image-3.png"></p>
<p>  Assume that the called function is running and doing its things, in
this process, it:</p>
<ul>
<li>Grow its working stack, and it now has a working stack of its
own.</li>
</ul>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image-4.png"></p>
<ul>
<li><p>When it is goint to <code>return</code> at some point, we push
the return value <strong>at the bottom of the stack</strong>.</p></li>
<li><p>We pop the topmost value, and <strong>copy it onto
<code>argument 0</code></strong> to replace the pushed arguments with
return value.</p></li>
<li><p>We <strong>restore the segment pointers of the callers</strong>,
take the saved <em>memory segments</em> to the <em>current
segments</em>.</p></li>
<li><p>Then we <strong>clear the stack of the called function</strong>,
and <strong>set the stack pointer for the caller</strong>.</p>
<ul>
<li>The stack pointer should be located after
<code>argument 0</code>.</li>
</ul></li>
<li><p>Finally, we <strong>jump to the return address</strong> in the
caller, and continue executing the caller's code.</p></li>
</ul>
<h3><span id="3global-stack">3.Global stack</span></h3>
<p>  Our previous discussion is only about the caller and callee, but
there are many other pairs of callers and callees in the calling chain,
and we have to maintain their states, too.</p>
<p>  As a result, we get a very large stack called <em>global stack</em>
containing the information of the entire program.</p>
<ul>
<li><p>We refer to some subset of the global stack <em>block</em>. It's
the world of the currently running function, and it contains:</p>
<ul>
<li><em>argument segment</em>. These are the function's arguments.</li>
<li><em>saved information that belongs to caller</em>.</li>
<li><em>local segment</em></li>
<li><em>working stack of its own</em></li>
</ul></li>
</ul>
<p><img src="/2024/04/11/7-8-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9E%BB/image-5.png"></p>
<ul>
<li>The global stack contains many more such blocks.</li>
</ul>
<p>  And there are some more observations we can make:</p>
<ul>
<li>We only have to save <code>local</code>, <code>argument</code>,
<code>this</code> and <code>that</code> segments, for the other four
parts don't belong to the world of the function.</li>
<li>We use the stack not only when executing the program, but also
executing all the behind-scene apparatus that is required to service the
program. Everything is saved on the same stack.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>7.9.函数运行模拟</title>
    <url>/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1><span id="79run-time-simulation"><span class="math inline">\(7.9.\)</span>Run-time Simulation</span></h1>
<h3><span id="1run-time-example">1.Run-time example</span></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	return factorial(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int factorial(int n) &#123;</span><br><span class="line">	if (n == 1) return 1;</span><br><span class="line">	else return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>When compiling the <code>main</code> part, we:</p>
<ul>
<li><code>push 3</code></li>
<li><code>call factorial</code></li>
<li><code>return</code></li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function main</span><br><span class="line">	push 3</span><br><span class="line">	call factorial</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Then we start to compile the function:</p>
<ul>
<li>We declare the function.</li>
<li>We evaluate the condition <code>n==1</code></li>
<li>If the conitional statement returns false, we <code>push n</code>,
and compute <code>factorial(n - 1)</code></li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function factorial(n) </span><br><span class="line">	push n</span><br><span class="line">	push 1</span><br><span class="line">	eq </span><br><span class="line">	if-goto BASECASE</span><br><span class="line">	</span><br><span class="line">	push n</span><br><span class="line">	push n</span><br><span class="line">	pusn 1</span><br><span class="line">	sub</span><br><span class="line">	call factorial</span><br><span class="line">	call mult</span><br><span class="line">	return</span><br><span class="line"></span><br><span class="line">label BASECASE</span><br><span class="line">	push 1</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>
<p>  The pseudo VM code can be translated into these VM codes:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function main 0</span><br><span class="line">	push constant 3</span><br><span class="line">	call factorial 1</span><br><span class="line">	return</span><br><span class="line"></span><br><span class="line">function factorial 0</span><br><span class="line">	push argument 0</span><br><span class="line">	push constant 1</span><br><span class="line">	eq</span><br><span class="line">	if-goto BASECASE</span><br><span class="line"></span><br><span class="line">	push argument 0</span><br><span class="line">	push argument 0</span><br><span class="line">	push constant 1</span><br><span class="line">	sub</span><br><span class="line">	call factorial 1</span><br><span class="line">	call mult 2</span><br><span class="line">	return </span><br><span class="line"></span><br><span class="line">label BASECASE</span><br><span class="line">	push constant 1</span><br><span class="line">	return</span><br></pre></td></tr></table></figure></p>
<p>  Then what happen during the runtime?</p>
<ol type="1">
<li><code>main</code> starts running, and informs that it has 0 local
variable.</li>
<li><code>main</code> pushes, so it starts with an empty stack.</li>
<li><code>push constant 3</code>, then we get a 3 on the stack.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image.png"></p>
<ol start="4" type="1">
<li><code>call factorial 1</code>, the 1 informs that 1 argument was
pushed onto the stack. So we can <strong>refer to the topmost value in
the stack as argument 0</strong>.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-1.png"></p>
<h3><span id="2callee-process">2.Callee process</span></h3>
<p>  Then we begin to deal with the <code>call</code> command.</p>
<ol type="1">
<li>We first <strong>save the frame of <code>main</code> onto the
stack</strong>. Then we jump to execute <code>factorial</code>.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-2.png"></p>
<ul>
<li>The blue dot shows the <em>return address</em> in the given code.
And this is exactly where we want to return to after
<code>factorial</code> finishes.</li>
</ul>
<ol start="2" type="1">
<li>The <code>eq</code> consumes <code>argument 0</code> and
<code>constant 1</code>, so <strong>the overall effect of the first 4
commands on the stack is <code>nil</code></strong>.</li>
<li>We <code>push argument 0</code>, <code>push argument 0</code>,
<code>push constant 1</code>, <code>sub</code>, so we are going to get 3
and 2 on the stack.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-3.png"></p>
<ol start="4" type="1">
<li><code>call factorial 1</code>, we <strong>inform the implementation
that 1 argument has been pushed onto the stack</strong>, we can refer to
it as <code>argument 0</code>.</li>
<li>We want to issue a <code>call</code> command, so the implementation
is going to <strong>save the frame of the current function</strong>, and
the return address is the green dot, we save it, too.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-4.png"></p>
<ol start="6" type="1">
<li>After several calls, we turn to <code>f(1)</code>, and the global
stack now looks like this:</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-5.png"></p>
<ol start="7" type="1">
<li>This time 1 equals 1, we jump to <code>BASECASE</code>,
<code>push constant 1</code> and do a <code>return</code>.</li>
</ol>
<p>  When the inplementation encounters the <code>return</code> command,
it:</p>
<ol type="1">
<li>Gets the return address off the stack.</li>
<li>Copy the return value. In this case, it's <code>argument 0</code>,
so we copy 1 on <code>arg0</code>.</li>
<li>After <code>return</code>, we can recycle the current frame, which
is no more relevant.</li>
</ol>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-6.png"></p>
<p>  And we do this step again and again:</p>
<p><img src="/2024/04/11/7-9-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F/image-7.png"></p>
<p>  During the process, the caller is completely oblivious of all the
drama, it takes part behind the scene.</p>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 7.VM Machine</category>
      </categories>
  </entry>
  <entry>
    <title>8.2.基于对象的编程</title>
    <url>/2024/04/13/8-2-%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1><span id="92object-based-programming"><span class="math inline">\(9.2.\)</span>Object-based Programming</span></h1>
<h3><span id="1object-oriented-programming">1.Object-oriented programming</span></h3>
<p>  When designing an abstraction, we</p>
<ol type="1">
<li><p>Consider <strong>what kind of data do we want to store
about</strong> and <strong>the objects that this class is supposed to
represent</strong>.</p>
<ul>
<li>In our case, we need to store numerator and denominator.</li>
</ul></li>
<li><p>We store these values into integer type of
<code>field</code>.</p></li>
<li><p><strong>The only way to access field values from outside the
class is through <em>accessor</em> methods</strong>, so we create
accessors to facilitate access.</p></li>
</ol>
<p><img src="/2024/04/13/8-2-%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/image.png"></p>
<ol start="4" type="1">
<li><p>Then we write a <em>constructor</em> to create new objects. We
create the object and <strong>return it to the base
address</strong>.</p>
<ul>
<li><p><code>this</code> is a standard reference to the current object.
It is actually <strong>the base address of the current object in the
host RAM</strong>.</p></li>
<li><p>One of the rules of the game is that a Jack constructor must</p>
<ul>
<li>return the <em>base address</em>.</li>
<li>return <em>an object of the type of the surrounding class</em> or
<em>the class to which this constructor belongs</em>.</li>
<li>In Jack, every subroutine must <strong>always terminate with
<code>return</code> command</strong>.</li>
</ul></li>
</ul></li>
<li><p>We create several methods as we wish, this is quite simple so we
skip this part.</p></li>
<li><p>We create <code>dispose</code> method:</p>
<ul>
<li>The method is implemented using a call to the host operation system.
We call the OS routine <code>deAlloc</code>, which takes an address in
memory and disposes the memory block that begins in this address.</li>
<li>This is important to Jack, because Jack has no garbage collection
services, so it's up to the programmer to do this.</li>
</ul></li>
</ol>
<h3><span id="2object-representation">2.Object representation</span></h3>
<p><img src="/2024/04/13/8-2-%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/image-1.png"></p>
<p>  In client's view:</p>
<ul>
<li>Each fraction is represented by a block that includes all the field
values of the current object.</li>
<li>We have a reference to each of these blocks, which is <strong>the
name of the variable</strong>.</li>
</ul>
<p>  In the host RAM:</p>
<ul>
<li>Some area of it <strong>is designated to represent the the stack of
the currently running application</strong>.</li>
<li>The <code>stack</code> is used to <strong>store
variables</strong>.</li>
<li>We have the <code>heap</code> where we <strong>represent objects and
arrays</strong>.</li>
</ul>
<p> We see that we have a variable <code>a</code> which contains the
number 15087. If we <strong>treat this variable as a pointer and look up
this address in the RAM</strong>, we see that the number after the 2 is
3. This two numbers comprise the memory block that represents our first
object.</p>
<p>  How does this representation is established? The secret is that:
when the compiler is going to compile your constructor, it would</p>
<ol type="1">
<li><strong>Inject some calls to the operating system</strong>.</li>
<li><strong>These calls are going to find available memory and allocate
it to the object that was just constructed</strong>.</li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 8.High Level Language</category>
      </categories>
  </entry>
  <entry>
    <title>8.3.列表处理</title>
    <url>/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1><span id="83listprocessing"><span class="math inline">\(8.3.\)</span>List
Processing</span></h1>
<h3><span id="1list-processing">1.List processing</span></h3>
<h4><span id="acreation">  $a.Creation</span></h4>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image.png"></p>
<p>  The client process is described as below:</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-1.png"></p>
<ol type="1">
<li>We create a V pointer. We will get the variable containing 0,
because all local variables are initialized to 0.</li>
<li>We invoke the list constructor, and the list constructor is going to
<strong>come back with a block of memory that represents the number 5
and null</strong>.</li>
<li>V is going to <strong>point to the base address</strong> of the
object that was returned by the constructor.</li>
<li>The previous version of V is no longer relevant, and the next
command will do exactly the same.</li>
</ol>
<h4><span id="bsequential-access">  <span class="math inline">\(b.\)</span>Sequential access</span></h4>
<p>  We will use the <code>print</code> method to illustrate the
sequential process:</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-2.png"></p>
<blockquote>
<p>In Object-based Programming, when we call a method on an object, we
are implicitily <strong>passing the object as a parameter to this
method</strong>.</p>
</blockquote>
<p>  In the constructor, we do these things:</p>
<ol type="1">
<li><p>We create <code>current</code>, it's an identifier that exist
outside the world of list. We use a special variable called
<code>this</code> which stands for the current object.</p>
<ul>
<li><code>this</code> is the point from which we are going to
<strong>refer to the object that was passed with</strong>.</li>
</ul></li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-3.png"></p>
<ol start="2" type="1">
<li>The entry point of the list is <code>this</code>, and we set
<code>current</code> to <code>this</code>, then we get two pointers
referring to the head of the list.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-4.png"></p>
<ol start="3" type="1">
<li>Now we enter the loop, we print the <code>data</code> and move
<code>current</code> to <code>next</code>.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-5.png"></p>
<ol start="4" type="1">
<li>At last we <code>return</code>, <code>current</code> no longer
exists and <code>this</code> is reinstated and points to the list as
before.</li>
</ol>
<p>  When the client want to create a list:</p>
<ol type="1">
<li>It all starts by creating a <code>V</code> pointer. We <strong>get
the variable containing value 0</strong> because all local variables are
initialized to 0.</li>
</ol>
<p>  Then we call the constructor, and the list constructor is going to
come back with a block of memory that represents the
<code>(5, null)</code>.</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-6.png"></p>
<ol start="2" type="1">
<li>Once the <code>List.new</code> is called, the previous vesion of
<code>V</code> is no longer relevant. The rest steps are trival.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-7.png"></p>
<h4><span id="crecursive-access">  <span class="math inline">\(c.\)</span>Recursive access</span></h4>
<p>  Let's take the <code>dispose</code> method as an example:</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-8.png"></p>
<ol type="1">
<li>As usual, we first call a variable <code>V</code>. The
<code>dispose</code> method doesn't know what <code>V</code> is, so the
variable <code>this</code> was passed to <code>dispose</code>.</li>
<li>The <code>next</code> isn't null, so we go to the recursive call.
The <code>this</code> now points at the tail of the list.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-9.png"></p>
<ol start="3" type="1">
<li>We finally meet 5, do the <code>deAlloc</code> and
<code>return</code>. Once we do the <code>return</code>, we get
completely out of the recursive method, and <strong>what used to be
called <code>this</code> goes back to be named
<code>V</code></strong>.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-10.png"></p>
<ol start="4" type="1">
<li>Now the <code>V</code> points to nothing, for we basically disposed
everything in this list.</li>
</ol>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-11.png"></p>
<p>  However, recursion is very inefficient operation and if you do this
with a big list, you will probably get a <code>StackOverflow</code>
error.</p>
<h3><span id="4list-representation">4.List representation</span></h3>
<p>  The following list:</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-12.png"></p>
<p>  is represented in the host RAM like this:</p>
<p><img src="/2024/04/13/8-3-%E5%88%97%E8%A1%A8%E5%A4%84%E7%90%86/image-13.png"></p>
<p>  Then who makes these work?</p>
<ul>
<li>High-level: the constructor</li>
<li>Low-level: when compiling the constructor, <strong>the compiler
plants calls to OS routines that find, and allocate, available memory
space for the new object</strong>.</li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 8.High Level Language</category>
      </categories>
  </entry>
  <entry>
    <title>8.2.渐进分析介绍</title>
    <url>/2024/05/31/8.2.Asymptotics%20I/</url>
    <content><![CDATA[<h1><span id="82渐进分析介绍"><span class="math inline">\(8.2\)</span>
渐进分析介绍</span></h1>
<h3><span id="1简化的分析流程">1.简化的分析流程</span></h3>
<blockquote>
<p>We can do the following steps to simplify our analysis: * Only
consider the worst case. * Pick a representative operation (aka: cost
model) * Ignore lower order terms * Ignore multiplicative constants.</p>
</blockquote>
<h3><span id="2big-theta">2.<span class="math inline">\(Big-Theta\)</span></span></h3>
<p>  当对于任一比<span class="math inline">\(N_0\)</span>大的<span class="math inline">\(N\)</span>，存在<span class="math inline">\(k_1\)</span>、<span class="math inline">\(k_2\)</span>使得<span class="math inline">\(k_1·f(N)\leq R(N)\leq
k_2·f(N)\)</span>，那么：<span class="math inline">\(R(N)\in
\Theta(f(N))\)</span>。</p>
<p>  我们可以用<span class="math inline">\(\Theta\)</span>来衡量程序的增长阶数，通过确定增长函数的上界和下界，我们相当于“确定”了增长函数。</p>
<h3><span id="3big-o">3.<span class="math inline">\(Big-O\)</span></span></h3>
<p>  <span class="math inline">\(O\)</span>可以看作是增长函数的“不等关系”，即“大于等于”。例如，我们可以说<span class="math inline">\(R(N)\in O(f(n^2))\)</span>。</p>
<p>  一般地，如果对于任一比<span class="math inline">\(N_0\)</span>大的<span class="math inline">\(N\)</span>，存在<span class="math inline">\(k_1\)</span>使得<span class="math inline">\(R(N)\leq k_1·f(N)\)</span>，有：<span class="math inline">\(R(n)\in O(f(n))\)</span>。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>8.Effecient Programming</category>
      </categories>
  </entry>
  <entry>
    <title>8.4.摊还分析</title>
    <url>/2024/05/31/8.4.Omega,Amortized%20Analysis/</url>
    <content><![CDATA[<h1><span id="84摊还分析"><span class="math inline">\(8.4\)</span>摊还分析</span></h1>
<h3><span id="1big-omega">1.<span class="math inline">\(Big-Omega\)</span></span></h3>
<p>  与<span class="math inline">\(O\)</span>相同，<span class="math inline">\(\Omega\)</span>描述的也是不等关系：如果对于任一比<span class="math inline">\(N_0\)</span>大的<span class="math inline">\(N\)</span>，存在<span class="math inline">\(k_1\)</span>使得<span class="math inline">\(R(N)\geq k_1·f(N)\)</span>，有：<span class="math inline">\(R(n)\in \Omega(f(n))\)</span>。</p>
<p>  关于<span class="math inline">\(\Omega\)</span>有以下两个结论：</p>
<ul>
<li><span class="math inline">\(R(n)=O(f(n)),R(n)=\Omega(f(n))\Rightarrow
R(n)=\Theta(f(n))\)</span>。</li>
<li>它用于分析算法的基本复杂度。例如，对于重复查找问题(<span class="math inline">\(duplicate-finding\)</span>)，有<span class="math inline">\(R(n)=\Omega(n)\)</span>，这说明该问题的时间复杂度最小不得超过<span class="math inline">\(n\)</span>(因为每个元素至少要遍历一次)。</li>
</ul>
<p><img src="/2024/05/31/8.4.Omega,Amortized%20Analysis/image.png"></p>
<h3><span id="2摊还分析">2.摊还分析</span></h3>
<h4><span id="a摊还分析的引入">  <span class="math inline">\(a.\)</span>摊还分析的引入</span></h4>
<p>  考虑下面的问题：</p>
<p>  <span class="math inline">\(e.g.\)</span>There are two choices to
feed Grigometh:</p>
<ul>
<li><p>Choice 1: Every day, Grigometh eats 3 bushels of hay from your
urn.</p></li>
<li><p>Choice 2:Grigometh eats exponentially more hay over time, but
comes exponentially less frequently. Specifically:</p>
<ul>
<li>On day 1, he eats 1 bushel of hay (total 1)</li>
<li>On day 2, he eats 2 additional bushels of hay (total 3)</li>
<li>On day 4, he eats 4 additional bushels of hay (total 7)</li>
<li>On day 8, he eats 8 additional bushels of hay (total 15)</li>
</ul></li>
</ul>
<p>  选择<span class="math inline">\(1\)</span>每次只用放置常数个干草，然而事实上，选择<span class="math inline">\(2\)</span>需要的干草数量更少，因为：</p>
<ul>
<li>On day 1, the average hay per day is 1.</li>
<li>On day 2, the average hay per day is 1.5.</li>
<li>On day 3, the average hay per day is 1.75.</li>
<li>On day 4, the average hay per day is 1.875.</li>
</ul>
<p>  这里我们采用的方法是将所有天数干草的总和“均摊”到每一天。可以看到，选择<span class="math inline">\(2\)</span>的每日干草消耗量实际上是常数。我们将选择<span class="math inline">\(2\)</span>的情况称为均摊常数。</p>
<h4><span id="b摊还分析的流程">  <span class="math inline">\(b.\)</span>摊还分析的流程</span></h4>
<p>  更为严谨的摊还分析流程如下：</p>
<ol type="1">
<li>选择一个耗费模型(<span class="math inline">\(cost\;model\)</span>)。</li>
<li>计算第<span class="math inline">\(i\)</span>次操作后的平均耗费。</li>
<li>证明平均耗费以常数为边界(<span class="math inline">\(bound\)</span>)。</li>
</ol>
<p>  以我们的数组扩容为例，对于数组扩容，我们每次需要执行的操作如下：</p>
<ul>
<li>x.add(0) performs 1 write operation. No resizing. Total: 1
operation</li>
<li>x.add(1) resizes and copies the existing array (1 read, 1 write),
and then writes the new element. Total: 3 operations</li>
<li>x.add(2) resizes and copies the existing array (2 reads, 2 writes),
and then writes the new element. Total: 5 operations</li>
<li>x.add(3) does not resize, and only writes the new element. Total: 1
operations</li>
<li>x.add(4) resizes and copies the existing array (4 reads, 4 writes),
and then writes the new element. Total: 9 operations</li>
</ul>
<p>  我们可以列出如下的表格：</p>
<p><img src="/2024/05/31/8.4.Omega,Amortized%20Analysis/image-1.png"></p>
<p>  我们接着引入“势能”(<span class="math inline">\(potential\)</span>)的概念。对于每个操作<span class="math inline">\(i\)</span>，令<span class="math inline">\(c_i\)</span>为该操作的真实时间耗费，令<span class="math inline">\(a_i\)</span>为任一摊还时间消耗。对于常数时间消耗，<span class="math inline">\(a_i\)</span>也必须是常数。</p>
<p>  我们令<span class="math inline">\(\Phi_i\)</span>为操作<span class="math inline">\(i\)</span>的势能，用于表示摊还消耗和真实消耗间的累积差距(<span class="math inline">\(difference\)</span>)，则：<span class="math inline">\(\Phi_i=\Phi_{i-1}+a_i-c_i\)</span>。</p>
<p>  <span class="math inline">\(a_i\)</span>可以是任一我们选择的数。如果对于我们选择的<span class="math inline">\(a_i\)</span>，<span class="math inline">\(\Phi_i\)</span>永远是非负的，那么我们预测的摊还消耗就是实际消耗的上界。如果<span class="math inline">\(a_i\)</span>为一个永远不变的常数，那么实际消耗就是以常数时间为上界，这即说明该函数的平均时间消耗为常数！</p>
<p>  对于数组扩容，可以列出以下表格：</p>
<p><img src="/2024/05/31/8.4.Omega,Amortized%20Analysis/image-2.png"></p>
<p>  可以看出，势能一直是非负的。这样，我们就可以宣称：数组扩容的操作的摊还时间是常数。</p>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>8.Effecient Programming</category>
      </categories>
  </entry>
  <entry>
    <title>9.2.词法分析</title>
    <url>/2024/04/15/9-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1><span id="92lexical-analysis"><span class="math inline">\(9.2.\)</span>Lexical Analysis</span></h1>
<h3><span id="1-tokenizing">1. Tokenizing</span></h3>
<p>  In the previous unit, we observed that the syntax analyzer consist
of two modules: a <em>tokenizer</em> and a <em>parser</em>:</p>
<p><img src="/2024/04/15/9-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image.png"></p>
<p>  And the tokenizer is an application of a more general area of
theory known as <em>lexical analysis</em>. Here's an example of
tokenizing in action:</p>
<p><img src="/2024/04/15/9-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-1.png"></p>
<ul>
<li><p>As far as <em>lexical analysis</em> is concerned, the input is
nothing more than <strong>a stream of characters</strong>.</p></li>
<li><p><em>Tokenizing</em> refers to <strong>grouping the primitive
stream of characters into a stream of meaningful tokens</strong>. It
provides a very simple yet important preliminary processing of the
file.</p></li>
<li><p>A <em>token</em> is <strong>a string of characters that has a
meaning</strong>.</p>
<ul>
<li>Different programming languages have different definitions of token.
For example, <code>x++</code> in C makes a lot of sense, but not in
Jack, for it doesn't have an <code>++</code> operation.</li>
</ul></li>
</ul>
<p>  Once we come up with these stream of tokens, we can <strong>hand it
over to the compiler and completely forget the original input
file</strong>.</p>
<h3><span id="2jack-tokenizer">2.Jack tokenizer</span></h3>
<p>  In Jack, we have 5 kinds of tokens:</p>
<p><img src="/2024/04/15/9-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-2.png"></p>
<p>  And our tokenizer will provide these useful service:</p>
<ol type="1">
<li><p>Handle the compiler's input: It allow us to view the input as a
stream of tokens.</p></li>
<li><p>Allow advancing the input: It allow us to know:</p>
<ul>
<li><strong>If there are more tokens to process</strong>.</li>
<li><strong>What the next token is</strong>.</li>
<li><strong>The value, type of this token</strong>.</li>
</ul></li>
<li><p>Supply the value, type of the current token.</p></li>
</ol>
<p>  Here's an example of a program that use these services:</p>
<p><img src="/2024/04/15/9-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-3.png"></p>
<p>  The <code>TokenizerTest</code> is a program that construct the
tokenizer object. Here's what it does:</p>
<ul>
<li>It goes through the input, and for every token, it <strong>lists the
token to be out of file</strong>.</li>
<li>In the first line, <code>if</code> is surrounded by two
<em>tags</em>, it <strong>describe the type of the token</strong>.</li>
</ul>
<p>  And to conduct these functionalities, we can write this pseudo
code: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tknzr = new JackTokenizer(&quot;Prog.jack&quot;)</span><br><span class="line">tknzr.advance();</span><br><span class="line">while tknzr.hasMoreTokens() &#123;</span><br><span class="line">	tokenclassification=  current token classification</span><br><span class="line">	print &quot;&lt;&quot; + tokenclassification + &quot;&gt;&quot;</span><br><span class="line">	print the current token value</span><br><span class="line">	print &quot;&lt;/&quot; + tokenclassification + &quot;&gt;&quot;</span><br><span class="line">	print newLine</span><br><span class="line">	tknzr.advance();</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li><p>We get the first token, and it becomes the current
token.</p></li>
<li><p>We enter a loop as long as we have more tokens to
process.</p></li>
<li><p>In each line of the program, we have to <strong>output the
classification of the token</strong>, and we have to <strong>do it
twice</strong>.</p></li>
<li><p>We:</p>
<ol type="1">
<li>Print the <strong>opening tag</strong>, then</li>
<li>Print the <strong>value of of the current token</strong>,</li>
<li>Print the <strong>token itself</strong>,</li>
<li>At last print <strong>end tag with token
classification</strong>.</li>
</ol></li>
<li><p>We print a newline, and <code>advance()</code> to get the next
token from the tokenizer, until we consume all the tokens from the input
file.</p></li>
</ol>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 9.Syntax Analyze</category>
      </categories>
  </entry>
  <entry>
    <title>9.9.分析器实现笔记</title>
    <url>/2024/04/19/9-9-%E5%88%86%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1><span id="99分析器实现笔记"><span class="math inline">\(9.9.\)</span>分析器实现笔记</span></h1>
<h3><span id="1分词器">1.分词器</span></h3>
<p>  实现分词器，容易想到先按照token进行分类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (Character.isDigit(ch))</span><br><span class="line"><span class="keyword">if</span> (isSymbol(ch))</span><br><span class="line"><span class="keyword">for</span> (String keywordName : keyword)</span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure>
<p>  但是，有时关键词会混杂在标识符中，导致分词错误。此时我们在处理完关键词后，可以引入一些<strong>语法模式</strong>，对一些特例<strong>优先处理</strong>，以避免意外情况的出现：</p>
<ol type="1">
<li>类的定义：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (keywordName.equals(<span class="string">&quot;class&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;&#123;&quot;</span>));</span><br><span class="line">    currentClass = classname;</span><br><span class="line">    writer.write(identifierVal(classname));</span><br><span class="line">    writer.newLine();</span><br><span class="line">    token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">    tokenLine.add(identifierVal(classname));</span><br><span class="line">    stringCollection.add(classname);</span><br><span class="line">    line = line.substring(classname.length());</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>变量的声明：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isVarDec(keywordName)) &#123;</span><br><span class="line">    <span class="comment">// The first is type declaration</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (String s : type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line.indexOf(s) == <span class="number">0</span>) &#123;</span><br><span class="line">            tag = <span class="literal">true</span>;</span><br><span class="line">            writer.write(keywordVal(s));</span><br><span class="line">            writer.newLine();</span><br><span class="line">            token.add(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            tokenLine.add(keywordVal(s));</span><br><span class="line">            stringCollection.add(s);</span><br><span class="line">            line = line.substring(s.length());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : className) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.indexOf(s) == <span class="number">0</span>) &#123;</span><br><span class="line">                writer.write(identifierVal(s));</span><br><span class="line">                writer.newLine();</span><br><span class="line">                token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">                tokenLine.add(identifierVal(s));</span><br><span class="line">                stringCollection.add(s);</span><br><span class="line">                line = line.substring(s.length());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then comes the varName</span></span><br><span class="line">    String varName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line.contains(<span class="string">&quot;,&quot;</span>) &amp;&amp; line.indexOf(<span class="string">&quot;,&quot;</span>) &lt; line.indexOf(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">        varName = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        writer.write(identifierVal(varName));</span><br><span class="line">        writer.newLine();</span><br><span class="line">        token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">        tokenLine.add(identifierVal(varName));</span><br><span class="line">        stringCollection.add(varName);</span><br><span class="line">        line = line.substring(varName.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need to consider if there exists a &#x27;,&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> (line.charAt(<span class="number">0</span>) == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">            writer.write(identifierVal(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            writer.newLine();</span><br><span class="line">            token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">            tokenLine.add(identifierVal(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            stringCollection.add(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            line = line.substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;,&quot;</span>) &amp;&amp; line.indexOf(<span class="string">&quot;,&quot;</span>) &lt; line.indexOf(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">                varName = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                varName = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            writer.write(identifierVal(varName));</span><br><span class="line">            writer.newLine();</span><br><span class="line">            token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">            tokenLine.add(identifierVal(varName));</span><br><span class="line">            stringCollection.add(varName);</span><br><span class="line">            line = line.substring(varName.length());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.write(identifierVal(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        writer.newLine();</span><br><span class="line">        token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">        tokenLine.add(identifierVal(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        stringCollection.add(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        line = line.substring(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// No &#x27;,&#x27;, just &#x27;;&#x27;</span></span><br><span class="line">        varName = line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        writer.write(identifierVal(varName));</span><br><span class="line">        writer.newLine();</span><br><span class="line">        token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">        tokenLine.add(identifierVal(varName));</span><br><span class="line">        stringCollection.add(varName);</span><br><span class="line">        line = line.substring(varName.length());</span><br><span class="line"></span><br><span class="line">        writer.write(identifierVal(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        writer.newLine();</span><br><span class="line">        token.add(<span class="string">&quot;symbol&quot;</span>);</span><br><span class="line">        tokenLine.add(identifierVal(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        stringCollection.add(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        line = line.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>函数的声明：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSubroutineDec(keywordName)) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (String s : type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line.indexOf(s) == <span class="number">0</span>) &#123;</span><br><span class="line">            tag = <span class="literal">true</span>;</span><br><span class="line">            writer.write(keywordVal(s));</span><br><span class="line">            writer.newLine();</span><br><span class="line">            token.add(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">            tokenLine.add(keywordVal(s));</span><br><span class="line">            stringCollection.add(s);</span><br><span class="line">            line = line.substring(s.length());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : className) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.indexOf(s) == <span class="number">0</span>) &#123;</span><br><span class="line">                writer.write(identifierVal(s));</span><br><span class="line">                writer.newLine();</span><br><span class="line">                token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">                tokenLine.add(identifierVal(s));</span><br><span class="line">                stringCollection.add(s);</span><br><span class="line">                line = line.substring(s.length());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">varName</span> <span class="operator">=</span> line.substring(<span class="number">0</span>, line.indexOf(<span class="string">&quot;(&quot;</span>));</span><br><span class="line">    funcCollection.add(currentClass + <span class="string">&quot;.&quot;</span> + varName);</span><br><span class="line">    writer.write(identifierVal(varName));</span><br><span class="line">    writer.newLine();</span><br><span class="line">    token.add(<span class="string">&quot;identifier&quot;</span>);</span><br><span class="line">    tokenLine.add(identifierVal(varName));</span><br><span class="line">    stringCollection.add(varName);</span><br><span class="line">    line = line.substring(varName.length());</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2分析器">2.分析器</span></h3>
<p>  在分析器中，我们使用经分词器处理过的文件来构建最终的.xml文件。由于对一个元素我们可能会生成多行代码，我们选择利用<code>ArrayList&lt;String&gt;</code>来存储每个元素产生的语句。当一个元素中包含了其他子元素时，我们<strong>在调用处理子元素的方法、得到子元素的分析代码后，加入该元素的<code>ArrayList</code>即可</strong>。这样，我们就可以通过<strong>递归</strong>调用来完成对程序的分析</p>
<p>  以<code>class</code>的分析为例，我们可以写出以下的代码框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title function_">compileClass</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; class_ = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    class_.add(<span class="string">&quot;&lt;class&gt;&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//call method recursively</span></span><br><span class="line">    class_.addAll(compileClassVar());</span><br><span class="line">    class_.addAll(compileSubroutineDec());</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    class_.add(<span class="string">&quot;&lt;/class&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> class_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 9.Syntax Analyze</category>
      </categories>
  </entry>
  <entry>
    <title>9.5.解析器逻辑</title>
    <url>/2024/04/16/9-5-%E8%A7%A3%E6%9E%90%E5%99%A8%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1><span id="95parserlogic"><span class="math inline">\(9.5.\)</span>Parser
Logic</span></h1>
<h3><span id="1parsing-logic">1.Parsing logic</span></h3>
<p>  In order to carry out parsing, we are going to build a
<code>CompilationEngine</code> class which consist of <strong>a set of
methods, one method for every non-terminal rule</strong>.</p>
<p><img src="/2024/04/16/9-5-%E8%A7%A3%E6%9E%90%E5%99%A8%E9%80%BB%E8%BE%91/image.png"></p>
<ul>
<li>The code of each <code>compilexxx</code> method follows the
right-hand side of the rule xxx</li>
<li>Each <code>compilexxx</code> method is responsible for
<strong>advancing</strong> and <strong>handling its own part of the
input</strong>.</li>
</ul>
<p>  To illustrate this, let's focus on one of these methods
<code>compileWhileStatement</code>:</p>
<p><img src="/2024/04/16/9-5-%E8%A7%A3%E6%9E%90%E5%99%A8%E9%80%BB%E8%BE%91/image-1.png"></p>
<ol type="1">
<li><p>We <strong>follow the right-hand side of the rule</strong>, and
parse the input it dictates.</p>
<ul>
<li>In <code>whileStatement</code>, it says we should expect to see the
token <code>while</code>. If we find it in the input, we record the
fact. Then the left parenthesis, and so on and so forth,</li>
<li>At some point we will get a non-terminal rule like
<code>expression</code>, then we go to next step:</li>
</ul></li>
<li><p>If the right-hand side specifies a non-terminal rule
<code>xxx</code>, we call the corresponding method
<code>compilexxx</code></p></li>
<li><p>We do this recursively untile we exhaust the input.</p></li>
</ol>
<p>  And to initialize this process, we:</p>
<ol type="1">
<li>Advance the tokenizer.</li>
<li>Call <code>compileWhileStatement</code>.</li>
</ol>
<h3><span id="2parser-design">2.Parser design</span></h3>
<p>  We also take the <code>compileWhileStatement</code> as an
example:</p>
<ol type="1">
<li>If we look at the grammar, we first see that you should see a
<code>while</code> , so we <strong>call a method
<code>eat('while')</code></strong>, which means you should expect now to
eat the <code>while</code> token.</li>
<li>We do the same thing <code>eat('(')</code>.</li>
<li>We meet a non-terminal rule <code>expression</code>, so we call
<code>compileExpression();</code></li>
<li>And so on and so forth...</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CompilationEngine &#123; </span><br><span class="line">	</span><br><span class="line">	compileWhileStatement() &#123; </span><br><span class="line">		eat(&#x27;while’);</span><br><span class="line">		eat(&#x27;(&#x27;);  </span><br><span class="line">		compileExpression(); </span><br><span class="line">		eat(&#x27;)&#x27;);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  When it comes to <code>eat</code> method:</p>
<ul>
<li>It's a private method.</li>
<li>It says <strong>you should expect to see the given string</strong>,
if not, you should <strong>throw an error</strong>.</li>
<li>Otherwise, simply <strong>advance the input</strong>.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eat(string) &#123;</span><br><span class="line">	if (currentToken &lt;&gt; string) </span><br><span class="line">		error...</span><br><span class="line">	else</span><br><span class="line">		advance...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="3some-observationabout-grammars-and-parsing">3.Some observation
about grammars and parsing</span></h3>
<ul>
<li><p><em>LL grammar</em>: It's a grammar that <strong>can be parsed by
a recursive descent algorithm parser without backtracking</strong>.</p>
<ul>
<li>When you make a decision that what you have is a <code>while</code>
statement, you don't have to kind of retract your progress and find out
a mistake.</li>
</ul></li>
<li><p><em>LL(k) parser</em>: It's an LL parser that needs to look ahead
at most k tokens before you know which rule you are dealing with.</p>
<ul>
<li>The grammar we saw so far is <em>LL1</em>, because <strong>once we
have a particular token in hand like <code>let</code>, we immediately
know which rule we have to invoke</strong>.</li>
<li>There are also things that don't belong to LL1, like English. For
example, when we meet a token word "lift", we still have no idea what we
should do with it. A verb? A noun? We have to look more tokens
downstream to know which rule to use. In this process, we may need to
backtrack and reconsider some of the rules we have to use...</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>The Elements of Computer System</category>
        <category>Module 9.Syntax Analyze</category>
      </categories>
  </entry>
  <entry>
    <title>9.2.快速查找</title>
    <url>/2024/05/31/9.2.Quick%20Find/</url>
    <content><![CDATA[<h1><span id="92快速查找"><span class="math inline">\(9.2\)</span>快速查找</span></h1>
<h3><span id="1并查集的构造">1.并查集的构造</span></h3>
<p>  直观上，我们可以通过<span class="math inline">\(ListOfSet\)</span>来表示并查集，例如<code>[&#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;, &#123;4&#125;, &#123;5&#125;, &#123;6&#125;]</code>。但是，这种形式的并查集难以合并。</p>
<p>  我们考虑只用一个数组来实现并查集的合并操作，该数组按如下方式构造：</p>
<ul>
<li>数组的下标值代表元素本身。</li>
<li>数组下标对应的值代表元素所属集合的序号。</li>
</ul>
<p>  例如，我们可以如下表示<code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code>：</p>
<p><img src="/2024/05/31/9.2.Quick%20Find/image.png"></p>
<p>  集合的序号并不重要，只需要确保相同的集合的值相同即可。</p>
<h3><span id="2connect操作">2.<code>connect</code>操作</span></h3>
<p>  有了上面的构造，我们可以通过更改数组对应下标的值来实现合并。例如，假如我们想将<span class="math inline">\(2\)</span>与<span class="math inline">\(3\)</span>合并：</p>
<p><img src="/2024/05/31/9.2.Quick%20Find/image-1.png"></p>
<h3><span id="3isconnected操作">3.<code>isConnected</code>操作</span></h3>
<p>  为了检查<code>isConnected(x, y)</code>，我们只需要检查它们对应集合的序号是否相等即可。这只需要常数时间。</p>
<h3><span id="4总结与代码实现">4.总结与代码实现</span></h3>
<p><img src="/2024/05/31/9.2.Quick%20Find/image-2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFindDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickFindDS</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="comment">// initialize the parent</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i += <span class="number">1</span>) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> id[p];</span><br><span class="line">        <span class="type">int</span> <span class="variable">qid</span> <span class="operator">=</span> id[q];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pid) &#123;</span><br><span class="line">                id[i] = qid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id[p] == id[q];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>9.Disjoint sets</category>
      </categories>
  </entry>
  <entry>
    <title>9.1.并查集介绍</title>
    <url>/2024/05/31/9.1.Introduction%20to%20Disjoint%20Sets/</url>
    <content><![CDATA[<h1><span id="91并查集介绍"><span class="math inline">\(9.1\)</span>并查集介绍</span></h1>
<h3><span id="1并查集的接口">1.并查集的接口</span></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="comment">/** connects two items P and Q */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** checks to see if two items are connected */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>9.Disjoint sets</category>
      </categories>
  </entry>
  <entry>
    <title>9.3.快速合并</title>
    <url>/2024/05/31/9.3.Quick%20Union/</url>
    <content><![CDATA[<h1><span id="93快速合并"><span class="math inline">\(9.3\)</span>快速合并</span></h1>
<h3><span id="1根节点的引入">1.根节点的引入</span></h3>
<p>  假如我们想让<code>connect</code>操作快一些，由于先前用<span class="math inline">\(id[x]\)</span>代指所属集合的操作仍是通过遍历序列实现的，时间复杂度为线性，我们希望用一个元素代指整个集合，这样合并操作只需要合并两个元素即可。</p>
<p>  对序列中的每个元素，我们给它分派(<span class="math inline">\(assign\)</span>)一个值，这个值是它的父亲(<span class="math inline">\(parent\)</span>)的索引；如果某个元素没有索引，那么它就是根节点，我们给它分派一个负数的值。下面的图示展示了<code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code>的对应表示：</p>
<p><img src="/2024/05/31/9.3.Quick%20Union/image-3.png"></p>
<p>  为了实现快速合并，我们引入一个辅助函数<code>find(int item)</code>，它返回某个元素对应的根节点。</p>
<h3><span id="2connectx-y">2.<code>connect(x, y)</code></span></h3>
<p>  为了合并两元素，我们找到两个元素对应的根节点，然后让其中一个根节点作为另一个的儿子(<span class="math inline">\(child\)</span>)。例如<code>connect(5, 2)</code>需要进行如下操作：</p>
<ol type="1">
<li><code>find(5)</code> <span class="math inline">\(\rightarrow
3\)</span></li>
<li><code>find(2)</code> <span class="math inline">\(\rightarrow
0\)</span></li>
<li>设置<code>parent[3] = 0</code></li>
</ol>
<p><img src="/2024/05/31/9.3.Quick%20Union/image-4.png"></p>
<h3><span id="3isconnectedx-y">3.<code>isConnected(x, y)</code></span></h3>
<p>  如果两个元素同属一个集合，那么它们的根节点应该相同。只需检查<code>find(x) == find(y)</code>即可。</p>
<h3><span id="4总结与代码实现">4.总结与代码实现</span></h3>
<p><img src="/2024/05/31/9.3.Quick%20Union/image-6.png"></p>
<p>  看起来快速合并的运行时间比快速查询长！但是<span class="math inline">\(O(n)\)</span>代表的是快速合并的上界。当我们的树比较平衡时，快速查询的时间复杂度会非常优秀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickUnionDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickUnionDS</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i += <span class="number">1</span>) &#123;</span><br><span class="line">            parent[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[p] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> find(q);</span><br><span class="line">        parent[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS61B DataStructure</category>
        <category>9.Disjoint sets</category>
      </categories>
  </entry>
</search>
