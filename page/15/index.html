<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fyerfyer.github.io.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":2,"unescape":true,"preload":false}}</script><script src="/js/config.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">


    <meta name="description" content="fyerfyer&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="fyerfyer">
<meta property="og:url" content="https://fyerfyer.github.io.com/page/15/index.html">
<meta property="og:site_name" content="fyerfyer">
<meta property="og:description" content="fyerfyer&apos;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="fyerfyer">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://fyerfyer.github.io.com/page/15/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/15/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>fyerfyer</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="&#x5207;&#x6362;&#x5BFC;&#x822A;&#x680F;" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">fyerfyer</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Hello! Nice to meet you!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="&#x641C;&#x7D22;" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>&#x9996;&#x9875;</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>&#x5173;&#x4E8E;</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>&#x5206;&#x7C7B;</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>&#x5F52;&#x6863;</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>&#x641C;&#x7D22;
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="&#x641C;&#x7D22;..." spellcheck="false" type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          &#x6587;&#x7AE0;&#x76EE;&#x5F55;
        </li>
        <li class="sidebar-nav-overview">
          &#x7AD9;&#x70B9;&#x6982;&#x89C8;
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fyerfyer" src="/images/head.png">
  <p class="site-author-name" itemprop="name">fyerfyer</p>
  <div class="site-description" itemprop="description">fyerfyer&apos;s blog</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">148</span>
          <span class="site-state-item-name">&#x65E5;&#x5FD7;</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">&#x5206;&#x7C7B;</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/fyerfyer" title="GitHub &#x2192; https://github.com/fyerfyer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/fuy60703@gmail.com" title="E-Mail &#x2192; fuy60703@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="&#x8FD4;&#x56DE;&#x9876;&#x90E8;">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang>
    <link itemprop="mainEntityOfPage" href="https://fyerfyer.github.io.com/2024/07/26/4-5-Pipelined-Y86-64-Implementations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="fyerfyer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fyerfyer">
      <meta itemprop="description" content="fyerfyer&apos;s blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | fyerfyer">
      <meta itemprop="description" content>
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/" class="post-title-link" itemprop="url">4.5.Pipelined Y86-64 Implementations</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">&#x53D1;&#x8868;&#x4E8E;</span>

      <time title="&#x521B;&#x5EFA;&#x65F6;&#x95F4;&#xFF1A;2024-07-26 19:31:22" itemprop="dateCreated datePublished" datetime="2024-07-26T19:31:22+08:00">2024-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">&#x66F4;&#x65B0;&#x4E8E;</span>
      <time title="&#x4FEE;&#x6539;&#x65F6;&#x95F4;&#xFF1A;2024-07-31 20:33:52" itemprop="dateModified" datetime="2024-07-31T20:33:52+08:00">2024-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">&#x5206;&#x7C7B;&#x4E8E;</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
        </span>
          &#xFF0C;
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP/Chapter-4-Processor-Architecture/" itemprop="url" rel="index"><span itemprop="name">Chapter 4.Processor Architecture</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="&#x672C;&#x6587;&#x5B57;&#x6570;">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">&#x672C;&#x6587;&#x5B57;&#x6570;&#xFF1A;</span>
      <span>3.6k</span>
    </span>
    <span class="post-meta-item" title="&#x9605;&#x8BFB;&#x65F6;&#x957F;">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">&#x9605;&#x8BFB;&#x65F6;&#x957F; &#x2248;</span>
      <span>13 &#x5206;&#x949F;</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="45pipelined-y86-64-implementations"><span class="math inline">\(4.5.\)</span>Pipelined Y86-64 Implementations</h1>
<h3 id="1seq-rearranging-thecomputation-stages">1.SEQ+ Rearranging the
Computation Stages</h3>
<p>&#x2003;&#x2003;We slightly rearrange the order of the five stages in SEQ so that
<strong>the PC update stage comes at the beginning of the clock
cycle</strong>, rather than at the end. We refer to this modified design
as SEQ+.</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image.png"></p>
<ul>
<li><p>The old SEQ computes the PC register based on the values of
signals computed during the current clock cycle.</p></li>
<li><p>While with SEQ+, we <strong>create state registers to hold the
signals computed during an instruction</strong>. Then as the new clock
cycle begins, <strong>the values propagate through the exact same logic
to compute the PC for the now-current instruction</strong>.</p></li>
</ul>
<blockquote>
<p>In SEQ+, there is no hardware register storing the program counter.
Instead, the PC <strong>is computed dynamically based on some state
information stored from the previous instruction</strong>.</p>
</blockquote>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-1.png"></p>
<h3 id="2inserting-pipelineregisters">2.Inserting Pipeline
Registers</h3>
<p>&#x2003;&#x2003;We first try to insert pipeline registers between the stages of
SEQ+. This kind of processor is called <em>PIPE-</em>, where the &apos;-&apos;
represents the decrement in performance. It uses the same hardware as
before, but with the pipeline registers separating the stages:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-2.png"></p>
<ul>
<li><p><em>F</em> holds a predicted value of the program
counter.</p></li>
<li><p><em>D</em> holds <strong>information about the most recently
fetched instruction</strong> for processing <strong>by the decode
stage</strong>.</p></li>
<li><p><em>E</em> holds information about <strong>the most recently
decoded instruction</strong> and <strong>the values read from the
register file</strong> for processing by the execute stage.</p></li>
<li><p><em>M</em> holds <strong>the results of the most recently
executed instruction</strong> for processing by the memory stage. It
also holds <strong>information about branch conditions and branch
targets</strong> for processing conditional jumps.</p></li>
<li><p><em>W</em> supply <strong>the computed results to the register
file</strong> for writing and <strong>the return address to the PC
selection logic</strong> when completing a <code>ret</code>
instruction.</p></li>
</ul>
<blockquote>
<p>Since normal program flow goes from top to bottom of a listing, we
preserve this ordering by having the pipeline flow go from bottom to
top.</p>
</blockquote>
<h3 id="3rearranging-and-relabelingsignals">3.Rearranging and Relabeling
Signals</h3>
<h4 id="asome-name-reference">&#x2003;&#x2003;<span class="math inline">\(a.\)</span>Some name reference</h4>
<ul>
<li><p>We use uppercase suffix to specified where data is stored. For
example, <code>D_stat</code>.</p></li>
<li><p>We use lowercase suffix to specified which stage data has been
computed. For example, <code>f_stat</code>.</p></li>
</ul>
<blockquote>
<p>The uppercase letters refer to pipeline registers, while the
lowercase letters refer to pipeline stages.</p>
</blockquote>
<h4 id="bdetails">&#x2003;&#x2003;<span class="math inline">\(b.\)</span>Details</h4>
<p>&#x2003;&#x2003;The decode stages generate <code>dstE</code> and
<code>dstM</code>:</p>
<ul>
<li><p>In SEQ+, we <strong>connect these signals directly to the address
inputs of the register file write ports</strong>.</p></li>
<li><p>With PIPE&#x2212;, these signals are directed to the register file
<strong>only once they reach</strong>.</p></li>
</ul>
<p>&#x2003;&#x2003;These are to make sure <strong>the write port address and data
inputs hold values from the same instruction</strong>.</p>
<ul>
<li><p>The &quot;Select A&quot; block generates the value <code>valA</code> for
the pipeline register E by <strong>choosing either <code>valP</code>
from pipeline register D or the value read from the A port of the
register file</strong>. This block is included to <strong>reduce the
amount of state that must be carried forward to pipeline registers E and
M</strong>.</p>
<ul>
<li>This is because only <code>call</code> instruction requires
<code>valP</code> in the memory stage, only <code>jump</code>
instruction requires <code>valP</code> in the execute stage(when the
jump isn&apos;t taken). None of these instructions requires a value read from
the register file.</li>
</ul></li>
</ul>
<h3 id="4next-pc-prediction">4.Next PC Prediction</h3>
<h4 id="abranch-prediction">&#x2003;&#x2003;<span class="math inline">\(a.\)</span>Branch prediction</h4>
<p>&#x2003;&#x2003;When we fetch a conditional branch instruction, to decide which
branch to take, we try to predict the next value of the PC.</p>
<ul>
<li><p>For conditional jumps, if we predict that a jump will be taken,
the PC will be <code>valC</code>(computed by the PC
incrementer).</p></li>
<li><p>If we predict that it won&apos;t be taken, the PC will be
<code>valP</code>(from the fetch instruction).</p></li>
</ul>
<p>&#x2003;&#x2003;There are several prediction strategies:</p>
<ol type="1">
<li><p><em>Always Taken</em>.</p></li>
<li><p><em>Never Taken</em>.</p></li>
<li><p><em>Backward Taken, Forward Not Taken</em>. That is, branches to
lower addresses than the next instruction will be taken, while those to
higher addresses will not be taken. This strategy stems from the fact
that <strong>loops are closed by backward branches and loops are
generally executed multiple times</strong>.</p></li>
</ol>
<p>&#x2003;&#x2003;We simply use &quot;Always Taken&quot; for branch prediction.</p>
<p>&#x2003;&#x2003;the block labeled &quot;Predict PC&quot; chooses either <code>valP</code> or
<code>valC</code>. This value <strong>is stored in pipeline register
F</strong> as the predicted value of the program counter.</p>
<h4 id="bret">&#x2003;&#x2003;<span class="math inline">\(b.\)</span><code>ret</code></h4>
<p>&#x2003;&#x2003;For <code>ret</code> instruction, we don&apos;t use any prediction.
Instead, we will simply <strong>hold off processing any more
instructions until the <code>ret</code> instruction passes through the
write-back stage</strong>.</p>
<h3 id="5pipeline-hazards">5.Pipeline Hazards</h3>
<p>&#x2003;&#x2003;When the dependencies referred before have the potential to cause
an erroneous computation by the pipeline, they are called
<em>hazards</em>. Hazards can be classified as either <em>data
hazards</em> or <em>control hazards</em>.</p>
<h4 id="astalling">&#x2003;&#x2003;<span class="math inline">\(a.\)</span>Stalling</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-3.png"></p>
<p>&#x2003;&#x2003;One very general technique for avoiding hazards involves stalling,
where the processor holds back one or more instructions in the pipeline
until the hazard condition no longer holds.</p>
<ul>
<li>Our processor can avoid data hazards by <strong>holding back an
instruction in the decode stage</strong> until <strong>the instructions
generating its source operands have passed through the write-back
stage</strong>.</li>
</ul>
<p>&#x2003;&#x2003;In holding back the <code>addq</code> instruction in the decode
stage, we must also <strong>hold back the <code>halt</code> instruction
following it in the fetch stage</strong>. We can do this by
<strong>keeping the program counter at a fixed value</strong>, so that
the halt instruction will be fetched repeatedly until the stall has
completed.</p>
<p>&#x2003;&#x2003;During the processing of <code>addq</code>, to perform the
stalling, we <strong>inject a <em>bubble</em></strong>, which is a
dynamically generated <code>nop</code> instruction, <strong>into the
execute stage</strong>.</p>
<h4 id="bforwarding">&#x2003;&#x2003;<span class="math inline">\(b.\)</span>Forwarding</h4>
<h5 id="iforwarding-process">&#x2003;&#x2003;<span class="math inline">\(i.\)</span>Forwarding process</h5>
<p>&#x2003;&#x2003;Rather than stalling until the write has completed, it can simply
<strong>pass the value</strong> that is about to be written to pipeline
register E <strong>as the source operand</strong>. This technique of
<strong>passing a result value directly from one pipeline stage to an
earlier one</strong> is commonly known as <em>data forwarding</em>:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-4.png"></p>
<p>&#x2003;&#x2003;For forwarding, we can <strong>pass the newly computed values from
the execute stage to the decode stage</strong>.</p>
<ul>
<li><p>The decode-stage logic <strong>detects a pending write to
register <code>%rdx</code> in the memory stage</strong>, and also that
<strong>the value being computed by the ALU in the execute stage will
later be written to register <code>%rax</code></strong>.</p></li>
<li><p>It can use the value in the memory stage(signal
<code>M_valE</code>) for operand <code>valA</code>. It can also use the
ALU output(signal <code>e_valE</code>) for operand
<code>valB</code>.</p></li>
</ul>
<p>&#x2003;&#x2003;Forwarding can also be used with values read from the memory and
destined for write port M:</p>
<ul>
<li><p>From the memory stage, we can forward <strong>the value that has
just been read from the data memory</strong>(signal
<code>m_valM</code>).</p></li>
<li><p>From the write-back stage, we can forward <strong>the pending
write to port M(signal <code>W_valM</code>)</strong>.</p></li>
</ul>
<p>&#x2003;&#x2003;This gives a total of five different forwarding
sources(<code>e_valE</code>, <code>m_valM</code>, <code>M_valE</code>,
<code>W_valM</code>, and <code>W_valE</code>) and two different
forwarding destinations (<code>valA</code> and <code>valB</code>).</p>
<p>&#x2003;&#x2003;The following figure shows the structure of PIPE that can handle
data hazards by forwarding. We can see that the values from the five
forwarding sources are fed back to the <strong>two blocks labeled
&apos;Sel+Fwd A&quot; and &quot;Fwd B&quot; in the decode stage</strong>.</p>
<ul>
<li>The block labeled &quot;Sel+Fwd A&quot; combines the role of the block labeled
&quot;Select A&quot; in PIPE with the forwarding logic.</li>
</ul>
<h5 id="iiforwarding-judgement">&#x2003;&#x2003;<span class="math inline">\(ii.\)</span>Forwarding judgement</h5>
<p>&#x2003;&#x2003;Associated with every value that will be written back to the
register file is the destination register ID. The logic can compare
these IDs with the source register IDs srcA and srcB to detect a case
for forwarding.</p>
<h4 id="cloaduse-hazards">&#x2003;&#x2003;<span class="math inline">\(c.\)</span>Load/Use hazards</h4>
<p>&#x2003;&#x2003;One class of data hazards cannot be handled purely by forwarding is
called <em>load/use hazards</em>:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-5.png"></p>
<p>&#x2003;&#x2003;The <code>addq</code> instruction requires the value of the
register in cycle 7, but <strong>it is not generated by the
<code>mrmovq</code> instruction until cycle 8. In order to &quot;forward&quot;
from the <code>mrmovq</code> to the <code>addq</code></strong>, the
forwarding logic would have to make the value go backward in time(or no
register will store our desired value)!</p>
<p>&#x2003;&#x2003;We can avoid a load/use data hazard <strong>with a combination of
stalling and forwarding</strong>:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-6.png"></p>
<p>&#x2003;&#x2003;This technique is called <em>load interlock</em>. Since only load
interlocks reduce the pipeline throughput, we can nearly achieve our
throughput goal of issuing one new instruction on every clock cycle.</p>
<h4 id="davoiding-control-hazards">&#x2003;&#x2003;<span class="math inline">\(d.\)</span>Avoiding control hazards</h4>
<p>&#x2003;&#x2003;Control hazards arise when the processor <strong>cannot reliably
determine the address of the next instruction</strong> based on the
current instruction in the fetch stage.</p>
<h5 id="iret">&#x2003;&#x2003;<span class="math inline">\(i.\)</span><code>ret</code></h5>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-7.png"></p>
<ul>
<li><p>While the <code>ret</code> instruction passes through the decode,
execute, and memory stages, the pipeline cannot do any useful
activity.</p></li>
<li><p>Once the <code>ret</code> instruction reaches the write-back
stage, the PC selection logic will <strong>set the program counter to
the return address</strong>, and therefore the fetch stage will fetch
the <code>irmovq</code> instruction at the return point(address
0x013).</p></li>
</ul>
<h5 id="iijump-instruction">&#x2003;&#x2003;<span class="math inline">\(ii\)</span>Jump instruction</h5>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-8.png"></p>
<ul>
<li><p>By the time the branch logic detects that the jump should not be
taken during cycle 4, two instructions have been fetched that should not
continue being executed.</p></li>
<li><p>Neither of these instructions has caused a change in the
programmer-visible state. So the pipeline can simply cancel (sometimes
called <em>instruction squashing</em>) the two misfetched instructions
by <strong>injecting bubbles into the decode and execute stages</strong>
on the following cycle while also fetching the instruction following the
jump instruction.</p></li>
</ul>
<h3 id="6exception-handling">6.Exception Handling</h3>
<h4 id="aseveral-exception-subleties">&#x2003;&#x2003;<span class="math inline">\(a.\)</span>Several exception subleties</h4>
<ol type="1">
<li><p>It is possible to have exceptions <strong>triggered by multiple
instructions simultaneously</strong>.</p>
<ul>
<li>For example, we could have a <code>halt</code> instruction in the
fetch stage, and the data memory could report an out-of-bounds data
address for the instruction in the memory stage.</li>
</ul></li>
<li><p>When an instruction is first fetched and begins execution, causes
an exception, and later is canceled due to a mispredicted branch. But we
want to avoid rasing the exception.</p></li>
<li><p>It&apos;s possible for an instruction following one causing an
exception to <strong>alter some part of the state before the excepting
instruction completes</strong>.</p>
<ul>
<li>Take the assembly program below as an example, The exception of
<code>pushq %rax</code> is detected in memory stage, while the
<code>addq %rax, %rax</code> has reached execute stage, and has already
cause the condition codes to be set to new values(and other
<code>stat</code>):</li>
</ul></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">irmovq $1,%rax           </span><br><span class="line">xorq %rsp,%rsp   # Set stack pointer to 0 and CC to 100</span><br><span class="line">pushq %rax       # Attempt to write to 0xfffffffffffffff8</span><br><span class="line">addq %rax,%rax   # (Should not be executed) Would set CC to 000</span><br></pre></td></tr></table></figure>
<h4 id="bhandling-exception">&#x2003;&#x2003;<span class="math inline">\(b.\)</span>Handling exception</h4>
<p>&#x2003;&#x2003;When an exception occurs in one or more stages of a pipeline,
<strong>the information is simply stored in the status fields of the
pipeline registers</strong>. The event has no effect on the flow of
instructions in the pipeline <strong>until an excepting instruction
reaches the final pipeline stage</strong>, except to <strong>disable any
updating of the programmer-visible state</strong>.</p>
<ul>
<li><p>For the first problem, we are guaranteed that the first
instruction encountering an exception will <strong>arrive first in the
write-back stage</strong>, at which point <strong>program execution can
stop</strong> and <strong>the status code in pipeline register W can be
recorded as the program status</strong>.</p></li>
<li><p>For the second problem, if some instruction is fetched but later
canceled, <strong>any exception status information about the instruction
gets canceled as well</strong>.</p></li>
<li><p>For the third problem, no instruction following one that causes
an exception can alter the programmer-visible state.</p></li>
</ul>
<h3 id="7pipe-stage-implementation">7.PIPE Stage Implementation</h3>
<h4 id="apc-selection-and-fetch-stage">&#x2003;&#x2003;<span class="math inline">\(a.\)</span>PC selection and Fetch stage</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-9.png"></p>
<ul>
<li><p>The hardware units for reading the instruction from memory and
for extracting the different instruction fields are the same as those we
considered for SEQ.</p></li>
<li><p>The PC selection logic chooses between three program counter
sources:</p>
<ul>
<li><p>For <em>mispredicted branches</em>, The value of
<code>valP</code>(indicating the address of the following instruction)
is read from pipeline register M(signal <code>M_valA</code>).</p></li>
<li><p>For <em><code>ret</code> instruction</em>, the return address is
read from pipeline register W(signal <code>W_valM</code>).</p></li>
<li><p>All other cases use <em>the predicted value of the PC</em>,
stored in pipeline register F (signal <code>F_predPC</code>)</p></li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word f_pc = [</span><br><span class="line">    # Mispredicted branch. Fetch at incremented PC</span><br><span class="line">    M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">    # Completion of RET instruction</span><br><span class="line">    W_icode == IRET : W_valM;</span><br><span class="line">    # Default: Use predicted value of PC</span><br><span class="line">    1 : F_predPC;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<ul>
<li>The PC prediction logic chooses <code>valC</code> for the fetched
instruction when <strong>it is either a call or a jump</strong>, and
<code>valP</code> otherwise:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word f_predPC = [</span><br><span class="line">    f_icode in { IJXX, ICALL } : f_valC;</span><br><span class="line">    1 : f_valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>&#x2003;&#x2003;Unlike in SEQ, we must <strong>split the computation of the
instruction status into two parts</strong>:</p>
<ul>
<li><p>In the fetch stage, we can test for a memory error <strong>due to
an out-of-range instruction address</strong>, and we can <strong>detect
an illegal instruction or a <code>halt</code>
instruction</strong>.</p></li>
<li><p>Detecting an invalid data address must <strong>be deferred to the
memory stage</strong>.</p></li>
</ul>
<h4 id="bdecode-and-write-back-stages">&#x2003;&#x2003;<span class="math inline">\(b.\)</span>Decode and Write-back stages</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-10.png"></p>
<ul>
<li><p>The register IDs supplied to the write ports come from the
write-back stage(signals <code>W_dstE</code> and <code>W_dstM</code>),
rather than from the decode stage. This is to ensure that the final
result is written back to the specified register <strong>only after the
instruction has actually completed all operations</strong>, including
memory access and execution.</p></li>
<li><p>The block labeled &quot;Sel+Fwd A&quot; serves two roles: It <strong>merges
the <code>valP</code> signal into the <code>valA</code> signal</strong>
for later stages in order to reduce the amount of state in the pipeline
register. It also <strong>implements the forwarding logic for source
operand <code>valA</code></strong>.</p></li>
<li><p><strong>Only the <code>call</code> and jump instructions need the
value of <code>valP</code> in later stages</strong>, and these
instructions do not need the value read from the A port of the register
file.</p>
<ul>
<li>This selection is controlled by the <code>icode</code> signal for
this stage. When <strong>signal <code>D_icode</code> matches the
instruction code for either <code>call</code> or
<code>jXX</code></strong>, this block should <strong>select
<code>D_valP</code> as it output</strong>.</li>
</ul></li>
</ul>
<p>&#x2003;&#x2003;there are five different forwarding sources, each with a data word
and a destination register ID:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-11.png"></p>
<p>&#x2003;&#x2003;If <strong>none of the forwarding conditions hold</strong>, the
block should select <code>d_rvalA</code>, the value read from register
port A, as its output.</p>
<p>&#x2003;&#x2003;The overall HCL description for the <code>d_valA</code> is as
below:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">word d_valA = [</span><br><span class="line">    D_icode in { ICALL, IJXX } : D_valP; # Use incremented PC</span><br><span class="line">    d_srcA == e_dstE : e_valE; # Forward valE from execute</span><br><span class="line">    d_srcA == M_dstM : m_valM; # Forward valM from memory</span><br><span class="line">    d_srcA == M_dstE : M_valE; # Forward valE from memory</span><br><span class="line">    d_srcA == W_dstM : W_valM; # Forward valM from write back</span><br><span class="line">    d_srcA == W_dstE : W_valE; # Forward valE from write back</span><br><span class="line">    1 : d_rvalA; # Use value read from register file</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>&#x2003;&#x2003;The priority given to the five forwarding sources in the above HCL
code is very important. This priority is determined in the HCL code
<strong>by the order in which the five destination register IDs are
tested</strong>.</p>
<blockquote>
<p>To imitate this behavior, our pipelined implementation should always
give priority to the forwarding source <strong>in the earliest pipeline
stage</strong>, since it holds the latest instruction in the program
sequence setting the register.</p>
</blockquote>
<p>&#x2003;&#x2003;In previous part, we know that the overall processor status
<code>Stat</code> is computed by a block based on the status value:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-12.png"></p>
<p>&#x2003;&#x2003;Since pipeline register W holds the state of the most recently
completed instruction, it is natural to <strong>use this value as an
indication of the overall processor status</strong>. The only special
case to consider is when <strong>there is a bubble in the write-back
stage</strong>. This is part of normal operation, and so we want
<strong>the status code to be AOK for this case as well</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word Stat = [</span><br><span class="line">    W_stat == SBUB : SAOK;</span><br><span class="line">    1 : W_stat;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h4 id="cexecute-stage">&#x2003;&#x2003;<span class="math inline">\(c.\)</span>Execute stage</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-13.png"></p>
<p>&#x2003;&#x2003;The logic labeled &quot;Set CC&quot;, which <strong>determines whether or not
to update the condition codes</strong>, has signals <code>m_stat</code>
and <code>W_stat</code> as inputs. These signals are used to detect
cases where an instruction causing an exception is passing through later
pipeline stages, and therefore <strong>any updating of the condition
codes should be suppressed</strong>.</p>
<blockquote>
<p>We need to ensure that <strong>the impact of the exception
instruction is dealt with first</strong> to avoid incorrect barcode
updates, so we suppress the condition codes.</p>
</blockquote>
<h4 id="dmemorystage">&#x2003;&#x2003;<span class="math inline">\(d.\)</span>Memory
stage</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-14.png"></p>
<h3 id="8pipeline-control-logic">8.Pipeline Control Logic</h3>
<h4 id="adesired-handling-of-special-controlcases">&#x2003;&#x2003;<span class="math inline">\(a.\)</span>Desired handling of special control
cases</h4>
<p>&#x2003;&#x2003;Implement the pipeline flow requires d<strong>etecting the hazard
condition</strong>, <strong>keeping pipeline registers F and D
fixed</strong>, and <strong>injecting a bubble into the execute
stage</strong>.</p>
<ul>
<li>The pipeline holds back an instruction in the decode stage by
<strong>keeping pipeline register D in a fixed state</strong>. It should
also keep pipeline register F in a fixed state, <strong>so that the next
instruction will be fetched a second time</strong>.</li>
</ul>
<h5 id="iret">&#x2003;&#x2003;<span class="math inline">\(i.\)</span><code>ret</code></h5>
<p>&#x2003;&#x2003;The figure below provides a detailed view of the processing of the
<code>ret</code> instruction for the example program:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-15.png"></p>
<ul>
<li>The fetch stage stalls, causing the <code>rrmovq</code> instruction
to be fetched but then replaced by a bubble in the decode stage.</li>
</ul>
<h5 id="iimispredicted-branch">&#x2003;&#x2003;<span class="math inline">\(ii.\)</span>Mispredicted branch</h5>
<p>&#x2003;&#x2003;When a mispredicted branch occurs, the control logic
<strong>injects bubbles into the decode and execute stages on the next
cycle</strong>, causing the two incorrectly fetched instructions to be
canceled. On the same cycle, <strong>the pipeline reads the correct
instruction into the fetch stage</strong>.</p>
<p>&#x2003;&#x2003;For an instruction that causes an exception, to make the pipeline
implementation matches the desired ISA behaviour:</p>
<ul>
<li><p>We record the status of each instruction by the status code
<code>stat</code>, and continue fetching, decoding, and executing
instructions as if nothing were amiss.</p></li>
<li><p>As the excepting instruction reaches the memory stage, we take
steps to prevent later instructions from modifying the
programmer-visible state by:</p>
<ol type="1">
<li><p>disabling the setting of condition codes by instructions in the
execute stage,</p></li>
<li><p>injecting bubbles into the memory stage to disable any writing to
the data memory,</p></li>
<li><p><strong>stalling the write-back stage when it has an excepting
instruction</strong>, thus bringing the pipeline to a halt.</p></li>
</ol></li>
</ul>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-16.png"></p>
<ul>
<li>We disable the setting of condition codes when an excepting
instruction is in the memory or write-back stage(by examining the
signals <code>m_stat</code> and <code>W_stat</code> and then setting the
signal <code>set_cc</code> to zero)</li>
</ul>
<h4 id="bdetecting-special-controlconditions">&#x2003;&#x2003;<span class="math inline">\(b.\)</span>Detecting special control
conditions</h4>
<p>&#x2003;&#x2003;The following figure give expressions describing the conditions
under which the three special cases arise:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-17.png"></p>
<ul>
<li><p>Detecting a <code>ret</code> instruction involves
<strong>checking the instruction codes of the instructions in the
decode, execute, and memory stages</strong>.</p></li>
<li><p>Detecting a load/use hazard involves <strong>checking the
instruction type(<code>mrmovq</code> or <code>popq</code>) of the
instruction in the execute stage</strong> and <strong>comparing its
destination register with the source registers of the instruction in the
decode stage</strong>.</p></li>
<li><p>The pipeline control logic should detect a mispredicted branch
while <strong>the jump instruction is in the execute stage</strong>, so
that it can <strong>set up the conditions required to recover from the
misprediction</strong> as the instruction enters the memory
stage.</p></li>
</ul>
<h4 id="cpipeline-control-mechanisms">&#x2003;&#x2003;<span class="math inline">\(c.\)</span>Pipeline control mechanisms</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-18.png"></p>
<ul>
<li>When the bubble signal is set to 1, the state of the register
<strong>will be set to some fixed reset configuration</strong>, giving
<strong>a state equivalent to that of a nop instruction</strong>.</li>
</ul>
<h4 id="dcontrol-logic-implementation">&#x2003;&#x2003;<span class="math inline">\(d.\)</span>Control logic implementation</h4>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-19.png"></p>
<ul>
<li>Pipeline register F must be stalled for either a load/use hazard or
a <code>ret</code> instruction:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool F_stall =</span><br><span class="line">    # Conditions for a load/use hazard</span><br><span class="line">    E_icode in { IMRMOVQ, IPOPQ } &amp;&amp;</span><br><span class="line">    E_dstM in { d_srcA, d_srcB } ||</span><br><span class="line">    # Stalling at fetch while ret passes through pipeline</span><br><span class="line">    IRET in { D_icode, E_icode, M_icode };</span><br></pre></td></tr></table></figure>
<p>&#x2003;&#x2003;Pipeline register E must be set to bubble for a load/use hazard or
for a mispredicted branch:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool E_bubble =</span><br><span class="line">    # Mispredicted branch</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # Conditions for a load/use hazard</span><br><span class="line">    E_icode in { IMRMOVQ, IPOPQ } &amp;&amp;</span><br><span class="line">    E_dstM in { d_srcA, d_srcB};</span><br></pre></td></tr></table></figure>
<p>&#x2003;&#x2003;Pipeline register D must be stalled for a load/use hazard:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool D_stall =</span><br><span class="line">    # Conditions for a load/use hazard</span><br><span class="line">    E_icode in { IMRMOVQ, IPOPQ } &amp;&amp;</span><br><span class="line">    E_dstM in { d_srcA, d_srcB };</span><br></pre></td></tr></table></figure>
<p>&#x2003;&#x2003;Pipeline register D must be set to bubble for a mispredicted branch
or a <code>ret</code> instruction. However, it should not inject a
bubble when there is a load/use hazard in combination with a
<code>ret</code> instruction:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool D_bubble =</span><br><span class="line">    # Mispredicted branch</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # Stalling at fetch while ret passes through pipeline</span><br><span class="line">    # but not condition for a load/use hazard</span><br><span class="line">    !(E_icode in { IMRMOVQ, IPOPQ } &amp;&amp; E_dstM in { d_srcA, d_srcB }) &amp;&amp;</span><br><span class="line">    IRET in { D_icode, E_icode, M_icode };</span><br></pre></td></tr></table></figure>
<p>&#x2003;&#x2003;Pipeline register E must be set to bubble for a load/use hazard or
for a mispredicted branch:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool E_bubble =</span><br><span class="line">    # Mispredicted branch</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # Conditions for a load/use hazard</span><br><span class="line">    E_icode in { IMRMOVQ, IPOPQ } &amp;&amp;</span><br><span class="line">    E_dstM in { d_srcA, d_srcB};</span><br></pre></td></tr></table></figure>
<h3 id="9performance-analysis">9.Performance Analysis</h3>
<p>&#x2003;&#x2003;We measure the overall performance by computing an estimate of
<strong>the average number of clock cycles PIPE would require per
instruction it executes</strong>, a measure known as the CPI (for
&quot;cycles per instruction&quot;).</p>
<ul>
<li>If the stage processes a total of <span class="math inline">\(C_i\)</span> instructions and <span class="math inline">\(C_b\)</span> bubbles, then the processor has
required around <span class="math inline">\(C_i+C_b\)</span> total clock
cycles to execute <span class="math inline">\(C_i\)</span> instructions,
and we can calculate the CPI as follows:</li>
</ul>
<p><span class="math display">\[
CPI={ {C_i+C_b} \over C_i}=1.0+ {C_b \over C_i}
\]</span></p>
<p>&#x2003;&#x2003;We can analyze the total penalty like below:</p>
<p><img src="/2024/07/26/4-5-Pipelined-Y86-64-Implementations/image-20.png"></p>
<h3 id="9multicycle-instructions">9.Multicycle Instructions</h3>
<p>&#x2003;&#x2003;In a more complete instruction set, we would also need to implement
instructions requiring more complex operations such as integer
multiplication and division and floating-point operations. However,
these operations require more than 1 cycle, so they need to be computed
specially.</p>
<p>&#x2003;&#x2003;We can design a functional unit for performing integer
multiplication and division, and another for performing floating-point
operations.</p>
<ul>
<li><p>As an instruction enters the decode stage, it can be issued to
the special unit. <strong>While the unit performs the operation, the
pipeline continues processing other instructions</strong>.</p></li>
<li><p>Typically, <strong>the floating-point unit is itself
pipelined</strong>, and thus multiple operations can execute
concurrently in the main pipeline and in the different units</p></li>
</ul>
<p>&#x2003;&#x2003;The operations of the different units must be synchronized to avoid
incorrect behavior. Often, <strong>different forms of
forwarding</strong> are used to convey results from one part of the
system to other parts, just as we saw between the different stages of
PIPE.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
    <!--  -->
    
  </article>
</div>





  <nav class="pagination">
    <a class="extend prev" rel="prev" title="&#x4E0A;&#x4E00;&#x9875;" aria-label="&#x4E0A;&#x4E00;&#x9875;" href="/page/14/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&#x2026;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&#x2026;</span><a class="page-number" href="/page/148/">148</a><a class="extend next" rel="next" title="&#x4E0B;&#x4E00;&#x9875;" aria-label="&#x4E0B;&#x4E00;&#x9875;" href="/page/16/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">



  <div class="copyright">
    &#xA9; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">fyerfyer</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>&#x7AD9;&#x70B9;&#x603B;&#x5B57;&#x6570;&#xFF1A;</span>
    <span title="&#x7AD9;&#x70B9;&#x603B;&#x5B57;&#x6570;">120k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>&#x7AD9;&#x70B9;&#x9605;&#x8BFB;&#x65F6;&#x957F; &#x2248;</span>
    <span title="&#x7AD9;&#x70B9;&#x9605;&#x8BFB;&#x65F6;&#x957F;">7:15</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="&#x603B;&#x8BBF;&#x5BA2;&#x91CF;">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="&#x603B;&#x8BBF;&#x95EE;&#x91CF;">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"fyerfyer","repo":"fyerfyer.github.io","client_id":"Ov23liESIp4eoFZzzDEq","client_secret":"2e451e3f77791ed6a3a4b0d07790e83fd1a3c8d0","admin_user":"fyerfyer","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"a5bce12480c8742b8f325f43baec7fcb"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
